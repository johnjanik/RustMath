//! Freely Generated Lie Conformal Algebras
//!
//! Provides the base structure for freely generated Lie conformal algebras,
//! which are generated by a set of generators with specified degrees and parities.
//!
//! Corresponds to sage.algebras.lie_conformal_algebras.freely_generated_lie_conformal_algebra

use rustmath_core::Ring;
use std::marker::PhantomData;
use crate::lie_conformal_algebra::{LieConformalAlgebra, GeneratorIndex};
use crate::graded_lie_conformal_algebra::{GradedLieConformalAlgebra, Degree, GradedLCA};
use crate::lie_conformal_algebra_element::LieConformalAlgebraElement;

/// Freely generated Lie conformal algebra
///
/// The free Lie conformal algebra on a set of generators, which serves as
/// a base for constructing specific Lie conformal algebras by quotients.
///
/// # Type Parameters
///
/// * `R` - The base ring
#[derive(Clone)]
pub struct FreelyGeneratedLCA<R: Ring> {
    /// The underlying graded structure
    graded: GradedLCA<R>,
    /// Phantom data for ring
    _phantom: PhantomData<R>,
}

impl<R: Ring + Clone> FreelyGeneratedLCA<R> {
    /// Create a new freely generated Lie conformal algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring
    /// * `ngens` - Number of generators
    /// * `names` - Generator names
    /// * `degrees` - Generator degrees (default to 1 if None)
    /// * `parities` - Optional generator parities for super-algebras
    pub fn new(
        base_ring: R,
        ngens: usize,
        names: Option<Vec<String>>,
        degrees: Option<Vec<Degree>>,
        parities: Option<Vec<u8>>,
    ) -> Self {
        // Generate default names if not provided
        let gen_names = names.unwrap_or_else(|| {
            (0..ngens).map(|i| format!("a{}", i)).collect()
        });

        // Generate default degrees if not provided (all degree 1)
        let gen_degrees = degrees.unwrap_or_else(|| {
            vec![Degree::int(1); ngens]
        });

        let graded = GradedLCA::new(base_ring, gen_names, gen_degrees, parities);

        FreelyGeneratedLCA {
            graded,
            _phantom: PhantomData,
        }
    }

    /// Get the underlying graded structure
    pub fn graded_structure(&self) -> &GradedLCA<R> {
        &self.graded
    }
}

impl<R: Ring + Clone + From<i64>> LieConformalAlgebra<R> for FreelyGeneratedLCA<R> {
    type Element = LieConformalAlgebraElement<R, GeneratorIndex>;

    fn base_ring(&self) -> &R {
        self.graded.base_ring()
    }

    fn ngens(&self) -> Option<usize> {
        Some(self.graded.ngens())
    }

    fn generator(&self, i: usize) -> Option<Self::Element> {
        if i < self.graded.ngens() {
            Some(LieConformalAlgebraElement::from_basis(
                GeneratorIndex::finite(i)
            ))
        } else {
            None
        }
    }

    fn zero(&self) -> Self::Element {
        LieConformalAlgebraElement::zero()
    }
}

impl<R: Ring + Clone + From<i64>> GradedLieConformalAlgebra<R> for FreelyGeneratedLCA<R> {
    fn generator_degree(&self, index: usize) -> Option<Degree> {
        self.graded.generator_degree(index)
    }

    fn degree(&self, _element: &Self::Element) -> Option<Degree> {
        // Computing the degree of a general element requires
        // looking at all its basis elements
        // For now, return None; concrete implementations can override
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_freely_generated_creation() {
        let base_ring = 1i64;
        let lca = FreelyGeneratedLCA::new(base_ring, 2, None, None, None);

        assert_eq!(lca.ngens(), Some(2));
        assert!(lca.generator(0).is_some());
        assert!(lca.generator(1).is_some());
        assert!(lca.generator(2).is_none());
    }

    #[test]
    fn test_freely_generated_with_names() {
        let base_ring = 1i64;
        let names = vec!["L".to_string(), "G".to_string()];
        let degrees = vec![Degree::int(2), Degree::rational(3, 2)];

        let lca = FreelyGeneratedLCA::new(base_ring, 2, Some(names), Some(degrees), None);

        assert_eq!(lca.ngens(), Some(2));
        assert_eq!(lca.generator_degree(0), Some(Degree::int(2)));
        assert_eq!(lca.generator_degree(1), Some(Degree::rational(3, 2)));
    }

    #[test]
    fn test_freely_generated_super() {
        let base_ring = 1i64;
        let names = vec!["a".to_string(), "b".to_string()];
        let degrees = vec![Degree::int(1), Degree::int(1)];
        let parities = Some(vec![0, 1]);

        let lca = FreelyGeneratedLCA::new(
            base_ring,
            2,
            Some(names),
            Some(degrees),
            parities,
        );

        assert!(lca.graded_structure().is_super());
    }
}
