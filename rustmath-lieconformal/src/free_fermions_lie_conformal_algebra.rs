//! Free Fermions Lie Conformal Algebra
//!
//! A super Lie conformal algebra based on free fermions with a symmetric bilinear pairing.
//!
//! # Mathematical Background
//!
//! The free fermions Lie conformal algebra is generated by fermionic generators ψ_i
//! (i = 1,...,n) which are purely odd elements, plus a central element K with TK = 0.
//!
//! The λ-bracket is defined by:
//!
//! [ψ_i_λ ψ_j] = M_ij K
//!
//! where M is the Gram matrix defining the pairing structure.
//!
//! # References
//!
//! - Kac, V. "Vertex Algebras for Beginners" (1998)
//! - Gorbounov, V., Malikov, F., & Schechtman, V. "Gerbes of chiral differential
//!   operators" (2001)
//!
//! Corresponds to sage.algebras.lie_conformal_algebras.free_fermions_lie_conformal_algebra

use rustmath_core::Ring;
use std::collections::HashMap;
use std::fmt::{self, Display};
use crate::lie_conformal_algebra::{LieConformalAlgebra, LambdaBracket, GeneratorIndex};
use crate::graded_lie_conformal_algebra::{GradedLieConformalAlgebra, Degree, GradedLCA};
use crate::lie_conformal_algebra_element::LieConformalAlgebraElement;

/// Free Fermions Lie conformal algebra
///
/// A super Lie conformal algebra of free fermions with a symmetric bilinear pairing.
///
/// # Type Parameters
///
/// * `R` - The base ring (must be a commutative ring)
///
/// # Examples
///
/// ```
/// use rustmath_lieconformal::FreeFermionsLieConformalAlgebra;
///
/// // Create free fermions algebra with 2 generators and identity Gram matrix
/// let lca = FreeFermionsLieConformalAlgebra::new(1i64, 2, None, None);
/// assert_eq!(lca.ngens(), Some(3)); // 2 generators + 1 central element
/// ```
#[derive(Clone)]
pub struct FreeFermionsLieConformalAlgebra<R: Ring> {
    /// The underlying graded structure
    graded: GradedLCA<R>,
    /// Number of non-central generators
    ngens_noncentral: usize,
    /// Gram matrix defining the symmetric bilinear pairing
    /// gram_matrix[i][j] = (ψ_i, ψ_j)
    gram_matrix: Vec<Vec<R>>,
    /// Index of the central element K
    central_index: usize,
}

impl<R: Ring + Clone + From<i64> + PartialEq> FreeFermionsLieConformalAlgebra<R> {
    /// Create a new free fermions Lie conformal algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring
    /// * `ngens` - Number of non-central fermionic generators (default: 1)
    /// * `gram_matrix` - Symmetric Gram matrix (default: identity matrix)
    /// * `names` - Optional generator names (defaults to psi0, psi1, ..., K)
    ///
    /// # Panics
    ///
    /// Panics if:
    /// - The Gram matrix is not square
    /// - The Gram matrix is not symmetric
    /// - The Gram matrix dimensions don't match ngens
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_lieconformal::FreeFermionsLieConformalAlgebra;
    ///
    /// // Identity Gram matrix
    /// let lca1 = FreeFermionsLieConformalAlgebra::new(1i64, 2, None, None);
    ///
    /// // Custom Gram matrix
    /// let gram = vec![vec![0, 1], vec![1, 0]]; // Skew pairing
    /// let lca2 = FreeFermionsLieConformalAlgebra::new(1i64, 2, Some(gram), None);
    /// ```
    pub fn new(
        base_ring: R,
        ngens: usize,
        gram_matrix: Option<Vec<Vec<R>>>,
        names: Option<Vec<String>>,
    ) -> Self {
        assert!(ngens > 0, "Number of generators must be positive");

        // Create or validate Gram matrix
        let gram = gram_matrix.unwrap_or_else(|| {
            // Default: identity matrix
            (0..ngens)
                .map(|i| {
                    (0..ngens)
                        .map(|j| if i == j { R::from(1) } else { R::from(0) })
                        .collect()
                })
                .collect()
        });

        // Validate Gram matrix
        assert_eq!(gram.len(), ngens, "Gram matrix must have ngens rows");
        for (i, row) in gram.iter().enumerate() {
            assert_eq!(row.len(), ngens, "Gram matrix must be square");

            // Check symmetry
            for j in 0..ngens {
                assert_eq!(
                    gram[i][j],
                    gram[j][i],
                    "Gram matrix must be symmetric"
                );
            }
        }

        // Central element K is the last generator
        let central_index = ngens;
        let total_gens = ngens + 1;

        // Generate default names if not provided
        let gen_names = names.unwrap_or_else(|| {
            let mut names = Vec::new();
            for i in 0..ngens {
                names.push(format!("psi{}", i));
            }
            names.push("K".to_string());
            names
        });

        assert_eq!(
            gen_names.len(),
            total_gens,
            "Number of names must match total generators"
        );

        // All fermionic generators have degree 1/2, K has degree 0
        let mut gen_weights = vec![Degree::rational(1, 2); ngens];
        gen_weights.push(Degree::int(0)); // Central element

        // All fermionic generators are odd (parity = 1), K is even (parity = 0)
        let mut parities = vec![1u8; ngens]; // Odd parity for fermions
        parities.push(0); // Even parity for central element

        let graded = GradedLCA::new(base_ring, gen_names, gen_weights, Some(parities));

        FreeFermionsLieConformalAlgebra {
            graded,
            ngens_noncentral: ngens,
            gram_matrix: gram,
            central_index,
        }
    }

    /// Get the Gram matrix
    pub fn gram_matrix(&self) -> &[Vec<R>] {
        &self.gram_matrix
    }

    /// Get the number of non-central generators
    pub fn ngens_noncentral(&self) -> usize {
        self.ngens_noncentral
    }

    /// Get the underlying graded structure
    pub fn graded_structure(&self) -> &GradedLCA<R> {
        &self.graded
    }

    /// Get total number of generators (including central element)
    pub fn ngens(&self) -> usize {
        self.graded.ngens()
    }

    /// Get generator names
    pub fn generator_names(&self) -> &[String] {
        self.graded.generator_names()
    }

    /// Get the bilinear pairing (ψ_i, ψ_j)
    fn get_pairing(&self, i: usize, j: usize) -> R {
        if i < self.ngens_noncentral && j < self.ngens_noncentral {
            self.gram_matrix[i][j].clone()
        } else {
            R::from(0)
        }
    }
}

/// Element type for free fermions Lie conformal algebras
pub type FreeFermionsLCAElement<R> = LieConformalAlgebraElement<R, GeneratorIndex>;

impl<R: Ring + Clone + From<i64> + PartialEq> LieConformalAlgebra<R>
    for FreeFermionsLieConformalAlgebra<R>
{
    type Element = FreeFermionsLCAElement<R>;

    fn base_ring(&self) -> &R {
        self.graded.base_ring()
    }

    fn ngens(&self) -> Option<usize> {
        Some(self.graded.ngens())
    }

    fn generator(&self, i: usize) -> Option<Self::Element> {
        if i < self.graded.ngens() {
            Some(LieConformalAlgebraElement::from_basis(
                GeneratorIndex::finite(i)
            ))
        } else {
            None
        }
    }

    fn is_abelian(&self) -> bool {
        false // Has non-trivial brackets (except when Gram matrix is zero)
    }

    fn zero(&self) -> Self::Element {
        LieConformalAlgebraElement::zero()
    }
}

impl<R: Ring + Clone + From<i64> + PartialEq> GradedLieConformalAlgebra<R>
    for FreeFermionsLieConformalAlgebra<R>
{
    fn generator_degree(&self, index: usize) -> Option<Degree> {
        self.graded.generator_degree(index)
    }

    fn degree(&self, element: &Self::Element) -> Option<Degree> {
        if element.is_zero() {
            return Some(Degree::int(0));
        }

        // Return None for non-homogeneous elements
        None
    }
}

impl<R: Ring + Clone + From<i64> + PartialEq + std::ops::Add<Output = R> + std::ops::Mul<Output = R>>
    LambdaBracket<R, FreeFermionsLCAElement<R>> for FreeFermionsLieConformalAlgebra<R>
{
    /// Compute the λ-bracket [ψ_i_λ ψ_j] = M_ij K
    fn lambda_bracket(
        &self,
        a: &FreeFermionsLCAElement<R>,
        b: &FreeFermionsLCAElement<R>,
    ) -> HashMap<usize, FreeFermionsLCAElement<R>> {
        let mut result = HashMap::new();

        // For each pair of basis elements in a and b
        for (basis_a, _poly_a) in a.terms() {
            for (basis_b, _poly_b) in b.terms() {
                if let (Some(i), Some(j)) = (basis_a.as_finite(), basis_b.as_finite()) {
                    // Skip if either is the central element
                    if i == self.central_index || j == self.central_index {
                        continue;
                    }

                    // Get the pairing (ψ_i, ψ_j)
                    let pairing = self.get_pairing(i, j);

                    if !pairing.is_zero() {
                        // Add M_ij K to the λ^0 term (no λ in the bracket)
                        let central_term = LieConformalAlgebraElement::from_basis(
                            GeneratorIndex::finite(self.central_index)
                        )
                        .scalar_mul(&pairing);

                        let existing = result
                            .entry(0)
                            .or_insert_with(|| LieConformalAlgebraElement::zero());
                        *existing = existing.add(&central_term);
                    }
                }
            }
        }

        result
    }

    fn n_product(&self, a: &FreeFermionsLCAElement<R>, b: &FreeFermionsLCAElement<R>, n: usize)
        -> FreeFermionsLCAElement<R>
    {
        self.lambda_bracket(a, b)
            .get(&n)
            .cloned()
            .unwrap_or_else(|| LieConformalAlgebraElement::zero())
    }
}

impl<R: Ring + Clone + From<i64> + PartialEq + Display> Display
    for FreeFermionsLieConformalAlgebra<R>
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "The free Fermions super Lie conformal algebra with {} generator(s) over {}",
            self.ngens_noncentral,
            self.graded.base_ring()
        )?;

        if self.ngens_noncentral <= 5 {
            write!(f, ": (")?;
            for (i, name) in self.graded.generator_names().iter().enumerate() {
                if i > 0 {
                    write!(f, ", ")?;
                }
                write!(f, "{}", name)?;
            }
            write!(f, ")")?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_free_fermions_creation() {
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, None, None);

        assert_eq!(lca.ngens_noncentral(), 2);
        assert_eq!(lca.ngens(), Some(3)); // 2 + central element
        assert!(!lca.is_abelian());
    }

    #[test]
    fn test_free_fermions_degrees() {
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, None, None);

        // Fermionic generators have degree 1/2
        assert_eq!(lca.generator_degree(0), Some(Degree::rational(1, 2)));
        assert_eq!(lca.generator_degree(1), Some(Degree::rational(1, 2)));

        // Central element has degree 0
        assert_eq!(lca.generator_degree(2), Some(Degree::int(0)));
    }

    #[test]
    fn test_free_fermions_identity_gram() {
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, None, None);

        // Identity Gram matrix
        assert_eq!(lca.get_pairing(0, 0), 1);
        assert_eq!(lca.get_pairing(0, 1), 0);
        assert_eq!(lca.get_pairing(1, 0), 0);
        assert_eq!(lca.get_pairing(1, 1), 1);
    }

    #[test]
    fn test_free_fermions_custom_gram() {
        let gram = vec![vec![0, 1], vec![1, 0]]; // Skew pairing
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, Some(gram), None);

        assert_eq!(lca.get_pairing(0, 0), 0);
        assert_eq!(lca.get_pairing(0, 1), 1);
        assert_eq!(lca.get_pairing(1, 0), 1);
        assert_eq!(lca.get_pairing(1, 1), 0);
    }

    #[test]
    fn test_free_fermions_generators() {
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, None, None);

        assert!(lca.generator(0).is_some()); // psi0
        assert!(lca.generator(1).is_some()); // psi1
        assert!(lca.generator(2).is_some()); // K
        assert!(lca.generator(3).is_none());
    }

    #[test]
    fn test_free_fermions_lambda_bracket() {
        let gram = vec![vec![2, 0], vec![0, 3]];
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, Some(gram), None);

        let psi0 = lca.generator(0).unwrap();
        let psi1 = lca.generator(1).unwrap();

        // [ψ0_λ ψ0] = 2K (λ^0 term, not λ^1)
        let bracket00 = lca.lambda_bracket(&psi0, &psi0);
        assert!(bracket00.contains_key(&0)); // λ^0 term exists

        // [ψ0_λ ψ1] = 0 (orthogonal in Gram matrix)
        let bracket01 = lca.lambda_bracket(&psi0, &psi1);
        assert!(bracket01.is_empty() || bracket01.values().all(|v| v.is_zero()));

        // [ψ1_λ ψ1] = 3K
        let bracket11 = lca.lambda_bracket(&psi1, &psi1);
        assert!(bracket11.contains_key(&0)); // λ^0 term exists
    }

    #[test]
    fn test_free_fermions_central_element_bracket() {
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, None, None);

        let k = lca.generator(2).unwrap(); // Central element
        let psi0 = lca.generator(0).unwrap();

        // [K_λ ψ0] = 0 (central element)
        let bracket = lca.lambda_bracket(&k, &psi0);
        assert!(bracket.is_empty() || bracket.values().all(|v| v.is_zero()));
    }

    #[test]
    fn test_free_fermions_zero() {
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 1, None, None);

        let zero = lca.zero();
        assert!(zero.is_zero());
    }

    #[test]
    fn test_free_fermions_with_custom_names() {
        let names = vec!["chi".to_string(), "eta".to_string(), "K".to_string()];
        let lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, None, Some(names.clone()));

        assert_eq!(lca.generator_names()[0], "chi");
        assert_eq!(lca.generator_names()[1], "eta");
        assert_eq!(lca.generator_names()[2], "K");
    }

    #[test]
    #[should_panic(expected = "Gram matrix must be symmetric")]
    fn test_free_fermions_nonsymmetric_gram() {
        let gram = vec![vec![1, 2], vec![3, 1]]; // Not symmetric
        let _lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 2, Some(gram), None);
    }

    #[test]
    #[should_panic(expected = "Gram matrix must have ngens rows")]
    fn test_free_fermions_wrong_gram_size() {
        let gram = vec![vec![1, 0], vec![0, 1]]; // 2x2 matrix but 3 generators
        let _lca: FreeFermionsLieConformalAlgebra<i64> =
            FreeFermionsLieConformalAlgebra::new(1, 3, Some(gram), None);
    }
}
