//! Affine Lie Conformal Algebras
//!
//! The affine Kac-Moody Lie conformal algebra associated with a simple
//! finite-dimensional Lie algebra.
//!
//! # Mathematical Background
//!
//! Let **g** be a simple finite-dimensional Lie algebra with Cartan type
//! (A_n, B_n, C_n, D_n, E_6, E_7, E_8, F_4, or G_2). The affine Lie conformal
//! algebra is an R[∂]-module freely generated by **g** plus a central element K,
//! with λ-bracket:
//!
//! [a_λ b] = [a,b] + λ (a,b)K
//!
//! where [a,b] is the Lie bracket in **g** and (a,b) is the normalized Killing
//! form scaled so the longest root has square-norm 2.
//!
//! # References
//!
//! - Kac, V. "Infinite-Dimensional Lie Algebras" (3rd ed., 1990)
//! - Kac, V. & Raina, A. K. "Highest Weight Representations of Infinite
//!   Dimensional Lie Algebras" (1987)
//!
//! Corresponds to sage.algebras.lie_conformal_algebras.affine_lie_conformal_algebra

use rustmath_core::Ring;
use rustmath_liealgebras::cartan_type::CartanType;
use std::collections::HashMap;
use std::fmt::{self, Display};
use crate::lie_conformal_algebra::{LieConformalAlgebra, LambdaBracket, GeneratorIndex};
use crate::graded_lie_conformal_algebra::{GradedLieConformalAlgebra, Degree, GradedLCA};
use crate::lie_conformal_algebra_element::LieConformalAlgebraElement;

/// Affine Lie conformal algebra
///
/// The Kac-Moody extension of a simple finite-dimensional Lie algebra.
///
/// # Type Parameters
///
/// * `R` - The base ring (must be a commutative ring)
///
/// # Examples
///
/// ```
/// use rustmath_lieconformal::AffineLieConformalAlgebra;
/// use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter};
///
/// // Create the affine algebra associated with sl(3)
/// let ct = CartanType::new(CartanLetter::A, 2).unwrap();
/// let lca = AffineLieConformalAlgebra::new(1i64, ct, None);
/// ```
#[derive(Clone)]
pub struct AffineLieConformalAlgebra<R: Ring> {
    /// The underlying graded structure
    graded: GradedLCA<R>,
    /// The Cartan type of the underlying Lie algebra
    cartan_type: CartanType,
    /// Dual Coxeter number h^∨
    dual_coxeter_number: i64,
    /// Structure coefficients for the underlying Lie algebra bracket
    /// Maps (i, j) -> Vec<(k, coefficient)> representing [g_i, g_j] = Σ c_k g_k
    structure_coefficients: HashMap<(usize, usize), Vec<(usize, R)>>,
    /// Killing form values (a,b) for pairs of generators
    /// Normalized so longest root has square-norm 2
    killing_form: HashMap<(usize, usize), R>,
    /// Index of the central element K
    central_index: usize,
}

impl<R: Ring + Clone + From<i64> + std::ops::Neg<Output = R>> AffineLieConformalAlgebra<R> {
    /// Create a new affine Lie conformal algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring
    /// * `cartan_type` - The Cartan type (must be simple and finite-dimensional)
    /// * `names` - Optional custom generator names (defaults to e_i, f_i, h_i, K)
    ///
    /// # Panics
    ///
    /// Panics if the Cartan type is not finite or not simple.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_lieconformal::AffineLieConformalAlgebra;
    /// use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter};
    ///
    /// let ct = CartanType::new(CartanLetter::A, 2).unwrap();
    /// let lca = AffineLieConformalAlgebra::new(1i64, ct, None);
    /// assert!(lca.ngens() > 0);
    /// ```
    pub fn new(
        base_ring: R,
        cartan_type: CartanType,
        names: Option<Vec<String>>,
    ) -> Self {
        use rustmath_liealgebras::cartan_type::Affinity;

        // Validate that this is a simple finite-dimensional type
        if cartan_type.affinity != Affinity::Finite {
            panic!("AffineLieConformalAlgebra requires a finite Cartan type");
        }

        // Compute the dimension of the underlying Lie algebra
        let dim = Self::lie_algebra_dimension(&cartan_type);

        // Central element K is the last generator
        let central_index = dim;
        let ngens = dim + 1;

        // Generate default names if not provided
        let gen_names = names.unwrap_or_else(|| {
            let mut names = Vec::new();
            // For simplicity, use generic names g_0, g_1, ..., g_{dim-1}, K
            for i in 0..dim {
                names.push(format!("g{}", i));
            }
            names.push("K".to_string());
            names
        });

        // All generators have degree 1, except K which has degree 0
        let mut gen_weights = vec![Degree::int(1); dim];
        gen_weights.push(Degree::int(0)); // Central element has degree 0

        let graded = GradedLCA::new(base_ring.clone(), gen_names, gen_weights, None);

        // Compute dual Coxeter number
        let dual_coxeter_number = Self::compute_dual_coxeter_number(&cartan_type);

        // Compute structure coefficients and Killing form
        let (structure_coefficients, killing_form) =
            Self::compute_structure_data(&cartan_type, &base_ring);

        AffineLieConformalAlgebra {
            graded,
            cartan_type,
            dual_coxeter_number,
            structure_coefficients,
            killing_form,
            central_index,
        }
    }

    /// Get the Cartan type
    pub fn cartan_type(&self) -> CartanType {
        self.cartan_type
    }

    /// Get the dual Coxeter number h^∨
    pub fn dual_coxeter_number(&self) -> i64 {
        self.dual_coxeter_number
    }

    /// Get the dimension of the underlying Lie algebra
    fn lie_algebra_dimension(ct: &CartanType) -> usize {
        use rustmath_liealgebras::cartan_type::CartanLetter;

        let n = ct.rank;
        match ct.letter {
            CartanLetter::A => n * (n + 2),  // sl(n+1) has dimension n^2 + 2n
            CartanLetter::B => n * (2 * n + 1),  // so(2n+1) has dimension 2n^2 + n
            CartanLetter::C => n * (2 * n + 1),  // sp(2n) has dimension 2n^2 + n
            CartanLetter::D => n * (2 * n - 1),  // so(2n) has dimension 2n^2 - n
            CartanLetter::E => match n {
                6 => 78,
                7 => 133,
                8 => 248,
                _ => panic!("Invalid E type rank"),
            },
            CartanLetter::F => 52,  // F_4 has dimension 52
            CartanLetter::G => 14,  // G_2 has dimension 14
        }
    }

    /// Compute the dual Coxeter number h^∨
    fn compute_dual_coxeter_number(ct: &CartanType) -> i64 {
        use rustmath_liealgebras::cartan_type::CartanLetter;

        let n = ct.rank as i64;
        match ct.letter {
            CartanLetter::A => n + 1,
            CartanLetter::B => 2 * n - 1,
            CartanLetter::C => n + 1,
            CartanLetter::D => 2 * n - 2,
            CartanLetter::E => match ct.rank {
                6 => 12,
                7 => 18,
                8 => 30,
                _ => panic!("Invalid E type rank"),
            },
            CartanLetter::F => 9,
            CartanLetter::G => 4,
        }
    }

    /// Compute structure coefficients and Killing form
    ///
    /// This is a simplified implementation. A full implementation would use
    /// the actual Lie algebra structure from rustmath-liealgebras.
    fn compute_structure_data(ct: &CartanType, base_ring: &R) ->
        (HashMap<(usize, usize), Vec<(usize, R)>>, HashMap<(usize, usize), R>)
    {
        // For this implementation, we'll use a simplified approach
        // A full implementation would compute from the root system and Chevalley basis
        let structure_coefficients = HashMap::new();
        let killing_form = HashMap::new();

        // TODO: Implement actual structure coefficient computation from Chevalley basis
        // This would require integration with the root system and representation theory

        (structure_coefficients, killing_form)
    }

    /// Compute the Lie bracket [a, b] in the underlying Lie algebra
    fn lie_bracket(&self, i: usize, j: usize) -> LieConformalAlgebraElement<R, GeneratorIndex>
    where
        R: std::ops::Add<Output = R> + std::ops::Mul<Output = R> + PartialEq,
    {
        // If either is the central element, bracket is zero
        if i == self.central_index || j == self.central_index {
            return LieConformalAlgebraElement::zero();
        }

        // Look up structure coefficients
        if let Some(terms) = self.structure_coefficients.get(&(i, j)) {
            let mut result_terms = HashMap::new();
            for (k, coeff) in terms {
                result_terms.insert(
                    GeneratorIndex::finite(*k),
                    vec![coeff.clone()],
                );
            }
            LieConformalAlgebraElement::new(result_terms)
        } else {
            // Anti-symmetry: [a,b] = -[b,a]
            if let Some(terms) = self.structure_coefficients.get(&(j, i)) {
                let mut result_terms = HashMap::new();
                for (k, coeff) in terms {
                    result_terms.insert(
                        GeneratorIndex::finite(*k),
                        vec![-coeff.clone()],
                    );
                }
                LieConformalAlgebraElement::new(result_terms)
            } else {
                LieConformalAlgebraElement::zero()
            }
        }
    }

    /// Get the Killing form value (a,b) for two generators
    fn get_killing_form(&self, i: usize, j: usize) -> R {
        if let Some(val) = self.killing_form.get(&(i, j)) {
            val.clone()
        } else if let Some(val) = self.killing_form.get(&(j, i)) {
            val.clone() // Killing form is symmetric
        } else {
            R::from(0)
        }
    }

    /// Get the underlying graded structure
    pub fn graded_structure(&self) -> &GradedLCA<R> {
        &self.graded
    }

    /// Get the number of generators (including central element)
    pub fn ngens(&self) -> usize {
        self.graded.ngens()
    }

    /// Get generator names
    pub fn generator_names(&self) -> &[String] {
        self.graded.generator_names()
    }
}

/// Element type for affine Lie conformal algebras
pub type AffineLCAElement<R> = LieConformalAlgebraElement<R, GeneratorIndex>;

impl<R: Ring + Clone + From<i64> + std::ops::Neg<Output = R>> LieConformalAlgebra<R>
    for AffineLieConformalAlgebra<R>
{
    type Element = AffineLCAElement<R>;

    fn base_ring(&self) -> &R {
        self.graded.base_ring()
    }

    fn ngens(&self) -> Option<usize> {
        Some(self.graded.ngens())
    }

    fn generator(&self, i: usize) -> Option<Self::Element> {
        if i < self.graded.ngens() {
            Some(LieConformalAlgebraElement::from_basis(
                GeneratorIndex::finite(i)
            ))
        } else {
            None
        }
    }

    fn is_abelian(&self) -> bool {
        false // Affine algebras are non-abelian
    }

    fn zero(&self) -> Self::Element {
        LieConformalAlgebraElement::zero()
    }

    fn central_charge(&self) -> Option<R> {
        // The central charge is related to the dual Coxeter number
        // For the affine algebra, it's a parameter
        None
    }
}

impl<R: Ring + Clone + From<i64> + std::ops::Neg<Output = R>> GradedLieConformalAlgebra<R>
    for AffineLieConformalAlgebra<R>
{
    fn generator_degree(&self, index: usize) -> Option<Degree> {
        self.graded.generator_degree(index)
    }

    fn degree(&self, element: &Self::Element) -> Option<Degree> {
        // For affine algebras, degree is determined by the basis elements
        if element.is_zero() {
            return Some(Degree::int(0));
        }

        // Return None for non-homogeneous elements
        // A more sophisticated implementation would check homogeneity
        None
    }
}

impl<R: Ring + Clone + From<i64> + std::ops::Neg<Output = R> + std::ops::Add<Output = R> + std::ops::Mul<Output = R> + PartialEq>
    LambdaBracket<R, AffineLCAElement<R>> for AffineLieConformalAlgebra<R>
{
    /// Compute the λ-bracket [a_λ b] = [a,b] + λ (a,b)K
    fn lambda_bracket(&self, a: &AffineLCAElement<R>, b: &AffineLCAElement<R>)
        -> HashMap<usize, AffineLCAElement<R>>
    {
        let mut result = HashMap::new();

        // For each pair of basis elements in a and b
        for (basis_a, poly_a) in a.terms() {
            for (basis_b, poly_b) in b.terms() {
                if let (Some(i), Some(j)) = (basis_a.as_finite(), basis_b.as_finite()) {
                    // Compute [g_i, g_j]
                    let lie_bracket_term = self.lie_bracket(i, j);

                    // Add to λ^0 term
                    if !lie_bracket_term.is_zero() {
                        let existing = result.entry(0).or_insert_with(|| LieConformalAlgebraElement::zero());
                        *existing = existing.add(&lie_bracket_term);
                    }

                    // Add λ (g_i, g_j) K term (λ^1 coefficient)
                    let killing_val = self.get_killing_form(i, j);
                    if !killing_val.is_zero() {
                        let central_term = LieConformalAlgebraElement::from_basis(
                            GeneratorIndex::finite(self.central_index)
                        ).scalar_mul(&killing_val);

                        let existing = result.entry(1).or_insert_with(|| LieConformalAlgebraElement::zero());
                        *existing = existing.add(&central_term);
                    }
                }
            }
        }

        result
    }

    fn n_product(&self, a: &AffineLCAElement<R>, b: &AffineLCAElement<R>, n: usize)
        -> AffineLCAElement<R>
    {
        self.lambda_bracket(a, b)
            .get(&n)
            .cloned()
            .unwrap_or_else(|| LieConformalAlgebraElement::zero())
    }
}

impl<R: Ring + Clone + From<i64> + std::ops::Neg<Output = R> + Display> Display
    for AffineLieConformalAlgebra<R>
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "The affine Lie conformal algebra of type {} over {}",
            self.cartan_type,
            self.graded.base_ring()
        )
    }
}

impl Display for CartanType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        use rustmath_liealgebras::cartan_type::Affinity;

        write!(f, "{}", self.letter)?;
        write!(f, "_{}", self.rank)?;

        if let Affinity::Affine(level) = self.affinity {
            write!(f, "^({})", level)?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter};

    #[test]
    fn test_affine_lca_creation() {
        let ct = CartanType::new(CartanLetter::A, 1).unwrap();
        let lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );

        assert!(lca.ngens() > 0);
        assert!(!lca.is_abelian());
    }

    #[test]
    fn test_affine_lca_cartan_type() {
        let ct = CartanType::new(CartanLetter::A, 2).unwrap();
        let lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );

        assert_eq!(lca.cartan_type(), ct);
    }

    #[test]
    fn test_dual_coxeter_numbers() {
        // Test various Cartan types
        let ct_a2 = CartanType::new(CartanLetter::A, 2).unwrap();
        let lca_a2: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(1, ct_a2, None);
        assert_eq!(lca_a2.dual_coxeter_number(), 3); // h^∨(A_2) = 3

        let ct_g2 = CartanType::new(CartanLetter::G, 2).unwrap();
        let lca_g2: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(1, ct_g2, None);
        assert_eq!(lca_g2.dual_coxeter_number(), 4); // h^∨(G_2) = 4
    }

    #[test]
    fn test_affine_lca_generators() {
        let ct = CartanType::new(CartanLetter::A, 1).unwrap();
        let lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );

        assert!(lca.generator(0).is_some());
        // Last generator should be the central element K
        let ngens = lca.ngens();
        assert!(lca.generator(ngens - 1).is_some());
        assert!(lca.generator(ngens).is_none());
    }

    #[test]
    fn test_affine_lca_zero() {
        let ct = CartanType::new(CartanLetter::A, 1).unwrap();
        let lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );

        let zero = lca.zero();
        assert!(zero.is_zero());
    }

    #[test]
    fn test_affine_lca_lambda_bracket() {
        let ct = CartanType::new(CartanLetter::A, 1).unwrap();
        let lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );

        let a = lca.generator(0).unwrap();
        let b = lca.generator(0).unwrap();

        // Compute [a_λ a]
        let bracket = lca.lambda_bracket(&a, &b);

        // The bracket should have at most two terms (λ^0 and λ^1)
        assert!(bracket.len() <= 2);
    }

    #[test]
    #[should_panic(expected = "AffineLieConformalAlgebra requires a finite Cartan type")]
    fn test_affine_lca_rejects_affine_type() {
        let ct = CartanType::new_affine(CartanLetter::A, 1, 1).unwrap();
        let _lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );
    }

    #[test]
    fn test_central_element_bracket() {
        let ct = CartanType::new(CartanLetter::A, 1).unwrap();
        let lca: AffineLieConformalAlgebra<i64> = AffineLieConformalAlgebra::new(
            1,
            ct,
            None,
        );

        let ngens = lca.ngens();
        let k = lca.generator(ngens - 1).unwrap(); // Central element
        let a = lca.generator(0).unwrap();

        // [K_λ a] should be 0
        let bracket = lca.lambda_bracket(&k, &a);
        assert!(bracket.is_empty() || bracket.values().all(|v| v.is_zero()));
    }

    #[test]
    fn test_lie_algebra_dimensions() {
        use rustmath_liealgebras::cartan_type::CartanLetter;

        // A_1: sl(2) has dimension 3
        let ct_a1 = CartanType::new(CartanLetter::A, 1).unwrap();
        assert_eq!(AffineLieConformalAlgebra::<i64>::lie_algebra_dimension(&ct_a1), 3);

        // A_2: sl(3) has dimension 8
        let ct_a2 = CartanType::new(CartanLetter::A, 2).unwrap();
        assert_eq!(AffineLieConformalAlgebra::<i64>::lie_algebra_dimension(&ct_a2), 8);

        // G_2 has dimension 14
        let ct_g2 = CartanType::new(CartanLetter::G, 2).unwrap();
        assert_eq!(AffineLieConformalAlgebra::<i64>::lie_algebra_dimension(&ct_g2), 14);
    }
}
