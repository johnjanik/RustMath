//! Abelian Lie Conformal Algebras
//!
//! An abelian Lie conformal algebra is one where all λ-brackets vanish:
//! [a_λ b] = 0 for all a, b.
//!
//! This is the free R[∂]-module generated by a set of generators.
//!
//! Corresponds to sage.algebras.lie_conformal_algebras.abelian_lie_conformal_algebra

use rustmath_core::Ring;
use std::collections::HashMap;
use std::fmt::{self, Display};
use crate::lie_conformal_algebra::{LieConformalAlgebra, LambdaBracket, GeneratorIndex};
use crate::graded_lie_conformal_algebra::{GradedLieConformalAlgebra, Degree, GradedLCA};
use crate::lie_conformal_algebra_element::LieConformalAlgebraElement;

/// Abelian Lie conformal algebra
///
/// The free R[∂]-module generated by M with vanishing λ-brackets.
///
/// # Mathematical Definition
///
/// For generators a, b: [a_λ b] = 0
///
/// This is the simplest possible Lie conformal algebra structure.
///
/// # Type Parameters
///
/// * `R` - The base ring (must be a commutative ring)
///
/// # Examples
///
/// ```
/// use rustmath_lieconformal::AbelianLieConformalAlgebra;
///
/// // Create an abelian LCA with 2 generators
/// let lca = AbelianLieConformalAlgebra::new(1i64, 2, None, None, None);
/// assert_eq!(lca.ngens(), Some(2));
/// assert!(lca.is_abelian());
/// ```
#[derive(Clone)]
pub struct AbelianLieConformalAlgebra<R: Ring> {
    /// The underlying graded structure
    graded: GradedLCA<R>,
}

impl<R: Ring + Clone> AbelianLieConformalAlgebra<R> {
    /// Create a new abelian Lie conformal algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring
    /// * `ngens` - Number of generators
    /// * `names` - Optional generator names (defaults to a0, a1, ...)
    /// * `weights` - Optional generator weights/degrees (defaults to all 1)
    /// * `parities` - Optional generator parities for super-algebras (0=even, 1=odd)
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_lieconformal::AbelianLieConformalAlgebra;
    /// use rustmath_lieconformal::graded_lie_conformal_algebra::Degree;
    ///
    /// let names = vec!["a".to_string(), "b".to_string()];
    /// let weights = vec![Degree::int(1), Degree::int(2)];
    /// let lca = AbelianLieConformalAlgebra::new(
    ///     1i64,
    ///     2,
    ///     Some(names),
    ///     Some(weights),
    ///     None,
    /// );
    /// ```
    pub fn new(
        base_ring: R,
        ngens: usize,
        names: Option<Vec<String>>,
        weights: Option<Vec<Degree>>,
        parities: Option<Vec<u8>>,
    ) -> Self {
        // Generate default names if not provided
        let gen_names = names.unwrap_or_else(|| {
            (0..ngens).map(|i| format!("a{}", i)).collect()
        });

        // Generate default weights if not provided (all weight 1)
        let gen_weights = weights.unwrap_or_else(|| {
            vec![Degree::int(1); ngens]
        });

        let graded = GradedLCA::new(base_ring, gen_names, gen_weights, parities);

        AbelianLieConformalAlgebra { graded }
    }

    /// Get the underlying graded structure
    pub fn graded_structure(&self) -> &GradedLCA<R> {
        &self.graded
    }

    /// Get the number of generators
    pub fn ngens(&self) -> usize {
        self.graded.ngens()
    }

    /// Get generator names
    pub fn generator_names(&self) -> &[String] {
        self.graded.generator_names()
    }

    /// Get generator weights
    pub fn generator_weights(&self) -> &[Degree] {
        self.graded.generator_degrees()
    }
}

/// Element type for abelian Lie conformal algebras
pub type AbelianLCAElement<R> = LieConformalAlgebraElement<R, GeneratorIndex>;

impl<R: Ring + Clone + From<i64>> LieConformalAlgebra<R> for AbelianLieConformalAlgebra<R> {
    type Element = AbelianLCAElement<R>;

    fn base_ring(&self) -> &R {
        self.graded.base_ring()
    }

    fn ngens(&self) -> Option<usize> {
        Some(self.graded.ngens())
    }

    fn generator(&self, i: usize) -> Option<Self::Element> {
        if i < self.graded.ngens() {
            Some(LieConformalAlgebraElement::from_basis(
                GeneratorIndex::finite(i)
            ))
        } else {
            None
        }
    }

    fn is_abelian(&self) -> bool {
        true // All abelian LCAs are abelian!
    }

    fn zero(&self) -> Self::Element {
        LieConformalAlgebraElement::zero()
    }
}

impl<R: Ring + Clone + From<i64>> GradedLieConformalAlgebra<R> for AbelianLieConformalAlgebra<R> {
    fn generator_degree(&self, index: usize) -> Option<Degree> {
        self.graded.generator_degree(index)
    }

    fn degree(&self, element: &Self::Element) -> Option<Degree> {
        // For an abelian algebra, the degree is determined by the basis elements
        // This is a simplified implementation
        if element.is_zero() {
            return Some(Degree::int(0));
        }

        // Return the degree of the first basis element (if homogeneous)
        // A more sophisticated implementation would check homogeneity
        None
    }
}

impl<R: Ring + Clone> LambdaBracket<R, AbelianLCAElement<R>> for AbelianLieConformalAlgebra<R> {
    fn lambda_bracket(&self, _a: &AbelianLCAElement<R>, _b: &AbelianLCAElement<R>) -> HashMap<usize, AbelianLCAElement<R>> {
        // All λ-brackets vanish in an abelian algebra
        HashMap::new()
    }

    fn n_product(&self, _a: &AbelianLCAElement<R>, _b: &AbelianLCAElement<R>, _n: usize) -> AbelianLCAElement<R> {
        // All n-products vanish
        LieConformalAlgebraElement::zero()
    }
}

impl<R: Ring + Clone + Display> Display for AbelianLieConformalAlgebra<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Abelian Lie conformal algebra with {} generator(s) over {}",
            self.graded.ngens(),
            self.graded.base_ring()
        )?;

        if self.graded.ngens() > 0 && self.graded.ngens() <= 5 {
            write!(f, ": ")?;
            for (i, name) in self.graded.generator_names().iter().enumerate() {
                if i > 0 {
                    write!(f, ", ")?;
                }
                if let Some(deg) = self.graded.generator_degree(i) {
                    write!(f, "{}[{}]", name, deg)?;
                } else {
                    write!(f, "{}", name)?;
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_abelian_lca_creation() {
        let lca: AbelianLieConformalAlgebra<i64> = AbelianLieConformalAlgebra::new(
            1,
            2,
            None,
            None,
            None,
        );

        assert_eq!(lca.ngens(), 2);
        assert!(lca.is_abelian());
        assert_eq!(lca.generator_names().len(), 2);
    }

    #[test]
    fn test_abelian_lca_with_custom_names() {
        let names = vec!["alpha".to_string(), "beta".to_string()];
        let lca: AbelianLieConformalAlgebra<i64> = AbelianLieConformalAlgebra::new(
            1,
            2,
            Some(names.clone()),
            None,
            None,
        );

        assert_eq!(lca.generator_names()[0], "alpha");
        assert_eq!(lca.generator_names()[1], "beta");
    }

    #[test]
    fn test_abelian_lca_with_weights() {
        let weights = vec![Degree::int(1), Degree::int(3)];
        let lca: AbelianLieConformalAlgebra<i64> = AbelianLieConformalAlgebra::new(
            1,
            2,
            None,
            Some(weights),
            None,
        );

        assert_eq!(lca.generator_degree(0), Some(Degree::int(1)));
        assert_eq!(lca.generator_degree(1), Some(Degree::int(3)));
    }

    #[test]
    fn test_abelian_lca_generators() {
        let lca: AbelianLieConformalAlgebra<i64> = AbelianLieConformalAlgebra::new(
            1,
            3,
            None,
            None,
            None,
        );

        assert!(lca.generator(0).is_some());
        assert!(lca.generator(1).is_some());
        assert!(lca.generator(2).is_some());
        assert!(lca.generator(3).is_none());
    }

    #[test]
    fn test_abelian_lca_lambda_bracket() {
        let lca: AbelianLieConformalAlgebra<i64> = AbelianLieConformalAlgebra::new(
            1,
            2,
            None,
            None,
            None,
        );

        let a = lca.generator(0).unwrap();
        let b = lca.generator(1).unwrap();

        // All λ-brackets should vanish
        let bracket = lca.lambda_bracket(&a, &b);
        assert!(bracket.is_empty());

        // All n-products should vanish
        let n_prod = lca.n_product(&a, &b, 0);
        assert!(n_prod.is_zero());
    }

    #[test]
    fn test_abelian_lca_zero() {
        let lca: AbelianLieConformalAlgebra<i64> = AbelianLieConformalAlgebra::new(
            1,
            1,
            None,
            None,
            None,
        );

        let zero = lca.zero();
        assert!(zero.is_zero());
    }
}
