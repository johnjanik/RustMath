warning: unused imports: `MathError` and `Result`
 --> rustmath-matrix/src/eigenvalues.rs:4:28
  |
4 | use rustmath_core::{Field, MathError, Result};
  |                            ^^^^^^^^^  ^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Vector`
 --> rustmath-matrix/src/inner_product.rs:6:21
  |
6 | use crate::{Matrix, Vector};
  |                     ^^^^^^

warning: unused import: `MathError`
 --> rustmath-matrix/src/integer_forms.rs:7:38
  |
7 | use rustmath_core::{EuclideanDomain, MathError, Result};
  |                                      ^^^^^^^^^

warning: unused import: `crate::Matrix`
 --> rustmath-matrix/src/polynomial_ops.rs:3:5
  |
3 | use crate::Matrix;
  |     ^^^^^^^^^^^^^

warning: unused imports: `Field`, `MathError`, and `Result`
 --> rustmath-matrix/src/polynomial_ops.rs:4:21
  |
4 | use rustmath_core::{Field, MathError, Result};
  |                     ^^^^^  ^^^^^^^^^  ^^^^^^

warning: unused import: `rustmath_polynomials::UnivariatePolynomial`
 --> rustmath-matrix/src/polynomial_ops.rs:5:5
  |
5 | use rustmath_polynomials::UnivariatePolynomial;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Vector`
 --> rustmath-matrix/src/vector_space.rs:3:21
  |
3 | use crate::{Matrix, Vector};
  |                     ^^^^^^

warning: method `scalar_mul` is never used
   --> rustmath-matrix/src/polynomial_matrix.rs:350:8
    |
346 | trait PolynomialExt<F: Field> {
    |       ------------- method in this trait
...
350 |     fn scalar_mul(&self, scalar: &F) -> Self;
    |        ^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: `rustmath-matrix` (lib) generated 8 warnings (run `cargo fix --lib -p rustmath-matrix` to apply 7 suggestions)
warning: unused `#[macro_use]` import
 --> rustmath-combinatorics/src/lib.rs:6:1
  |
6 | #[macro_use]
  | ^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unnecessary parentheses around closure body
   --> rustmath-combinatorics/src/affine_permutations.rs:136:63
    |
136 |         let mut remainders: Vec<i64> = window.iter().map(|&x| ((x - 1).rem_euclid(n1))).collect();
    |                                                               ^                      ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
136 -         let mut remainders: Vec<i64> = window.iter().map(|&x| ((x - 1).rem_euclid(n1))).collect();
136 +         let mut remainders: Vec<i64> = window.iter().map(|&x| (x - 1).rem_euclid(n1)).collect();
    |

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-combinatorics/src/cluster_complex.rs:21:5
   |
21 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-combinatorics/src/cluster_complex.rs:22:24
   |
22 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `Polynomial`
  --> rustmath-combinatorics/src/cyclic_sieving.rs:29:28
   |
29 | use rustmath_polynomials::{Polynomial, UnivariatePolynomial};
   |                            ^^^^^^^^^^

warning: unused import: `crate::permutations::Permutation`
  --> rustmath-combinatorics/src/constellation.rs:37:5
   |
37 | use crate::permutations::Permutation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-combinatorics/src/constellation.rs:38:24
   |
38 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-combinatorics/src/interval_posets.rs:12:33
   |
12 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `crate::partitions::Partition`
  --> rustmath-combinatorics/src/gelfand_tsetlin.rs:32:5
   |
32 | use crate::partitions::Partition;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `OrderedTreeNode`
  --> rustmath-combinatorics/src/grossman_larson.rs:26:40
   |
26 | use crate::ordered_tree::{OrderedTree, OrderedTreeNode};
   |                                        ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-combinatorics/src/grossman_larson.rs:28:5
   |
28 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
 --> rustmath-combinatorics/src/plane_partition.rs:9:5
  |
9 | use rustmath_rationals::Rational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `random`
  --> rustmath-combinatorics/src/ranking.rs:73:11
   |
73 |     #[cfg(feature = "random")]
   |           ^^^^^^^^^^^^^^^^^^ help: remove the condition
   |
   = note: no expected values for `feature`
   = help: consider adding `random` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
   = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `AutomaticSequence`
  --> rustmath-combinatorics/src/regular_sequences.rs:29:19
   |
29 | use crate::word::{AutomaticSequence, Morphism, Word};
   |                   ^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-combinatorics/src/regular_sequences.rs:30:5
   |
30 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-combinatorics/src/regular_sequences.rs:31:33
   |
31 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `HashMap`
 --> rustmath-combinatorics/src/set_system.rs:7:24
  |
7 | use std::collections::{HashMap, HashSet};
  |                        ^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-combinatorics/src/triangles_fhm.rs:13:5
   |
13 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/alternating_sign_matrix.rs:12:5
   |
12 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/fully_packed_loop.rs:506:9
    |
506 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/fully_packed_loop.rs:526:9
    |
526 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/key_polynomial.rs:23:5
   |
23 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/lib.rs:345:5
    |
345 | use rustmath_core::Ring;
    |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/hall_polynomial.rs:42:5
   |
42 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-combinatorics/src/integer_vectors.rs:19:40
   |
19 | use rustmath_core::{NumericConversion, Ring};
   |                                        ^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/integer_matrices.rs:20:5
   |
20 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/kazhdan_lusztig.rs:18:5
   |
18 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/triangles_fhm.rs:10:5
   |
10 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/tiling.rs:19:5
   |
19 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-combinatorics/src/symmetric_group_representations.rs:15:21
   |
15 | use rustmath_core::{Ring, NumericConversion};
   |                     ^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-combinatorics/src/plane_partition.rs:7:5
  |
7 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/q_analogue.rs:31:5
   |
31 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/t_sequences.rs:38:5
   |
38 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/six_vertex_model.rs:39:5
   |
39 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/set_partition.rs:325:9
    |
325 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/set_partition.rs:369:9
    |
369 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `num_orbits_x`
   --> rustmath-combinatorics/src/bijectionist.rs:304:14
    |
304 |         let (num_orbits_x, fixed_x) = burnside_count(action_x, elements_x, group);
    |              ^^^^^^^^^^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
304 |         let (_num_orbits_x, fixed_x) = burnside_count(action_x, elements_x, group);
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
304 -         let (num_orbits_x, fixed_x) = burnside_count(action_x, elements_x, group);
304 +         let (permutation_simd::inverse_avx2::SIMD_WIDTH, fixed_x) = burnside_count(action_x, elements_x, group);
    |

warning: unused variable: `num_orbits_y`
   --> rustmath-combinatorics/src/bijectionist.rs:308:14
    |
308 |         let (num_orbits_y, fixed_y) = burnside_count(action_y, elements_y, group);
    |              ^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
308 |         let (_num_orbits_y, fixed_y) = burnside_count(action_y, elements_y, group);
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
308 -         let (num_orbits_y, fixed_y) = burnside_count(action_y, elements_y, group);
308 +         let (permutation_simd::inverse_avx2::SIMD_WIDTH, fixed_y) = burnside_count(action_y, elements_y, group);
    |

warning: unused variable: `n`
   --> rustmath-combinatorics/src/cluster_complex.rs:413:34
    |
413 |             ClusterCartanType::A(n) => {
    |                                  ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `heights`
   --> rustmath-combinatorics/src/dyck_word.rs:389:13
    |
389 |         let heights = self.heights();
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_heights`

warning: unused variable: `reflected_height`
   --> rustmath-combinatorics/src/dyck_word.rs:403:17
    |
403 |             let reflected_height = 2 * nu_at_next - bounce[i + 1];
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_reflected_height`

warning: unused variable: `lower`
   --> rustmath-combinatorics/src/interval_posets.rs:291:13
    |
291 |         let lower: Vec<usize> = elements
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_lower`

warning: unused variable: `upper`
   --> rustmath-combinatorics/src/interval_posets.rs:300:13
    |
300 |         let upper: Vec<usize> = elements
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_upper`

warning: unused variable: `shape`
   --> rustmath-combinatorics/src/growth_diagram.rs:110:13
    |
110 |         let shape = &self.grid[self.n][self.n];
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_shape`

warning: unused variable: `binom`
   --> rustmath-combinatorics/src/hall_polynomial.rs:404:13
    |
404 |         let binom = q_binomial(l2 as u32, (l2 - m2) as u32);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_binom`

warning: unused variable: `u_len`
  --> rustmath-combinatorics/src/kazhdan_lusztig.rs:46:9
   |
46 |     let u_len = length(u);
   |         ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
46 |     let _u_len = length(u);
   |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
46 -     let u_len = length(u);
46 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = length(u);
   |

warning: unused variable: `n`
  --> rustmath-combinatorics/src/kazhdan_lusztig.rs:40:64
   |
40 | pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, n: usize) -> Vec<Permutation> {
   |                                                                ^
   |
help: if this is intentional, prefix it with an underscore
   |
40 | pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, _n: usize) -> Vec<Permutation> {
   |                                                                +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
40 - pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, n: usize) -> Vec<Permutation> {
40 + pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, permutation_simd::inverse_avx2::SIMD_WIDTH: usize) -> Vec<Permutation> {
   |

warning: unused variable: `u_len`
   --> rustmath-combinatorics/src/kazhdan_lusztig.rs:250:9
    |
250 |     let u_len = length(u);
    |         ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
250 |     let _u_len = length(u);
    |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
250 -     let u_len = length(u);
250 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = length(u);
    |

warning: unused variable: `v_len`
   --> rustmath-combinatorics/src/kazhdan_lusztig.rs:251:9
    |
251 |     let v_len = length(v);
    |         ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
251 |     let _v_len = length(v);
    |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
251 -     let v_len = length(v);
251 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = length(v);
    |

warning: unused variable: `interval`
   --> rustmath-combinatorics/src/kazhdan_lusztig.rs:278:9
    |
278 |     let interval = bruhat_interval(u, v);
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_interval`

warning: variable does not need to be mutable
  --> rustmath-combinatorics/src/ordered_tree.rs:87:13
   |
87 |         let mut tree = OrderedTree {
   |             ----^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `n`
   --> rustmath-combinatorics/src/partitions.rs:162:13
    |
162 |         let n = self.sum();
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
162 |         let _n = self.sum();
    |             +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
162 -         let n = self.sum();
162 +         let permutation_simd::inverse_avx2::SIMD_WIDTH = self.sum();
    |

warning: unused variable: `expected_beta`
   --> rustmath-combinatorics/src/partitions.rs:238:17
    |
238 |             let expected_beta = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
    |                 ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
238 |             let _expected_beta = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
    |                 +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
238 -             let expected_beta = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
238 +             let permutation_simd::inverse_avx2::SIMD_WIDTH = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
    |

warning: unused variable: `beta_i`
   --> rustmath-combinatorics/src/partitions.rs:247:17
    |
247 |             let beta_i = (i / t) * t + runner + t * (pos / abacus.len());
    |                 ^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
247 |             let _beta_i = (i / t) * t + runner + t * (pos / abacus.len());
    |                 +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
247 -             let beta_i = (i / t) * t + runner + t * (pos / abacus.len());
247 +             let permutation_simd::inverse_avx2::SIMD_WIDTH = (i / t) * t + runner + t * (pos / abacus.len());
    |

warning: unused variable: `j`
   --> rustmath-combinatorics/src/partitions.rs:318:22
    |
318 |                 for (j, &hook) in row.iter().enumerate() {
    |                      ^
    |
help: if this is intentional, prefix it with an underscore
    |
318 |                 for (_j, &hook) in row.iter().enumerate() {
    |                      +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
318 -                 for (j, &hook) in row.iter().enumerate() {
318 +                 for (permutation_simd::inverse_avx2::SIMD_WIDTH, &hook) in row.iter().enumerate() {
    |

warning: unused variable: `core_beads`
   --> rustmath-combinatorics/src/partitions.rs:403:17
    |
403 |             let core_beads = &core_abacus[runner_idx];
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_core_beads`

warning: unused variable: `gap`
   --> rustmath-combinatorics/src/partitions.rs:430:17
    |
430 |             for gap in gaps {
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
430 |             for _gap in gaps {
    |                 +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
430 -             for gap in gaps {
430 +             for permutation_simd::inverse_avx2::SIMD_WIDTH in gaps {
    |

warning: variable does not need to be mutable
   --> rustmath-combinatorics/src/partitions.rs:560:17
    |
560 |             let mut new_parts = self.parts.clone();
    |                 ----^^^^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `remainder`
  --> rustmath-combinatorics/src/permutation_simd.rs:61:9
   |
61 |     let remainder = n % SIMD_WIDTH;
   |         ^^^^^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
61 |     let _remainder = n % SIMD_WIDTH;
   |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
61 -     let remainder = n % SIMD_WIDTH;
61 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = n % SIMD_WIDTH;
   |

warning: unused variable: `remainder`
   --> rustmath-combinatorics/src/permutation_simd.rs:134:9
    |
134 |     let remainder = n % SIMD_WIDTH;
    |         ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
134 |     let _remainder = n % SIMD_WIDTH;
    |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
134 -     let remainder = n % SIMD_WIDTH;
134 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = n % SIMD_WIDTH;
    |

warning: unused variable: `i`
   --> rustmath-combinatorics/src/q_analogue.rs:314:14
    |
314 |         for (i, c) in q.coefficients().iter().enumerate() {
    |              ^
    |
help: if this is intentional, prefix it with an underscore
    |
314 |         for (_i, c) in q.coefficients().iter().enumerate() {
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
314 -         for (i, c) in q.coefficients().iter().enumerate() {
314 +         for (permutation_simd::inverse_avx2::SIMD_WIDTH, c) in q.coefficients().iter().enumerate() {
    |

warning: unused variable: `left_size`
   --> rustmath-combinatorics/src/ranking.rs:450:60
    |
450 | fn combine_tree_ranks(left_rank: usize, right_rank: usize, left_size: usize, right_size: usize) -> us...
    |                                                            ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
450 | fn combine_tree_ranks(left_rank: usize, right_rank: usize, _left_size: usize, right_size: usize) -> usize {
    |                                                            +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
450 - fn combine_tree_ranks(left_rank: usize, right_rank: usize, left_size: usize, right_size: usize) -> usize {
450 + fn combine_tree_ranks(left_rank: usize, right_rank: usize, permutation_simd::inverse_avx2::SIMD_WIDTH: usize, right_size: usize) -> usize {
    |

warning: unused variable: `i`
   --> rustmath-combinatorics/src/t_sequences.rs:594:14
    |
594 |         for (i, c) in q.coefficients().iter().enumerate() {
    |              ^
    |
help: if this is intentional, prefix it with an underscore
    |
594 |         for (_i, c) in q.coefficients().iter().enumerate() {
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
594 -         for (i, c) in q.coefficients().iter().enumerate() {
594 +         for (permutation_simd::inverse_avx2::SIMD_WIDTH, c) in q.coefficients().iter().enumerate() {
    |

warning: unused variable: `cells`
   --> rustmath-combinatorics/src/ribbon_tableau.rs:287:9
    |
287 |     let cells = shape.cells();
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_cells`

warning: unused variable: `i`
  --> rustmath-combinatorics/src/restricted_growth.rs:57:14
   |
57 |         for (i, &value) in sequence.iter().enumerate().skip(1) {
   |              ^
   |
help: if this is intentional, prefix it with an underscore
   |
57 |         for (_i, &value) in sequence.iter().enumerate().skip(1) {
   |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
57 -         for (i, &value) in sequence.iter().enumerate().skip(1) {
57 +         for (permutation_simd::inverse_avx2::SIMD_WIDTH, &value) in sequence.iter().enumerate().skip(1) {
   |

warning: unused variable: `input`
   --> rustmath-combinatorics/src/similarity_class_type.rs:515:22
    |
515 | pub fn input_parsing(input: &str) -> Result<Vec<(usize, Partition)>, String> {
    |                      ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `q`
   --> rustmath-combinatorics/src/similarity_class_type.rs:533:44
    |
533 | pub fn matrix_similarity_classes(n: usize, q: &Integer) -> Vec<SimilarityClassType> {
    |                                            ^ help: if this is intentional, prefix it with an underscore: `_q`

warning: unused variable: `left_in`
   --> rustmath-combinatorics/src/six_vertex_model.rs:185:22
    |
185 |                 let (left_in, right_out, up_in, down_out) = vertex.arrows();
    |                      ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_left_in`

warning: unused variable: `up_in`
   --> rustmath-combinatorics/src/six_vertex_model.rs:185:42
    |
185 |                 let (left_in, right_out, up_in, down_out) = vertex.arrows();
    |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_up_in`

warning: unused variable: `row`
   --> rustmath-combinatorics/src/skew_partition.rs:695:43
    |
695 |     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
    |                                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
695 |     fn compute_shape_after_removal(&self, _row: usize, col: usize) -> Option<SkewPartition> {
    |                                           +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
695 -     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
695 +     fn compute_shape_after_removal(&self, permutation_simd::inverse_avx2::SIMD_WIDTH: usize, col: usize) -> Option<SkewPartition> {
    |

warning: unused variable: `col`
   --> rustmath-combinatorics/src/skew_partition.rs:695:55
    |
695 |     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
    |                                                       ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
695 |     fn compute_shape_after_removal(&self, row: usize, _col: usize) -> Option<SkewPartition> {
    |                                                       +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
695 -     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
695 +     fn compute_shape_after_removal(&self, row: usize, permutation_simd::inverse_avx2::SIMD_WIDTH: usize) -> Option<SkewPartition> {
    |

warning: variable does not need to be mutable
  --> rustmath-combinatorics/src/specht_module.rs:42:13
   |
42 |         let mut rows: Vec<Vec<usize>> = tableau
   |             ----^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `new_tabloid`
   --> rustmath-combinatorics/src/specht_module.rs:446:17
    |
446 |             let new_tabloid = tabloid.apply_permutation(perm);
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_tabloid`

warning: unused variable: `rep1`
   --> rustmath-combinatorics/src/symmetric_group_representations.rs:528:17
    |
528 |         for (i, rep1) in self.representations.iter().enumerate() {
    |                 ^^^^ help: if this is intentional, prefix it with an underscore: `_rep1`

warning: unused variable: `rep2`
   --> rustmath-combinatorics/src/symmetric_group_representations.rs:529:21
    |
529 |             for (j, rep2) in self.representations.iter().enumerate() {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_rep2`

warning: unused variable: `param`
   --> rustmath-combinatorics/src/tableaux.rs:806:56
    |
806 | fn hecke_insert_value(tableau: &Tableau, value: usize, param: u8) -> Tableau {
    |                                                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_param`

warning: unused variable: `path_to_index`
   --> rustmath-combinatorics/src/tamari.rs:283:9
    |
283 |         path_to_index: &HashMap<Vec<bool>, usize>,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_path_to_index`

warning: unused variable: `count`
   --> rustmath-combinatorics/src/ncsym.rs:249:13
    |
249 |     let mut count = 0;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_count`

warning: variable does not need to be mutable
   --> rustmath-combinatorics/src/ncsym.rs:249:9
    |
249 |     let mut count = 0;
    |         ----^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `swapped_mon`
   --> rustmath-combinatorics/src/key_polynomial.rs:357:17
    |
357 |             let swapped_mon = mon.swap_variables(i);
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_swapped_mon`

warning: field `index` is never read
   --> rustmath-combinatorics/src/dlx.rs:101:5
    |
 99 | struct ColumnHeader {
    |        ------------ field in this struct
100 |     /// Column index
101 |     index: usize,
    |     ^^^^^
    |
    = note: `ColumnHeader` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `n` is never read
   --> rustmath-combinatorics/src/enumeration.rs:701:5
    |
700 | pub struct PartitionIterator {
    |            ----------------- field in this struct
701 |     n: usize,
    |     ^

warning: fields `n` and `current` are never read
   --> rustmath-combinatorics/src/enumeration.rs:741:5
    |
740 | pub struct CompositionIterator {
    |            ------------------- fields in this struct
741 |     n: usize,
    |     ^
742 |     current: Option<Vec<usize>>,
    |     ^^^^^^^

warning: function `compute_northeast_partition` is never used
   --> rustmath-combinatorics/src/growth_diagram.rs:242:4
    |
242 | fn compute_northeast_partition(
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: struct `GenerationState` is never constructed
   --> rustmath-combinatorics/src/integer_lists.rs:251:8
    |
251 | struct GenerationState {
    |        ^^^^^^^^^^^^^^^

warning: fields `constraints`, `current_length`, `max_length`, `current_sum`, `max_sum`, and `stack` are never read
   --> rustmath-combinatorics/src/integer_lists.rs:573:5
    |
572 | pub struct IntegerListIterator {
    |            ------------------- fields in this struct
573 |     constraints: IntegerListConstraints,
    |     ^^^^^^^^^^^
574 |     current_length: usize,
    |     ^^^^^^^^^^^^^^
575 |     max_length: usize,
    |     ^^^^^^^^^^
576 |     current_sum: usize,
    |     ^^^^^^^^^^^
577 |     max_sum: usize,
    |     ^^^^^^^
578 |     stack: Vec<(Vec<usize>, usize)>, // (current list, position)
    |     ^^^^^

warning: field `cache` is never read
  --> rustmath-combinatorics/src/regular_sequences.rs:99:5
   |
95 | pub struct MorphicSequence<T: Clone + Ord + Hash> {
   |            --------------- field in this struct
...
99 |     cache: HashMap<usize, usize>,
   |     ^^^^^

warning: field `n` is never read
   --> rustmath-combinatorics/src/similarity_class_type.rs:381:5
    |
380 | pub struct SimilarityClassTypes {
    |            -------------------- field in this struct
381 |     n: usize,
    |     ^

warning: method `compute_shape_after_removal` is never used
   --> rustmath-combinatorics/src/skew_partition.rs:695:8
    |
398 | impl SkewTableau {
    | ---------------- method in this implementation
...
695 |     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: fields `col`, `start_row`, and `end_row` are never read
   --> rustmath-combinatorics/src/specht_module.rs:265:5
    |
263 | pub struct GarnirSet {
    |            --------- fields in this struct
264 |     /// First column index
265 |     col: usize,
    |     ^^^
266 |     /// Starting row index
267 |     start_row: usize,
    |     ^^^^^^^^^
268 |     /// Ending row index (inclusive)
269 |     end_row: usize,
    |     ^^^^^^^
    |
    = note: `GarnirSet` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `is_molecular` is never read
   --> rustmath-combinatorics/src/species.rs:421:5
    |
418 | pub struct MolecularSpecies {
    |            ---------------- field in this struct
...
421 |     is_molecular: bool,
    |     ^^^^^^^^^^^^
    |
    = note: `MolecularSpecies` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `n` and `k` are never read
   --> rustmath-combinatorics/src/subset.rs:524:5
    |
523 | pub struct KSubsetIterator {
    |            --------------- fields in this struct
524 |     n: usize,
    |     ^
525 |     k: usize,
    |     ^

warning: field `current_indices` is never read
   --> rustmath-combinatorics/src/subset.rs:716:5
    |
712 | pub struct PairwiseDisjointFamilyIterator {
    |            ------------------------------ field in this struct
...
716 |     current_indices: Vec<usize>,
    |     ^^^^^^^^^^^^^^^

warning: function `hillman_grassl_insert` is never used
   --> rustmath-combinatorics/src/tableaux.rs:646:4
    |
646 | fn hillman_grassl_insert(tableau: &Tableau, value: usize) -> Tableau {
    |    ^^^^^^^^^^^^^^^^^^^^^

warning: function `generate_parts_up_to` is never used
   --> rustmath-combinatorics/src/vector_partition.rs:197:4
    |
197 | fn generate_parts_up_to(max_vec: &[usize], constraint: &[usize]) -> Vec<Vec<usize>> {
    |    ^^^^^^^^^^^^^^^^^^^^

warning: field `states` is never read
   --> rustmath-combinatorics/src/word.rs:764:5
    |
760 | pub struct AutomaticSequence {
    |            ----------------- field in this struct
...
764 |     states: Vec<String>,
    |     ^^^^^^
    |
    = note: `AutomaticSequence` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `slope_p`, `slope_q`, and `rho` are never read
   --> rustmath-combinatorics/src/words.rs:714:5
    |
710 | pub struct SturmianWord {
    |            ------------ fields in this struct
...
714 |     slope_p: usize,
    |     ^^^^^^^
715 |     slope_q: usize,
    |     ^^^^^^^
716 |     /// The intercept parameter rho
717 |     rho: f64,
    |     ^^^
    |
    = note: `SturmianWord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `num_states` is never read
   --> rustmath-combinatorics/src/words.rs:971:5
    |
969 | pub struct AutomaticSequence {
    |            ----------------- field in this struct
970 |     /// Number of states
971 |     num_states: usize,
    |     ^^^^^^^^^^
    |
    = note: `AutomaticSequence` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: unexpected `cfg` condition value: `random`
   --> rustmath-graphs/src/generators/mod.rs:118:7
    |
118 | #[cfg(feature = "random")]
    |       ^^^^^^^^^^^^^^^^^^ help: remove the condition
    |
    = note: no expected values for `feature`
    = help: consider adding `random` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `rustmath_core::Ring`
  --> rustmath-graphs/src/graph_path.rs:10:5
   |
10 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `vertex_map`
    --> rustmath-graphs/src/graph.rs:1585:9
     |
1585 |     let vertex_map: Vec<usize> = (0..n)
     |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vertex_map`
     |
     = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `alpha`
   --> rustmath-graphs/src/generators/distance_regular.rs:921:60
    |
921 | pub fn graph_with_classical_parameters(d: usize, b: usize, alpha: i32, beta: i32) -> Graph {
    |                                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`

warning: unused variable: `beta`
   --> rustmath-graphs/src/generators/distance_regular.rs:921:72
    |
921 | pub fn graph_with_classical_parameters(d: usize, b: usize, alpha: i32, beta: i32) -> Graph {
    |                                                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `r`
   --> rustmath-graphs/src/generators/families.rs:945:35
    |
945 | pub fn fuzzy_ball_graph(n: usize, r: usize) -> Graph {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_r`

warning: unused variable: `graph`
  --> rustmath-graphs/src/cographs.rs:64:19
   |
64 | pub fn find_pivot(graph: &Graph, vertices: &[usize]) -> Option<usize> {
   |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_graph`

warning: unused variable: `current`
  --> rustmath-graphs/src/cographs.rs:74:18
   |
74 | pub fn next_tree(current: &CoTree) -> Option<CoTree> {
   |                  ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_current`

warning: unused variable: `count`
   --> rustmath-graphs/src/convexity_properties.rs:241:13
    |
241 |         let count = 0;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_count`

warning: unused variable: `start`
   --> rustmath-graphs/src/planarity.rs:166:30
    |
166 |     fn new(graph: &'a Graph, start: usize, visited: &'a mut Vec<bool>) -> Self {
    |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `n`
   --> rustmath-graphs/src/automorphisms.rs:109:20
    |
109 |     pub fn trivial(n: usize) -> Self {
    |                    ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `old_num_colors`
   --> rustmath-graphs/src/automorphisms.rs:234:17
    |
234 |             let old_num_colors = self.num_colors;
    |                 ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_old_num_colors`

warning: field `start` is never read
   --> rustmath-graphs/src/backends/c_graph.rs:218:5
    |
212 | pub struct SearchIterator {
    |            -------------- field in this struct
...
218 |     start: usize,
    |     ^^^^^
    |
    = note: `SearchIterator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `graph` is never read
  --> rustmath-graphs/src/edge_connectivity.rs:21:5
   |
19 | pub struct GabowEdgeConnectivity {
   |            --------------------- field in this struct
20 |     /// The directed graph to analyze
21 |     graph: DiGraph,
   |     ^^^^^

warning: method `is_descendant` is never used
   --> rustmath-graphs/src/planarity.rs:243:8
    |
165 | impl<'a> DfsTree<'a> {
    | -------------------- method in this implementation
...
243 |     fn is_descendant(&self, v: usize, ancestor: usize) -> bool {
    |        ^^^^^^^^^^^^^

warning: associated function `trivial` is never used
   --> rustmath-graphs/src/automorphisms.rs:171:8
    |
169 | impl ColorPartition {
    | ------------------- associated function in this implementation
170 |     /// Create initial partition with all vertices having the same color
171 |     fn trivial(n: usize) -> Self {
    |        ^^^^^^^

   Compiling rustmath-symbolic v0.1.0 (/home/john/RustMath/rustmath-symbolic)
warning: `rustmath-combinatorics` (lib) generated 98 warnings (run `cargo fix --lib -p rustmath-combinatorics` to apply 39 suggestions)
warning: `rustmath-graphs` (lib) generated 16 warnings
   Compiling rustmath-groups v0.1.0 (/home/john/RustMath/rustmath-groups)
   Compiling rustmath-rings v0.1.0 (/home/john/RustMath/rustmath-rings)
warning: associated items `new`, `from_points`, `center`, `volume`, and `contains` are never used
   --> rustmath-plot-core/src/bbox.rs:221:12
    |
219 | impl BoundingBox3D {
    | ------------------ associated items in this implementation
220 |     /// Create a new 3D bounding box
221 |     pub fn new(xmin: f64, xmax: f64, ymin: f64, ymax: f64, zmin: f64, zmax: f64) -> Self {
    |            ^^^
...
237 |     pub fn from_points(points: &[Point3D]) -> Result<Self> {
    |            ^^^^^^^^^^^
...
271 |     pub fn center(&self) -> Point3D {
    |            ^^^^^^
...
280 |     pub fn volume(&self) -> f64 {
    |            ^^^^^^
...
285 |     pub fn contains(&self, point: &Point3D) -> bool {
    |            ^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: `rustmath-plot-core` (lib) generated 1 warning
   Compiling rustmath-liealgebras v0.1.0 (/home/john/RustMath/rustmath-liealgebras)
warning: unused variable: `n`
   --> rustmath-geometry/src/hyperplane_arrangement/check_freeness.rs:219:9
    |
219 |     let n = hyperplanes.len();
    |         ^ help: if this is intentional, prefix it with an underscore: `_n`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `obj`
   --> rustmath-geometry/src/lattice_polytope.rs:539:28
    |
539 | pub fn is_lattice_polytope(obj: &LatticePolytopeClass) -> bool {
    |                            ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: associated function `empty` is never used
  --> rustmath-geometry/src/hyperplane_arrangement/arrangement.rs:88:8
   |
42 | impl<R: Ring> HyperplaneArrangementElement<R> {
   | --------------------------------------------- associated function in this implementation
...
88 |     fn empty(ambient_dim: usize) -> Self {
   |        ^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::collections::HashSet`
 --> rustmath-ellipticcurves/src/descent.rs:8:5
  |
8 | use std::collections::HashSet;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Zero`
 --> rustmath-ellipticcurves/src/lfunction.rs:7:31
  |
7 | use num_traits::{ToPrimitive, Zero, One};
  |                               ^^^^

warning: unnecessary parentheses around method argument
   --> rustmath-ellipticcurves/src/modular.rs:192:40
    |
192 |                 result.set_coefficient((m * self.index as usize), new_coeff);
    |                                        ^                       ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
192 -                 result.set_coefficient((m * self.index as usize), new_coeff);
192 +                 result.set_coefficient(m * self.index as usize, new_coeff);
    |

warning: unused import: `num_rational::BigRational`
 --> rustmath-ellipticcurves/src/bsd.rs:9:5
  |
9 | use num_rational::BigRational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `One`
  --> rustmath-ellipticcurves/src/bsd.rs:10:37
   |
10 | use num_traits::{ToPrimitive, Zero, One, Signed};
   |                                     ^^^

warning: variable `N` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:228:13
    |
228 |         let N = self.conductor.to_f64().unwrap_or(1.0);
    |             ^ help: convert the identifier to snake case: `n`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `L_value` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:231:13
    |
231 |         let L_value = self.evaluate(s, 1000);
    |             ^^^^^^^ help: convert the identifier to snake case: `l_value`

warning: variable `N_to_s_half` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:233:13
    |
233 |         let N_to_s_half = N.powf(s.re / 2.0) * ComplexNum::new(
    |             ^^^^^^^^^^^ help: convert the identifier to snake case: `n_to_s_half`

warning: unused import: `NumericConversion`
  --> rustmath-numbertheory/src/bernoulli.rs:46:27
   |
46 | use rustmath_core::{Ring, NumericConversion};
   |                           ^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `num_traits::ToPrimitive`
  --> rustmath-numbertheory/src/bernoulli.rs:47:5
   |
47 | use num_traits::ToPrimitive;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-numbertheory/src/quadratic_forms.rs:9:59
  |
9 | use rustmath_core::{MathError, NumericConversion, Result, Ring};
  |                                                           ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-numbertheory/src/quadratic_forms.rs:9:32
  |
9 | use rustmath_core::{MathError, NumericConversion, Result, Ring};
  |                                ^^^^^^^^^^^^^^^^^

warning: value assigned to `count` is never read
   --> rustmath-numbertheory/src/quadratic_forms.rs:432:17
    |
432 |         let mut count = Integer::zero();
    |                 ^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: creating a shared reference to mutable static
  --> rustmath-numbertheory/src/bernoulli.rs:87:12
   |
87 |         if CACHE.is_none() {
   |            ^^^^^^^^^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
   = note: `#[warn(static_mut_refs)]` (part of `#[warn(rust_2024_compatibility)]`) on by default

warning: creating a mutable reference to mutable static
  --> rustmath-numbertheory/src/bernoulli.rs:91:21
   |
91 |         let cache = CACHE.as_mut().unwrap();
   |                     ^^^^^^^^^^^^^^ mutable reference to mutable static
   |
   = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>
   = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives

warning: creating a mutable reference to mutable static
   --> rustmath-numbertheory/src/bernoulli.rs:124:9
    |
124 |         CACHE.as_mut().unwrap().insert(n, result.clone());
    |         ^^^^^^^^^^^^^^ mutable reference to mutable static
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>
    = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives

   Compiling rustmath-crystals v0.1.0 (/home/john/RustMath/rustmath-crystals)
   Compiling rustmath-symmetricfunctions v0.1.0 (/home/john/RustMath/rustmath-symmetricfunctions)
warning: unused import: `num_rational::BigRational`
 --> rustmath-modular/src/arithgroup.rs:9:5
  |
9 | use num_rational::BigRational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Signed`
  --> rustmath-modular/src/arithgroup.rs:10:29
   |
10 | use num_traits::{Zero, One, Signed};
   |                             ^^^^^^

warning: unused imports: `CongruenceSubgroup`, `Gamma0`, and `Gamma1`
 --> rustmath-modular/src/modform.rs:5:45
  |
5 | use crate::arithgroup::{ArithmeticSubgroup, CongruenceSubgroup, Gamma0, Gamma1};
  |                                             ^^^^^^^^^^^^^^^^^^  ^^^^^^  ^^^^^^

warning: unused import: `crate::cusps::Cusp`
 --> rustmath-modular/src/modform.rs:6:5
  |
6 | use crate::cusps::Cusp;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `CongruenceSubgroup`
 --> rustmath-modular/src/modsym.rs:7:45
  |
7 | use crate::arithgroup::{ArithmeticSubgroup, CongruenceSubgroup};
  |                                             ^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-modular/src/modsym.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CongruenceSubgroup`
 --> rustmath-modular/src/abvar.rs:6:45
  |
6 | use crate::arithgroup::{ArithmeticSubgroup, CongruenceSubgroup, Gamma0, Gamma1};
  |                                             ^^^^^^^^^^^^^^^^^^

warning: unused import: `Zero`
  --> rustmath-modular/src/abvar.rs:11:18
   |
11 | use num_traits::{Zero, One};
   |                  ^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-modular/src/abvar.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ToPrimitive`
  --> rustmath-modular/src/dims.rs:19:29
   |
19 | use num_traits::{Zero, One, ToPrimitive};
   |                             ^^^^^^^^^^^

warning: unused import: `Zero`
  --> rustmath-modular/src/dirichlet.rs:10:18
   |
10 | use num_traits::{Zero, One, ToPrimitive, Signed};
   |                  ^^^^

warning: unused import: `std::f64::consts::PI`
  --> rustmath-modular/src/dirichlet.rs:13:5
   |
13 | use std::f64::consts::PI;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `One`
  --> rustmath-modular/src/lfunction.rs:23:18
   |
23 | use num_traits::{One, ToPrimitive, Zero};
   |                  ^^^

warning: unused import: `ToPrimitive`
  --> rustmath-modular/src/etaproducts.rs:11:29
   |
11 | use num_traits::{Zero, One, ToPrimitive};
   |                             ^^^^^^^^^^^

warning: unused variable: `obj`
   --> rustmath-modular/src/abvar.rs:491:35
    |
491 | pub fn is_modular_abelian_variety(obj: &ModularAbelianVariety) -> bool {
    |                                   ^^^ help: if this is intentional, prefix it with an underscore: `_obj`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `space`
   --> rustmath-modular/src/abvar.rs:520:24
    |
520 | pub fn modsym_lattices(space: &ModularSymbolSpace) -> Vec<Vec<BigRational>> {
    |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_space`

warning: unused variable: `coeffs`
   --> rustmath-modular/src/abvar.rs:532:18
    |
532 | pub fn sqrt_poly(coeffs: &[BigRational]) -> Option<Vec<BigRational>> {
    |                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: unused variable: `h_subgroup`
   --> rustmath-modular/src/abvar.rs:936:27
    |
936 |     pub fn jh(level: u64, h_subgroup: Vec<u64>) -> ModularAbelianVariety {
    |                           ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_h_subgroup`

warning: unused variable: `obj`
   --> rustmath-modular/src/dirichlet.rs:214:31
    |
214 | pub fn is_dirichlet_character(obj: &DirichletCharacter) -> bool {
    |                               ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `obj`
   --> rustmath-modular/src/dirichlet.rs:220:27
    |
220 | pub fn is_dirichlet_group(obj: &DirichletGroup) -> bool {
    |                           ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `N`
   --> rustmath-modular/src/etaproducts.rs:323:5
    |
323 |     N: &BigInt,
    |     ^ help: if this is intentional, prefix it with an underscore: `_N`

warning: unused variable: `degree`
   --> rustmath-modular/src/etaproducts.rs:324:5
    |
324 |     degree: usize,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `p`
 --> rustmath-modular/src/btquotients/btquotient.rs:6:16
  |
6 |     pub fn new(p: u64, level: u64) -> Self {
  |                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `level`
 --> rustmath-modular/src/btquotients/btquotient.rs:6:24
  |
6 |     pub fn new(p: u64, level: u64) -> Self {
  |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_level`

warning: unused variable: `weight`
 --> rustmath-modular/src/btquotients/pautomorphicform.rs:6:16
  |
6 |     pub fn new(weight: i32) -> Self {
  |                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_weight`

warning: unused variable: `coeffs`
 --> rustmath-modular/src/drinfeld_modform/element.rs:6:16
  |
6 |     pub fn new(coeffs: Vec<f64>) -> Self {
  |                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: unused variable: `rank`
 --> rustmath-modular/src/drinfeld_modform/ring.rs:6:16
  |
6 |     pub fn new(rank: usize) -> Self {
  |                ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`

warning: unused variable: `level`
 --> rustmath-modular/src/quatalg/brandt.rs:6:16
  |
6 |     pub fn new(level: u64) -> Self {
  |                ^^^^^ help: if this is intentional, prefix it with an underscore: `_level`

warning: unused variable: `p`
 --> rustmath-modular/src/ssmod/ssmod.rs:6:16
  |
6 |     pub fn new(p: u64) -> Self {
  |                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `alpha`
  --> rustmath-modular/src/hypergeometric_motive.rs:29:26
   |
29 |     fn compute_conductor(alpha: &[f64], beta: &[f64]) -> u64 {
   |                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`

warning: unused variable: `beta`
  --> rustmath-modular/src/hypergeometric_motive.rs:29:41
   |
29 |     fn compute_conductor(alpha: &[f64], beta: &[f64]) -> u64 {
   |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `p`
  --> rustmath-modular/src/hypergeometric_motive.rs:35:32
   |
35 |     pub fn euler_factor(&self, p: u64) -> Vec<f64> {
   |                                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
  --> rustmath-modular/src/hypergeometric_motive.rs:41:38
   |
41 |     pub fn is_wildly_ramified(&self, p: u64) -> bool {
   |                                      ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `precision`
  --> rustmath-modular/src/multiple_zeta.rs:30:35
   |
30 |     pub fn numerical_value(&self, precision: usize) -> f64 {
   |                                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`

warning: field `matrix` is never read
  --> rustmath-modular/src/hecke.rs:20:5
   |
14 | pub struct HeckeOperator {
   |            ------------- field in this struct
...
20 |     matrix: Option<Vec<Vec<BigRational>>>,
   |     ^^^^^^
   |
   = note: `HeckeOperator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `base` is never read
   --> rustmath-modular/src/abvar.rs:576:5
    |
574 | pub struct FiniteSubgroupLattice {
    |            --------------------- field in this struct
575 |     /// Base finite subgroup
576 |     base: FiniteSubgroup,
    |     ^^^^
    |
    = note: `FiniteSubgroupLattice` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-modular/src/abvar.rs:678:5
    |
676 | pub struct LseriesComplex {
    |            -------------- field in this struct
677 |     /// Base L-series
678 |     base: Lseries,
    |     ^^^^
    |
    = note: `LseriesComplex` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-modular/src/abvar.rs:700:5
    |
698 | pub struct LseriesPadic {
    |            ------------ field in this struct
699 |     /// Base L-series
700 |     base: Lseries,
    |     ^^^^
    |
    = note: `LseriesPadic` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variable `N` should have a snake case name
  --> rustmath-modular/src/dims.rs:54:14
   |
54 | pub fn eisen(N: &BigInt, k: i64) -> BigInt {
   |              ^ help: convert the identifier to snake case: `n`
   |
   = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `N` should have a snake case name
  --> rustmath-modular/src/dims.rs:79:17
   |
79 | pub fn co_delta(N: &BigInt) -> BigInt {
   |                 ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:109:14
    |
109 | pub fn co_nu(N: &BigInt) -> BigInt {
    |              ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:141:23
    |
141 | pub fn cohen_oesterle(N: &BigInt, k: i64) -> BigInt {
    |                       ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:173:33
    |
173 | pub fn dimension_new_cusp_forms(N: &BigInt, k: i64) -> BigInt {
    |                                 ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:202:29
    |
202 | pub fn dimension_cusp_forms(N: &BigInt, k: i64) -> BigInt {
    |                             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:241:22
    |
241 | pub fn dimension_eis(N: &BigInt, k: i64) -> BigInt {
    |                      ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:253:32
    |
253 | pub fn dimension_modular_forms(N: &BigInt, k: i64) -> BigInt {
    |                                ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:280:20
    |
280 | pub fn sturm_bound(N: &BigInt, k: i64) -> BigInt {
    |                    ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dirichlet.rs:209:30
    |
209 | pub fn dirichlet_group_class(N: BigInt) -> DirichletGroup {
    |                              ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dirichlet.rs:232:26
    |
232 | pub fn trivial_character(N: BigInt) -> DirichletCharacter {
    |                          ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dirichlet.rs:266:28
    |
266 | pub fn principal_character(N: BigInt) -> DirichletCharacter {
    |                            ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:141:13
    |
141 |         let N = self.conductor as f64;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N_power` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:145:13
    |
145 |         let N_power = Complex64::new(
    |             ^^^^^^^ help: convert the identifier to snake case: `n_power`

warning: variable `L_value` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:161:13
    |
161 |         let L_value = self.evaluate_series(s, 1000);
    |             ^^^^^^^ help: convert the identifier to snake case: `l_value`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:203:13
    |
203 |         let N = self.conductor as f64;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `W` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:219:13
    |
219 |         let W = self.root_number();
    |             ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: variable `N_power` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:220:13
    |
220 |         let N_power = Complex64::from(N).powc(Complex64::from(0.5) - s);
    |             ^^^^^^^ help: convert the identifier to snake case: `n_power`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:310:13
    |
310 |         let N = self.conductor as f64;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `sqrt_N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:314:13
    |
314 |         let sqrt_N = N.sqrt();
    |             ^^^^^^ help: convert the identifier to snake case: `sqrt_n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:323:13
    |
323 |         let N = self.conductor;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:346:13
    |
346 |         let N = self.conductor;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:169:24
    |
169 | pub fn eta_group_class(N: BigInt) -> EtaGroup {
    |                        ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:178:20
    |
178 | pub fn eta_product(N: BigInt, powers: HashMap<BigInt, i64>) -> EtaGroupElement {
    |                    ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:260:18
    |
260 | pub fn all_cusps(N: BigInt) -> Vec<(BigInt, BigInt)> {
    |                  ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:283:27
    |
283 | pub fn num_cusps_of_width(N: &BigInt, width: &BigInt) -> usize {
    |                           ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:323:5
    |
323 |     N: &BigInt,
    |     ^ help: convert the identifier to snake case: `n`

warning: unused imports: `ANBinaryExpr`, `ANRational`, and `BinaryOp`
 --> rustmath-algebraic/src/algebraic_real.rs:8:34
  |
8 |     AlgebraicDescriptor, ANRoot, ANRational, ANUnaryExpr, ANBinaryExpr, BinaryOp, UnaryOp,
  |                                  ^^^^^^^^^^               ^^^^^^^^^^^^  ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `crate::algebraic_number::AlgebraicNumber`
 --> rustmath-algebraic/src/radicals.rs:6:5
  |
6 | use crate::algebraic_number::AlgebraicNumber;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `precision`
  --> rustmath-algebraic/src/algebraic_number.rs:51:30
   |
51 |     pub fn to_complex(&self, precision: usize) -> Complex {
   |                              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `precision`
   --> rustmath-algebraic/src/algebraic_real.rs:149:26
    |
149 |     pub fn to_f64(&self, precision: usize) -> f64 {
    |                          ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`

warning: unused variable: `min_poly`
  --> rustmath-algebraic/src/conjugates.rs:18:9
   |
18 |     let min_poly = minimal_polynomial(alpha);
   |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_poly`

warning: unused imports: `Float`, `One`, and `Zero`
  --> rustmath-special-functions/src/lib.rs:12:18
   |
12 | use num_traits::{Float, One, Zero};
   |                  ^^^^^  ^^^  ^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `E` and `PI`
  --> rustmath-special-functions/src/lib.rs:13:24
   |
13 | use std::f64::consts::{E, PI};
   |                        ^  ^^

warning: unused variable: `mu`
  --> rustmath-special-functions/src/bessel.rs:64:9
   |
64 |     let mu = 4.0 * (n as f64).powi(2);
   |         ^^
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
   |
64 |     let _mu = 4.0 * (n as f64).powi(2);
   |         +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
   |
64 -     let mu = 4.0 * (n as f64).powi(2);
64 +     let error::erfc_continued_fraction::EPSILON = 4.0 * (n as f64).powi(2);
   |

warning: unused variable: `k_f`
   --> rustmath-special-functions/src/bessel.rs:120:13
    |
120 |         let k_f = k as f64;
    |             ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
120 |         let _k_f = k as f64;
    |             +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
    |
120 -         let k_f = k as f64;
120 +         let error::erfc_continued_fraction::EPSILON = k as f64;
    |

warning: unused variable: `x2`
  --> rustmath-special-functions/src/error.rs:69:9
   |
69 |     let x2 = x * x;
   |         ^^
   |
help: if this is intentional, prefix it with an underscore
   |
69 |     let _x2 = x * x;
   |         +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
   |
69 -     let x2 = x * x;
69 +     let error::erfc_continued_fraction::EPSILON = x * x;
   |

warning: value assigned to `a` is never read
  --> rustmath-special-functions/src/error.rs:93:13
   |
93 |     let mut a = 1.0;
   |             ^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: `rustmath-geometry` (lib) generated 3 warnings
warning: `rustmath-ellipticcurves` (lib) generated 8 warnings (run `cargo fix --lib -p rustmath-ellipticcurves` to apply 5 suggestions)
warning: `rustmath-numbertheory` (lib) generated 8 warnings
warning: `rustmath-modular` (lib) generated 65 warnings (run `cargo fix --lib -p rustmath-modular` to apply 14 suggestions)
warning: `rustmath-algebraic` (lib) generated 5 warnings (run `cargo fix --lib -p rustmath-algebraic` to apply 2 suggestions)
warning: `rustmath-special-functions` (lib) generated 6 warnings (run `cargo fix --lib -p rustmath-special-functions` to apply 5 suggestions)
warning: unused import: `rustmath_core::Ring`
 --> rustmath-quadraticforms/src/quadratic_form.rs:6:5
  |
6 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/theta_series.rs:8:21
  |
8 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/theta_series.rs:8:27
  |
8 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/local_densities.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/local_densities.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/genus_theory.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/genus_theory.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/advanced.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/advanced.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused variable: `d`
  --> rustmath-quadraticforms/src/local_densities.rs:83:13
   |
83 |         let d = (-self.form.discriminant()).clone();
   |             ^ help: if this is intentional, prefix it with an underscore: `_d`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p_power`
   --> rustmath-quadraticforms/src/local_densities.rs:173:13
    |
173 |         let p_power = p_int.pow(k);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_p_power`

warning: unused variable: `n3`
  --> rustmath-quadraticforms/src/advanced.rs:96:42
   |
96 |             if let [(n1, a1), (n2, a2), (n3, a3)] = window {
   |                                          ^^ help: if this is intentional, prefix it with an underscore: `_n3`

warning: method `p_adic_equivalent` is never used
   --> rustmath-quadraticforms/src/genus_theory.rs:189:8
    |
 18 | impl GenusTheory {
    | ---------------- method in this implementation
...
189 |     fn p_adic_equivalent(&self, form1: &QuadraticForm, form2: &QuadraticForm, p: u64) -> bool {
    |        ^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `plot_multiple` is never used
  --> rustmath-plot/src/plots/plot.rs:95:8
   |
95 | pub fn plot_multiple<F>(
   |        ^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `parametric_plot_adaptive` is never used
   --> rustmath-plot/src/plots/parametric_plot.rs:111:8
    |
111 | pub fn parametric_plot_adaptive<F, G>(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `list_plot_y` is never used
  --> rustmath-plot/src/plots/list_plot.rs:91:8
   |
91 | pub fn list_plot_y(
   |        ^^^^^^^^^^^

warning: function `list_plot_multiple` is never used
   --> rustmath-plot/src/plots/list_plot.rs:137:8
    |
137 | pub fn list_plot_multiple(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `scatter_plot_y` is never used
  --> rustmath-plot/src/plots/scatter_plot.rs:77:8
   |
77 | pub fn scatter_plot_y(
   |        ^^^^^^^^^^^^^^

warning: function `scatter_plot_colored` is never used
   --> rustmath-plot/src/plots/scatter_plot.rs:116:8
    |
116 | pub fn scatter_plot_colored(
    |        ^^^^^^^^^^^^^^^^^^^^

warning: function `scatter_plot_sized` is never used
   --> rustmath-plot/src/plots/scatter_plot.rs:160:8
    |
160 | pub fn scatter_plot_sized(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `contour_plot_filled` is never used
   --> rustmath-plot/src/plots/contour_plot.rs:122:8
    |
122 | pub fn contour_plot_filled<F>(
    |        ^^^^^^^^^^^^^^^^^^^

warning: function `density_plot_custom` is never used
   --> rustmath-plot/src/plots/density_plot.rs:154:8
    |
154 | pub fn density_plot_custom<F, C>(
    |        ^^^^^^^^^^^^^^^^^^^

warning: function `histogram_custom_bins` is never used
   --> rustmath-plot/src/plots/histogram.rs:132:8
    |
132 | pub fn histogram_custom_bins(
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: function `bar_chart_horizontal` is never used
  --> rustmath-plot/src/plots/bar_chart.rs:77:8
   |
77 | pub fn bar_chart_horizontal(
   |        ^^^^^^^^^^^^^^^^^^^^

warning: function `bar_chart_colored` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:122:8
    |
122 | pub fn bar_chart_colored(data: Vec<(f64, f64, Color)>, bar_width: Option<f64>) -> Graphics {
    |        ^^^^^^^^^^^^^^^^^

warning: function `bar_chart_grouped` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:166:8
    |
166 | pub fn bar_chart_grouped(
    |        ^^^^^^^^^^^^^^^^^

warning: function `bar_chart_stacked` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:232:8
    |
232 | pub fn bar_chart_stacked(data: Vec<(f64, Vec<f64>, Vec<Color>)>, bar_width: Option<f64>) -> Graphics {
    |        ^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_range` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:119:8
    |
119 | pub fn matrix_plot_range(
    |        ^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_binary` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:173:8
    |
173 | pub fn matrix_plot_binary(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_spy` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:222:8
    |
222 | pub fn matrix_plot_spy(matrix: Vec<Vec<f64>>, threshold: Option<f64>, color: Color) -> Graphics {
    |        ^^^^^^^^^^^^^^^

warning: unused variable: `x`
   --> rustmath-numerical/src/lib.rs:121:24
    |
121 |     fn gradient(&self, x: T) -> Option<T> {
    |                        ^ help: if this is intentional, prefix it with an underscore: `_x`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `fb` is never read
  --> rustmath-numerical/src/root_finding/methods.rs:60:13
   |
60 |             fb = fc;
   |             ^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-numerical/src/optimization/brent.rs:172:13
    |
172 |         let mut s;
    |             ----^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `b`
  --> rustmath-numerical/src/linear_programming.rs:20:5
   |
20 |     b: &[f64],
   |     ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `max_iter`
  --> rustmath-numerical/src/linear_programming.rs:21:5
   |
21 |     max_iter: usize,
   |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_iter`

warning: constant `PHI` is never used
   --> rustmath-numerical/src/optimization/brent.rs:322:11
    |
322 |     const PHI: f64 = 1.618033988749895; // Golden ratio
    |           ^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

   Compiling rustmath-plot3d v0.1.0 (/home/john/RustMath/rustmath-plot3d)
warning: field `headers` is never read
 --> rustmath-misc/src/table.rs:7:5
  |
5 | pub struct Table {
  |            ----- field in this struct
6 |     rows: Vec<Vec<String>>,
7 |     headers: Option<Vec<String>>,
  |     ^^^^^^^
  |
  = note: `Table` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
  = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `x_prev` is never read
   --> rustmath-dynamics/src/chaos.rs:169:13
    |
169 |     let mut x_prev = x;
    |             ^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `x_prev` is never read
   --> rustmath-dynamics/src/chaos.rs:173:9
    |
173 |         x_prev = x;
    |         ^^^^^^
    |
    = help: maybe it is overwritten before being read?

warning: unused import: `rustmath_core::Ring`
 --> rustmath-coding/src/linear_code.rs:5:5
  |
5 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `field_char`
   --> rustmath-coding/src/linear_code.rs:207:60
    |
207 |     fn compute_parity_check_matrix(generator: &[Vec<u64>], field_char: u64) -> Vec<Vec<u64>> {
    |                                                            ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_field_char`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p`
   --> rustmath-coding/src/reed_solomon.rs:103:13
    |
103 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
   --> rustmath-coding/src/reed_solomon.rs:165:13
    |
165 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `k`
  --> rustmath-coding/src/bch.rs:63:38
   |
63 |     pub fn with_parameters(n: usize, k: usize, delta: usize) -> Result<Self, String> {
   |                                      ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `p`
   --> rustmath-coding/src/syndrome.rs:197:13
    |
197 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
   --> rustmath-coding/src/syndrome.rs:205:13
    |
205 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: field `eval_points` is never read
  --> rustmath-coding/src/reed_solomon.rs:23:5
   |
13 | pub struct ReedSolomonCode {
   |            --------------- field in this struct
...
23 |     eval_points: Vec<u64>,
   |     ^^^^^^^^^^^
   |
   = note: `ReedSolomonCode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: fields `m` and `field_char` are never read
  --> rustmath-coding/src/bch.rs:19:5
   |
11 | pub struct BCHCode {
   |            ------- fields in this struct
...
19 |     m: usize,
   |     ^
...
23 |     field_char: u64,
   |     ^^^^^^^^^^
   |
   = note: `BCHCode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `field_char` is never read
  --> rustmath-coding/src/syndrome.rs:12:5
   |
 8 | pub struct SyndromeTable {
   |            ------------- field in this struct
...
12 |     field_char: u64,
   |     ^^^^^^^^^^
   |
   = note: `SyndromeTable` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: unused variable: `text`
   --> rustmath-crypto/src/classical.rs:212:21
    |
212 | pub fn hill_decrypt(text: &str, key_matrix: &Matrix<Integer>) -> Result<String> {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_text`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `key_matrix`
   --> rustmath-crypto/src/classical.rs:212:33
    |
212 | pub fn hill_decrypt(text: &str, key_matrix: &Matrix<Integer>) -> Result<String> {
    |                                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_key_matrix`

warning: unused variable: `j`
   --> rustmath-crypto/src/kdf.rs:213:17
    |
213 |             for j in 0..32 {
    |                 ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `challenge`
   --> rustmath-crypto/src/eddsa.rs:351:13
    |
351 |         let challenge = SHA256::hash(&challenge_input);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_challenge`

warning: unused variable: `s_point`
   --> rustmath-crypto/src/eddsa.rs:358:13
    |
358 |         let s_point = basepoint.scalar_mul(&signature.s);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_s_point`

warning: unused variable: `r_point`
   --> rustmath-crypto/src/eddsa.rs:359:13
    |
359 |         let r_point = basepoint.scalar_mul(&signature.r);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_r_point`

warning: unused variable: `verify_hash`
   --> rustmath-crypto/src/eddsa.rs:367:13
    |
367 |         let verify_hash = SHA256::hash(&verify_input);
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_verify_hash`

warning: associated function `quarter_round` is never used
   --> rustmath-crypto/src/stream_cipher.rs:144:8
    |
 88 | impl ChaCha20 {
    | ------------- associated function in this implementation
...
144 |     fn quarter_round(a: &mut u32, b: &mut u32, c: &mut u32, d: &mut u32) {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: associated items `P`, `from_bytes`, and `mul_small` are never used
   --> rustmath-crypto/src/eddsa.rs:52:11
    |
 50 | impl FieldElement {
    | ----------------- associated items in this implementation
 51 |     /// Prime for Curve25519: 2^255 - 19
 52 |     const P: [u64; 5] = [
    |           ^
...
 69 |     fn from_bytes(bytes: &[u8; 32]) -> Self {
    |        ^^^^^^^^^^
...
122 |     fn mul_small(&self, scalar: u64) -> FieldElement {
    |        ^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
 --> rustmath-stats/src/hypothesis.rs:6:5
  |
6 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `variance`
 --> rustmath-stats/src/regression.rs:5:31
  |
5 | use crate::statistics::{mean, variance};
  |                               ^^^^^^^^

warning: unused variable: `alpha`
   --> rustmath-stats/src/hypothesis.rs:195:21
    |
195 | fn t_critical_value(alpha: f64, df: usize) -> f64 {
    |                     ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `n_features`
   --> rustmath-stats/src/regression.rs:131:13
    |
131 |         let n_features = x_matrix[0].len();
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_features`

warning: variable does not need to be mutable
   --> rustmath-stats/src/regression.rs:134:13
    |
134 |         let mut x_with_intercept: Vec<Vec<f64>> = x_matrix
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_core::Ring`
  --> rustmath-constants/src/certificates.rs:12:5
   |
12 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_core::Ring`
 --> rustmath-constants/src/factorizations.rs:8:5
  |
8 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-constants/src/sequences.rs:13:5
   |
13 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-constants/src/tables.rs:6:5
  |
6 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: field `mult_table` is never read
  --> rustmath-monoids/src/automatic_semigroup.rs:35:5
   |
31 | pub struct AutomaticSemigroup {
   |            ------------------ field in this struct
...
35 |     mult_table: Option<HashMap<(usize, usize), usize>>,
   |     ^^^^^^^^^^
   |
   = note: `AutomaticSemigroup` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: `rustmath-quadraticforms` (lib) generated 13 warnings
warning: `rustmath-plot` (lib) generated 17 warnings
warning: `rustmath-numerical` (lib) generated 6 warnings (run `cargo fix --lib -p rustmath-numerical` to apply 1 suggestion)
warning: `rustmath-misc` (lib) generated 1 warning
warning: `rustmath-dynamics` (lib) generated 2 warnings
warning: `rustmath-coding` (lib) generated 10 warnings
warning: `rustmath-crypto` (lib) generated 9 warnings
warning: `rustmath-stats` (lib) generated 5 warnings (run `cargo fix --lib -p rustmath-stats` to apply 3 suggestions)
warning: `rustmath-constants` (lib) generated 4 warnings
warning: `rustmath-monoids` (lib) generated 1 warning
warning: field `count` is never read
   --> rustmath-databases/src/oeis.rs:114:5
    |
110 | struct OEISResponse {
    |        ------------ field in this struct
...
114 |     count: i32,
    |     ^^^^^
    |
    = note: `OEISResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `data_path` is never read
   --> rustmath-databases/src/cunningham.rs:205:5
    |
201 | pub struct CunninghamTables {
    |            ---------------- field in this struct
...
205 |     data_path: Option<String>,
    |     ^^^^^^^^^

warning: field `data_path` is never read
   --> rustmath-databases/src/cremona.rs:385:5
    |
381 | pub struct CremonaDatabase {
    |            --------------- field in this struct
...
385 |     data_path: Option<String>,
    |     ^^^^^^^^^

warning: fields `base_url`, `client`, and `cache` are never read
   --> rustmath-databases/src/lmfdb.rs:115:5
    |
114 | pub struct LMFDBClient {
    |            ----------- fields in this struct
115 |     base_url: String,
    |     ^^^^^^^^
116 |     client: reqwest::blocking::Client,
    |     ^^^^^^
117 |     /// In-memory cache of queries
118 |     cache: std::sync::Mutex<HashMap<String, String>>,
    |     ^^^^^

warning: `rustmath-databases` (lib) generated 4 warnings
error: expected item after doc comment
  --> rustmath-groups/src/groups_catalog.rs:84:5
   |
54 | /     /// Creates a General Linear Group GL(n) over a ring
55 | |     ///
56 | |     /// # Arguments
57 | |     ///
...  |
82 | |     ///
83 | |     /// let sl2 = matrix::SL(2);
   | |________________________________- other attributes here
84 |       /// ```
   |       ^^^^^^^ this doc comment doesn't document anything

warning: unused import: `Field`
  --> rustmath-symmetricfunctions/src/basis.rs:11:27
   |
11 | use rustmath_core::{Ring, Field};
   |                           ^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-symmetricfunctions/src/basis.rs:12:5
   |
12 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-symmetricfunctions/src/basis.rs:13:5
   |
13 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-symmetricfunctions/src/basis.rs:15:5
   |
15 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Tableau`
 --> rustmath-symmetricfunctions/src/kostka.rs:7:41
  |
7 | use rustmath_combinatorics::{Partition, Tableau};
  |                                         ^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-symmetricfunctions/src/plethysm.rs:10:5
   |
10 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-symmetricfunctions/src/plethysm.rs:11:5
   |
11 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `compositions_k` and `compositions`
  --> rustmath-symmetricfunctions/src/ncsf.rs:14:43
   |
14 | use rustmath_combinatorics::{Composition, compositions, compositions_k};
   |                                           ^^^^^^^^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-symmetricfunctions/src/ncsf.rs:17:5
   |
17 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `compositions_k`
  --> rustmath-symmetricfunctions/src/qsym.rs:13:57
   |
13 | use rustmath_combinatorics::{Composition, compositions, compositions_k};
   |                                                         ^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-symmetricfunctions/src/qsym.rs:16:5
   |
16 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `complete_to_monomial`
   --> rustmath-symmetricfunctions/src/qsym.rs:449:34
    |
449 |     use crate::ncsf::{NCSFBasis, complete_to_monomial};
    |                                  ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
 --> rustmath-plot3d/src/transform.rs:4:5
  |
4 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Vector3D`
 --> rustmath-plot3d/src/shapes.rs:6:78
  |
6 | use crate::base::{Graphics3dPrimitive, IndexFaceSet, BoundingBox3D, Point3D, Vector3D};
  |                                                                              ^^^^^^^^

warning: unused import: `Vector3D`
 --> rustmath-plot3d/src/plots/scatter_plot3d.rs:6:54
  |
6 | use crate::base::{Graphics3d, IndexFaceSet, Point3D, Vector3D};
  |                                                      ^^^^^^^^

warning: unused import: `Vector3D`
 --> rustmath-plot3d/src/plots/implicit_plot3d.rs:6:54
  |
6 | use crate::base::{Graphics3d, IndexFaceSet, Point3D, Vector3D};
  |                                                      ^^^^^^^^

warning: unused import: `Point3D`
 --> rustmath-plot3d/src/export.rs:6:45
  |
6 | use crate::base::{Graphics3d, IndexFaceSet, Point3D, Vector3D};
  |                                             ^^^^^^^

warning: unused import: `Plot3DError`
 --> rustmath-plot3d/src/export.rs:7:13
  |
7 | use crate::{Plot3DError, Result};
  |             ^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/tableau_crystal.rs:6:33
  |
6 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_combinatorics::Tableau`
 --> rustmath-crystals/src/tableau_crystal.rs:8:5
  |
8 | use rustmath_combinatorics::Tableau;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-crystals/src/tensor_product.rs:11:5
   |
11 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/affine.rs:9:33
  |
9 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/highest_weight.rs:6:33
  |
6 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/littelmann.rs:8:33
  |
8 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/spin_crystal.rs:8:33
  |
8 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/kr_crystal.rs:9:33
  |
9 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/elementary.rs:9:33
  |
9 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
  --> rustmath-crystals/src/morphisms.rs:10:33
   |
10 | use crate::operators::{Crystal, CrystalElement};
   |                                 ^^^^^^^^^^^^^^

warning: unused import: `crate::weight::Weight`
  --> rustmath-crystals/src/morphisms.rs:11:5
   |
11 | use crate::weight::Weight;
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
 --> rustmath-crystals/src/nakajima.rs:6:33
  |
6 | use crate::operators::{Crystal, CrystalElement};
  |                                 ^^^^^^^^^^^^^^

warning: unused import: `CrystalElement`
  --> rustmath-crystals/src/rigged_configurations.rs:24:33
   |
24 | use crate::operators::{Crystal, CrystalElement};
   |                                 ^^^^^^^^^^^^^^

warning: unused import: `KRCrystal`
  --> rustmath-crystals/src/rigged_configurations.rs:26:25
   |
26 | use crate::kr_crystal::{KRCrystal, KRElement};
   |                         ^^^^^^^^^

warning: unused variable: `face_idx`
   --> rustmath-plot3d/src/export.rs:209:10
    |
209 |     for (face_idx, face) in mesh.faces.iter().enumerate() {
    |          ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_face_idx`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0432]: unresolved import `braid::BraidGroup_class`
  --> rustmath-groups/src/lib.rs:60:29
   |
60 | pub use braid::{BraidGroup, BraidGroup_class, Braid, braid_group, MappingClassGroupAction, MappingClass, RightQuantumWord};
   |                             ^^^^^^^^^^^^^^^^
   |                             |
   |                             no `BraidGroup_class` in `braid`
   |                             help: a similar name exists in the module: `BraidGroupClass`

error[E0432]: unresolved imports `class_function::ClassFunction_gap`, `class_function::ClassFunction_libgap`
  --> rustmath-groups/src/lib.rs:62:41
   |
62 | pub use class_function::{ClassFunction, ClassFunction_gap, ClassFunction_libgap, class_function, trivial_class_function, class_function_f...
   |                                         ^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^ no `ClassFunction_libgap` in `class_function`
   |                                         |
   |                                         no `ClassFunction_gap` in `class_function`
   |
help: a similar name exists in the module
   |
62 - pub use class_function::{ClassFunction, ClassFunction_gap, ClassFunction_libgap, class_function, trivial_class_function, class_function_from_values};
62 + pub use class_function::{ClassFunction, ClassFunctionGap, ClassFunction_libgap, class_function, trivial_class_function, class_function_from_values};
   |
help: a similar name exists in the module
   |
62 - pub use class_function::{ClassFunction, ClassFunction_gap, ClassFunction_libgap, class_function, trivial_class_function, class_function_from_values};
62 + pub use class_function::{ClassFunction, ClassFunction_gap, ClassFunctionLibgap, class_function, trivial_class_function, class_function_from_values};
   |

error[E0432]: unresolved imports `libgap_morphism::GroupMorphism_libgap`, `libgap_morphism::GroupHomset_libgap`
  --> rustmath-groups/src/lib.rs:88:27
   |
88 | pub use libgap_morphism::{GroupMorphism_libgap, GroupHomset_libgap};
   |                           ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^ no `GroupHomset_libgap` in `libgap_morphism`
   |                           |
   |                           no `GroupMorphism_libgap` in `libgap_morphism`
   |
help: a similar name exists in the module
   |
88 - pub use libgap_morphism::{GroupMorphism_libgap, GroupHomset_libgap};
88 + pub use libgap_morphism::{GroupMorphismLibgap, GroupHomset_libgap};
   |
help: a similar name exists in the module
   |
88 - pub use libgap_morphism::{GroupMorphism_libgap, GroupHomset_libgap};
88 + pub use libgap_morphism::{GroupMorphism_libgap, GroupHomsetLibgap};
   |

warning: unused import: `std::collections::HashSet`
  --> rustmath-liealgebras/src/root_system.rs:12:5
   |
12 | use std::collections::HashSet;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_combinatorics::permutations::Permutation`
  --> rustmath-liealgebras/src/weyl_group.rs:10:5
   |
10 | use rustmath_combinatorics::permutations::Permutation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/weight_lattice.rs:18:21
   |
18 | use std::ops::{Add, Mul, Neg};
   |                     ^^^

warning: unused import: `Affinity`
  --> rustmath-liealgebras/src/dynkin_diagram.rs:15:52
   |
15 | use crate::cartan_type::{CartanType, CartanLetter, Affinity};
   |                                                    ^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/lie_algebra.rs:32:5
   |
32 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-liealgebras/src/lie_algebra.rs:34:5
   |
34 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-liealgebras/src/lie_algebra_element.rs:31:5
   |
31 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/lie_algebra_element.rs:35:26
   |
35 | use std::ops::{Add, Sub, Mul, Neg};
   |                          ^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-liealgebras/src/lie_algebra_element.rs:36:5
   |
36 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/poincare_birkhoff_witt.rs:42:26
   |
42 | use std::ops::{Add, Sub, Mul, Neg};
   |                          ^^^

warning: unused imports: `Display` and `self`
  --> rustmath-liealgebras/src/representation.rs:39:16
   |
39 | use std::fmt::{self, Display, Debug};
   |                ^^^^  ^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-liealgebras/src/representation.rs:40:5
   |
40 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/representation.rs:41:26
   |
41 | use std::ops::{Add, Sub, Mul, Neg};
   |                          ^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/abelian.rs:17:5
   |
17 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/heisenberg.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `LieBracket`
  --> rustmath-liealgebras/src/bch.rs:21:54
   |
21 | use crate::free_lie_algebra::{FreeLieAlgebraElement, LieBracket};
   |                                                      ^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/affine_lie_algebra.rs:45:5
   |
45 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-liealgebras/src/bgg_dual_module.rs:44:33
   |
44 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-liealgebras/src/bgg_dual_module.rs:46:5
   |
46 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `BGGDualModule` and `SimpleModule`
  --> rustmath-liealgebras/src/bgg_resolution.rs:37:30
   |
37 | use crate::bgg_dual_module::{SimpleModule, BGGDualModule};
   |                              ^^^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> rustmath-liealgebras/src/verma_module.rs:19:24
   |
19 | use std::collections::{HashMap, BTreeMap};
   |                        ^^^^^^^

warning: unused imports: `Mul` and `Sub`
  --> rustmath-liealgebras/src/verma_module.rs:21:21
   |
21 | use std::ops::{Add, Mul, Neg, Sub};
   |                     ^^^       ^^^

warning: unused import: `PBWElement`
  --> rustmath-liealgebras/src/verma_module.rs:22:37
   |
22 | use crate::poincare_birkhoff_witt::{PBWElement, PBWMonomial, PoincareBirkhoffWittBasis};
   |                                     ^^^^^^^^^^

warning: unused import: `FinitelyGeneratedLieAlgebra`
  --> rustmath-liealgebras/src/verma_module.rs:23:42
   |
23 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `WeylGroup`
  --> rustmath-liealgebras/src/verma_module.rs:25:25
   |
25 | use crate::weyl_group::{WeylGroup, WeylGroupElement};
   |                         ^^^^^^^^^

warning: unused import: `BTreeSet`
  --> rustmath-liealgebras/src/center_uea.rs:16:43
   |
16 | use std::collections::{HashMap, BTreeMap, BTreeSet};
   |                                           ^^^^^^^^

warning: unused imports: `PBWMonomial` and `PoincareBirkhoffWittBasis`
  --> rustmath-liealgebras/src/center_uea.rs:19:49
   |
19 | use crate::poincare_birkhoff_witt::{PBWElement, PBWMonomial, PoincareBirkhoffWittBasis};
   |                                                 ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `FinitelyGeneratedLieAlgebra`
  --> rustmath-liealgebras/src/center_uea.rs:20:42
   |
20 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-liealgebras/src/symplectic_derivation.rs:20:27
   |
20 | use rustmath_core::{Ring, Field, MathError, Result};
   |                           ^^^^^

warning: unused import: `HashMap`
  --> rustmath-liealgebras/src/symplectic_derivation.rs:21:24
   |
21 | use std::collections::{HashMap, BTreeMap};
   |                        ^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-liealgebras/src/subalgebra.rs:14:24
   |
14 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-liealgebras/src/compact_real_form.rs:31:5
   |
31 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0412]: cannot find type `GroupMorphism_libgap` in this scope
  --> rustmath-groups/src/libgap_morphism.rs:54:12
   |
36 | / pub struct GroupMorphismLibgap<G, H>
37 | | where
38 | |     G: Group,
39 | |     H: Group,
...  |
51 | |     is_validated: bool,
52 | | }
   | |_- similarly named struct `GroupMorphismLibgap` defined here
53 |
54 |   impl<G, H> GroupMorphism_libgap<G, H>
   |              ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0422]: cannot find struct, variant or union type `GroupMorphism_libgap` in this scope
  --> rustmath-groups/src/libgap_morphism.rs:79:24
   |
36 | / pub struct GroupMorphismLibgap<G, H>
37 | | where
38 | |     G: Group,
39 | |     H: Group,
...  |
51 | |     is_validated: bool,
52 | | }
   | |_- similarly named struct `GroupMorphismLibgap` defined here
...
79 |           let morphism = GroupMorphism_libgap {
   |                          ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0422]: cannot find struct, variant or union type `GroupMorphism_libgap` in this scope
  --> rustmath-groups/src/libgap_morphism.rs:95:9
   |
36 | / pub struct GroupMorphismLibgap<G, H>
37 | | where
38 | |     G: Group,
39 | |     H: Group,
...  |
51 | |     is_validated: bool,
52 | | }
   | |_- similarly named struct `GroupMorphismLibgap` defined here
...
95 |           GroupMorphism_libgap {
   |           ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0412]: cannot find type `GroupMorphism_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:248:29
    |
 36 | / pub struct GroupMorphismLibgap<G, H>
 37 | | where
 38 | |     G: Group,
 39 | |     H: Group,
...   |
 51 | |     is_validated: bool,
 52 | | }
    | |_- similarly named struct `GroupMorphismLibgap` defined here
...
248 |   impl<G, H> fmt::Display for GroupMorphism_libgap<G, H>
    |                               ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0412]: cannot find type `GroupMorphism_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:278:31
    |
 36 | / pub struct GroupMorphismLibgap<G, H>
 37 | | where
 38 | |     G: Group,
 39 | |     H: Group,
...   |
 51 | |     is_validated: bool,
 52 | | }
    | |_- similarly named struct `GroupMorphismLibgap` defined here
...
278 |       homomorphisms: Option<Vec<GroupMorphism_libgap<G, H>>>,
    |                                 ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0412]: cannot find type `GroupHomset_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:281:12
    |
266 | / pub struct GroupHomsetLibgap<G, H>
267 | | where
268 | |     G: Group,
269 | |     H: Group,
...   |
278 | |     homomorphisms: Option<Vec<GroupMorphism_libgap<G, H>>>,
279 | | }
    | |_- similarly named struct `GroupHomsetLibgap` defined here
280 |
281 |   impl<G, H> GroupHomset_libgap<G, H>
    |              ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupHomsetLibgap`

error[E0422]: cannot find struct, variant or union type `GroupHomset_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:288:9
    |
266 | / pub struct GroupHomsetLibgap<G, H>
267 | | where
268 | |     G: Group,
269 | |     H: Group,
...   |
278 | |     homomorphisms: Option<Vec<GroupMorphism_libgap<G, H>>>,
279 | | }
    | |_- similarly named struct `GroupHomsetLibgap` defined here
...
288 |           GroupHomset_libgap {
    |           ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupHomsetLibgap`

error[E0412]: cannot find type `GroupMorphism_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:296:33
    |
 36 | / pub struct GroupMorphismLibgap<G, H>
 37 | | where
 38 | |     G: Group,
 39 | |     H: Group,
...   |
 51 | |     is_validated: bool,
 52 | | }
    | |_- similarly named struct `GroupMorphismLibgap` defined here
...
296 |       pub fn an_element(&self) -> GroupMorphism_libgap<G, H> {
    |                                   ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0412]: cannot find type `GroupMorphism_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:303:41
    |
 36 | / pub struct GroupMorphismLibgap<G, H>
 37 | | where
 38 | |     G: Group,
 39 | |     H: Group,
...   |
 51 | |     is_validated: bool,
 52 | | }
    | |_- similarly named struct `GroupMorphismLibgap` defined here
...
303 |       pub fn natural_map(&self) -> Option<GroupMorphism_libgap<G, H>> {
    |                                           ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0412]: cannot find type `GroupHomset_libgap` in this scope
   --> rustmath-groups/src/libgap_morphism.rs:331:29
    |
266 | / pub struct GroupHomsetLibgap<G, H>
267 | | where
268 | |     G: Group,
269 | |     H: Group,
...   |
278 | |     homomorphisms: Option<Vec<GroupMorphism_libgap<G, H>>>,
279 | | }
    | |_- similarly named struct `GroupHomsetLibgap` defined here
...
331 |   impl<G, H> fmt::Display for GroupHomset_libgap<G, H>
    |                               ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `GroupHomsetLibgap`

warning: unused import: `rustmath_rationals::Rational`
 --> rustmath-groups/src/matrix_group.rs:7:5
  |
7 | use rustmath_rationals::Rational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/additive_abelian_group.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/additive_abelian_wrapper.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AdditiveAbelianGroupElement`
  --> rustmath-groups/src/additive_abelian_wrapper.rs:13:59
   |
13 | use crate::additive_abelian_group::{AdditiveAbelianGroup, AdditiveAbelianGroupElement};
   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/artin.rs:36:5
   |
36 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ops::Mul`
  --> rustmath-groups/src/artin.rs:39:5
   |
39 | use std::ops::Mul;
   |     ^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/braid.rs:48:5
   |
48 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ArtinGroupElement`
  --> rustmath-groups/src/braid.rs:52:32
   |
52 | use crate::artin::{ArtinGroup, ArtinGroupElement, FiniteTypeArtinGroup, FiniteTypeArtinGroupElement, CoxeterMatrix};
   |                                ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::free_group::FreeGroupElement`
  --> rustmath-groups/src/braid.rs:53:5
   |
53 | use crate::free_group::FreeGroupElement;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/cactus_group.rs:30:5
   |
30 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ops::Mul`
  --> rustmath-groups/src/cactus_group.rs:32:5
   |
32 | use std::ops::Mul;
   |     ^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/cubic_braid.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-groups/src/finitely_presented.rs:30:24
   |
30 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `crate::group_traits::Group`
  --> rustmath-groups/src/misc_groups.rs:30:5
   |
30 | use crate::group_traits::Group;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `FiniteGroupTrait`
  --> rustmath-groups/src/semimonomial_transformation_group.rs:36:34
   |
36 | use crate::group_traits::{Group, FiniteGroupTrait};
   |                                  ^^^^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> rustmath-groups/src/libgap_mixin.rs:21:24
   |
21 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `std::ops::Mul`
  --> rustmath-groups/src/nilpotent_lie_group.rs:33:5
   |
33 | use std::ops::Mul;
   |     ^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-groups/src/raag.rs:44:24
   |
44 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused variable: `outer`
   --> rustmath-symmetricfunctions/src/ribbon.rs:188:5
    |
188 |     outer: &Partition,
    |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_outer`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `inner`
   --> rustmath-symmetricfunctions/src/ribbon.rs:189:5
    |
189 |     inner: &Partition,
    |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_inner`

warning: unused variable: `f`
   --> rustmath-symmetricfunctions/src/operations.rs:207:18
    |
207 | pub fn coproduct(f: &SymFun) -> Vec<(SymFun, SymFun)> {
    |                  ^ help: if this is intentional, prefix it with an underscore: `_f`

warning: unused variable: `max_degree`
  --> rustmath-symmetricfunctions/src/plethysm.rs:70:35
   |
70 | pub fn plethystic_exp(f: &SymFun, max_degree: usize) -> SymFun {
   |                                   ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_degree`

warning: unused variable: `f`
  --> rustmath-symmetricfunctions/src/plethysm.rs:92:25
   |
92 | pub fn internal_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
   |                         ^ help: if this is intentional, prefix it with an underscore: `_f`

warning: unused variable: `g`
  --> rustmath-symmetricfunctions/src/plethysm.rs:92:37
   |
92 | pub fn internal_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
   |                                     ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `f`
   --> rustmath-symmetricfunctions/src/plethysm.rs:103:26
    |
103 | pub fn kronecker_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
    |                          ^ help: if this is intentional, prefix it with an underscore: `_f`

warning: unused variable: `g`
   --> rustmath-symmetricfunctions/src/plethysm.rs:103:38
    |
103 | pub fn kronecker_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
    |                                      ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `lambda`
   --> rustmath-symmetricfunctions/src/plethysm.rs:112:32
    |
112 | pub fn schur_complete_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lambda`

warning: unused variable: `m`
   --> rustmath-symmetricfunctions/src/plethysm.rs:112:52
    |
112 | pub fn schur_complete_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                                    ^ help: if this is intentional, prefix it with an underscore: `_m`

warning: unused variable: `lambda`
   --> rustmath-symmetricfunctions/src/plethysm.rs:121:34
    |
121 | pub fn schur_elementary_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lambda`

warning: unused variable: `m`
   --> rustmath-symmetricfunctions/src/plethysm.rs:121:54
    |
121 | pub fn schur_elementary_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                                      ^ help: if this is intentional, prefix it with an underscore: `_m`

warning: unused variable: `n`
   --> rustmath-symmetricfunctions/src/ncsf.rs:266:13
    |
266 |         let n = I.sum();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
   --> rustmath-symmetricfunctions/src/qsym.rs:339:9
    |
339 |     let n: usize = parts.iter().sum();
    |         ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
  --> rustmath-symmetricfunctions/src/super_schur.rs:76:9
   |
76 |     let n = shape.sum();
   |         ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:176:20
    |
176 | pub fn concatenate(I: &Composition, J: &Composition) -> Composition {
    |                    ^ help: convert the identifier to snake case (notice the capitalization): `i`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:176:37
    |
176 | pub fn concatenate(I: &Composition, J: &Composition) -> Composition {
    |                                     ^ help: convert the identifier to snake case: `j`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:219:10
    |
219 |     for (I, coeff_I) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `coeff_I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:219:13
    |
219 |     for (I, coeff_I) in &f.coeffs {
    |             ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `coeff_i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:220:14
    |
220 |         for (J, coeff_J) in &g.coeffs {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `coeff_J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:220:17
    |
220 |         for (J, coeff_J) in &g.coeffs {
    |                 ^^^^^^^ help: convert the identifier to snake case: `coeff_j`

warning: variable `IJ` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:221:17
    |
221 |             let IJ = concatenate(I, J);
    |                 ^^ help: convert the identifier to snake case: `ij`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:242:10
    |
242 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:243:14
    |
243 |         for (J, K) in composition_splits(I) {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `K` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:243:17
    |
243 |         for (J, K) in composition_splits(I) {
    |                 ^ help: convert the identifier to snake case (notice the capitalization): `k`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:265:10
    |
265 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J_comp` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:274:13
    |
274 |         let J_comp = I.clone(); // Placeholder - needs proper implementation
    |             ^^^^^^ help: convert the identifier to snake case: `j_comp`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:289:10
    |
289 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J_comp` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:290:13
    |
290 |         let J_comp = I.clone(); // Placeholder - needs proper implementation
    |             ^^^^^^ help: convert the identifier to snake case: `j_comp`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:308:10
    |
308 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:325:10
    |
325 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:390:10
    |
390 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:402:16
    |
402 | pub fn refines(J: &Composition, I: &Composition) -> bool {
    |                ^ help: convert the identifier to snake case: `j`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:402:33
    |
402 | pub fn refines(J: &Composition, I: &Composition) -> bool {
    |                                 ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:403:9
    |
403 |     let I_parts = I.parts();
    |         ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_parts`

warning: variable `J_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:404:9
    |
404 |     let J_parts = J.parts();
    |         ^^^^^^^ help: convert the identifier to snake case: `j_parts`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:236:10
    |
236 |     for (I, coeff_I) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `coeff_I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:236:13
    |
236 |     for (I, coeff_I) in &f.coeffs {
    |             ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `coeff_i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:237:14
    |
237 |         for (J, coeff_J) in &g.coeffs {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `coeff_J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:237:17
    |
237 |         for (J, coeff_J) in &g.coeffs {
    |                 ^^^^^^^ help: convert the identifier to snake case: `coeff_j`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:255:18
    |
255 | fn quasi_shuffle(I: &Composition, J: &Composition) -> Vec<Composition> {
    |                  ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:255:35
    |
255 | fn quasi_shuffle(I: &Composition, J: &Composition) -> Vec<Composition> {
    |                                   ^ help: convert the identifier to snake case: `j`

warning: variable `I_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:256:9
    |
256 |     let I_parts = I.parts();
    |         ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_parts`

warning: variable `J_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:257:9
    |
257 |     let J_parts = J.parts();
    |         ^^^^^^^ help: convert the identifier to snake case: `j_parts`

warning: variable `I_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:270:9
    |
270 |         I_parts: &[usize],
    |         ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_parts`

warning: variable `J_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:271:9
    |
271 |         J_parts: &[usize],
    |         ^^^^^^^ help: convert the identifier to snake case: `j_parts`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:322:10
    |
322 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:324:14
    |
324 |         for (J, K) in splits {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `K` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:324:17
    |
324 |         for (J, K) in splits {
    |                 ^ help: convert the identifier to snake case (notice the capitalization): `k`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:389:10
    |
389 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:409:10
    |
409 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I_len` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:410:13
    |
410 |         let I_len = I.length();
    |             ^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_len`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:413:13
    |
413 |         for J in refinements(I) {
    |             ^ help: convert the identifier to snake case: `j`

warning: variable `J_len` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:414:17
    |
414 |             let J_len = J.length();
    |                 ^^^^^ help: convert the identifier to snake case: `j_len`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:427:10
    |
427 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:468:10
    |
468 |     for (I, f_coeff) in &f_mono.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: `rustmath-plot3d` (lib) generated 7 warnings (run `cargo fix --lib -p rustmath-plot3d` to apply 6 suggestions)
error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:34:43
   |
34 |                         Expr::Binary(*op, Arc::new(left_exp), Arc::new(right_exp))
   |                                           ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:34:63
   |
34 |                         Expr::Binary(*op, Arc::new(left_exp), Arc::new(right_exp))
   |                                                               ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:42:53
   |
42 |                         Expr::Binary(BinaryOp::Div, Arc::new(left_exp), Arc::new(right_exp))
   |                                                     ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:42:73
   |
42 |                         Expr::Binary(BinaryOp::Div, Arc::new(left_exp), Arc::new(right_exp))
   |                                                                         ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:54:53
   |
54 |                         Expr::Binary(BinaryOp::Pow, Arc::new(left_exp), Arc::new(right_exp))
   |                                                     ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:54:73
   |
54 |                         Expr::Binary(BinaryOp::Pow, Arc::new(left_exp), Arc::new(right_exp))
   |                                                                         ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:66:43
   |
66 |                     _ => Expr::Unary(*op, Arc::new(inner_exp)),
   |                                           ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0412]: cannot find type `Arc` in this scope
  --> rustmath-symbolic/src/expand.rs:72:40
   |
72 |                 let expanded_args: Vec<Arc<Expr>> = args
   |                                        ^^^ not found in this scope
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/expand.rs:74:32
   |
74 |                     .map(|arg| Arc::new(arg.expand()))
   |                                ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 3 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/limits.rs:99:77
   |
99 | ...                   LimitResult::Finite(Expr::Binary(BinaryOp::Mod, Arc::new(l), Arc::new(r)))
   |                                                                       ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 6 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/limits.rs:99:90
   |
99 | ...                   LimitResult::Finite(Expr::Binary(BinaryOp::Mod, Arc::new(l), Arc::new(r)))
   |                                                                                    ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
 6 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/specialfunctions/generalized.rs:81:67
   |
81 |             return Expr::Function("dirac_delta".to_string(), vec![Arc::new(Expr::from(0))]);
   |                                                                   ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
32 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/specialfunctions/generalized.rs:88:52
   |
88 |     Expr::Function("dirac_delta".to_string(), vec![Arc::new(x.clone())])
   |                                                    ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
32 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/generalized.rs:135:50
    |
135 |     Expr::Function("heaviside".to_string(), vec![Arc::new(x.clone())])
    |                                                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 32 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/generalized.rs:201:44
    |
201 |     Expr::Function("sgn".to_string(), vec![Arc::new(x.clone())])
    |                                            ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 32 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/generalized.rs:253:14
    |
253 |         vec![Arc::new(i.clone()), Arc::new(j.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 32 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/generalized.rs:253:35
    |
253 |         vec![Arc::new(i.clone()), Arc::new(j.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 32 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:81:14
   |
81 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
   |              ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
36 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:81:35
   |
81 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
   |                                   ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
36 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:104:18
    |
104 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:104:50
    |
104 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                                                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:139:14
    |
139 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:139:35
    |
139 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:151:18
    |
151 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:151:50
    |
151 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                                                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:185:14
    |
185 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:185:35
    |
185 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:200:18
    |
200 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:200:50
    |
200 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                                                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:220:14
    |
220 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:220:35
    |
220 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:252:14
    |
252 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:252:35
    |
252 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:264:18
    |
264 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:264:50
    |
264 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                                                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:297:14
    |
297 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:297:35
    |
297 |         vec![Arc::new(n.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:308:18
    |
308 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:308:50
    |
308 |             vec![Arc::new(Expr::from(n as i64)), Arc::new(x.clone())],
    |                                                  ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:333:13
    |
333 |             Arc::new(n.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:334:13
    |
334 |             Arc::new(alpha.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:335:13
    |
335 |             Arc::new(x.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:366:13
    |
366 |             Arc::new(n.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:367:13
    |
367 |             Arc::new(alpha.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:368:13
    |
368 |             Arc::new(beta.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:369:13
    |
369 |             Arc::new(x.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:395:13
    |
395 |             Arc::new(n.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:396:13
    |
396 |             Arc::new(lambda.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:397:13
    |
397 |             Arc::new(x.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:436:14
    |
436 |         vec![Arc::new(n.clone()), Arc::new(m.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:436:35
    |
436 |         vec![Arc::new(n.clone()), Arc::new(m.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:436:56
    |
436 |         vec![Arc::new(n.clone()), Arc::new(m.clone()), Arc::new(x.clone())],
    |                                                        ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:463:14
    |
463 |         vec![Arc::new(n.clone()), Arc::new(m.clone()), Arc::new(x.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:463:35
    |
463 |         vec![Arc::new(n.clone()), Arc::new(m.clone()), Arc::new(x.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:463:56
    |
463 |         vec![Arc::new(n.clone()), Arc::new(m.clone()), Arc::new(x.clone())],
    |                                                        ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:508:13
    |
508 |             Arc::new(n.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:509:13
    |
509 |             Arc::new(x.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:510:13
    |
510 |             Arc::new(alpha.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:511:13
    |
511 |             Arc::new(beta.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:512:13
    |
512 |             Arc::new(N.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:556:13
    |
556 |             Arc::new(n.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:557:13
    |
557 |             Arc::new(x.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:558:13
    |
558 |             Arc::new(p.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:559:13
    |
559 |             Arc::new(N.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:603:13
    |
603 |             Arc::new(n.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:604:13
    |
604 |             Arc::new(x.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:605:13
    |
605 |             Arc::new(beta.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:606:13
    |
606 |             Arc::new(c.clone()),
    |             ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 36 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
  --> rustmath-symbolic/src/specialfunctions/prime_pi.rs:81:49
   |
81 |     Expr::Function("prime_pi".to_string(), vec![Arc::new(x.clone())])
   |                                                 ^^^ use of undeclared type `Arc`
   |
help: consider importing this struct
   |
28 + use std::sync::Arc;
   |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/prime_pi.rs:153:14
    |
153 |         vec![Arc::new(x.clone()), Arc::new(a.clone())],
    |              ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 28 + use std::sync::Arc;
    |

error[E0433]: failed to resolve: use of undeclared type `Arc`
   --> rustmath-symbolic/src/specialfunctions/prime_pi.rs:153:35
    |
153 |         vec![Arc::new(x.clone()), Arc::new(a.clone())],
    |                                   ^^^ use of undeclared type `Arc`
    |
help: consider importing this struct
    |
 28 + use std::sync::Arc;
    |

warning: unused variable: `rank`
   --> rustmath-crystals/src/character.rs:139:47
    |
139 | pub fn weyl_character(highest_weight: Weight, rank: usize) -> Character {
    |                                               ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `hw_weight`
   --> rustmath-crystals/src/character.rs:155:13
    |
155 |         let hw_weight = crystal.weight(&hw);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hw_weight`

warning: unused variable: `diff`
  --> rustmath-crystals/src/littelmann.rs:73:13
   |
73 |         let diff = v2 - v1;
   |             ^^^^ help: if this is intentional, prefix it with an underscore: `_diff`

warning: unused variable: `min_val`
   --> rustmath-crystals/src/littelmann.rs:185:23
    |
185 |         let (min_idx, min_val) = path.i_string_min(i, &self.root_system);
    |                       ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_val`

error[E0038]: the trait `AbstractArgument` is not dyn compatible
   --> rustmath-groups/src/argument_groups.rs:643:23
    |
643 | pub fn exponent(arg: &dyn AbstractArgument) -> Complex {
    |                       ^^^^^^^^^^^^^^^^^^^^ `AbstractArgument` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-groups/src/argument_groups.rs:55:29
    |
 55 | pub trait AbstractArgument: Clone + fmt::Debug {
    |           ----------------  ^^^^^ ...because it requires `Self: Sized`
    |           |
    |           this trait is not dyn compatible...
    = help: the following types implement `AbstractArgument`:
              argument_groups::UnitCirclePoint
              argument_groups::RootOfUnity
              argument_groups::Sign
              argument_groups::ArgumentByElement
            consider defining an enum where each variant holds one of these types,
            implementing `AbstractArgument` for this new enum and using it instead
    = note: `AbstractArgument` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type

error[E0432]: unresolved imports `charzero_drinfeld_module::DrinfeldModule_charzero`, `charzero_drinfeld_module::DrinfeldModule_rational`
   --> rustmath-rings/src/function_field/drinfeld_modules/mod.rs:104:52
    |
104 | pub use charzero_drinfeld_module::{DrinfeldModule, DrinfeldModule_charzero, DrinfeldModule_rational};
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^ no `DrinfeldModule_rational` in `function_field::drinfeld_modules::charzero_drinfeld_module`
    |                                                    |
    |                                                    no `DrinfeldModule_charzero` in `function_field::drinfeld_modules::charzero_drinfeld_module`
    |
help: a similar name exists in the module
    |
104 - pub use charzero_drinfeld_module::{DrinfeldModule, DrinfeldModule_charzero, DrinfeldModule_rational};
104 + pub use charzero_drinfeld_module::{DrinfeldModule, DrinfeldModuleCharzero, DrinfeldModule_rational};
    |
help: a similar name exists in the module
    |
104 - pub use charzero_drinfeld_module::{DrinfeldModule, DrinfeldModule_charzero, DrinfeldModule_rational};
104 + pub use charzero_drinfeld_module::{DrinfeldModule, DrinfeldModule_charzero, DrinfeldModuleRational};
    |

warning: unused variable: `tab`
   --> rustmath-crystals/src/kr_crystal.rs:222:32
    |
222 |             KRElement::Tableau(tab) => {
    |                                ^^^ help: if this is intentional, prefix it with an underscore: `_tab`

warning: unused variable: `i`
   --> rustmath-crystals/src/kr_crystal.rs:220:42
    |
220 |     fn apply_ei(&self, elem: &KRElement, i: usize) -> Option<KRElement> {
    |                                          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `tab`
   --> rustmath-crystals/src/kr_crystal.rs:235:32
    |
235 |             KRElement::Tableau(tab) => {
    |                                ^^^ help: if this is intentional, prefix it with an underscore: `_tab`

warning: unused variable: `i`
   --> rustmath-crystals/src/kr_crystal.rs:233:42
    |
233 |     fn apply_fi(&self, elem: &KRElement, i: usize) -> Option<KRElement> {
    |                                          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `crystal`
   --> rustmath-crystals/src/kr_crystal.rs:308:24
    |
308 | pub fn energy_function(crystal: &KRCrystal, elem: &KRElement) -> i64 {
    |                        ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_crystal`

warning: unused variable: `elem`
   --> rustmath-crystals/src/kr_crystal.rs:308:45
    |
308 | pub fn energy_function(crystal: &KRCrystal, elem: &KRElement) -> i64 {
    |                                             ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`

error[E0432]: unresolved import `finite_drinfeld_module::DrinfeldModule_finite`
   --> rustmath-rings/src/function_field/drinfeld_modules/mod.rs:106:9
    |
106 | pub use finite_drinfeld_module::DrinfeldModule_finite;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^---------------------
    |         |                       |
    |         |                       help: a similar name exists in the module: `DrinfeldModuleFinite`
    |         no `DrinfeldModule_finite` in `function_field::drinfeld_modules::finite_drinfeld_module`

error[E0107]: struct takes 3 generic arguments but 1 generic argument was supplied
   --> rustmath-groups/src/cactus_group.rs:386:28
    |
386 | pub type PureCactusGroup = KernelSubgroup<CactusGroup>;
    |                            ^^^^^^^^^^^^^^ ----------- supplied 1 generic argument
    |                            |
    |                            expected 3 generic arguments
    |
note: struct defined here, with 3 generic parameters: `G`, `H`, `F`
   --> rustmath-groups/src/kernel_subgroup.rs:81:12
    |
 81 | pub struct KernelSubgroup<G, H, F>
    |            ^^^^^^^^^^^^^^ -  -  -
help: add missing generic arguments
    |
386 | pub type PureCactusGroup = KernelSubgroup<CactusGroup, H, F>;
    |                                                      ++++++

error[E0432]: unresolved import `place_polymod::FunctionFieldPlace_polymod`
   --> rustmath-rings/src/function_field/mod.rs:142:9
    |
142 | pub use place_polymod::FunctionFieldPlace_polymod;
    |         ^^^^^^^^^^^^^^^--------------------------
    |         |              |
    |         |              help: a similar name exists in the module: `FunctionFieldPlacePolymod`
    |         no `FunctionFieldPlace_polymod` in `function_field::place_polymod`

error[E0432]: unresolved import `place_rational::FunctionFieldPlace_rational`
   --> rustmath-rings/src/function_field/mod.rs:144:9
    |
144 | pub use place_rational::FunctionFieldPlace_rational;
    |         ^^^^^^^^^^^^^^^^---------------------------
    |         |               |
    |         |               help: a similar name exists in the module: `FunctionFieldPlaceRational`
    |         no `FunctionFieldPlace_rational` in `function_field::place_rational`

error[E0432]: unresolved imports `valuation::FunctionFieldValuation_base`, `valuation::ClassicalFunctionFieldValuation_base`, `valuation::RationalFunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/mod.rs:148:5
    |
148 |     FunctionFieldValuation_base,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldValuation_base` in `function_field::valuation`
149 |     ClassicalFunctionFieldValuation_base,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `ClassicalFunctionFieldValuation_base` in `function_field::valuation`
150 |     RationalFunctionFieldValuation_base,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `RationalFunctionFieldValuation_base` in `function_field::valuation`
    |
help: a similar name exists in the module
    |
148 -     FunctionFieldValuation_base,
148 +     FunctionFieldValuationBase,
    |
help: a similar name exists in the module
    |
149 -     ClassicalFunctionFieldValuation_base,
149 +     ClassicalFunctionFieldValuationBase,
    |
help: a similar name exists in the module
    |
150 -     RationalFunctionFieldValuation_base,
150 +     RationalFunctionFieldValuationBase,
    |

error[E0432]: unresolved imports `order_basis::FunctionFieldOrder_basis`, `order_basis::FunctionFieldOrderInfinite_basis`
   --> rustmath-rings/src/function_field/mod.rs:159:23
    |
159 | pub use order_basis::{FunctionFieldOrder_basis, FunctionFieldOrderInfinite_basis};
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldOrderInfinite_basis` in `function_field::order_basis`
    |                       |
    |                       no `FunctionFieldOrder_basis` in `function_field::order_basis`
    |
help: a similar name exists in the module
    |
159 - pub use order_basis::{FunctionFieldOrder_basis, FunctionFieldOrderInfinite_basis};
159 + pub use order_basis::{FunctionFieldOrderBasis, FunctionFieldOrderInfinite_basis};
    |
help: a similar name exists in the module
    |
159 - pub use order_basis::{FunctionFieldOrder_basis, FunctionFieldOrderInfinite_basis};
159 + pub use order_basis::{FunctionFieldOrder_basis, FunctionFieldOrderInfiniteBasis};
    |

warning: unused variable: `k`
  --> rustmath-crystals/src/nakajima.rs:70:19
   |
70 |         for (&(i, k), &exp) in &self.exponents {
   |                   ^ help: if this is intentional, prefix it with an underscore: `_k`

error[E0432]: unresolved imports `order_polymod::FunctionFieldMaximalOrder_polymod`, `order_polymod::FunctionFieldMaximalOrder_global`, `order_polymod::FunctionFieldMaximalOrderInfinite_polymod`
   --> rustmath-rings/src/function_field/mod.rs:162:5
    |
162 |     FunctionFieldMaximalOrder_polymod, FunctionFieldMaximalOrder_global,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldMaximalOrder_global` in `function_field::order_polymod`
    |     |
    |     no `FunctionFieldMaximalOrder_polymod` in `function_field::order_polymod`
163 |     FunctionFieldMaximalOrderInfinite_polymod,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldMaximalOrderInfinite_polymod` in `function_field::order_polymod`
    |
help: a similar name exists in the module
    |
162 -     FunctionFieldMaximalOrder_polymod, FunctionFieldMaximalOrder_global,
162 +     FunctionFieldMaximalOrderPolymod, FunctionFieldMaximalOrder_global,
    |
help: a similar name exists in the module
    |
162 -     FunctionFieldMaximalOrder_polymod, FunctionFieldMaximalOrder_global,
162 +     FunctionFieldMaximalOrder_polymod, FunctionFieldMaximalOrderGlobal,
    |
help: a similar name exists in the module
    |
163 -     FunctionFieldMaximalOrderInfinite_polymod,
163 +     FunctionFieldMaximalOrderInfinitePolymod,
    |

warning: unused variable: `other_part`
   --> rustmath-crystals/src/rigged_configurations.rs:218:18
    |
218 |             for &other_part in &other_partition.parts {
    |                  ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_part`

warning: unused variable: `i`
   --> rustmath-crystals/src/rigged_configurations.rs:364:38
    |
364 | fn compute_epsilon_i(rc: &RCElement, i: usize) -> i64 {
    |                                      ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `rc`
   --> rustmath-crystals/src/rigged_configurations.rs:408:12
    |
408 | fn phi_map(rc: &RCElement, tensor_shape: &[(usize, usize)]) -> TensorProductImage {
    |            ^^ help: if this is intentional, prefix it with an underscore: `_rc`

warning: unused variable: `tp`
   --> rustmath-crystals/src/rigged_configurations.rs:429:16
    |
429 | fn phi_inverse(tp: &TensorProductImage, rank: usize) -> RCElement {
    |                ^^ help: if this is intentional, prefix it with an underscore: `_tp`

warning: unused variable: `tensor_shape`
   --> rustmath-crystals/src/rigged_configurations.rs:437:52
    |
437 | fn generate_all_rigged_configurations(rank: usize, tensor_shape: &[(usize, usize)]) -> Vec<RCElement> {
    |                                                    ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tensor_shape`

error[E0432]: unresolved imports `order_rational::FunctionFieldMaximalOrder_rational`, `order_rational::FunctionFieldMaximalOrderInfinite_rational`
   --> rustmath-rings/src/function_field/mod.rs:167:5
    |
167 |     FunctionFieldMaximalOrder_rational, FunctionFieldMaximalOrderInfinite_rational,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldMaximalOrderInfinite_rational` in `function_field::order_rational`
    |     |
    |     no `FunctionFieldMaximalOrder_rational` in `function_field::order_rational`
    |
help: a similar name exists in the module
    |
167 -     FunctionFieldMaximalOrder_rational, FunctionFieldMaximalOrderInfinite_rational,
167 +     FunctionFieldMaximalOrderRational, FunctionFieldMaximalOrderInfinite_rational,
    |
help: a similar name exists in the module
    |
167 -     FunctionFieldMaximalOrder_rational, FunctionFieldMaximalOrderInfinite_rational,
167 +     FunctionFieldMaximalOrder_rational, FunctionFieldMaximalOrderInfiniteRational,
    |

warning: unused variable: `highest_weight`
   --> rustmath-crystals/src/rigged_configurations.rs:523:29
    |
523 |     pub fn new(rank: usize, highest_weight: Weight) -> Self {
    |                             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_highest_weight`

warning: unused variable: `node`
   --> rustmath-crystals/src/rigged_configurations.rs:544:22
    |
544 | fn build_kleber_tree(node: &mut KleberNode, rank: usize) {
    |                      ^^^^ help: if this is intentional, prefix it with an underscore: `_node`

warning: unused variable: `rank`
   --> rustmath-crystals/src/rigged_configurations.rs:544:45
    |
544 | fn build_kleber_tree(node: &mut KleberNode, rank: usize) {
    |                                             ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`

warning: unused variable: `rc`
   --> rustmath-crystals/src/rigged_configurations.rs:713:23
    |
713 |     pub fn e_0(&self, rc: &RCElement) -> Option<RCElement> {
    |                       ^^ help: if this is intentional, prefix it with an underscore: `_rc`

warning: unused variable: `rc`
   --> rustmath-crystals/src/rigged_configurations.rs:719:23
    |
719 |     pub fn f_0(&self, rc: &RCElement) -> Option<RCElement> {
    |                       ^^ help: if this is intentional, prefix it with an underscore: `_rc`

error[E0432]: unresolved imports `jacobian_base::JacobianPoint_base`, `jacobian_base::JacobianGroup_base`, `jacobian_base::Jacobian_base`, `jacobian_base::JacobianPoint_finite_field_base`, `jacobian_base::JacobianGroup_finite_field_base`
   --> rustmath-rings/src/function_field/mod.rs:171:5
    |
171 |     JacobianPoint_base, JacobianGroup_base, Jacobian_base,
    |     ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^ no `Jacobian_base` in `function_field::jacobian_base`
    |     |                   |
    |     |                   no `JacobianGroup_base` in `function_field::jacobian_base`
    |     no `JacobianPoint_base` in `function_field::jacobian_base`
172 |     JacobianPoint_finite_field_base, JacobianGroup_finite_field_base,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianGroup_finite_field_base` in `function_field::jacobian_base`
    |     |
    |     no `JacobianPoint_finite_field_base` in `function_field::jacobian_base`
    |
help: a similar name exists in the module
    |
171 -     JacobianPoint_base, JacobianGroup_base, Jacobian_base,
171 +     JacobianPointBase, JacobianGroup_base, Jacobian_base,
    |
help: a similar name exists in the module
    |
171 -     JacobianPoint_base, JacobianGroup_base, Jacobian_base,
171 +     JacobianPoint_base, JacobianGroupBase, Jacobian_base,
    |
help: a similar name exists in the module
    |
171 -     JacobianPoint_base, JacobianGroup_base, Jacobian_base,
171 +     JacobianPoint_base, JacobianGroup_base, JacobianBase,
    |
help: a similar name exists in the module
    |
172 -     JacobianPoint_finite_field_base, JacobianGroup_finite_field_base,
172 +     JacobianPointFiniteFieldBase, JacobianGroup_finite_field_base,
    |
help: a similar name exists in the module
    |
172 -     JacobianPoint_finite_field_base, JacobianGroup_finite_field_base,
172 +     JacobianPoint_finite_field_base, JacobianGroupFiniteFieldBase,
    |

error[E0277]: `I` doesn't implement `std::fmt::Display`
   --> rustmath-groups/src/indexed_free_group.rs:152:20
    |
152 |     type Element = IndexedFreeGroupElement<I>;
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `I`
    |
note: required for `IndexedFreeGroupElement<I>` to implement `group_traits::GroupElement`
   --> rustmath-groups/src/indexed_free_group.rs:343:56
    |
343 | impl<I: Clone + Eq + Hash + fmt::Debug + fmt::Display> crate::group_traits::GroupElement for IndexedFreeGroupElement<I> {
    |                                          ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                                          |
    |                                          unsatisfied trait bound introduced here
note: required by a bound in `group_traits::Group::Element`
   --> rustmath-groups/src/group_traits.rs:18:19
    |
 18 |     type Element: GroupElement;
    |                   ^^^^^^^^^^^^ required by this bound in `Group::Element`
help: consider further restricting type parameter `I` with trait `Display`
    |
151 | impl<I: Clone + Eq + Hash + fmt::Debug + std::fmt::Display> Group for IndexedFreeGroup<I> {
    |                                        +++++++++++++++++++

error[E0432]: unresolved imports `jacobian_hess::Jacobian_finite_field`, `jacobian_hess::JacobianPoint_finite_field`, `jacobian_hess::JacobianGroup_finite_field`, `jacobian_hess::JacobianGroupEmbedding_finite_field`
   --> rustmath-rings/src/function_field/mod.rs:179:5
    |
179 |     Jacobian_finite_field as JacobianHess_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `Jacobian_finite_field` in `function_field::jacobian_hess`
180 |     JacobianPoint_finite_field as JacobianPointHess_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianPoint_finite_field` in `function_field::jacobian_hess`
181 |     JacobianGroup_finite_field as JacobianGroupHess_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianGroup_finite_field` in `function_field::jacobian_hess`
182 |     JacobianGroupEmbedding_finite_field as JacobianGroupEmbeddingHess_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianGroupEmbedding_finite_field` in `function_field::jacobian_hess`
    |
help: a similar name exists in the module
    |
179 -     Jacobian_finite_field as JacobianHess_finite_field,
179 +     JacobianFiniteField as JacobianHess_finite_field,
    |
help: a similar name exists in the module
    |
180 -     JacobianPoint_finite_field as JacobianPointHess_finite_field,
180 +     JacobianPointFiniteField as JacobianPointHess_finite_field,
    |
help: a similar name exists in the module
    |
181 -     JacobianGroup_finite_field as JacobianGroupHess_finite_field,
181 +     JacobianGroupFiniteField as JacobianGroupHess_finite_field,
    |
help: a similar name exists in the module
    |
182 -     JacobianGroupEmbedding_finite_field as JacobianGroupEmbeddingHess_finite_field,
182 +     JacobianGroupEmbeddingFiniteField as JacobianGroupEmbeddingHess_finite_field,
    |

error[E0277]: `I` doesn't implement `std::fmt::Display`
   --> rustmath-groups/src/indexed_free_group.rs:449:20
    |
449 |     type Element = IndexedFreeAbelianGroupElement<I>;
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::fmt::Display` is not implemented for `I`
    |
note: required for `IndexedFreeAbelianGroupElement<I>` to implement `group_traits::GroupElement`
   --> rustmath-groups/src/indexed_free_group.rs:606:56
    |
606 | impl<I: Clone + Eq + Hash + fmt::Debug + fmt::Display> crate::group_traits::GroupElement for IndexedFreeAbelianGroupElement<I> {
    |                                          ------------  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                                          |
    |                                          unsatisfied trait bound introduced here
note: required by a bound in `group_traits::Group::Element`
   --> rustmath-groups/src/group_traits.rs:18:19
    |
 18 |     type Element: GroupElement;
    |                   ^^^^^^^^^^^^ required by this bound in `Group::Element`
help: consider further restricting type parameter `I` with trait `Display`
    |
448 | impl<I: Clone + Eq + Hash + fmt::Debug + std::fmt::Display> Group for IndexedFreeAbelianGroup<I> {
    |                                        +++++++++++++++++++

error[E0432]: unresolved imports `jacobian_khuri_makdisi::Jacobian_finite_field`, `jacobian_khuri_makdisi::JacobianPoint_finite_field`, `jacobian_khuri_makdisi::JacobianGroup_finite_field`, `jacobian_khuri_makdisi::JacobianGroupEmbedding_finite_field`
   --> rustmath-rings/src/function_field/mod.rs:188:5
    |
188 |     Jacobian_finite_field as JacobianKM_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `Jacobian_finite_field` in `function_field::jacobian_khuri_makdisi`
189 |     JacobianPoint_finite_field as JacobianPointKM_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianPoint_finite_field` in `function_field::jacobian_khuri_makdisi`
190 |     JacobianGroup_finite_field as JacobianGroupKM_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianGroup_finite_field` in `function_field::jacobian_khuri_makdisi`
191 |     JacobianGroupEmbedding_finite_field as JacobianGroupEmbeddingKM_finite_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `JacobianGroupEmbedding_finite_field` in `function_field::jacobian_khuri_makdisi`
    |
help: a similar name exists in the module
    |
188 -     Jacobian_finite_field as JacobianKM_finite_field,
188 +     JacobianFiniteField as JacobianKM_finite_field,
    |
help: a similar name exists in the module
    |
189 -     JacobianPoint_finite_field as JacobianPointKM_finite_field,
189 +     JacobianPointFiniteField as JacobianPointKM_finite_field,
    |
help: a similar name exists in the module
    |
190 -     JacobianGroup_finite_field as JacobianGroupKM_finite_field,
190 +     JacobianGroupFiniteField as JacobianGroupKM_finite_field,
    |
help: a similar name exists in the module
    |
191 -     JacobianGroupEmbedding_finite_field as JacobianGroupEmbeddingKM_finite_field,
191 +     JacobianGroupEmbeddingFiniteField as JacobianGroupEmbeddingKM_finite_field,
    |

error[E0432]: unresolved imports `khuri_makdisi::KhuriMakdisi_base`, `khuri_makdisi::KhuriMakdisi_small`, `khuri_makdisi::KhuriMakdisi_medium`, `khuri_makdisi::KhuriMakdisi_large`
   --> rustmath-rings/src/function_field/mod.rs:195:5
    |
195 |     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisi_large,
    |     ^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^ no `KhuriMakdisi_large` in `function_field::khuri_makdisi`
    |     |                  |                   |
    |     |                  |                   no `KhuriMakdisi_medium` in `function_field::khuri_makdisi`
    |     |                  no `KhuriMakdisi_small` in `function_field::khuri_makdisi`
    |     no `KhuriMakdisi_base` in `function_field::khuri_makdisi`
    |
help: a similar name exists in the module
    |
195 -     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisi_large,
195 +     KhuriMakdisiBase, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisi_large,
    |
help: a similar name exists in the module
    |
195 -     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisi_large,
195 +     KhuriMakdisi_base, KhuriMakdisiSmall, KhuriMakdisi_medium, KhuriMakdisi_large,
    |
help: a similar name exists in the module
    |
195 -     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisi_large,
195 +     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisiMedium, KhuriMakdisi_large,
    |
help: a similar name exists in the module
    |
195 -     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisi_large,
195 +     KhuriMakdisi_base, KhuriMakdisi_small, KhuriMakdisi_medium, KhuriMakdisiLarge,
    |

error[E0432]: unresolved imports `function_field_polymod::FunctionField_polymod`, `function_field_polymod::FunctionField_simple`, `function_field_polymod::FunctionField_char_zero`, `function_field_polymod::FunctionField_integral`, `function_field_polymod::FunctionField_char_zero_integral`, `function_field_polymod::FunctionField_global`, `function_field_polymod::FunctionField_global_integral`
   --> rustmath-rings/src/function_field/mod.rs:212:5
    |
212 |     FunctionField_polymod, FunctionField_simple, FunctionField_char_zero,
    |     ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionField_char_zero` in `function_field::function_field_polymod`
    |     |                      |
    |     |                      no `FunctionField_simple` in `function_field::function_field_polymod`
    |     no `FunctionField_polymod` in `function_field::function_field_polymod`
213 |     FunctionField_integral, FunctionField_char_zero_integral,
    |     ^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionField_char_zero_integral` in `function_field::function_field_polymod`
    |     |
    |     no `FunctionField_integral` in `function_field::function_field_polymod`
214 |     FunctionField_global, FunctionField_global_integral,
    |     ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionField_global_integral` in `function_field::function_field_polymod`
    |     |
    |     no `FunctionField_global` in `function_field::function_field_polymod`
    |
help: a similar name exists in the module
    |
212 -     FunctionField_polymod, FunctionField_simple, FunctionField_char_zero,
212 +     FunctionFieldPolymod, FunctionField_simple, FunctionField_char_zero,
    |
help: a similar name exists in the module
    |
212 -     FunctionField_polymod, FunctionField_simple, FunctionField_char_zero,
212 +     FunctionField_polymod, FunctionFieldSimple, FunctionField_char_zero,
    |
help: a similar name exists in the module
    |
212 -     FunctionField_polymod, FunctionField_simple, FunctionField_char_zero,
212 +     FunctionField_polymod, FunctionField_simple, FunctionFieldCharZero,
    |
help: a similar name exists in the module
    |
213 -     FunctionField_integral, FunctionField_char_zero_integral,
213 +     FunctionFieldIntegral, FunctionField_char_zero_integral,
    |
help: a similar name exists in the module
    |
213 -     FunctionField_integral, FunctionField_char_zero_integral,
213 +     FunctionField_integral, FunctionFieldCharZeroIntegral,
    |
help: a similar name exists in the module
    |
214 -     FunctionField_global, FunctionField_global_integral,
214 +     FunctionFieldGlobal, FunctionField_global_integral,
    |
help: a similar name exists in the module
    |
214 -     FunctionField_global, FunctionField_global_integral,
214 +     FunctionField_global, FunctionFieldGlobalIntegral,
    |

error[E0432]: unresolved imports `function_field_rational::RationalFunctionField_char_zero`, `function_field_rational::RationalFunctionField_global`
   --> rustmath-rings/src/function_field/mod.rs:218:28
    |
218 |     RationalFunctionField, RationalFunctionField_char_zero,
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `RationalFunctionField_char_zero` in `function_field::function_field_rational`
219 |     RationalFunctionField_global, is_function_field,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `RationalFunctionField_global` in `function_field::function_field_rational`
    |
help: a similar name exists in the module
    |
218 -     RationalFunctionField, RationalFunctionField_char_zero,
218 +     RationalFunctionField, RationalFunctionFieldCharZero,
    |
help: a similar name exists in the module
    |
219 -     RationalFunctionField_global, is_function_field,
219 +     RationalFunctionFieldGlobal, is_function_field,
    |

error[E0432]: unresolved imports `ideal_polymod::FunctionFieldIdeal_polymod`, `ideal_polymod::FunctionFieldIdealInfinite_polymod`, `ideal_polymod::FunctionFieldIdeal_global`
   --> rustmath-rings/src/function_field/mod.rs:227:5
    |
227 |     FunctionFieldIdeal_polymod, FunctionFieldIdealInfinite_polymod,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldIdealInfinite_polymod` in `function_field::ideal_polymod`
    |     |
    |     no `FunctionFieldIdeal_polymod` in `function_field::ideal_polymod`
228 |     FunctionFieldIdeal_global,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldIdeal_global` in `function_field::ideal_polymod`
    |
help: a similar name exists in the module
    |
227 -     FunctionFieldIdeal_polymod, FunctionFieldIdealInfinite_polymod,
227 +     FunctionFieldIdealPolymod, FunctionFieldIdealInfinite_polymod,
    |
help: a similar name exists in the module
    |
227 -     FunctionFieldIdeal_polymod, FunctionFieldIdealInfinite_polymod,
227 +     FunctionFieldIdeal_polymod, FunctionFieldIdealInfinitePolymod,
    |
help: a similar name exists in the module
    |
228 -     FunctionFieldIdeal_global,
228 +     FunctionFieldIdealGlobal,
    |

error[E0432]: unresolved imports `ideal_rational::FunctionFieldIdeal_rational`, `ideal_rational::FunctionFieldIdealInfinite_rational`
   --> rustmath-rings/src/function_field/mod.rs:232:5
    |
232 |     FunctionFieldIdeal_rational, FunctionFieldIdealInfinite_rational,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldIdealInfinite_rational` in `function_field::ideal_rational`
    |     |
    |     no `FunctionFieldIdeal_rational` in `function_field::ideal_rational`
    |
help: a similar name exists in the module
    |
232 -     FunctionFieldIdeal_rational, FunctionFieldIdealInfinite_rational,
232 +     FunctionFieldIdealRational, FunctionFieldIdealInfinite_rational,
    |
help: a similar name exists in the module
    |
232 -     FunctionFieldIdeal_rational, FunctionFieldIdealInfinite_rational,
232 +     FunctionFieldIdeal_rational, FunctionFieldIdealInfiniteRational,
    |

error[E0432]: unresolved imports `maps::FunctionFieldMorphism_polymod`, `maps::FunctionFieldMorphism_rational`
   --> rustmath-rings/src/function_field/mod.rs:236:28
    |
236 |     FunctionFieldMorphism, FunctionFieldMorphism_polymod, FunctionFieldMorphism_rational,
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `FunctionFieldMorphism_rational` in `function_field::maps`
    |                            |
    |                            no `FunctionFieldMorphism_polymod` in `function_field::maps`
    |
help: a similar name exists in the module
    |
236 -     FunctionFieldMorphism, FunctionFieldMorphism_polymod, FunctionFieldMorphism_rational,
236 +     FunctionFieldMorphism, FunctionFieldMorphismPolymod, FunctionFieldMorphism_rational,
    |
help: a similar name exists in the module
    |
236 -     FunctionFieldMorphism, FunctionFieldMorphism_polymod, FunctionFieldMorphism_rational,
236 +     FunctionFieldMorphism, FunctionFieldMorphism_polymod, FunctionFieldMorphismRational,
    |

error[E0432]: unresolved import `order::FunctionFieldOrder_base`
   --> rustmath-rings/src/function_field/mod.rs:245:5
    |
245 |     FunctionFieldOrder_base, FunctionFieldOrder, FunctionFieldOrderInfinite,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
    |     |
    |     no `FunctionFieldOrder_base` in `function_field::order`
    |     help: a similar name exists in the module: `FunctionFieldOrderBase`

warning: `rustmath-symmetricfunctions` (lib) generated 68 warnings (run `cargo fix --lib -p rustmath-symmetricfunctions` to apply 12 suggestions)
error[E0277]: cannot add `T` to `T`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:44:17
    |
 44 |         element.element()
    |                 ^^^^^^^ no implementation for `T + T`
    |
note: required by a bound in `AdditiveAbelianGroupWrapperElement::<T>::element`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:132:12
    |
130 |     pub fn element(&self) -> Result<T, String>
    |            ------- required by a bound in this associated function
131 |     where
132 |         T: std::ops::Add<Output = T>,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `AdditiveAbelianGroupWrapperElement::<T>::element`
help: consider further restricting type parameter `T` with trait `Add`
    |
 27 | impl<T: Clone + std::ops::Add> UnwrappingMorphism<T> {
    |               +++++++++++++++

error[E0277]: cannot add `T` to `T`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:109:29
    |
109 |         let vector = parent.discrete_log(&ambient_element)?;
    |                             ^^^^^^^^^^^^ no implementation for `T + T`
    |
note: required by a bound in `AdditiveAbelianGroupWrapper::<T>::discrete_log`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:298:24
    |
296 |     pub fn discrete_log(&self, element: &T) -> Result<Vec<i64>, String>
    |            ------------ required by a bound in this associated function
297 |     where
298 |         T: PartialEq + std::ops::Add<Output = T> + std::ops::Mul<i64, Output = T> + Default,
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `AdditiveAbelianGroupWrapper::<T>::discrete_log`
help: consider further restricting type parameter `T` with trait `Add`
    |
 78 | impl<T: Clone + std::ops::Add> AdditiveAbelianGroupWrapperElement<T> {
    |               +++++++++++++++

error[E0277]: cannot multiply `T` by `i64`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:109:29
    |
109 |         let vector = parent.discrete_log(&ambient_element)?;
    |                             ^^^^^^^^^^^^ no implementation for `T * i64`
    |
note: required by a bound in `AdditiveAbelianGroupWrapper::<T>::discrete_log`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:298:52
    |
296 |     pub fn discrete_log(&self, element: &T) -> Result<Vec<i64>, String>
    |            ------------ required by a bound in this associated function
297 |     where
298 |         T: PartialEq + std::ops::Add<Output = T> + std::ops::Mul<i64, Output = T> + Default,
    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `AdditiveAbelianGroupWrapper::<T>::discrete_log`
help: consider further restricting type parameter `T` with trait `Mul`
    |
 78 | impl<T: Clone + std::ops::Mul<i64>> AdditiveAbelianGroupWrapperElement<T> {
    |               ++++++++++++++++++++

error[E0277]: the trait bound `T: Default` is not satisfied
   --> rustmath-groups/src/additive_abelian_wrapper.rs:109:29
    |
109 |         let vector = parent.discrete_log(&ambient_element)?;
    |                             ^^^^^^^^^^^^ the trait `Default` is not implemented for `T`
    |
note: required by a bound in `AdditiveAbelianGroupWrapper::<T>::discrete_log`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:298:85
    |
296 |     pub fn discrete_log(&self, element: &T) -> Result<Vec<i64>, String>
    |            ------------ required by a bound in this associated function
297 |     where
298 |         T: PartialEq + std::ops::Add<Output = T> + std::ops::Mul<i64, Output = T> + Default,
    |                                                                                     ^^^^^^^ required by this bound in `AdditiveAbelianGroupWrapper::<T>::discrete_log`
help: consider further restricting type parameter `T` with trait `Default`
    |
 78 | impl<T: Clone + std::default::Default> AdditiveAbelianGroupWrapperElement<T> {
    |               +++++++++++++++++++++++

error[E0277]: cannot multiply `T` by `i64`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:138:21
    |
138 |         self.parent.discrete_exp(&self.vector)
    |                     ^^^^^^^^^^^^ no implementation for `T * i64`
    |
note: required by a bound in `AdditiveAbelianGroupWrapper::<T>::discrete_exp`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:265:40
    |
263 |     pub fn discrete_exp(&self, coefficients: &[i64]) -> Result<T, String>
    |            ------------ required by a bound in this associated function
264 |     where
265 |         T: std::ops::Add<Output = T> + std::ops::Mul<i64, Output = T> + Default,
    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `AdditiveAbelianGroupWrapper::<T>::discrete_exp`
help: consider further restricting type parameter `T` with trait `Mul`
    |
 78 | impl<T: Clone + std::ops::Mul<i64>> AdditiveAbelianGroupWrapperElement<T> {
    |               ++++++++++++++++++++

error[E0277]: the trait bound `T: Default` is not satisfied
   --> rustmath-groups/src/additive_abelian_wrapper.rs:138:21
    |
138 |         self.parent.discrete_exp(&self.vector)
    |                     ^^^^^^^^^^^^ the trait `Default` is not implemented for `T`
    |
note: required by a bound in `AdditiveAbelianGroupWrapper::<T>::discrete_exp`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:265:73
    |
263 |     pub fn discrete_exp(&self, coefficients: &[i64]) -> Result<T, String>
    |            ------------ required by a bound in this associated function
264 |     where
265 |         T: std::ops::Add<Output = T> + std::ops::Mul<i64, Output = T> + Default,
    |                                                                         ^^^^^^^ required by this bound in `AdditiveAbelianGroupWrapper::<T>::discrete_exp`
help: consider further restricting type parameter `T` with trait `Default`
    |
 78 | impl<T: Clone + std::default::Default> AdditiveAbelianGroupWrapperElement<T> {
    |               +++++++++++++++++++++++

error[E0369]: binary operation `!=` cannot be applied to type `AdditiveAbelianGroupWrapper<T>`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:143:24
    |
143 |         if self.parent != other.parent {
    |            ----------- ^^ ------------ AdditiveAbelianGroupWrapper<T>
    |            |
    |            AdditiveAbelianGroupWrapper<T>
    |
help: consider further restricting type parameter `T` with trait `PartialEq`
    |
 78 | impl<T: Clone + std::cmp::PartialEq> AdditiveAbelianGroupWrapperElement<T> {
    |               +++++++++++++++++++++

error[E0599]: no method named `is_zero` found for struct `rustmath_rationals::Rational` in the current scope
   --> rustmath-symbolic/src/expand.rs:115:28
    |
115 |                     if val.is_zero() {
    |                            ^^^^^^^ method not found in `rustmath_rationals::Rational`
    |
   ::: /home/john/RustMath/rustmath-core/src/traits.rs:63:8
    |
 63 |     fn is_zero(&self) -> bool;
    |        ------- the method is available for `rustmath_rationals::Rational` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
    |
  3 + use rustmath_core::Ring;
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/affine_group.rs:127:42
    |
127 |         let new_matrix = self.matrix.mul(&other.matrix)?;
    |                                      --- ^^^^^^^^^^^^^ expected `Matrix<R>`, found `&Matrix<R>`
    |                                      |
    |                                      arguments to this method are incorrect
    |
    = note: expected struct `Matrix<_>`
            found reference `&Matrix<_>`
help: the return type of this call is `&Matrix<R>` due to the type of the argument passed
   --> rustmath-groups/src/affine_group.rs:127:26
    |
127 |         let new_matrix = self.matrix.mul(&other.matrix)?;
    |                          ^^^^^^^^^^^^^^^^-------------^
    |                                          |
    |                                          this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
127 -         let new_matrix = self.matrix.mul(&other.matrix)?;
127 +         let new_matrix = self.matrix.mul(other.matrix)?;
    |

error[E0277]: `?` couldn't convert the error to `String`
   --> rustmath-groups/src/affine_group.rs:127:56
    |
127 |         let new_matrix = self.matrix.mul(&other.matrix)?;
    |                                      ------------------^ the trait `From<MathError>` is not implemented for `String`
    |                                      |
    |                                      this can't be annotated with `?` because it has type `Result<_, MathError>`
    |
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the following other types implement trait `From<T>`:
              `String` implements `From<&String>`
              `String` implements `From<&mut str>`
              `String` implements `From<&str>`
              `String` implements `From<Box<str>>`
              `String` implements `From<Cow<'_, str>>`
              `String` implements `From<char>`

error[E0599]: the method `inverse` exists for struct `Matrix<R>`, but its trait bounds were not satisfied
   --> rustmath-groups/src/affine_group.rs:177:38
    |
177 |         let inv_matrix = self.matrix.inverse()?;
    |                                      ^^^^^^^ method cannot be called on `Matrix<R>` due to unsatisfied trait bounds
    |
    = note: the following trait bounds were not satisfied:
            `R: Field`
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `inverse`, perhaps you need to implement one of them:
            candidate #1: `AbstractArgument`
            candidate #2: `SemidirectProductCompatible`
            candidate #3: `conjugacy_classes::GroupElement`
            candidate #4: `group_traits::GroupElement`

error[E0308]: mismatched types
   --> rustmath-groups/src/argument_groups.rs:251:9
    |
250 |     pub fn exponent_rational(&self) -> Rational {
    |                                        -------- expected `Rational` because of return type
251 |         Rational::new(self.k.into(), self.n.into())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Rational`, found `Result<Rational, MathError>`
    |
    = note: expected struct `Rational`
                 found enum `Result<Rational, MathError>`
help: consider using `Result::expect` to unwrap the `Result<Rational, MathError>` value, panicking if the value is a `Result::Err`
    |
251 |         Rational::new(self.k.into(), self.n.into()).expect("REASON")
    |                                                    +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-liealgebras/src/weight_lattice.rs:125:71
    |
125 |         self.coefficients.iter().fold(Integer::zero(), |acc, c| acc + c)
    |                                                                 ---   ^ expected `Integer`, found `&Integer`
    |                                                                 |
    |                                                                 expected because this is `Integer`
    |
help: consider using clone here
    |
125 |         self.coefficients.iter().fold(Integer::zero(), |acc, c| acc + c.clone())
    |                                                                        ++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/argument_groups.rs:403:23
    |
403 |         Complex::from(self.to_f64())
    |         ------------- ^^^^^^^^^^^^^ expected `Complex`, found `f64`
    |         |
    |         arguments to this function are incorrect
    |
note: associated function defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:592:8
    |
592 |     fn from(value: T) -> Self;
    |        ^^^^

error[E0308]: mismatched types
   --> rustmath-groups/src/argument_groups.rs:524:45
    |
524 |             self.element.div(&Complex::from(r))
    |                               ------------- ^ expected `Complex`, found `f64`
    |                               |
    |                               arguments to this function are incorrect
    |
note: associated function defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:592:8
    |
592 |     fn from(value: T) -> Self;
    |        ^^^^

error[E0308]: mismatched types
   --> rustmath-groups/src/argument_groups.rs:524:13
    |
519 |     fn to_complex(&self) -> Complex {
    |                             ------- expected `Complex` because of return type
...
524 |             self.element.div(&Complex::from(r))
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Complex`, found `Result<Complex, MathError>`
    |
    = note: expected struct `Complex`
                 found enum `Result<Complex, MathError>`
help: consider using `Result::expect` to unwrap the `Result<Complex, MathError>` value, panicking if the value is a `Result::Err`
    |
524 |             self.element.div(&Complex::from(r)).expect("REASON")
    |                                                +++++++++++++++++

error[E0599]: no method named `is_zero` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-symbolic/src/inequalities.rs:653:18
    |
653 |             if r.is_zero() {
    |                  ^^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
    |
 11 + use rustmath_core::Ring;
    |

error[E0599]: no method named `is_zero` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-symbolic/src/inequalities.rs:682:32
    |
682 |         Expr::Rational(r) => r.is_zero(),
    |                                ^^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
    |
 11 + use rustmath_core::Ring;
    |

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/artin.rs:227:24
    |
222 |                     relations.push(relation);
    |                     ---------      -------- this argument has type `FreeGroupElement`...
    |                     |
    |                     ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
227 |         let fp_group = FinitelyPresentedGroup::new(rank, relations);
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/artin.rs:227:52
    |
227 |         let fp_group = FinitelyPresentedGroup::new(rank, relations);
    |                                                    ^^^^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/artin.rs:227:58
    |
227 |         let fp_group = FinitelyPresentedGroup::new(rank, relations);
    |                                                          ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: mismatched types
   --> rustmath-groups/src/artin.rs:347:33
    |
347 |             word: self.word.pow(n),
    |                             --- ^ expected `isize`, found `i32`
    |                             |
    |                             arguments to this method are incorrect
    |
note: method defined here
   --> rustmath-groups/src/free_group.rs:376:12
    |
376 |     pub fn pow(&self, n: isize) -> FreeGroupElement {
    |            ^^^        --------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
347 |             word: self.word.pow(n.try_into().unwrap()),
    |                                  ++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/braid.rs:253:13
    |
253 |         for (gen, exp) in word.letters() {
    |             ^^^^^^^^^^    -------------- this is an iterator with items of type `usize`
    |             |
    |             expected `usize`, found `(_, _)`
    |
    = note: expected type `usize`
              found tuple `(_, _)`

error[E0308]: mismatched types
   --> rustmath-groups/src/braid.rs:280:42
    |
280 |         self.element.word().exponent_sum(i as i32 - 1)
    |                             ------------ ^^^^^^^^^^^^ expected `usize`, found `i32`
    |                             |
    |                             arguments to this method are incorrect
    |
note: method defined here
   --> rustmath-groups/src/free_group.rs:327:12
    |
327 |     pub fn exponent_sum(&self, generator: usize) -> isize {
    |            ^^^^^^^^^^^^        ----------------
help: you can convert an `i32` to a `usize` and panic if the converted value doesn't fit
    |
280 |         self.element.word().exponent_sum((i as i32 - 1).try_into().unwrap())
    |                                          +            +++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/braid.rs:280:9
    |
278 |     pub fn exponent_sum(&self, i: usize) -> i32 {
    |                                             --- expected `i32` because of return type
279 |         assert!(i >= 1 && i < self.parent.strands(), "Generator index out of bounds");
280 |         self.element.word().exponent_sum(i as i32 - 1)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `isize`
    |
help: you can convert an `isize` to an `i32` and panic if the converted value doesn't fit
    |
280 |         self.element.word().exponent_sum(i as i32 - 1).try_into().unwrap()
    |                                                       ++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/braid.rs:462:19
    |
462 |             .map(|(g, e)| (*g as usize, *e))
    |                   ^^^^^^
    |                   |
    |                   expected `usize`, found `(_, _)`
    |                   expected due to this
    |
    = note: expected type `usize`
              found tuple `(_, _)`

warning: `rustmath-crystals` (lib) generated 35 warnings (run `cargo fix --lib -p rustmath-crystals` to apply 14 suggestions)
error[E0308]: mismatched types
   --> rustmath-groups/src/class_function.rs:196:40
    |
196 |         self.scalar_mul(&Complex::from(-1.0))
    |                          ------------- ^^^^ expected `Complex`, found floating-point number
    |                          |
    |                          arguments to this function are incorrect
    |
note: associated function defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:592:8
    |
592 |     fn from(value: T) -> Self;
    |        ^^^^

error[E0308]: mismatched types
   --> rustmath-groups/src/class_function.rs:222:37
    |
222 |         Some(sum.div(&Complex::from(order)))
    |                       ------------- ^^^^^ expected `Complex`, found `f64`
    |                       |
    |                       arguments to this function are incorrect
    |
note: associated function defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:592:8
    |
592 |     fn from(value: T) -> Self;
    |        ^^^^

error[E0308]: mismatched types
   --> rustmath-groups/src/class_function.rs:222:14
    |
222 |         Some(sum.div(&Complex::from(order)))
    |         ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Complex`, found `Result<Complex, MathError>`
    |         |
    |         arguments to this enum variant are incorrect
    |
    = note: expected struct `Complex`
                 found enum `Result<Complex, MathError>`
help: the type constructed contains `Result<Complex, MathError>` due to the type of the argument passed
   --> rustmath-groups/src/class_function.rs:222:9
    |
222 |         Some(sum.div(&Complex::from(order)))
    |         ^^^^^------------------------------^
    |              |
    |              this argument influences the type of `Some`
note: tuple variant defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:602:5
    |
602 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^^^
help: consider using `Result::expect` to unwrap the `Result<Complex, MathError>` value, panicking if the value is a `Result::Err`
    |
222 |         Some(sum.div(&Complex::from(order)).expect("REASON"))
    |                                            +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/class_function.rs:315:44
    |
315 |         values.insert(class, Complex::from(1.0));
    |                              ------------- ^^^ expected `Complex`, found floating-point number
    |                              |
    |                              arguments to this function are incorrect
    |
note: associated function defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/convert/mod.rs:592:8
    |
592 |     fn from(value: T) -> Self;
    |        ^^^^

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/cubic_braid.rs:196:24
    |
 98 |             relations.push(gen);
    |             ---------      --- this argument has type `FreeGroupElement`...
    |             |
    |             ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
196 |         let fp_group = FinitelyPresentedGroup::new(n_gens, relations);
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/cubic_braid.rs:196:52
    |
196 |         let fp_group = FinitelyPresentedGroup::new(n_gens, relations);
    |                                                    ^^^^^^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/cubic_braid.rs:196:60
    |
196 |         let fp_group = FinitelyPresentedGroup::new(n_gens, relations);
    |                                                            ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: mismatched types
   --> rustmath-groups/src/cubic_braid.rs:426:33
    |
426 |             word: self.word.pow(n),
    |                             --- ^ expected `isize`, found `i32`
    |                             |
    |                             arguments to this method are incorrect
    |
note: method defined here
   --> rustmath-groups/src/free_group.rs:376:12
    |
376 |     pub fn pow(&self, n: isize) -> FreeGroupElement {
    |            ^^^        --------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
426 |             word: self.word.pow(n.try_into().unwrap()),
    |                                  ++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/free_group.rs:401:18
    |
401 |             .mul(&self.inverse())
    |              --- ^^^^^^^^^^^^^^^ expected `FreeGroupElement`, found `&FreeGroupElement`
    |              |
    |              arguments to this method are incorrect
    |
help: the return type of this call is `&FreeGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/free_group.rs:400:9
    |
400 | /         self.mul(other)
401 | |             .mul(&self.inverse())
    | |__________________---------------^
    |                    |
    |                    this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
401 -             .mul(&self.inverse())
401 +             .mul(self.inverse())
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/free_group.rs:402:18
    |
402 |             .mul(&other.inverse())
    |              --- ^^^^^^^^^^^^^^^^ expected `FreeGroupElement`, found `&FreeGroupElement`
    |              |
    |              arguments to this method are incorrect
    |
help: the return type of this call is `&FreeGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/free_group.rs:400:9
    |
400 | /         self.mul(other)
401 | |             .mul(&self.inverse())
402 | |             .mul(&other.inverse())
    | |__________________----------------^
    |                    |
    |                    this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
402 -             .mul(&other.inverse())
402 +             .mul(other.inverse())
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/free_group.rs:407:29
    |
407 |         other.mul(self).mul(&other.inverse())
    |                         --- ^^^^^^^^^^^^^^^^ expected `FreeGroupElement`, found `&FreeGroupElement`
    |                         |
    |                         arguments to this method are incorrect
    |
help: the return type of this call is `&FreeGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/free_group.rs:407:9
    |
407 |         other.mul(self).mul(&other.inverse())
    |         ^^^^^^^^^^^^^^^^^^^^----------------^
    |                             |
    |                             this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
407 -         other.mul(self).mul(&other.inverse())
407 +         other.mul(self).mul(other.inverse())
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/free_group.rs:456:47
    |
456 |                         let term = prefix.mul(&self.group.generator(gen_index).unwrap().pow(i));
    |                                           --- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `FreeGroupElement`, found `&FreeGroupElement`
    |                                           |
    |                                           arguments to this method are incorrect
    |
help: the return type of this call is `&FreeGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/free_group.rs:456:36
    |
456 |                         let term = prefix.mul(&self.group.generator(gen_index).unwrap().pow(i));
    |                                    ^^^^^^^^^^^------------------------------------------------^
    |                                               |
    |                                               this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
456 -                         let term = prefix.mul(&self.group.generator(gen_index).unwrap().pow(i));
456 +                         let term = prefix.mul(self.group.generator(gen_index).unwrap().pow(i));
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/free_group.rs:462:47
    |
462 |                         let term = prefix.mul(&gen_elem.pow(-i - 1));
    |                                           --- ^^^^^^^^^^^^^^^^^^^^^ expected `FreeGroupElement`, found `&FreeGroupElement`
    |                                           |
    |                                           arguments to this method are incorrect
    |
help: the return type of this call is `&FreeGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/free_group.rs:462:36
    |
462 |                         let term = prefix.mul(&gen_elem.pow(-i - 1));
    |                                    ^^^^^^^^^^^---------------------^
    |                                               |
    |                                               this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
462 -                         let term = prefix.mul(&gen_elem.pow(-i - 1));
462 +                         let term = prefix.mul(gen_elem.pow(-i - 1));
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/free_group.rs:469:33
    |
469 |               prefix = prefix.mul(&FreeGroupElement {
    |  _____________________________---_^
    | |                             |
    | |                             arguments to this method are incorrect
470 | |                 group: self.group.clone(),
471 | |                 word: vec![(g, e)],
472 | |             });
    | |_____________^ expected `FreeGroupElement`, found `&FreeGroupElement`
    |
help: the return type of this call is `&FreeGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/free_group.rs:469:22
    |
469 |                prefix = prefix.mul(&FreeGroupElement {
    |   ______________________^          -
    |  |_________________________________|
470 | ||                 group: self.group.clone(),
471 | ||                 word: vec![(g, e)],
472 | ||             });
    | ||_____________-^
    | |______________|
    |                this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
469 -             prefix = prefix.mul(&FreeGroupElement {
469 +             prefix = prefix.mul(FreeGroupElement {
    |

error[E0599]: no method named `is_zero` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-symbolic/src/solve.rs:111:32
    |
111 |         Expr::Rational(r) if r.is_zero() => Solution::All,
    |                                ^^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
    |
  5 + use rustmath_core::Ring;
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented.rs:329:33
    |
329 |             result = result.mul(self);
    |                             --- ^^^^ expected `FinitelyPresentedGroupElement`, found `&FinitelyPresentedGroupElement`
    |                             |
    |                             arguments to this method are incorrect
    |
help: the return type of this call is `&FinitelyPresentedGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/finitely_presented.rs:329:22
    |
329 |             result = result.mul(self);
    |                      ^^^^^^^^^^^----^
    |                                 |
    |                                 this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider using clone here
    |
329 |             result = result.mul(self.clone());
    |                                     ++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented.rs:336:29
    |
336 |         self.mul(other).mul(&self.inverse()).mul(&other.inverse())
    |                         --- ^^^^^^^^^^^^^^^ expected `FinitelyPresentedGroupElement`, found `&FinitelyPresentedGroupElement`
    |                         |
    |                         arguments to this method are incorrect
    |
help: the return type of this call is `&FinitelyPresentedGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/finitely_presented.rs:336:9
    |
336 |         self.mul(other).mul(&self.inverse()).mul(&other.inverse())
    |         ^^^^^^^^^^^^^^^^^^^^---------------^
    |                             |
    |                             this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
336 -         self.mul(other).mul(&self.inverse()).mul(&other.inverse())
336 +         self.mul(other).mul(self.inverse()).mul(&other.inverse())
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented.rs:336:50
    |
336 |         self.mul(other).mul(&self.inverse()).mul(&other.inverse())
    |                                              --- ^^^^^^^^^^^^^^^^ expected `FinitelyPresentedGroupElement`, found `&FinitelyPresentedGroupElement`
    |                                              |
    |                                              arguments to this method are incorrect
    |
help: the return type of this call is `&FinitelyPresentedGroupElement` due to the type of the argument passed
   --> rustmath-groups/src/finitely_presented.rs:336:9
    |
336 |         self.mul(other).mul(&self.inverse()).mul(&other.inverse())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^----------------^
    |                                                  |
    |                                                  this argument influences the return type of `mul`
note: method defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:8
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |        ^^^
help: consider removing the borrow
    |
336 -         self.mul(other).mul(&self.inverse()).mul(&other.inverse())
336 +         self.mul(other).mul(&self.inverse()).mul(other.inverse())
    |

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:40:57
    |
 40 |     let relations = vec![FreeGroupElement::generator(0, n as i32)];
    |                          ---------------------------    ^^^^^^^^ expected `isize`, found `i32`
    |                          |
    |                          arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
 40 |     let relations = vec![FreeGroupElement::generator(0, (n as i32).try_into().unwrap())];
    |                                                         +        +++++++++++++++++++++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:42:5
    |
 42 |     FinitelyPresentedGroup::new(1, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found integer
   --> rustmath-groups/src/finitely_presented_named.rs:42:33
    |
 42 |     FinitelyPresentedGroup::new(1, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `{integer}`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:42:36
    |
 42 |     FinitelyPresentedGroup::new(1, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:77:66
    |
 77 |             relations.push(FreeGroupElement::generator(i as i32, inv as i32));
    |                            ---------------------------           ^^^^^^^^^^ expected `isize`, found `i32`
    |                            |
    |                            arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
 77 |             relations.push(FreeGroupElement::generator(i as i32, (inv as i32).try_into().unwrap()));
    |                                                                  +          +++++++++++++++++++++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:95:5
    |
 77 |             relations.push(FreeGroupElement::generator(i as i32, inv as i32));
    |             ---------      ------------------------------------------------- this argument has type `FreeGroupElement`...
    |             |
    |             ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
 95 |     FinitelyPresentedGroup::new(n_gens, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/finitely_presented_named.rs:95:33
    |
 95 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                 ^^^^^^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:95:41
    |
 95 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                         ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0599]: no method named `is_zero` found for reference `&rustmath_rationals::Rational` in the current scope
    --> rustmath-symbolic/src/solve.rs:1522:32
     |
1522 |         Expr::Rational(r) => r.is_zero(),
     |                                ^^^^^^^ method not found in `&rustmath_rationals::Rational`
     |
     = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
     |
   5 + use rustmath_core::Ring;
     |

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:209:66
    |
209 |         relations.push(FreeGroupElement::generator(z_idx as i32, p as i32));
    |                        ---------------------------               ^^^^^^^^ expected `isize`, found `i32`
    |                        |
    |                        arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
209 |         relations.push(FreeGroupElement::generator(z_idx as i32, (p as i32).try_into().unwrap()));
    |                                                                  +        +++++++++++++++++++++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:212:5
    |
139 |         relations.push(comm);
    |         ---------      ---- this argument has type `FreeGroupElement`...
    |         |
    |         ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
212 |     FinitelyPresentedGroup::new(n_gens, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/finitely_presented_named.rs:212:33
    |
212 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                 ^^^^^^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:212:41
    |
212 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                         ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:231:51
    |
231 |     relations.push(FreeGroupElement::generator(0, n as i32));
    |                    ---------------------------    ^^^^^^^^ expected `isize`, found `i32`
    |                    |
    |                    arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
231 |     relations.push(FreeGroupElement::generator(0, (n as i32).try_into().unwrap()));
    |                                                   +        +++++++++++++++++++++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:242:5
    |
231 |     relations.push(FreeGroupElement::generator(0, n as i32));
    |     ---------      ---------------------------------------- this argument has type `FreeGroupElement`...
    |     |
    |     ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
242 |     FinitelyPresentedGroup::new(2, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found integer
   --> rustmath-groups/src/finitely_presented_named.rs:242:33
    |
242 |     FinitelyPresentedGroup::new(2, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `{integer}`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:242:36
    |
242 |     FinitelyPresentedGroup::new(2, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:261:51
    |
261 |     relations.push(FreeGroupElement::generator(0, (2 * n) as i32));
    |                    ---------------------------    ^^^^^^^^^^^^^^ expected `isize`, found `i32`
    |                    |
    |                    arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
261 |     relations.push(FreeGroupElement::generator(0, ((2 * n) as i32).try_into().unwrap()));
    |                                                   +              +++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:265:50
    |
265 |     let a_neg_n = FreeGroupElement::generator(0, -(n as i32));
    |                   ---------------------------    ^^^^^^^^^^^ expected `isize`, found `i32`
    |                   |
    |                   arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
265 |     let a_neg_n = FreeGroupElement::generator(0, (-(n as i32)).try_into().unwrap());
    |                                                  +           +++++++++++++++++++++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:275:5
    |
261 |     relations.push(FreeGroupElement::generator(0, (2 * n) as i32));
    |     ---------      ---------------------------------------------- this argument has type `FreeGroupElement`...
    |     |
    |     ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
275 |     FinitelyPresentedGroup::new(2, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found integer
   --> rustmath-groups/src/finitely_presented_named.rs:275:33
    |
275 |     FinitelyPresentedGroup::new(2, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `{integer}`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:275:36
    |
275 |     FinitelyPresentedGroup::new(2, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:302:5
    |
288 |     relations.push(FreeGroupElement::generator(0, 4));
    |     ---------      --------------------------------- this argument has type `FreeGroupElement`...
    |     |
    |     ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
302 |     FinitelyPresentedGroup::new(2, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found integer
   --> rustmath-groups/src/finitely_presented_named.rs:302:33
    |
302 |     FinitelyPresentedGroup::new(2, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `{integer}`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:302:36
    |
302 |     FinitelyPresentedGroup::new(2, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:328:5
    |
315 |     relations.push(FreeGroupElement::generator(0, 2));
    |     ---------      --------------------------------- this argument has type `FreeGroupElement`...
    |     |
    |     ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
328 |     FinitelyPresentedGroup::new(2, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found integer
   --> rustmath-groups/src/finitely_presented_named.rs:328:33
    |
328 |     FinitelyPresentedGroup::new(2, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `{integer}`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:328:36
    |
328 |     FinitelyPresentedGroup::new(2, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: mismatched types
   --> rustmath-groups/src/finitely_presented_named.rs:353:45
    |
353 |     let zn = FreeGroupElement::generator(2, n as i32);
    |              ---------------------------    ^^^^^^^^ expected `isize`, found `i32`
    |              |
    |              arguments to this function are incorrect
    |
note: associated function defined here
   --> rustmath-groups/src/free_group.rs:194:12
    |
194 |     pub fn generator(gen_index: i32, exponent: isize) -> Self {
    |            ^^^^^^^^^                 ---------------
help: you can convert an `i32` to an `isize` and panic if the converted value doesn't fit
    |
353 |     let zn = FreeGroupElement::generator(2, (n as i32).try_into().unwrap());
    |                                             +        +++++++++++++++++++++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:364:5
    |
349 |     relations.push(x_neg2.multiply(&y2));
    |     ---------      -------------------- this argument has type `FreeGroupElement`...
    |     |
    |     ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
364 |     FinitelyPresentedGroup::new(3, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found integer
   --> rustmath-groups/src/finitely_presented_named.rs:364:33
    |
364 |     FinitelyPresentedGroup::new(3, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `{integer}`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:364:36
    |
364 |     FinitelyPresentedGroup::new(3, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0599]: no function or associated item named `zero` found for struct `rustmath_rationals::Rational` in the current scope
   --> rustmath-symbolic/src/specialfunctions/other.rs:329:31
    |
329 |             if r > &Rational::zero() {
    |                               ^^^^ function or associated item not found in `rustmath_rationals::Rational`
    |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
      rustmath_rationals::Rational::from_i64
      rustmath_rationals::Rational::from_f64
   --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
    |
 18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 44 |     pub fn from_i64(n: i64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
156 |     pub fn from_f64(f: f64) -> Result<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
    |
 32 + use rustmath_core::Ring;
    |
help: there is a method `is_zero` with a similar name
    |
329 |             if r > &Rational::is_zero() {
    |                               +++

error[E0599]: no function or associated item named `zero` found for struct `rustmath_rationals::Rational` in the current scope
   --> rustmath-symbolic/src/specialfunctions/other.rs:331:38
    |
331 |             } else if r < &Rational::zero() {
    |                                      ^^^^ function or associated item not found in `rustmath_rationals::Rational`
    |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
      rustmath_rationals::Rational::from_i64
      rustmath_rationals::Rational::from_f64
   --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
    |
 18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 44 |     pub fn from_i64(n: i64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
156 |     pub fn from_f64(f: f64) -> Result<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
    |
 32 + use rustmath_core::Ring;
    |
help: there is a method `is_zero` with a similar name
    |
331 |             } else if r < &Rational::is_zero() {
    |                                      +++

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:411:5
    |
390 |         relations.push(FreeGroupElement::generator(i as i32, 2));
    |         ---------      ---------------------------------------- this argument has type `FreeGroupElement`...
    |         |
    |         ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
411 |     FinitelyPresentedGroup::new(n, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/finitely_presented_named.rs:411:33
    |
411 |     FinitelyPresentedGroup::new(n, relations)
    |                                 ^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:411:36
    |
411 |     FinitelyPresentedGroup::new(n, relations)
    |                                    ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:467:5
    |
435 |         relations.push(FreeGroupElement::generator(i as i32, 2));
    |         ---------      ---------------------------------------- this argument has type `FreeGroupElement`...
    |         |
    |         ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
467 |     FinitelyPresentedGroup::new(n_gens, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/finitely_presented_named.rs:467:33
    |
467 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                 ^^^^^^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:467:41
    |
467 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                         ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0308]: arguments to this function are incorrect
   --> rustmath-groups/src/finitely_presented_named.rs:514:5
    |
497 |         relations.push(FreeGroupElement::generator(i as i32, 3));
    |         ---------      ---------------------------------------- this argument has type `FreeGroupElement`...
    |         |
    |         ... which causes `relations` to have type `Vec<FreeGroupElement>`
...
514 |     FinitelyPresentedGroup::new(n_gens, relations)
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
note: expected `Vec<String>`, found `usize`
   --> rustmath-groups/src/finitely_presented_named.rs:514:33
    |
514 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                 ^^^^^^
    = note: expected struct `Vec<String>`
                 found type `usize`
note: expected `Vec<Vec<i32>>`, found `Vec<FreeGroupElement>`
   --> rustmath-groups/src/finitely_presented_named.rs:514:41
    |
514 |     FinitelyPresentedGroup::new(n_gens, relations)
    |                                         ^^^^^^^^^
    = note: expected struct `Vec<Vec<i32>>`
               found struct `Vec<FreeGroupElement>`
note: associated function defined here
   --> rustmath-groups/src/finitely_presented.rs:109:12
    |
109 |     pub fn new(generator_names: Vec<String>, relations: Vec<Vec<i32>>) -> Self {
    |            ^^^ ----------------------------  ------------------------

error[E0369]: cannot multiply `G` by `G`
   --> rustmath-groups/src/semidirect_product.rs:146:49
    |
146 |         let g_result = left.g_component.clone() * action_result;
    |                        ------------------------ ^ ------------- G
    |                        |
    |                        G
    |
help: consider further restricting type parameter `G` with trait `Mul`
    |
130 |     G: Clone + Mul<Output = G> + std::ops::Mul,
    |                                +++++++++++++++

error[E0369]: cannot multiply `H` by `H`
   --> rustmath-groups/src/semidirect_product.rs:149:49
    |
149 |         let h_result = left.h_component.clone() * right.h_component.clone();
    |                        ------------------------ ^ ------------------------- H
    |                        |
    |                        H
    |
help: consider further restricting type parameter `H` with trait `Mul`
    |
131 |     H: Clone + Mul<Output = H> + std::ops::Mul,
    |                                +++++++++++++++

error[E0599]: no method named `is_zero` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-symbolic/src/substitute.rs:88:30
   |
88 |                         if r.is_zero() {
   |                              ^^^^^^^ method not found in `rustmath_rationals::Rational`
   |
  ::: /home/john/RustMath/rustmath-core/src/traits.rs:63:8
   |
63 |     fn is_zero(&self) -> bool;
   |        ------- the method is available for `rustmath_rationals::Rational` here
   |
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
   |
 3 + use rustmath_core::Ring;
   |

error[E0599]: no method named `pow` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-symbolic/src/substitute.rs:99:40
   |
99 | ...                   Some(l.pow(e as u32))
   |                              ^^^ method not found in `rustmath_rationals::Rational`
   |
  ::: /home/john/RustMath/rustmath-core/src/traits.rs:69:8
   |
69 |     fn pow(&self, n: u32) -> Self {
   |        --- the method is available for `rustmath_rationals::Rational` here
   |
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `pow` is implemented but not in scope; perhaps you want to import it
   |
 3 + use rustmath_core::Ring;
   |

error[E0308]: mismatched types
   --> rustmath-groups/src/group_exp.rs:180:20
    |
180 |             value: self.value.add(&other.value),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AdditiveAbelianGroupElement`, found `Result<AdditiveAbelianGroupElement, ...>`
    |
    = note: expected struct `AdditiveAbelianGroupElement`
                 found enum `Result<AdditiveAbelianGroupElement, String>`
help: consider using `Result::expect` to unwrap the `Result<AdditiveAbelianGroupElement, String>` value, panicking if the value is a `Result::Err`
    |
180 |             value: self.value.add(&other.value).expect("REASON"),
    |                                                +++++++++++++++++

error[E0599]: no method named `is_zero` found for struct `AdditiveAbelianGroupElement` in the current scope
   --> rustmath-groups/src/group_exp.rs:194:20
    |
194 |         self.value.is_zero()
    |                    ^^^^^^^ method not found in `AdditiveAbelianGroupElement`
    |
   ::: rustmath-groups/src/additive_abelian_group.rs:40:1
    |
 40 | pub struct AdditiveAbelianGroupElement {
    | -------------------------------------- method `is_zero` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `is_zero`, perhaps you need to implement one of them:
            candidate #1: `Module`
            candidate #2: `Ring`
            candidate #3: `libm::math::support::int_traits::Int`
            candidate #4: `num_traits::identities::Zero`
            candidate #5: `rug::integer::mini::SealedToMini`
            candidate #6: `rustmath_polynomials::polynomial::Polynomial`

error[E0599]: no method named `scalar_multiply` found for struct `AdditiveAbelianGroupElement` in the current scope
   --> rustmath-groups/src/group_exp.rs:201:31
    |
201 |             value: self.value.scalar_multiply(n),
    |                               ^^^^^^^^^^^^^^^
    |
   ::: rustmath-groups/src/additive_abelian_group.rs:40:1
    |
 40 | pub struct AdditiveAbelianGroupElement {
    | -------------------------------------- method `scalar_multiply` not found for this struct
    |
help: there is a method `scalar_mul` with a similar name
    |
201 -             value: self.value.scalar_multiply(n),
201 +             value: self.value.scalar_mul(n),
    |

error[E0599]: no method named `hash` found for struct `AdditiveAbelianGroupElement` in the current scope
   --> rustmath-groups/src/group_exp.rs:235:20
    |
235 |         self.value.hash(state);
    |                    ^^^^ method not found in `AdditiveAbelianGroupElement`
    |
   ::: rustmath-groups/src/additive_abelian_group.rs:40:1
    |
 40 | pub struct AdditiveAbelianGroupElement {
    | -------------------------------------- method `hash` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following trait defines an item `hash`, perhaps you need to implement it:
            candidate #1: `Hash`

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> rustmath-groups/src/group_exp.rs:253:24
    |
253 |         let additive = AdditiveAbelianGroup::new(vec![1]);
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ ------- argument #1 of type `usize` is missing
    |
note: associated function defined here
   --> rustmath-groups/src/additive_abelian_group.rs:244:12
    |
244 |     pub fn new(free_rank: usize, invariant_factors: Vec<usize>) -> Result<Self, String> {
    |            ^^^ ----------------
help: provide the argument
    |
253 |         let additive = AdditiveAbelianGroup::new(/* usize */, vec![1]);
    |                                                  ++++++++++++

error[E0308]: mismatched types
   --> rustmath-groups/src/group_exp.rs:254:39
    |
254 |         let exp_group = GroupExp::new(additive.clone());
    |                         ------------- ^^^^^^^^^^^^^^^^ expected `AdditiveAbelianGroup`, found `Result<AdditiveAbelianGroup, String>`
    |                         |
    |                         arguments to this function are incorrect
    |
    = note: expected struct `AdditiveAbelianGroup`
                 found enum `Result<AdditiveAbelianGroup, String>`
note: associated function defined here
   --> rustmath-groups/src/group_exp.rs:61:12
    |
 61 |     pub fn new(base_group: AdditiveAbelianGroup) -> Self {
    |            ^^^ --------------------------------
help: consider using `Result::expect` to unwrap the `Result<AdditiveAbelianGroup, String>` value, panicking if the value is a `Result::Err`
    |
254 |         let exp_group = GroupExp::new(additive.clone().expect("REASON"));
    |                                                       +++++++++++++++++

warning: unused variable: `discriminant`
   --> rustmath-symbolic/src/diffeq.rs:329:13
    |
329 |         let discriminant = b.clone().pow(Expr::from(2))
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_discriminant`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `var`
   --> rustmath-symbolic/src/diffeq.rs:318:9
    |
318 |         var: &Symbol,
    |         ^^^ help: if this is intentional, prefix it with an underscore: `_var`

warning: unused variable: `dm_dy`
   --> rustmath-symbolic/src/diffeq.rs:348:13
    |
348 |         let dm_dy = m.differentiate(y_var);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dm_dy`

warning: unused variable: `dn_dx`
   --> rustmath-symbolic/src/diffeq.rs:349:13
    |
349 |         let dn_dx = n.differentiate(x_var);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dn_dx`

error[E0599]: no method named `zero` found for enum `Result<T, E>` in the current scope
   --> rustmath-groups/src/group_exp.rs:257:29
    |
257 |             value: additive.zero(),
    |                             ^^^^ method not found in `Result<AdditiveAbelianGroup, String>`
    |
note: the method `zero` exists on the type `AdditiveAbelianGroup`
   --> rustmath-groups/src/additive_abelian_group.rs:359:5
    |
359 |     pub fn zero(&self) -> AdditiveAbelianGroupElement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: consider using `Result::expect` to unwrap the `AdditiveAbelianGroup` value, panicking if the value is a `Result::Err`
    |
257 |             value: additive.expect("REASON").zero(),
    |                            +++++++++++++++++

error[E0277]: the trait bound `IndexedFreeGroup<I>: Hash` is not satisfied
   --> rustmath-groups/src/indexed_free_group.rs:183:5
    |
181 | #[derive(Clone, Hash, Debug)]
    |                 ---- in this derive macro expansion
182 | pub struct IndexedFreeGroupElement<I: Clone + Eq + Hash + fmt::Debug> {
183 |     parent: IndexedFreeGroup<I>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `IndexedFreeGroup<I>`
    |
help: consider annotating `IndexedFreeGroup<I>` with `#[derive(Hash)]`
    |
 52 + #[derive(Hash)]
 53 | pub struct IndexedFreeGroup<I: Clone + Eq + Hash + fmt::Debug> {
    |

warning: unused variable: `degree`
   --> rustmath-symbolic/src/factor.rs:177:9
    |
177 |     let degree = degree.unwrap();
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `args`
  --> rustmath-symbolic/src/function.rs:23:26
   |
23 |     fn derivative(&self, args: &[Expr], arg_index: usize) -> Result<Expr, String> {
   |                          ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

warning: unused variable: `arg_index`
  --> rustmath-symbolic/src/function.rs:23:41
   |
23 |     fn derivative(&self, args: &[Expr], arg_index: usize) -> Result<Expr, String> {
   |                                         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_arg_index`

error[E0277]: the trait bound `IndexedFreeAbelianGroup<I>: Hash` is not satisfied
   --> rustmath-groups/src/indexed_free_group.rs:484:5
    |
482 | #[derive(Clone, Hash, Debug)]
    |                 ---- in this derive macro expansion
483 | pub struct IndexedFreeAbelianGroupElement<I: Clone + Eq + Hash + fmt::Debug> {
484 |     parent: IndexedFreeAbelianGroup<I>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `IndexedFreeAbelianGroup<I>`
    |
help: consider annotating `IndexedFreeAbelianGroup<I>` with `#[derive(Hash)]`
    |
369 + #[derive(Hash)]
370 | pub struct IndexedFreeAbelianGroup<I: Clone + Eq + Hash + fmt::Debug> {
    |

error[E0277]: the trait bound `HashMap<I, i32>: Hash` is not satisfied
   --> rustmath-groups/src/indexed_free_group.rs:485:5
    |
482 | #[derive(Clone, Hash, Debug)]
    |                 ---- in this derive macro expansion
...
485 |     exponents: HashMap<I, i32>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Hash` is not implemented for `HashMap<I, i32>`

error[E0308]: mismatched types
   --> rustmath-liealgebras/src/chevalley_basis.rs:276:16
    |
276 |         if let Some(val) = i.to_i64() {
    |                ^^^^^^^^^   ---------- this expression has type `i64`
    |                |
    |                expected `i64`, found `Option<_>`
    |
    = note: expected type `i64`
               found enum `Option<_>`

warning: unused import: `NumericConversion`
  --> rustmath-liealgebras/src/chevalley_basis.rs:27:27
   |
27 | use rustmath_core::{Ring, NumericConversion};
   |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `LieAlgebraBase`
  --> rustmath-liealgebras/src/verma_module.rs:23:26
   |
23 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                          ^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-liealgebras/src/verma_module.rs:18:21
   |
18 | use rustmath_core::{Ring, Field, MathError, Result};
   |                     ^^^^

warning: unused import: `LieAlgebraBase`
  --> rustmath-liealgebras/src/center_uea.rs:20:26
   |
20 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                          ^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-liealgebras/src/center_uea.rs:15:21
   |
15 | use rustmath_core::{Ring, Field, MathError, Result};
   |                     ^^^^

error[E0433]: failed to resolve: use of undeclared type `GroupMorphism_libgap`
   --> rustmath-groups/src/libgap_morphism.rs:297:9
    |
297 |         GroupMorphism_libgap::trivial(self.domain.clone(), self.codomain.clone())
    |         ^^^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `GroupMorphism_libgap`
    |         help: a struct with a similar name exists: `GroupMorphismLibgap`

error[E0282]: type annotations needed
   --> rustmath-groups/src/libgap_morphism.rs:325:30
    |
325 |             return Some(homs.len());
    |                              ^^^ cannot infer type

warning: unused variable: `size`
   --> rustmath-liealgebras/src/cartan_matrix.rs:293:13
    |
293 |         let size = n + 1;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_size`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `size`
   --> rustmath-liealgebras/src/cartan_matrix.rs:311:13
    |
311 |         let size = n + 1;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: unused variable: `initial_velocity`
   --> rustmath-symbolic/src/pde.rs:257:9
    |
257 |         initial_velocity: &Expr,
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_velocity`

warning: unused variable: `size`
   --> rustmath-liealgebras/src/cartan_matrix.rs:329:13
    |
329 |         let size = n + 1;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: unused import: `std::hash::Hash`
  --> rustmath-groups/src/libgap_group.rs:19:5
   |
19 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-groups/src/artin.rs:38:5
   |
38 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-groups/src/braid.rs:50:5
   |
50 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `Group`
  --> rustmath-groups/src/semimonomial_transformation_group.rs:36:27
   |
36 | use crate::group_traits::{Group, FiniteGroupTrait};
   |                           ^^^^^

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
  --> rustmath-rings/src/function_field_element_polymod.rs:63:16
   |
53 | pub struct FunctionFieldElementPolymod<F: Field> {
   | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
63 | impl<F: Field> FunctionFieldElement_polymod<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
  --> rustmath-rings/src/function_field_element_polymod.rs:81:9
   |
53 | pub struct FunctionFieldElementPolymod<F: Field> {
   | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
81 |         FunctionFieldElement_polymod {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
  --> rustmath-rings/src/function_field_element_polymod.rs:90:9
   |
53 | pub struct FunctionFieldElementPolymod<F: Field> {
   | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
90 |         FunctionFieldElement_polymod {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
  --> rustmath-rings/src/function_field_element_polymod.rs:99:9
   |
53 | pub struct FunctionFieldElementPolymod<F: Field> {
   | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
99 |         FunctionFieldElement_polymod {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:213:30
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
213 | impl<F: Field> PartialEq for FunctionFieldElement_polymod<F> {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:232:23
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
232 | impl<F: Field> Eq for FunctionFieldElement_polymod<F> {}
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:234:33
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
234 | impl<F: Field> fmt::Display for FunctionFieldElement_polymod<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

warning: unused variable: `highest_weight`
   --> rustmath-liealgebras/src/weight_lattice.rs:364:34
    |
364 |     pub fn weyl_dimension(&self, highest_weight: &Weight) -> Integer {
    |                                  ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_highest_weight`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:260:34
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
260 | impl<F: Field> std::ops::Add for FunctionFieldElement_polymod<F> {
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:278:9
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
278 |         FunctionFieldElement_polymod {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:286:34
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
286 | impl<F: Field> std::ops::Sub for FunctionFieldElement_polymod<F> {
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:303:9
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
303 |         FunctionFieldElement_polymod {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

warning: unused variable: `processed`
   --> rustmath-liealgebras/src/dynkin_diagram.rs:107:17
    |
107 |         let mut processed: HashSet<(usize, usize)> = HashSet::new();
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_processed`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:311:34
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
311 | impl<F: Field> std::ops::Mul for FunctionFieldElement_polymod<F> {
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

warning: variable does not need to be mutable
   --> rustmath-liealgebras/src/dynkin_diagram.rs:107:13
    |
107 |         let mut processed: HashSet<(usize, usize)> = HashSet::new();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `c2`
   --> rustmath-symbolic/src/specialfunctions/airy.rs:269:13
    |
269 |         let c2 = 0.258819403792807; // |Ai'(0)|
    |             ^^ help: if this is intentional, prefix it with an underscore: `_c2`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:323:9
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
323 |         FunctionFieldElement_polymod {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0412]: cannot find type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:331:34
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
331 | impl<F: Field> std::ops::Neg for FunctionFieldElement_polymod<F> {
    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_polymod` in this scope
   --> rustmath-rings/src/function_field_element_polymod.rs:341:9
    |
 53 | pub struct FunctionFieldElementPolymod<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldElementPolymod` defined here
...
341 |         FunctionFieldElement_polymod {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementPolymod`

error[E0412]: cannot find type `FunctionFieldElement_rational` in this scope
  --> rustmath-rings/src/function_field_element_rational.rs:52:16
   |
45 | pub struct FunctionFieldElementRational<F: Field> {
   | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
52 | impl<F: Field> FunctionFieldElement_rational<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_rational` in this scope
  --> rustmath-rings/src/function_field_element_rational.rs:68:9
   |
45 | pub struct FunctionFieldElementRational<F: Field> {
   | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
68 |         FunctionFieldElement_rational {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_rational` in this scope
  --> rustmath-rings/src/function_field_element_rational.rs:76:9
   |
45 | pub struct FunctionFieldElementRational<F: Field> {
   | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
76 |         FunctionFieldElement_rational {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_rational` in this scope
  --> rustmath-rings/src/function_field_element_rational.rs:84:9
   |
45 | pub struct FunctionFieldElementRational<F: Field> {
   | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
84 |         FunctionFieldElement_rational {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_rational` in this scope
  --> rustmath-rings/src/function_field_element_rational.rs:92:9
   |
45 | pub struct FunctionFieldElementRational<F: Field> {
   | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
92 |         FunctionFieldElement_rational {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_rational` in this scope
   --> rustmath-rings/src/function_field_element_rational.rs:143:18
    |
 45 | pub struct FunctionFieldElementRational<F: Field> {
    | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
143 |             Some(FunctionFieldElement_rational {
    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldElement_rational` in this scope
   --> rustmath-rings/src/function_field_element_rational.rs:199:9
    |
 45 | pub struct FunctionFieldElementRational<F: Field> {
    | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
199 |         FunctionFieldElement_rational {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0412]: cannot find type `FunctionFieldElement_rational` in this scope
   --> rustmath-rings/src/function_field_element_rational.rs:274:30
    |
 45 | pub struct FunctionFieldElementRational<F: Field> {
    | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
274 | impl<F: Field> PartialEq for FunctionFieldElement_rational<F> {
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0412]: cannot find type `FunctionFieldElement_rational` in this scope
   --> rustmath-rings/src/function_field_element_rational.rs:288:23
    |
 45 | pub struct FunctionFieldElementRational<F: Field> {
    | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
288 | impl<F: Field> Eq for FunctionFieldElement_rational<F> {}
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0412]: cannot find type `FunctionFieldElement_rational` in this scope
   --> rustmath-rings/src/function_field_element_rational.rs:290:33
    |
 45 | pub struct FunctionFieldElementRational<F: Field> {
    | ------------------------------------------------- similarly named struct `FunctionFieldElementRational` defined here
...
290 | impl<F: Field> fmt::Display for FunctionFieldElement_rational<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldElementRational`

error[E0412]: cannot find type `IdealMonoid_nc` in this scope
  --> rustmath-rings/src/noncommutative_ideals.rs:77:6
   |
57 | pub struct IdealMonoidNc {
   | ------------------------ similarly named struct `IdealMonoidNc` defined here
...
77 | impl IdealMonoid_nc {
   |      ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `IdealMonoidNc`

error[E0422]: cannot find struct, variant or union type `IdealMonoid_nc` in this scope
  --> rustmath-rings/src/noncommutative_ideals.rs:98:9
   |
57 | pub struct IdealMonoidNc {
   | ------------------------ similarly named struct `IdealMonoidNc` defined here
...
98 |         IdealMonoid_nc {
   |         ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `IdealMonoidNc`

warning: unused variable: `element`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:296:32
    |
296 |     pub fn discrete_log(&self, element: &T) -> Result<Vec<i64>, String>
    |                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0412]: cannot find type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:146:33
    |
146 |     pub fn unit_ideal(&self) -> Ideal_nc {
    |                                 ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`
...
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here

error[E0412]: cannot find type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:155:33
    |
155 |     pub fn zero_ideal(&self) -> Ideal_nc {
    |                                 ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`
...
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here

error[E0412]: cannot find type `IdealMonoid_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:160:23
    |
 57 | pub struct IdealMonoidNc {
    | ------------------------ similarly named struct `IdealMonoidNc` defined here
...
160 | impl fmt::Display for IdealMonoid_nc {
    |                       ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `IdealMonoidNc`

error[E0412]: cannot find type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:192:6
    |
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here
...
192 | impl Ideal_nc {
    |      ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`

warning: unused variable: `p`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:454:5
    |
454 |     p: usize,
    |     ^ help: if this is intentional, prefix it with an underscore: `_p`

error[E0422]: cannot find struct, variant or union type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:222:9
    |
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here
...
222 |         Ideal_nc {
    |         ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`

error[E0422]: cannot find struct, variant or union type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:242:9
    |
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here
...
242 |         Ideal_nc {
    |         ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`

error[E0422]: cannot find struct, variant or union type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:262:9
    |
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here
...
262 |         Ideal_nc {
    |         ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`

error[E0412]: cannot find type `Ideal_nc` in this scope
   --> rustmath-rings/src/noncommutative_ideals.rs:340:23
    |
179 | pub struct IdealNc {
    | ------------------ similarly named struct `IdealNc` defined here
...
340 | impl fmt::Display for Ideal_nc {
    |                       ^^^^^^^^ help: a struct with a similar name exists: `IdealNc`

error[E0412]: cannot find type `DrinfeldModule_charzero` in this scope
  --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:76:16
   |
67 | pub struct DrinfeldModuleCharzero<F: Field> {
   | ------------------------------------------- similarly named struct `DrinfeldModuleCharzero` defined here
...
76 | impl<F: Field> DrinfeldModule_charzero<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleCharzero`

Some errors have detailed explanations: E0412, E0433, E0599.
For more information about an error, try `rustc --explain E0412`.
error[E0422]: cannot find struct, variant or union type `DrinfeldModule_charzero` in this scope
  --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:98:9
   |
67 | pub struct DrinfeldModuleCharzero<F: Field> {
   | ------------------------------------------- similarly named struct `DrinfeldModuleCharzero` defined here
...
98 |         DrinfeldModule_charzero {
   |         ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleCharzero`

error[E0412]: cannot find type `DrinfeldModule_charzero` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:142:35
    |
 67 | pub struct DrinfeldModuleCharzero<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleCharzero` defined here
...
142 | impl<F: Field> DrinfeldModule for DrinfeldModule_charzero<F> {
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleCharzero`

error[E0412]: cannot find type `DrinfeldModule_charzero` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:156:33
    |
 67 | pub struct DrinfeldModuleCharzero<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleCharzero` defined here
...
156 | impl<F: Field> fmt::Display for DrinfeldModule_charzero<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleCharzero`

error[E0412]: cannot find type `DrinfeldModule_charzero` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:184:18
    |
 67 | pub struct DrinfeldModuleCharzero<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleCharzero` defined here
...
184 |     base_module: DrinfeldModule_charzero<F>,
    |                  ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleCharzero`

error[E0412]: cannot find type `DrinfeldModule_rational` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:189:16
    |
182 | pub struct DrinfeldModuleRational<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleRational` defined here
...
189 | impl<F: Field> DrinfeldModule_rational<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleRational`

error[E0422]: cannot find struct, variant or union type `DrinfeldModule_rational` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:209:9
    |
182 | pub struct DrinfeldModuleRational<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleRational` defined here
...
209 |         DrinfeldModule_rational {
    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleRational`

error[E0422]: cannot find struct, variant or union type `DrinfeldModule_rational` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:226:9
    |
182 | pub struct DrinfeldModuleRational<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleRational` defined here
...
226 |         DrinfeldModule_rational {
    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleRational`

error[E0412]: cannot find type `DrinfeldModule_rational` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:260:35
    |
182 | pub struct DrinfeldModuleRational<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleRational` defined here
...
260 | impl<F: Field> DrinfeldModule for DrinfeldModule_rational<F> {
    |                                   ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleRational`

warning: `rustmath-symbolic` (lib) generated 9 warnings
error: could not compile `rustmath-symbolic` (lib) due to 80 previous errors; 9 warnings emitted
warning: build failed, waiting for other jobs to finish...
error[E0412]: cannot find type `DrinfeldModule_rational` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:274:33
    |
182 | pub struct DrinfeldModuleRational<F: Field> {
    | ------------------------------------------- similarly named struct `DrinfeldModuleRational` defined here
...
274 | impl<F: Field> fmt::Display for DrinfeldModule_rational<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleRational`

error[E0412]: cannot find type `DrinfeldModule_finite` in this scope
  --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:70:25
   |
61 | pub struct DrinfeldModuleFinite<F: Field, R: Ring> {
   | -------------------------------------------------- similarly named struct `DrinfeldModuleFinite` defined here
...
70 | impl<F: Field, R: Ring> DrinfeldModule_finite<F, R> {
   |                         ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleFinite`

error[E0422]: cannot find struct, variant or union type `DrinfeldModule_finite` in this scope
  --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:93:9
   |
61 | pub struct DrinfeldModuleFinite<F: Field, R: Ring> {
   | -------------------------------------------------- similarly named struct `DrinfeldModuleFinite` defined here
...
93 |         DrinfeldModule_finite {
   |         ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleFinite`

error[E0422]: cannot find struct, variant or union type `DrinfeldModule_finite` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:119:9
    |
 61 | pub struct DrinfeldModuleFinite<F: Field, R: Ring> {
    | -------------------------------------------------- similarly named struct `DrinfeldModuleFinite` defined here
...
119 |         DrinfeldModule_finite {
    |         ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleFinite`

error[E0412]: cannot find type `DrinfeldModule_finite` in this scope
   --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:235:42
    |
 61 | pub struct DrinfeldModuleFinite<F: Field, R: Ring> {
    | -------------------------------------------------- similarly named struct `DrinfeldModuleFinite` defined here
...
235 | impl<F: Field, R: Ring> fmt::Display for DrinfeldModule_finite<F, R> {
    |                                          ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `DrinfeldModuleFinite`

error[E0412]: cannot find type `FunctionFieldPlace_polymod` in this scope
  --> rustmath-rings/src/function_field/place_polymod.rs:60:16
   |
45 | pub struct FunctionFieldPlacePolymod<F: Field> {
   | ---------------------------------------------- similarly named struct `FunctionFieldPlacePolymod` defined here
...
60 | impl<F: Field> FunctionFieldPlace_polymod<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlacePolymod`

error[E0422]: cannot find struct, variant or union type `FunctionFieldPlace_polymod` in this scope
   --> rustmath-rings/src/function_field/place_polymod.rs:101:9
    |
 45 | pub struct FunctionFieldPlacePolymod<F: Field> {
    | ---------------------------------------------- similarly named struct `FunctionFieldPlacePolymod` defined here
...
101 |         FunctionFieldPlace_polymod {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlacePolymod`

error[E0412]: cannot find type `FunctionFieldPlace_polymod` in this scope
   --> rustmath-rings/src/function_field/place_polymod.rs:259:33
    |
 45 | pub struct FunctionFieldPlacePolymod<F: Field> {
    | ---------------------------------------------- similarly named struct `FunctionFieldPlacePolymod` defined here
...
259 | impl<F: Field> fmt::Display for FunctionFieldPlace_polymod<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlacePolymod`

error[E0412]: cannot find type `FunctionFieldPlace_rational` in this scope
  --> rustmath-rings/src/function_field/place_rational.rs:68:16
   |
57 | pub struct FunctionFieldPlaceRational<F: Field> {
   | ----------------------------------------------- similarly named struct `FunctionFieldPlaceRational` defined here
...
68 | impl<F: Field> FunctionFieldPlace_rational<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlaceRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldPlace_rational` in this scope
  --> rustmath-rings/src/function_field/place_rational.rs:99:9
   |
57 | pub struct FunctionFieldPlaceRational<F: Field> {
   | ----------------------------------------------- similarly named struct `FunctionFieldPlaceRational` defined here
...
99 |         FunctionFieldPlace_rational {
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlaceRational`

error[E0422]: cannot find struct, variant or union type `FunctionFieldPlace_rational` in this scope
   --> rustmath-rings/src/function_field/place_rational.rs:120:9
    |
 57 | pub struct FunctionFieldPlaceRational<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldPlaceRational` defined here
...
120 |         FunctionFieldPlace_rational {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlaceRational`

error[E0412]: cannot find type `FunctionFieldPlace_rational` in this scope
   --> rustmath-rings/src/function_field/place_rational.rs:306:33
    |
 57 | pub struct FunctionFieldPlaceRational<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldPlaceRational` defined here
...
306 | impl<F: Field> fmt::Display for FunctionFieldPlace_rational<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPlaceRational`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:130:16
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
130 | impl<F: Field> FunctionFieldValuation_base<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0422]: cannot find struct, variant or union type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:142:9
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
142 |         FunctionFieldValuation_base {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:168:33
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
168 | impl<F: Field> fmt::Display for FunctionFieldValuation_base<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:184:11
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
184 |     base: FunctionFieldValuation_base<F>,
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `ClassicalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:191:16
    |
182 | pub struct ClassicalFunctionFieldValuationBase<F: Field> {
    | -------------------------------------------------------- similarly named struct `ClassicalFunctionFieldValuationBase` defined here
...
191 | impl<F: Field> ClassicalFunctionFieldValuation_base<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ClassicalFunctionFieldValuationBase`

error[E0422]: cannot find struct, variant or union type `ClassicalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:205:9
    |
182 | pub struct ClassicalFunctionFieldValuationBase<F: Field> {
    | -------------------------------------------------------- similarly named struct `ClassicalFunctionFieldValuationBase` defined here
...
205 |         ClassicalFunctionFieldValuation_base {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ClassicalFunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:235:28
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
235 |     pub fn base(&self) -> &FunctionFieldValuation_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `ClassicalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:240:54
    |
182 | pub struct ClassicalFunctionFieldValuationBase<F: Field> {
    | -------------------------------------------------------- similarly named struct `ClassicalFunctionFieldValuationBase` defined here
...
240 | impl<F: Field> DiscreteFunctionFieldValuation<F> for ClassicalFunctionFieldValuation_base<F> {
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ClassicalFunctionFieldValuationBase`

error[E0412]: cannot find type `ClassicalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:263:33
    |
182 | pub struct ClassicalFunctionFieldValuationBase<F: Field> {
    | -------------------------------------------------------- similarly named struct `ClassicalFunctionFieldValuationBase` defined here
...
263 | impl<F: Field> fmt::Display for ClassicalFunctionFieldValuation_base<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `ClassicalFunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:283:11
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
283 |     base: FunctionFieldValuation_base<F>,
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:288:16
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
288 | impl<F: Field> RationalFunctionFieldValuation_base<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0422]: cannot find struct, variant or union type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:301:9
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
301 |         RationalFunctionFieldValuation_base {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0422]: cannot find struct, variant or union type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:317:9
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
317 |         RationalFunctionFieldValuation_base {
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:346:28
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
346 |     pub fn base(&self) -> &FunctionFieldValuation_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:351:54
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
351 | impl<F: Field> DiscreteFunctionFieldValuation<F> for RationalFunctionFieldValuation_base<F> {
    |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:398:33
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
398 | impl<F: Field> fmt::Display for RationalFunctionFieldValuation_base<F> {
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:425:11
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
425 |     base: RationalFunctionFieldValuation_base<F>,
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:450:28
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
450 |     pub fn base(&self) -> &RationalFunctionFieldValuation_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:493:11
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
493 |     base: RationalFunctionFieldValuation_base<F>,
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `RationalFunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:517:28
    |
281 | pub struct RationalFunctionFieldValuationBase<F: Field> {
    | ------------------------------------------------------- similarly named struct `RationalFunctionFieldValuationBase` defined here
...
517 |     pub fn base(&self) -> &RationalFunctionFieldValuation_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:561:11
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
561 |     base: FunctionFieldValuation_base<F>,
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionFieldValuation_base` in this scope
   --> rustmath-rings/src/function_field/valuation.rs:599:28
    |
121 | pub struct FunctionFieldValuationBase<F: Field> {
    | ----------------------------------------------- similarly named struct `FunctionFieldValuationBase` defined here
...
599 |     pub fn base(&self) -> &FunctionFieldValuation_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0412]: cannot find type `FunctionField_polymod` in this scope
  --> rustmath-rings/src/function_field/function_field_polymod.rs:93:16
   |
80 | pub struct FunctionFieldPolymod<F: Field> {
   | ----------------------------------------- similarly named struct `FunctionFieldPolymod` defined here
...
93 | impl<F: Field> FunctionField_polymod<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPolymod`

error[E0412]: cannot find type `FunctionField_polymod` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:170:12
    |
 80 | pub struct FunctionFieldPolymod<F: Field> {
    | ----------------------------------------- similarly named struct `FunctionFieldPolymod` defined here
...
170 |     inner: FunctionField_polymod<F>,
    |            ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldPolymod`

error[E0412]: cannot find type `FunctionField_simple` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:173:16
    |
168 | pub struct FunctionFieldSimple<F: Field> {
    | ---------------------------------------- similarly named struct `FunctionFieldSimple` defined here
...
173 | impl<F: Field> FunctionField_simple<F> {
    |                ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0412]: cannot find type `FunctionField_simple` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:221:12
    |
168 | pub struct FunctionFieldSimple<F: Field> {
    | ---------------------------------------- similarly named struct `FunctionFieldSimple` defined here
...
221 |     inner: FunctionField_simple<F>,
    |            ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0412]: cannot find type `FunctionField_char_zero` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:224:16
    |
219 | pub struct FunctionFieldCharZero<F: Field> {
    | ------------------------------------------ similarly named struct `FunctionFieldCharZero` defined here
...
224 | impl<F: Field> FunctionField_char_zero<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldCharZero`

error[E0412]: cannot find type `FunctionField_simple` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:254:12
    |
168 | pub struct FunctionFieldSimple<F: Field> {
    | ---------------------------------------- similarly named struct `FunctionFieldSimple` defined here
...
254 |     inner: FunctionField_simple<F>,
    |            ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0412]: cannot find type `FunctionField_integral` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:257:16
    |
252 | pub struct FunctionFieldIntegral<F: Field> {
    | ------------------------------------------ similarly named struct `FunctionFieldIntegral` defined here
...
257 | impl<F: Field> FunctionField_integral<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIntegral`

error[E0412]: cannot find type `FunctionField_char_zero` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:288:16
    |
219 | pub struct FunctionFieldCharZero<F: Field> {
    | ------------------------------------------ similarly named struct `FunctionFieldCharZero` defined here
...
288 |     char_zero: FunctionField_char_zero<F>,
    |                ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldCharZero`

error[E0412]: cannot find type `FunctionField_integral` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:290:15
    |
252 | pub struct FunctionFieldIntegral<F: Field> {
    | ------------------------------------------ similarly named struct `FunctionFieldIntegral` defined here
...
290 |     integral: FunctionField_integral<F>,
    |               ^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIntegral`

error[E0412]: cannot find type `FunctionField_char_zero_integral` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:293:16
    |
286 | pub struct FunctionFieldCharZeroIntegral<F: Field> {
    | -------------------------------------------------- similarly named struct `FunctionFieldCharZeroIntegral` defined here
...
293 | impl<F: Field> FunctionField_char_zero_integral<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldCharZeroIntegral`

error[E0412]: cannot find type `FunctionField_simple` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:323:12
    |
168 | pub struct FunctionFieldSimple<F: Field> {
    | ---------------------------------------- similarly named struct `FunctionFieldSimple` defined here
...
323 |     inner: FunctionField_simple<F>,
    |            ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0412]: cannot find type `FunctionField_global` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:328:16
    |
321 | pub struct FunctionFieldGlobal<F: Field> {
    | ---------------------------------------- similarly named struct `FunctionFieldGlobal` defined here
...
328 | impl<F: Field> FunctionField_global<F> {
    |                ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldGlobal`

error[E0412]: cannot find type `FunctionField_global` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:377:13
    |
321 | pub struct FunctionFieldGlobal<F: Field> {
    | ---------------------------------------- similarly named struct `FunctionFieldGlobal` defined here
...
377 |     global: FunctionField_global<F>,
    |             ^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldGlobal`

error[E0412]: cannot find type `FunctionField_integral` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:379:15
    |
252 | pub struct FunctionFieldIntegral<F: Field> {
    | ------------------------------------------ similarly named struct `FunctionFieldIntegral` defined here
...
379 |     integral: FunctionField_integral<F>,
    |               ^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIntegral`

error[E0412]: cannot find type `FunctionField_global_integral` in this scope
   --> rustmath-rings/src/function_field/function_field_polymod.rs:382:16
    |
375 | pub struct FunctionFieldGlobalIntegral<F: Field> {
    | ------------------------------------------------ similarly named struct `FunctionFieldGlobalIntegral` defined here
...
382 | impl<F: Field> FunctionField_global_integral<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldGlobalIntegral`

error[E0412]: cannot find type `RationalFunctionField_char_zero` in this scope
   --> rustmath-rings/src/function_field/function_field_rational.rs:171:16
    |
166 | pub struct RationalFunctionFieldCharZero<F: Field> {
    | -------------------------------------------------- similarly named struct `RationalFunctionFieldCharZero` defined here
...
171 | impl<F: Field> RationalFunctionField_char_zero<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldCharZero`

error[E0412]: cannot find type `RationalFunctionField_global` in this scope
   --> rustmath-rings/src/function_field/function_field_rational.rs:238:16
    |
231 | pub struct RationalFunctionFieldGlobal<F: Field> {
    | ------------------------------------------------ similarly named struct `RationalFunctionFieldGlobal` defined here
...
238 | impl<F: Field> RationalFunctionField_global<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `RationalFunctionFieldGlobal`

error[E0412]: cannot find type `FunctionFieldIdeal_polymod` in this scope
  --> rustmath-rings/src/function_field/ideal_polymod.rs:81:16
   |
70 | pub struct FunctionFieldIdealPolymod<F: Field> {
   | ---------------------------------------------- similarly named struct `FunctionFieldIdealPolymod` defined here
...
81 | impl<F: Field> FunctionFieldIdeal_polymod<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealPolymod`

error[E0412]: cannot find type `FunctionFieldIdeal_polymod` in this scope
   --> rustmath-rings/src/function_field/ideal_polymod.rs:229:12
    |
 70 | pub struct FunctionFieldIdealPolymod<F: Field> {
    | ---------------------------------------------- similarly named struct `FunctionFieldIdealPolymod` defined here
...
229 |     inner: FunctionFieldIdeal_polymod<F>,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealPolymod`

warning: variable does not need to be mutable
   --> rustmath-groups/src/free_group.rs:362:13
    |
362 |         let mut word: Vec<(isize, isize)> = self
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0412]: cannot find type `FunctionFieldIdealInfinite_polymod` in this scope
   --> rustmath-rings/src/function_field/ideal_polymod.rs:234:16
    |
227 | pub struct FunctionFieldIdealInfinitePolymod<F: Field> {
    | ------------------------------------------------------ similarly named struct `FunctionFieldIdealInfinitePolymod` defined here
...
234 | impl<F: Field> FunctionFieldIdealInfinite_polymod<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealInfinitePolymod`

error[E0412]: cannot find type `FunctionFieldIdeal_polymod` in this scope
   --> rustmath-rings/src/function_field/ideal_polymod.rs:286:12
    |
 70 | pub struct FunctionFieldIdealPolymod<F: Field> {
    | ---------------------------------------------- similarly named struct `FunctionFieldIdealPolymod` defined here
...
286 |     inner: FunctionFieldIdeal_polymod<F>,
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealPolymod`

error[E0412]: cannot find type `FunctionFieldIdeal_global` in this scope
   --> rustmath-rings/src/function_field/ideal_polymod.rs:291:16
    |
284 | pub struct FunctionFieldIdealGlobal<F: Field> {
    | --------------------------------------------- similarly named struct `FunctionFieldIdealGlobal` defined here
...
291 | impl<F: Field> FunctionFieldIdeal_global<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealGlobal`

error[E0412]: cannot find type `FunctionFieldIdeal_rational` in this scope
  --> rustmath-rings/src/function_field/ideal_rational.rs:84:16
   |
73 | pub struct FunctionFieldIdealRational<F: Field> {
   | ----------------------------------------------- similarly named struct `FunctionFieldIdealRational` defined here
...
84 | impl<F: Field> FunctionFieldIdeal_rational<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealRational`

error[E0412]: cannot find type `FunctionFieldIdealInfinite_rational` in this scope
   --> rustmath-rings/src/function_field/ideal_rational.rs:259:16
    |
254 | pub struct FunctionFieldIdealInfiniteRational<F: Field> {
    | ------------------------------------------------------- similarly named struct `FunctionFieldIdealInfiniteRational` defined here
...
259 | impl<F: Field> FunctionFieldIdealInfinite_rational<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealInfiniteRational`

error[E0412]: cannot find type `FunctionFieldIdealInfinite_rational` in this scope
   --> rustmath-rings/src/function_field/ideal_rational.rs:303:28
    |
254 | pub struct FunctionFieldIdealInfiniteRational<F: Field> {
    | ------------------------------------------------------- similarly named struct `FunctionFieldIdealInfiniteRational` defined here
...
303 | impl<F: Field> Default for FunctionFieldIdealInfinite_rational<F> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldIdealInfiniteRational`

error[E0412]: cannot find type `FunctionFieldMorphism_polymod` in this scope
   --> rustmath-rings/src/function_field/maps.rs:145:16
    |
138 | pub struct FunctionFieldMorphismPolymod<F: Field> {
    | ------------------------------------------------- similarly named struct `FunctionFieldMorphismPolymod` defined here
...
145 | impl<F: Field> FunctionFieldMorphism_polymod<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMorphismPolymod`

error[E0412]: cannot find type `FunctionFieldMorphism_rational` in this scope
   --> rustmath-rings/src/function_field/maps.rs:187:16
    |
180 | pub struct FunctionFieldMorphismRational<F: Field> {
    | -------------------------------------------------- similarly named struct `FunctionFieldMorphismRational` defined here
...
187 | impl<F: Field> FunctionFieldMorphism_rational<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMorphismRational`

error[E0412]: cannot find type `FunctionFieldOrder_base` in this scope
  --> rustmath-rings/src/function_field/order.rs:77:16
   |
66 | pub struct FunctionFieldOrderBase<F: Field> {
   | ------------------------------------------- similarly named struct `FunctionFieldOrderBase` defined here
...
77 | impl<F: Field> FunctionFieldOrder_base<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0412]: cannot find type `FunctionFieldOrder_base` in this scope
   --> rustmath-rings/src/function_field/order.rs:160:12
    |
 66 | pub struct FunctionFieldOrderBase<F: Field> {
    | ------------------------------------------- similarly named struct `FunctionFieldOrderBase` defined here
...
160 |     inner: FunctionFieldOrder_base<F>,
    |            ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0412]: cannot find type `FunctionFieldOrder_base` in this scope
   --> rustmath-rings/src/function_field/order.rs:223:12
    |
 66 | pub struct FunctionFieldOrderBase<F: Field> {
    | ------------------------------------------- similarly named struct `FunctionFieldOrderBase` defined here
...
223 |     inner: FunctionFieldOrder_base<F>,
    |            ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0412]: cannot find type `FunctionFieldOrder_base` in this scope
   --> rustmath-rings/src/function_field/order.rs:268:12
    |
 66 | pub struct FunctionFieldOrderBase<F: Field> {
    | ------------------------------------------- similarly named struct `FunctionFieldOrderBase` defined here
...
268 |     inner: FunctionFieldOrder_base<F>,
    |            ^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0412]: cannot find type `FunctionFieldOrder_basis` in this scope
  --> rustmath-rings/src/function_field/order_basis.rs:96:16
   |
85 | pub struct FunctionFieldOrderBasis<F: Field> {
   | -------------------------------------------- similarly named struct `FunctionFieldOrderBasis` defined here
...
96 | impl<F: Field> FunctionFieldOrder_basis<F> {
   |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldOrderBasis`

error[E0412]: cannot find type `FunctionFieldOrderInfinite_basis` in this scope
   --> rustmath-rings/src/function_field/order_basis.rs:244:16
    |
233 | pub struct FunctionFieldOrderInfiniteBasis<F: Field> {
    | ---------------------------------------------------- similarly named struct `FunctionFieldOrderInfiniteBasis` defined here
...
244 | impl<F: Field> FunctionFieldOrderInfinite_basis<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldOrderInfiniteBasis`

error[E0412]: cannot find type `FunctionFieldMaximalOrder_polymod` in this scope
   --> rustmath-rings/src/function_field/order_polymod.rs:109:16
    |
 94 | pub struct FunctionFieldMaximalOrderPolymod<F: Field> {
    | ----------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderPolymod` defined here
...
109 | impl<F: Field> FunctionFieldMaximalOrder_polymod<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderPolymod`

error[E0412]: cannot find type `FunctionFieldMaximalOrder_polymod` in this scope
   --> rustmath-rings/src/function_field/order_polymod.rs:276:14
    |
 94 | pub struct FunctionFieldMaximalOrderPolymod<F: Field> {
    | ----------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderPolymod` defined here
...
276 |     polymod: FunctionFieldMaximalOrder_polymod<F>,
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderPolymod`

error[E0412]: cannot find type `FunctionFieldMaximalOrder_global` in this scope
   --> rustmath-rings/src/function_field/order_polymod.rs:283:16
    |
274 | pub struct FunctionFieldMaximalOrderGlobal<F: Field> {
    | ---------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderGlobal` defined here
...
283 | impl<F: Field> FunctionFieldMaximalOrder_global<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderGlobal`

error[E0412]: cannot find type `FunctionFieldMaximalOrder_polymod` in this scope
   --> rustmath-rings/src/function_field/order_polymod.rs:362:37
    |
 94 | pub struct FunctionFieldMaximalOrderPolymod<F: Field> {
    | ----------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderPolymod` defined here
...
362 |     pub fn polymod_order(&self) -> &FunctionFieldMaximalOrder_polymod<F> {
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderPolymod`

error[E0412]: cannot find type `FunctionFieldMaximalOrder_polymod` in this scope
   --> rustmath-rings/src/function_field/order_polymod.rs:367:49
    |
 94 | pub struct FunctionFieldMaximalOrderPolymod<F: Field> {
    | ----------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderPolymod` defined here
...
367 |     pub fn polymod_order_mut(&mut self) -> &mut FunctionFieldMaximalOrder_polymod<F> {
    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderPolymod`

error[E0412]: cannot find type `FunctionFieldMaximalOrderInfinite_polymod` in this scope
   --> rustmath-rings/src/function_field/order_polymod.rs:414:16
    |
401 | pub struct FunctionFieldMaximalOrderInfinitePolymod<F: Field> {
    | ------------------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderInfinitePolymod` defined here
...
414 | impl<F: Field> FunctionFieldMaximalOrderInfinite_polymod<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderInfinitePolymod`

error[E0412]: cannot find type `FunctionFieldMaximalOrder_rational` in this scope
   --> rustmath-rings/src/function_field/order_rational.rs:102:16
    |
 91 | pub struct FunctionFieldMaximalOrderRational<F: Field> {
    | ------------------------------------------------------ similarly named struct `FunctionFieldMaximalOrderRational` defined here
...
102 | impl<F: Field> FunctionFieldMaximalOrder_rational<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderRational`

error[E0412]: cannot find type `FunctionFieldMaximalOrderInfinite_rational` in this scope
   --> rustmath-rings/src/function_field/order_rational.rs:322:16
    |
311 | pub struct FunctionFieldMaximalOrderInfiniteRational<F: Field> {
    | -------------------------------------------------------------- similarly named struct `FunctionFieldMaximalOrderInfiniteRational` defined here
...
322 | impl<F: Field> FunctionFieldMaximalOrderInfinite_rational<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `FunctionFieldMaximalOrderInfiniteRational`

error[E0412]: cannot find type `JacobianPoint_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:112:16
    |
101 | pub struct JacobianPointBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianPointBase` defined here
...
112 | impl<F: Field> JacobianPoint_base<F> {
    |                ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointBase`

error[E0412]: cannot find type `JacobianGroup_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:214:16
    |
203 | pub struct JacobianGroupBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianGroupBase` defined here
...
214 | impl<F: Field> JacobianGroup_base<F> {
    |                ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupBase`

warning: variable `pk` is assigned to, but never used
   --> rustmath-groups/src/generic.rs:290:17
    |
290 |         let mut pk = 1usize;
    |                 ^^
    |
    = note: consider using `_pk` instead

error[E0412]: cannot find type `JacobianPoint_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:261:27
    |
101 | pub struct JacobianPointBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianPointBase` defined here
...
261 |     pub fn zero(&self) -> JacobianPoint_base<F> {
    |                           ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointBase`

error[E0412]: cannot find type `JacobianPoint_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:266:45
    |
101 | pub struct JacobianPointBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianPointBase` defined here
...
266 |     pub fn point(&self, divisor: String) -> JacobianPoint_base<F> {
    |                                             ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointBase`

warning: unused variable: `target_order`
   --> rustmath-groups/src/generic.rs:446:9
    |
446 |     let target_order = lcm(order_a, order_b);
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_target_order`

error[E0412]: cannot find type `JacobianPoint_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:271:53
    |
101 | pub struct JacobianPointBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianPointBase` defined here
...
271 |     pub fn abel_jacobi(&self, curve_point: &str) -> JacobianPoint_base<F> {
    |                                                     ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointBase`

error[E0412]: cannot find type `JacobianGroup_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:317:12
    |
203 | pub struct JacobianGroupBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianGroupBase` defined here
...
317 |     group: JacobianGroup_base<F>,
    |            ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupBase`

error[E0412]: cannot find type `Jacobian_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:320:16
    |
309 | pub struct JacobianBase<F: Field> {
    | --------------------------------- similarly named struct `JacobianBase` defined here
...
320 | impl<F: Field> Jacobian_base<F> {
    |                ^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianBase`

error[E0412]: cannot find type `JacobianGroup_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:356:29
    |
203 | pub struct JacobianGroupBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianGroupBase` defined here
...
356 |     pub fn group(&self) -> &JacobianGroup_base<F> {
    |                             ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupBase`

error[E0412]: cannot find type `JacobianPoint_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:402:11
    |
101 | pub struct JacobianPointBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianPointBase` defined here
...
402 |     base: JacobianPoint_base<F>,
    |           ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointBase`

error[E0412]: cannot find type `JacobianPoint_finite_field_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:407:16
    |
400 | pub struct JacobianPointFiniteFieldBase<F: Field> {
    | ------------------------------------------------- similarly named struct `JacobianPointFiniteFieldBase` defined here
...
407 | impl<F: Field> JacobianPoint_finite_field_base<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointFiniteFieldBase`

error[E0412]: cannot find type `JacobianPoint_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:422:28
    |
101 | pub struct JacobianPointBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianPointBase` defined here
...
422 |     pub fn base(&self) -> &JacobianPoint_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointBase`

error[E0412]: cannot find type `JacobianGroup_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:478:11
    |
203 | pub struct JacobianGroupBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianGroupBase` defined here
...
478 |     base: JacobianGroup_base<F>,
    |           ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupBase`

error[E0412]: cannot find type `JacobianGroup_finite_field_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:485:16
    |
476 | pub struct JacobianGroupFiniteFieldBase<F: Field> {
    | ------------------------------------------------- similarly named struct `JacobianGroupFiniteFieldBase` defined here
...
485 | impl<F: Field> JacobianGroup_finite_field_base<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupFiniteFieldBase`

error[E0412]: cannot find type `JacobianGroup_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:506:28
    |
203 | pub struct JacobianGroupBase<F: Field> {
    | -------------------------------------- similarly named struct `JacobianGroupBase` defined here
...
506 |     pub fn base(&self) -> &JacobianGroup_base<F> {
    |                            ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupBase`

error[E0412]: cannot find type `Jacobian_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:567:57
    |
309 | pub struct JacobianBase<F: Field> {
    | --------------------------------- similarly named struct `JacobianBase` defined here
...
567 |     pub fn apply(&self, curve: String, genus: usize) -> Jacobian_base<F> {
    |                                                         ^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianBase`

warning: variable does not need to be mutable
   --> rustmath-groups/src/indexed_free_group.rs:226:13
    |
226 |         let mut inv_word: Vec<(I, i32)> = self
    |             ----^^^^^^^^
    |             |
    |             help: remove this `mut`

error[E0412]: cannot find type `JacobianGroup_finite_field_base` in this scope
   --> rustmath-rings/src/function_field/jacobian_base.rs:577:10
    |
476 | pub struct JacobianGroupFiniteFieldBase<F: Field> {
    | ------------------------------------------------- similarly named struct `JacobianGroupFiniteFieldBase` defined here
...
577 |     ) -> JacobianGroup_finite_field_base<F> {
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupFiniteFieldBase`

error[E0412]: cannot find type `Jacobian_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_hess.rs:349:16
    |
342 | pub struct JacobianFiniteField<F: Field> {
    | ---------------------------------------- similarly named struct `JacobianFiniteField` defined here
...
349 | impl<F: Field> Jacobian_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianFiniteField`

error[E0412]: cannot find type `JacobianPoint_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_hess.rs:408:16
    |
401 | pub struct JacobianPointFiniteField<F: Field> {
    | --------------------------------------------- similarly named struct `JacobianPointFiniteField` defined here
...
408 | impl<F: Field> JacobianPoint_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointFiniteField`

error[E0412]: cannot find type `JacobianGroup_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_hess.rs:466:16
    |
459 | pub struct JacobianGroupFiniteField<F: Field> {
    | --------------------------------------------- similarly named struct `JacobianGroupFiniteField` defined here
...
466 | impl<F: Field> JacobianGroup_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupFiniteField`

error[E0412]: cannot find type `JacobianGroupEmbedding_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_hess.rs:518:16
    |
511 | pub struct JacobianGroupEmbeddingFiniteField<F: Field> {
    | ------------------------------------------------------ similarly named struct `JacobianGroupEmbeddingFiniteField` defined here
...
518 | impl<F: Field> JacobianGroupEmbedding_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupEmbeddingFiniteField`

error[E0412]: cannot find type `JacobianPoint_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_hess.rs:538:41
    |
401 | pub struct JacobianPointFiniteField<F: Field> {
    | --------------------------------------------- similarly named struct `JacobianPointFiniteField` defined here
...
538 |     pub fn apply(&self, point: &str) -> JacobianPoint_finite_field<F> {
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointFiniteField`

error[E0412]: cannot find type `Jacobian_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:406:16
    |
399 | pub struct JacobianFiniteField<F: Field> {
    | ---------------------------------------- similarly named struct `JacobianFiniteField` defined here
...
406 | impl<F: Field> Jacobian_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianFiniteField`

error[E0412]: cannot find type `JacobianPoint_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:467:16
    |
460 | pub struct JacobianPointFiniteField<F: Field> {
    | --------------------------------------------- similarly named struct `JacobianPointFiniteField` defined here
...
467 | impl<F: Field> JacobianPoint_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointFiniteField`

error[E0412]: cannot find type `JacobianGroup_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:526:16
    |
519 | pub struct JacobianGroupFiniteField<F: Field> {
    | --------------------------------------------- similarly named struct `JacobianGroupFiniteField` defined here
...
526 | impl<F: Field> JacobianGroup_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupFiniteField`

error[E0412]: cannot find type `JacobianGroupEmbedding_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:585:16
    |
578 | pub struct JacobianGroupEmbeddingFiniteField<F: Field> {
    | ------------------------------------------------------ similarly named struct `JacobianGroupEmbeddingFiniteField` defined here
...
585 | impl<F: Field> JacobianGroupEmbedding_finite_field<F> {
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianGroupEmbeddingFiniteField`

error[E0412]: cannot find type `JacobianPoint_finite_field` in this scope
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:605:41
    |
460 | pub struct JacobianPointFiniteField<F: Field> {
    | --------------------------------------------- similarly named struct `JacobianPointFiniteField` defined here
...
605 |     pub fn apply(&self, point: &str) -> JacobianPoint_finite_field<F> {
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `JacobianPointFiniteField`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:111:16
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
111 | impl<F: Field> KhuriMakdisi_base<F> {
    |                ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:247:11
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
247 |     base: KhuriMakdisi_base<F>,
    |           ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0412]: cannot find type `KhuriMakdisi_small` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:250:16
    |
245 | pub struct KhuriMakdisiSmall<F: Field> {
    | -------------------------------------- similarly named struct `KhuriMakdisiSmall` defined here
...
250 | impl<F: Field> KhuriMakdisi_small<F> {
    |                ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiSmall`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:265:28
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
265 |     pub fn base(&self) -> &KhuriMakdisi_base<F> {
    |                            ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:331:11
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
331 |     base: KhuriMakdisi_base<F>,
    |           ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0412]: cannot find type `KhuriMakdisi_medium` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:336:16
    |
329 | pub struct KhuriMakdisiMedium<F: Field> {
    | --------------------------------------- similarly named struct `KhuriMakdisiMedium` defined here
...
336 | impl<F: Field> KhuriMakdisi_medium<F> {
    |                ^^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiMedium`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:361:28
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
361 |     pub fn base(&self) -> &KhuriMakdisi_base<F> {
    |                            ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:443:11
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
443 |     base: KhuriMakdisi_base<F>,
    |           ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0412]: cannot find type `KhuriMakdisi_large` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:448:16
    |
441 | pub struct KhuriMakdisiLarge<F: Field> {
    | -------------------------------------- similarly named struct `KhuriMakdisiLarge` defined here
...
448 | impl<F: Field> KhuriMakdisi_large<F> {
    |                ^^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiLarge`

error[E0412]: cannot find type `KhuriMakdisi_base` in this scope
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:474:28
    |
 98 | pub struct KhuriMakdisiBase<F: Field> {
    | ------------------------------------- similarly named struct `KhuriMakdisiBase` defined here
...
474 |     pub fn base(&self) -> &KhuriMakdisi_base<F> {
    |                            ^^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0573]: expected type, found function `RealLazyField`
   --> rustmath-rings/src/real_lazy.rs:553:6
    |
553 | impl RealLazyField {
    |      ^^^^^^^^^^^^^ not a type

error[E0574]: expected struct, variant or union type, found function `RealLazyField`
   --> rustmath-rings/src/real_lazy.rs:556:9
    |
556 |         RealLazyField {}
    |         ^^^^^^^^^^^^^ not a struct, variant or union type

error[E0573]: expected type, found function `RealLazyField`
   --> rustmath-rings/src/real_lazy.rs:605:18
    |
605 | impl Default for RealLazyField {
    |                  ^^^^^^^^^^^^^ not a type

error[E0573]: expected type, found function `ComplexLazyField`
   --> rustmath-rings/src/real_lazy.rs:624:6
    |
620 | pub struct complex_lazy_field {
    | ----------------------------- similarly named struct `complex_lazy_field` defined here
...
624 | impl ComplexLazyField {
    |      ^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `complex_lazy_field`

error[E0574]: expected struct, variant or union type, found function `ComplexLazyField`
   --> rustmath-rings/src/real_lazy.rs:627:9
    |
620 | pub struct complex_lazy_field {
    | ----------------------------- similarly named struct `complex_lazy_field` defined here
...
627 |         ComplexLazyField {}
    |         ^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `complex_lazy_field`

error[E0573]: expected type, found function `ComplexLazyField`
   --> rustmath-rings/src/real_lazy.rs:671:18
    |
620 | pub struct complex_lazy_field {
    | ----------------------------- similarly named struct `complex_lazy_field` defined here
...
671 | impl Default for ComplexLazyField {
    |                  ^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `complex_lazy_field`

error[E0573]: expected type, found function `RealLazyField`
   --> rustmath-rings/src/real_lazy.rs:682:27
    |
682 | pub fn RealLazyField() -> RealLazyField {
    |                           ^^^^^^^^^^^^^ not a type

error[E0573]: expected type, found function `ComplexLazyField`
   --> rustmath-rings/src/real_lazy.rs:687:30
    |
620 | pub struct complex_lazy_field {
    | ----------------------------- similarly named struct `complex_lazy_field` defined here
...
687 | pub fn ComplexLazyField() -> ComplexLazyField {
    |                              ^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `complex_lazy_field`

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/algebraic_closure.rs:25:21
   |
25 | use rustmath_core::{CommutativeRing, Field, IntegralDomain};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `CommutativeRing`
  --> rustmath-rings/src/asymptotic.rs:44:27
   |
44 | use rustmath_core::{Ring, CommutativeRing};
   |                           ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-rings/src/asymptotic.rs:45:5
   |
45 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/asymptotic.rs:47:5
   |
47 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/category_methods.rs:23:27
   |
23 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain, EuclideanDomain, MathError, Result};
   |                           ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `std::fmt::Debug`
  --> rustmath-rings/src/category_methods.rs:24:5
   |
24 | use std::fmt::Debug;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/cfinite_sequence.rs:42:5
   |
42 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `IntegralDomain` and `Ring`
  --> rustmath-rings/src/constructor.rs:33:21
   |
33 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                     ^^^^         ^^^^^^^^^^^^^^

warning: unused import: `EuclideanDomain`
  --> rustmath-rings/src/derivation.rs:11:27
   |
11 | use rustmath_core::{Ring, EuclideanDomain};
   |                           ^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-rings/src/derivation.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-rings/src/differential.rs:43:21
   |
43 | use std::ops::{Add, Mul, Neg, Div};
   |                     ^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field.rs:12:43
   |
12 | use rustmath_core::{Ring, IntegralDomain, Field};
   |                                           ^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/fraction_field.rs:15:17
   |
15 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `EuclideanDomain`
  --> rustmath-rings/src/fraction_field_element.rs:33:50
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field, EuclideanDomain};
   |                                                  ^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/fraction_field_element.rs:35:5
   |
35 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/fraction_field_element.rs:36:17
   |
36 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `IntegralDomain`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:34
   |
37 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                                  ^^^^^^^^^^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/fraction_field_fpt.rs:40:17
   |
40 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `IntegralDomain`
  --> rustmath-rings/src/function_field_element.rs:31:34
   |
31 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                                  ^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/function_field_element_rational.rs:29:5
   |
29 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/growth_group.rs:46:5
   |
46 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Signed`
  --> rustmath-rings/src/growth_group.rs:48:29
   |
48 | use num_traits::{Zero, One, Signed};
   |                             ^^^^^^

warning: unused imports: `ExponentialGrowthElement`, `ExponentialGrowthGroup`, `MonomialGrowthElement`, and `MonomialGrowthGroup`
  --> rustmath-rings/src/growth_group_cartesian.rs:35:33
   |
35 |     GrowthElement, GrowthGroup, MonomialGrowthElement, MonomialGrowthGroup,
   |                                 ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^
36 |     ExponentialGrowthElement, ExponentialGrowthGroup, Variable, GrowthGroupFactor,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/growth_group_cartesian.rs:38:5
   |
38 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `num_rational::BigRational`
  --> rustmath-rings/src/growth_group_cartesian.rs:39:5
   |
39 | use num_rational::BigRational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `One` and `Zero`
  --> rustmath-rings/src/growth_group_cartesian.rs:40:18
   |
40 | use num_traits::{Zero, One};
   |                  ^^^^  ^^^

warning: unused import: `std::sync::Arc`
  --> rustmath-rings/src/growth_group_cartesian.rs:43:5
   |
43 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused imports: `MorphismError` and `RingHomomorphismFromQuotient`
  --> rustmath-rings/src/homset.rs:40:41
   |
40 | use crate::morphism::{RingHomomorphism, RingHomomorphismFromQuotient, MorphismError};
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `CommutativeRing`
  --> rustmath-rings/src/homset.rs:41:27
   |
41 | use rustmath_core::{Ring, CommutativeRing};
   |                           ^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `Ring`
  --> rustmath-rings/src/infinity.rs:46:21
   |
46 | use rustmath_core::{Ring, Field, CommutativeRing};
   |                     ^^^^  ^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `Add`, `Div`, `Mul`, and `Sub`
  --> rustmath-rings/src/infinity.rs:49:16
   |
49 | use std::ops::{Add, Sub, Mul, Div, Neg};
   |                ^^^  ^^^  ^^^  ^^^

warning: unused import: `std::collections::HashSet`
  --> rustmath-rings/src/monomials.rs:38:5
   |
38 | use std::collections::HashSet;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/padics/extension.rs:59:38
   |
59 | use rustmath_core::{CommutativeRing, Field, MathError, Result, Ring};
   |                                      ^^^^^

warning: unused import: `Div`
  --> rustmath-rings/src/padics/extension.rs:64:21
   |
64 | use std::ops::{Add, Div, Mul, Neg, Sub};
   |                     ^^^

warning: unused variable: `i`
   --> rustmath-liealgebras/src/affine_lie_algebra.rs:565:20
    |
565 |     fn affine_root(i: usize) -> Self
    |                    ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> rustmath-liealgebras/src/affine_lie_algebra.rs:578:22
    |
578 |     fn affine_coroot(i: usize) -> Self
    |                      ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/padics/capped_relative.rs:44:21
   |
44 | use rustmath_core::{CommutativeRing, Field, IntegralDomain, MathError, Result, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^

warning: unused imports: `Field` and `IntegralDomain`
  --> rustmath-rings/src/quotient_ring.rs:45:44
   |
45 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain};
   |                                            ^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Field`
  --> rustmath-rings/src/real_interval_absolute.rs:42:5
   |
42 | use rustmath_core::Field;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/real_mpfi.rs:51:5
   |
51 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing` and `IntegralDomain`
  --> rustmath-rings/src/residue_field.rs:24:34
   |
24 | use rustmath_core::{Ring, Field, IntegralDomain, CommutativeRing};
   |                                  ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/residue_field.rs:27:17
   |
27 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/residue_field.rs:364:13
    |
364 |         use rustmath_integers::Integer;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/residue_field.rs:445:13
    |
445 |         use rustmath_integers::Integer;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/residue_field.rs:543:13
    |
543 |         use rustmath_integers::Integer;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::morphism::RingHomomorphism`
  --> rustmath-rings/src/ring_extension.rs:38:5
   |
38 | use crate::morphism::RingHomomorphism;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing` and `Field`
  --> rustmath-rings/src/ring_extension.rs:39:27
   |
39 | use rustmath_core::{Ring, CommutativeRing, Field};
   |                           ^^^^^^^^^^^^^^^  ^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-rings/src/ring_extension.rs:40:5
   |
40 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::fmt`
  --> rustmath-rings/src/ring_extension_morphism.rs:14:5
   |
14 | use std::fmt;
   |     ^^^^^^^^

warning: unused imports: `GrowthGroup`, `MonomialGrowthElement`, and `Variable`
  --> rustmath-rings/src/term_monoid.rs:38:42
   |
38 | use crate::growth_group::{GrowthElement, GrowthGroup, MonomialGrowthElement, Variable};
   |                                          ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/term_monoid.rs:39:5
   |
39 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Signed`
  --> rustmath-rings/src/term_monoid.rs:41:29
   |
41 | use num_traits::{Zero, One, Signed};
   |                             ^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/universal_cyclotomic_field.rs:41:21
   |
41 | use rustmath_core::{Field, Ring};
   |                     ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:34:21
   |
34 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-rings/src/function_field/drinfeld_modules/drinfeld_module.rs:42:5
   |
42 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:39:5
   |
39 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/extensions.rs:38:21
   |
38 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/ideal.rs:42:21
   |
42 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/function_field_polymod.rs:53:28
   |
53 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused imports: `EuclideanDomain` and `Ring`
  --> rustmath-rings/src/function_field/hermite_form_polynomial.rs:43:21
   |
43 | use rustmath_core::{EuclideanDomain, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^

warning: unused import: `std::fmt::Debug`
  --> rustmath-rings/src/function_field/hermite_form_polynomial.rs:44:5
   |
44 | use std::fmt::Debug;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:70:5
   |
70 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-rings/src/function_field/picard_group.rs:58:5
   |
58 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Field`
  --> rustmath-rings/src/function_field/theta_functions.rs:73:5
   |
73 | use rustmath_core::Field;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing` and `Field`
  --> rustmath-rings/src/invariants/invariant_theory.rs:25:27
   |
25 | use rustmath_core::{Ring, Field, CommutativeRing};
   |                           ^^^^^  ^^^^^^^^^^^^^^^

warning: unused import: `std::fmt`
  --> rustmath-rings/src/invariants/invariant_theory.rs:26:5
   |
26 | use std::fmt;
   |     ^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/invariants/invariant_theory.rs:27:5
   |
27 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/invariants/reconstruction.rs:27:27
   |
27 | use rustmath_core::{Ring, Field};
   |                           ^^^^^

warning: unused import: `Mul`
  --> rustmath-rings/src/laurent_series_ring_element.rs:39:26
   |
39 | use std::ops::{Add, Sub, Mul};
   |                          ^^^

warning: unused import: `std::fmt`
  --> rustmath-rings/src/lazy_series.rs:30:5
   |
30 | use std::fmt;
   |     ^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/lazy_series.rs:31:5
   |
31 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-rings/src/multi_power_series_ring_element.rs:29:26
   |
29 | use std::ops::{Add, Sub, Mul};
   |                          ^^^

warning: unused import: `Div`
  --> rustmath-rings/src/power_series_poly.rs:34:21
   |
34 | use std::ops::{Add, Div, Mul, Neg, Sub};
   |                     ^^^

warning: unused import: `std::cmp::Ordering`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:35:5
   |
35 | use std::cmp::Ordering;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Div`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:37:21
   |
37 | use std::ops::{Add, Div, Mul, Neg, Sub};
   |                     ^^^

warning: unused import: `Field`
  --> rustmath-rings/src/real_arb.rs:41:21
   |
41 | use rustmath_core::{Field, Ring};
   |                     ^^^^^

warning: type `real_lazy_field` should have an upper camel case name
   --> rustmath-rings/src/real_lazy.rs:548:12
    |
548 | pub struct real_lazy_field {
    |            ^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RealLazyField`
    |
    = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: type `complex_lazy_field` should have an upper camel case name
   --> rustmath-rings/src/real_lazy.rs:620:12
    |
620 | pub struct complex_lazy_field {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `ComplexLazyField`

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-rings/src/sum_of_squares.rs:29:5
   |
29 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `DiscreteValuation`
 --> rustmath-rings/src/valuation/scaled_valuation.rs:5:49
  |
5 | use super::valuation::{DiscretePseudoValuation, DiscreteValuation, ValuationValue};
  |                                                 ^^^^^^^^^^^^^^^^^

warning: unused import: `ValuationValue`
 --> rustmath-rings/src/valuation/gauss_valuation.rs:5:49
  |
5 | use super::valuation::{DiscretePseudoValuation, ValuationValue};
  |                                                 ^^^^^^^^^^^^^^

warning: unused import: `DiscreteValuation`
 --> rustmath-rings/src/valuation/mapped_valuation.rs:5:49
  |
5 | use super::valuation::{DiscretePseudoValuation, DiscreteValuation, ValuationValue};
  |                                                 ^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/qqbar.rs:43:21
   |
43 | use rustmath_core::{CommutativeRing, Field, IntegralDomain, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/number_field/mod.rs:147:5
    |
147 | use rustmath_integers::Integer;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `gen_index`
   --> rustmath-liealgebras/src/bgg_dual_module.rs:442:9
    |
442 |         gen_index: usize,
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_gen_index`

warning: unused variable: `degree`
   --> rustmath-liealgebras/src/bgg_resolution.rs:137:36
    |
137 |     pub fn module_at_degree(&self, degree: usize) -> Vec<R>
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `degree`
   --> rustmath-liealgebras/src/bgg_resolution.rs:149:31
    |
149 |     pub fn is_exact_at(&self, degree: usize) -> bool {
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `cartan_type`
   --> rustmath-liealgebras/src/bgg_resolution.rs:255:5
    |
255 |     cartan_type: &CartanType,
    |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cartan_type`

warning: unused variable: `highest_weight`
   --> rustmath-liealgebras/src/bgg_resolution.rs:256:5
    |
256 |     highest_weight: &[R],
    |     ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_highest_weight`

warning: unused variable: `i`
   --> rustmath-liealgebras/src/bgg_resolution.rs:292:10
    |
292 |     for &i in weyl_element {
    |          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> rustmath-liealgebras/src/bgg_resolution.rs:285:9
    |
285 |     let mut shifted: Vec<R> = weight
    |         ----^^^^^^^
    |         |
    |         help: remove this `mut`

warning: variable does not need to be mutable
   --> rustmath-groups/src/nilpotent_lie_group.rs:196:17
    |
196 |             let mut coords = vec![0.0; self.dim];
    |                 ----^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `pbw_element`
   --> rustmath-liealgebras/src/center_uea.rs:345:27
    |
345 |     pub fn retract(&self, pbw_element: &PBWElement<F>) -> Option<CenterElement<F>> {
    |                           ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pbw_element`

warning: unused variable: `pbw_element`
   --> rustmath-liealgebras/src/center_uea.rs:352:30
    |
352 |     pub fn is_central(&self, pbw_element: &PBWElement<F>) -> bool {
    |                              ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pbw_element`

Some errors have detailed explanations: E0038, E0061, E0107, E0277, E0282, E0308, E0369, E0412, E0422...
For more information about an error, try `rustc --explain E0038`.
warning: `rustmath-groups` (lib) generated 29 warnings
error: could not compile `rustmath-groups` (lib) due to 85 previous errors; 29 warnings emitted
For more information about this error, try `rustc --explain E0308`.
warning: `rustmath-liealgebras` (lib) generated 54 warnings
error: could not compile `rustmath-liealgebras` (lib) due to 2 previous errors; 54 warnings emitted
error[E0308]: mismatched types
   --> rustmath-rings/src/function_field_element_polymod.rs:114:36
    |
 63 | impl<F: Field> FunctionFieldElement_polymod<F> {
    |      - expected this type parameter
...
114 |         self.coefficients.len() == 1 && self.coefficients[0] == "1"
    |                                    ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field_element_polymod.rs:114:65
    |
 63 | impl<F: Field> FunctionFieldElement_polymod<F> {
    |      - expected this type parameter
...
114 |         self.coefficients.len() == 1 && self.coefficients[0] == "1"
    |                                                                 ^^^ expected type parameter `F`, found `&str`
    |
    = note: expected type parameter `F`
                    found reference `&'static str`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field_element_polymod.rs:173:36
    |
 63 | impl<F: Field> FunctionFieldElement_polymod<F> {
    |      - expected this type parameter
...
173 |         self.coefficients.len() == 1
    |                                    ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field_element_rational.rs:106:33
    |
 52 | impl<F: Field> FunctionFieldElement_rational<F> {
    |      - expected this type parameter
...
106 |         self.numerator.len() == 1
    |                                 ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field_element_rational.rs:107:42
    |
 52 | impl<F: Field> FunctionFieldElement_rational<F> {
    |      - expected this type parameter
...
107 |             && self.denominator.len() == 1
    |                                          ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field_element_rational.rs:263:35
    |
 52 | impl<F: Field> FunctionFieldElement_rational<F> {
    |      - expected this type parameter
...
263 |         self.denominator.len() == 1 && !self.denominator[0].is_zero()
    |                                   ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `Ideal_nc`
   --> rustmath-rings/src/noncommutative_ideals.rs:147:9
    |
147 |         Ideal_nc::unit(self.ring_name.clone(), self.ideal_type.clone())
    |         ^^^^^^^^
    |         |
    |         use of undeclared type `Ideal_nc`
    |         help: a struct with a similar name exists: `IdealNc`

error[E0433]: failed to resolve: use of undeclared type `Ideal_nc`
   --> rustmath-rings/src/noncommutative_ideals.rs:156:9
    |
156 |         Ideal_nc::zero(self.ring_name.clone(), self.ideal_type.clone())
    |         ^^^^^^^^
    |         |
    |         use of undeclared type `Ideal_nc`
    |         help: a struct with a similar name exists: `IdealNc`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:152:21
    |
142 | impl<F: Field> DrinfeldModule for DrinfeldModule_charzero<F> {
    |      - expected this type parameter
...
152 |         self.rank > 0 && !self.base_field.is_empty()
    |                     ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `DrinfeldModule_charzero`
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:210:26
    |
210 |             base_module: DrinfeldModule_charzero::new(base_field, 1),
    |                          ^^^^^^^^^^^^^^^^^^^^^^^
    |                          |
    |                          use of undeclared type `DrinfeldModule_charzero`
    |                          help: a struct with a similar name exists: `DrinfeldModuleCharzero`

error[E0433]: failed to resolve: use of undeclared type `DrinfeldModule_charzero`
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:227:26
    |
227 |             base_module: DrinfeldModule_charzero::new(base_field, rank),
    |                          ^^^^^^^^^^^^^^^^^^^^^^^
    |                          |
    |                          use of undeclared type `DrinfeldModule_charzero`
    |                          help: a struct with a similar name exists: `DrinfeldModuleCharzero`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:256:36
    |
189 | impl<F: Field> DrinfeldModule_rational<F> {
    |      - expected this type parameter
...
256 |         self.base_module.rank() == 1
    |                                    ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_polymod.rs:162:35
    |
 60 | impl<F: Field> FunctionFieldPlace_polymod<F> {
    |      - expected this type parameter
...
162 |         self.ramification_index > 1
    |                                   ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_polymod.rs:171:36
    |
 60 | impl<F: Field> FunctionFieldPlace_polymod<F> {
    |      - expected this type parameter
...
171 |         self.ramification_index == 1
    |                                    ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_polymod.rs:184:36
    |
 60 | impl<F: Field> FunctionFieldPlace_polymod<F> {
    |      - expected this type parameter
...
184 |         self.ramification_index == extension_degree
    |                                    ^^^^^^^^^^^^^^^^ expected type parameter `F`, found `usize`
    |
    = note: expected type parameter `F`
                         found type `usize`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_polymod.rs:193:38
    |
 60 | impl<F: Field> FunctionFieldPlace_polymod<F> {
    |      - expected this type parameter
...
193 |         if self.ramification_index > 0 {
    |                                      ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_polymod.rs:194:39
    |
 60 | impl<F: Field> FunctionFieldPlace_polymod<F> {
    |      - expected this type parameter
...
194 |             self.ramification_index - 1
    |                                       ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldPlace_rational`
   --> rustmath-rings/src/function_field/place_rational.rs:152:9
    |
152 |         FunctionFieldPlace_rational::new(name, 1, polynomial)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `FunctionFieldPlace_rational`
    |         help: a struct with a similar name exists: `FunctionFieldPlaceRational`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_rational.rs:215:31
    |
 68 | impl<F: Field> FunctionFieldPlace_rational<F> {
    |      - expected this type parameter
...
215 |         self.base.degree() == 1
    |                               ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_rational.rs:289:26
    |
 68 | impl<F: Field> FunctionFieldPlace_rational<F> {
    |      - expected this type parameter
...
289 |         self.degree() == 1
    |                          ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/place_rational.rs:302:26
    |
 68 | impl<F: Field> FunctionFieldPlace_rational<F> {
    |      - expected this type parameter
...
302 |         self.degree() == max_degree
    |                          ^^^^^^^^^^ expected type parameter `F`, found `usize`
    |
    = note: expected type parameter `F`
                         found type `usize`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/valuation.rs:206:19
    |
206 |             base: FunctionFieldValuation_base::new(function_field, name),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `FunctionFieldValuation_base`
    |                   help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/valuation.rs:302:19
    |
302 |             base: FunctionFieldValuation_base::new(function_field, name),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `FunctionFieldValuation_base`
    |                   help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/valuation.rs:318:19
    |
318 |             base: FunctionFieldValuation_base::new(function_field, "v_".to_string()),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `FunctionFieldValuation_base`
    |                   help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0433]: failed to resolve: use of undeclared type `RationalFunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/valuation.rs:441:19
    |
441 |             base: RationalFunctionFieldValuation_base::finite(function_field, prime_polynomial),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `RationalFunctionFieldValuation_base`
    |                   help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0433]: failed to resolve: use of undeclared type `RationalFunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/valuation.rs:508:19
    |
508 |             base: RationalFunctionFieldValuation_base::infinite(function_field),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `RationalFunctionFieldValuation_base`
    |                   help: a struct with a similar name exists: `RationalFunctionFieldValuationBase`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldValuation_base`
   --> rustmath-rings/src/function_field/valuation.rs:580:19
    |
580 |             base: FunctionFieldValuation_base::new(function_field, name),
    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `FunctionFieldValuation_base`
    |                   help: a struct with a similar name exists: `FunctionFieldValuationBase`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_polymod.rs:148:23
    |
 93 | impl<F: Field> FunctionField_polymod<F> {
    |      - expected this type parameter
...
148 |         self.degree > 0 && !self.polynomial.is_empty()
    |                       ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_polymod.rs:156:27
    |
 93 | impl<F: Field> FunctionField_polymod<F> {
    |      - expected this type parameter
...
156 |         if self.degree == 1 {
    |                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_polymod.rs:159:28
    |
 93 | impl<F: Field> FunctionField_polymod<F> {
    |      - expected this type parameter
...
159 |             (self.degree - 1) * (base_genus + self.degree / 2)
    |                            ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_polymod.rs:159:61
    |
 93 | impl<F: Field> FunctionField_polymod<F> {
    |      - expected this type parameter
...
159 |             (self.degree - 1) * (base_genus + self.degree / 2)
    |                                                             ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_polymod.rs:159:33
    |
 93 | impl<F: Field> FunctionField_polymod<F> {
    |      - expected this type parameter
...
159 |             (self.degree - 1) * (base_genus + self.degree / 2)
    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `F`, found `usize`
    |
    = note: expected type parameter `F`
                         found type `usize`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_polymod`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:177:20
    |
177 |             inner: FunctionField_polymod::new(base_field, variable, degree),
    |                    ^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionField_polymod`
    |                    help: a struct with a similar name exists: `FunctionFieldPolymod`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_polymod`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:189:20
    |
189 |             inner: FunctionField_polymod::with_polynomial(base_field, variable, degree, polynomial),
    |                    ^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionField_polymod`
    |                    help: a struct with a similar name exists: `FunctionFieldPolymod`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_simple`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:228:20
    |
228 |             inner: FunctionField_simple::new(base_field, variable, degree),
    |                    ^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionField_simple`
    |                    help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_simple`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:261:20
    |
261 |             inner: FunctionField_simple::new(base_field, variable, degree),
    |                    ^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionField_simple`
    |                    help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_char_zero`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:297:24
    |
297 |             char_zero: FunctionField_char_zero::new(
    |                        ^^^^^^^^^^^^^^^^^^^^^^^
    |                        |
    |                        use of undeclared type `FunctionField_char_zero`
    |                        help: a struct with a similar name exists: `FunctionFieldCharZero`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_integral`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:302:23
    |
302 |             integral: FunctionField_integral::new(base_field, variable, degree),
    |                       ^^^^^^^^^^^^^^^^^^^^^^
    |                       |
    |                       use of undeclared type `FunctionField_integral`
    |                       help: a struct with a similar name exists: `FunctionFieldIntegral`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_simple`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:337:20
    |
337 |             inner: FunctionField_simple::new(base_field, variable, degree),
    |                    ^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionField_simple`
    |                    help: a struct with a similar name exists: `FunctionFieldSimple`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_global`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:391:21
    |
391 |             global: FunctionField_global::new(
    |                     ^^^^^^^^^^^^^^^^^^^^
    |                     |
    |                     use of undeclared type `FunctionField_global`
    |                     help: a struct with a similar name exists: `FunctionFieldGlobal`

error[E0433]: failed to resolve: use of undeclared type `FunctionField_integral`
   --> rustmath-rings/src/function_field/function_field_polymod.rs:397:23
    |
397 |             integral: FunctionField_integral::new(base_field, variable, degree),
    |                       ^^^^^^^^^^^^^^^^^^^^^^
    |                       |
    |                       use of undeclared type `FunctionField_integral`
    |                       help: a struct with a similar name exists: `FunctionFieldIntegral`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_rational.rs:277:36
    |
238 | impl<F: Field> RationalFunctionField_global<F> {
    |      - expected this type parameter
...
277 |         self.constant_field_size + 1 // q finite + 1 infinite
    |                                    ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/function_field_rational.rs:296:54
    |
238 | impl<F: Field> RationalFunctionField_global<F> {
    |      - expected this type parameter
...
296 |             self.constant_field_size.pow(d as u32) / d
    |                                                      ^ expected type parameter `F`, found `usize`
    |
    = note: expected type parameter `F`
                         found type `usize`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldIdeal_polymod`
   --> rustmath-rings/src/function_field/ideal_polymod.rs:238:20
    |
238 |             inner: FunctionFieldIdeal_polymod::new(name),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldIdeal_polymod`
    |                    help: a struct with a similar name exists: `FunctionFieldIdealPolymod`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_polymod.rs:265:27
    |
234 | impl<F: Field> FunctionFieldIdealInfinite_polymod<F> {
    |      - expected this type parameter
...
265 |         self.valuation == 1
    |                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldIdeal_polymod`
   --> rustmath-rings/src/function_field/ideal_polymod.rs:295:20
    |
295 |             inner: FunctionFieldIdeal_polymod::new(name),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldIdeal_polymod`
    |                    help: a struct with a similar name exists: `FunctionFieldIdealPolymod`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldIdeal_polymod`
   --> rustmath-rings/src/function_field/ideal_polymod.rs:303:20
    |
303 |             inner: FunctionFieldIdeal_polymod::prime(name),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldIdeal_polymod`
    |                    help: a struct with a similar name exists: `FunctionFieldIdealPolymod`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_rational.rs:128:27
    |
 84 | impl<F: Field> FunctionFieldIdeal_rational<F> {
    |      - expected this type parameter
...
128 |         self.generator == "1"
    |                           ^^^ expected type parameter `F`, found `&str`
    |
    = note: expected type parameter `F`
                    found reference `&'static str`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_rational.rs:133:27
    |
 84 | impl<F: Field> FunctionFieldIdeal_rational<F> {
    |      - expected this type parameter
...
133 |         self.generator == "0" || self.generator.is_empty()
    |                           ^^^ expected type parameter `F`, found `&str`
    |
    = note: expected type parameter `F`
                    found reference `&'static str`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_rational.rs:166:37
    |
 84 | impl<F: Field> FunctionFieldIdeal_rational<F> {
    |      - expected this type parameter
...
166 |         } else if self.generator == "1" {
    |                                     ^^^ expected type parameter `F`, found `&str`
    |
    = note: expected type parameter `F`
                    found reference `&'static str`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_rational.rs:168:38
    |
 84 | impl<F: Field> FunctionFieldIdeal_rational<F> {
    |      - expected this type parameter
...
168 |         } else if other.generator == "1" {
    |                                      ^^^ expected type parameter `F`, found `&str`
    |
    = note: expected type parameter `F`
                    found reference `&'static str`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_rational.rs:294:50
    |
259 | impl<F: Field> FunctionFieldIdealInfinite_rational<F> {
    |      - expected this type parameter
...
294 |         self.valuation(numerator, denominator) < 0
    |                                                  ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/ideal_rational.rs:299:50
    |
259 | impl<F: Field> FunctionFieldIdealInfinite_rational<F> {
    |      - expected this type parameter
...
299 |         self.valuation(numerator, denominator) > 0
    |                                                  ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldOrder_base`
   --> rustmath-rings/src/function_field/order.rs:167:20
    |
167 |             inner: FunctionFieldOrder_base::new(field, name),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldOrder_base`
    |                    help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldOrder_base`
   --> rustmath-rings/src/function_field/order.rs:174:20
    |
174 |             inner: FunctionFieldOrder_base::with_basis(field, name, basis),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldOrder_base`
    |                    help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldOrder_base`
   --> rustmath-rings/src/function_field/order.rs:230:20
    |
230 |             inner: FunctionFieldOrder_base::new(field, name),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldOrder_base`
    |                    help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldOrder_base`
   --> rustmath-rings/src/function_field/order.rs:275:20
    |
275 |             inner: FunctionFieldOrder_base::new(field.clone(), format!("O_{}", field)),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^
    |                    |
    |                    use of undeclared type `FunctionFieldOrder_base`
    |                    help: a struct with a similar name exists: `FunctionFieldOrderBase`

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:313:14
    |
313 |         self.class_number() == 1
    |              ^^^^^^^^^^^^ cannot infer type for type parameter `F`
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldMaximalOrder::<F>::class_number`
   --> rustmath-rings/src/function_field/order.rs:271:9
    |
271 | impl<F: Field> FunctionFieldMaximalOrder<F> {
    |         ^^^^^ required by this bound in `FunctionFieldMaximalOrder::<F>::class_number`
...
295 |     pub fn class_number(&self) -> usize {
    |            ------------ required by a bound in this associated function

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:333:17
    |
333 | #[derive(Debug, Clone)]
    |                 ^ cannot infer type
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldMaximalOrderInfinite`
   --> rustmath-rings/src/function_field/order.rs:334:49
    |
334 | pub struct FunctionFieldMaximalOrderInfinite<F: Field> {
    |                                                 ^^^^^ required by this bound in `FunctionFieldMaximalOrderInfinite`

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:345:22
    |
345 |             maximal: FunctionFieldMaximalOrder::new(field.clone()),
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `F` declared on the struct `FunctionFieldMaximalOrder`
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldMaximalOrder`
   --> rustmath-rings/src/function_field/order.rs:266:41
    |
266 | pub struct FunctionFieldMaximalOrder<F: Field> {
    |                                         ^^^^^ required by this bound in `FunctionFieldMaximalOrder`
help: consider specifying the generic argument
    |
345 |             maximal: FunctionFieldMaximalOrder::<F>::new(field.clone()),
    |                                               +++++

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:352:22
    |
352 |         self.maximal.is_maximal()
    |                      ^^^^^^^^^^ cannot infer type for type parameter `F`
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldMaximalOrder::<F>::is_maximal`
   --> rustmath-rings/src/function_field/order.rs:271:9
    |
271 | impl<F: Field> FunctionFieldMaximalOrder<F> {
    |         ^^^^^ required by this bound in `FunctionFieldMaximalOrder::<F>::is_maximal`
...
280 |     pub fn is_maximal(&self) -> bool {
    |            ---------- required by a bound in this associated function

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:357:23
    |
357 |         self.infinite.is_at_infinity()
    |                       ^^^^^^^^^^^^^^ cannot infer type for type parameter `F`
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldOrderInfinite::<F>::is_at_infinity`
   --> rustmath-rings/src/function_field/order.rs:226:9
    |
226 | impl<F: Field> FunctionFieldOrderInfinite<F> {
    |         ^^^^^ required by this bound in `FunctionFieldOrderInfinite::<F>::is_at_infinity`
...
235 |     pub fn is_at_infinity(&self) -> bool {
    |            -------------- required by a bound in this associated function

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:362:22
    |
362 |         self.maximal.function_field()
    |                      ^^^^^^^^^^^^^^ cannot infer type for type parameter `F`
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldMaximalOrder::<F>::function_field`
   --> rustmath-rings/src/function_field/order.rs:271:9
    |
271 | impl<F: Field> FunctionFieldMaximalOrder<F> {
    |         ^^^^^ required by this bound in `FunctionFieldMaximalOrder::<F>::function_field`
...
285 |     pub fn function_field(&self) -> &str {
    |            -------------- required by a bound in this associated function

error[E0283]: type annotations needed
   --> rustmath-rings/src/function_field/order.rs:367:22
    |
367 |         self.maximal.integral_basis()
    |                      ^^^^^^^^^^^^^^ cannot infer type for type parameter `F`
    |
    = note: cannot satisfy `_: Field`
    = help: the following types implement trait `Field`:
              ComplexMPFR
              PadicRational
              RealMPFR
              rustmath_complex::Complex
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
              rustmath_rationals::Rational
              rustmath_reals::Real
note: required by a bound in `FunctionFieldMaximalOrder::<F>::integral_basis`
   --> rustmath-rings/src/function_field/order.rs:271:9
    |
271 | impl<F: Field> FunctionFieldMaximalOrder<F> {
    |         ^^^^^ required by this bound in `FunctionFieldMaximalOrder::<F>::integral_basis`
...
290 |     pub fn integral_basis(&self) -> &[String] {
    |            -------------- required by a bound in this associated function

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/order_polymod.rs:208:32
    |
109 | impl<F: Field> FunctionFieldMaximalOrder_polymod<F> {
    |      - expected this type parameter
...
208 |         self.class_number() == 1
    |                                ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/order_polymod.rs:232:43
    |
109 | impl<F: Field> FunctionFieldMaximalOrder_polymod<F> {
    |      - expected this type parameter
...
232 |         self.ramification_index(prime) == 1
    |                                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `FunctionFieldMaximalOrder_polymod`
   --> rustmath-rings/src/function_field/order_polymod.rs:294:22
    |
294 |             polymod: FunctionFieldMaximalOrder_polymod::new(base_field, polynomial, degree),
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                      |
    |                      use of undeclared type `FunctionFieldMaximalOrder_polymod`
    |                      help: a struct with a similar name exists: `FunctionFieldMaximalOrderPolymod`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/order_polymod.rs:338:27
    |
283 | impl<F: Field> FunctionFieldMaximalOrder_global<F> {
    |      - expected this type parameter
...
338 |         q.pow(n as u32) + 1
    |                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/order_polymod.rs:480:54
    |
414 | impl<F: Field> FunctionFieldMaximalOrderInfinite_polymod<F> {
    |      - expected this type parameter
...
480 |         self.pole_order_at_infinity(element).abs() < i64::MAX
    |                                                      ^^^^^^^^ expected type parameter `F`, found `i64`
    |
    = note: expected type parameter `F`
                         found type `i64`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/order_rational.rs:400:48
    |
322 | impl<F: Field> FunctionFieldMaximalOrderInfinite_rational<F> {
    |      - expected this type parameter
...
400 |         self.valuation_at_infinity(element) >= 0
    |                                                ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/order_rational.rs:427:37
    |
322 | impl<F: Field> FunctionFieldMaximalOrderInfinite_rational<F> {
    |      - expected this type parameter
...
427 |         self.pole_order(element) == 1
    |                                     ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_base.rs:155:25
    |
112 | impl<F: Field> JacobianPoint_base<F> {
    |      - expected this type parameter
...
155 |         self.divisor == "0" || self.divisor.is_empty()
    |                         ^^^ expected type parameter `F`, found `&str`
    |
    = note: expected type parameter `F`
                    found reference `&'static str`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:262:9
    |
262 |         JacobianPoint_base::new(self.jacobian.clone(), "0".to_string())
    |         ^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `JacobianPoint_base`
    |         help: a struct with a similar name exists: `JacobianPointBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:267:9
    |
267 |         JacobianPoint_base::new(self.jacobian.clone(), divisor)
    |         ^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `JacobianPoint_base`
    |         help: a struct with a similar name exists: `JacobianPointBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:273:13
    |
273 |             JacobianPoint_base::new(
    |             ^^^^^^^^^^^^^^^^^^
    |             |
    |             use of undeclared type `JacobianPoint_base`
    |             help: a struct with a similar name exists: `JacobianPointBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:278:13
    |
278 |             JacobianPoint_base::new(self.jacobian.clone(), curve_point.to_string())
    |             ^^^^^^^^^^^^^^^^^^
    |             |
    |             use of undeclared type `JacobianPoint_base`
    |             help: a struct with a similar name exists: `JacobianPointBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianGroup_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:325:21
    |
325 |         let group = JacobianGroup_base::new(jacobian_name, genus);
    |                     ^^^^^^^^^^^^^^^^^^
    |                     |
    |                     use of undeclared type `JacobianGroup_base`
    |                     help: a struct with a similar name exists: `JacobianGroupBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:411:19
    |
411 |             base: JacobianPoint_base::new(jacobian, divisor),
    |                   ^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `JacobianPoint_base`
    |                   help: a struct with a similar name exists: `JacobianPointBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianGroup_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:489:19
    |
489 |             base: JacobianGroup_base::new(jacobian, genus),
    |                   ^^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `JacobianGroup_base`
    |                   help: a struct with a similar name exists: `JacobianGroupBase`

error[E0433]: failed to resolve: use of undeclared type `Jacobian_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:568:9
    |
568 |         Jacobian_base::new(curve, genus)
    |         ^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `Jacobian_base`
    |         help: a struct with a similar name exists: `JacobianBase`

error[E0433]: failed to resolve: use of undeclared type `JacobianGroup_finite_field_base`
   --> rustmath-rings/src/function_field/jacobian_base.rs:579:9
    |
579 |         JacobianGroup_finite_field_base::new(jacobian_name, genus, field_size)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `JacobianGroup_finite_field_base`
    |         help: a struct with a similar name exists: `JacobianGroupFiniteFieldBase`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hess.rs:371:27
    |
349 | impl<F: Field> Jacobian_finite_field<F> {
    |      - expected this type parameter
...
371 |         self.field_size + 1
    |                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hess.rs:487:27
    |
466 | impl<F: Field> JacobianGroup_finite_field<F> {
    |      - expected this type parameter
...
487 |         self.field_size + 1
    |                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_finite_field`
   --> rustmath-rings/src/function_field/jacobian_hess.rs:540:9
    |
540 |         JacobianPoint_finite_field::new(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `JacobianPoint_finite_field`
    |         help: a struct with a similar name exists: `JacobianPointFiniteField`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:430:15
    |
406 | impl<F: Field> Jacobian_finite_field<F> {
    |      - expected this type parameter
...
430 |         ((q + 1) as f64).powi(g as i32) as usize
    |               ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:554:15
    |
526 | impl<F: Field> JacobianGroup_finite_field<F> {
    |      - expected this type parameter
...
554 |         ((q + 1) as f64).powi(g as i32) as usize
    |               ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0433]: failed to resolve: use of undeclared type `JacobianPoint_finite_field`
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:607:9
    |
607 |         JacobianPoint_finite_field::new(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |         |
    |         use of undeclared type `JacobianPoint_finite_field`
    |         help: a struct with a similar name exists: `JacobianPointFiniteField`

error[E0433]: failed to resolve: use of undeclared type `KhuriMakdisi_base`
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:260:19
    |
260 |             base: KhuriMakdisi_base::new(curve, genus),
    |                   ^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `KhuriMakdisi_base`
    |                   help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0433]: failed to resolve: use of undeclared type `KhuriMakdisi_base`
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:346:19
    |
346 |             base: KhuriMakdisi_base::new(curve, genus),
    |                   ^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `KhuriMakdisi_base`
    |                   help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0433]: failed to resolve: use of undeclared type `KhuriMakdisi_base`
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:355:19
    |
355 |             base: KhuriMakdisi_base::new(curve, genus),
    |                   ^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `KhuriMakdisi_base`
    |                   help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0433]: failed to resolve: use of undeclared type `KhuriMakdisi_base`
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:458:19
    |
458 |             base: KhuriMakdisi_base::new(curve, genus),
    |                   ^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `KhuriMakdisi_base`
    |                   help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0433]: failed to resolve: use of undeclared type `KhuriMakdisi_base`
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:468:19
    |
468 |             base: KhuriMakdisi_base::new(curve, genus),
    |                   ^^^^^^^^^^^^^^^^^
    |                   |
    |                   use of undeclared type `KhuriMakdisi_base`
    |                   help: a struct with a similar name exists: `KhuriMakdisiBase`

error[E0433]: failed to resolve: use of undeclared type `RealLazyField`
   --> rustmath-rings/src/real_lazy.rs:683:5
    |
682 | / pub fn RealLazyField() -> RealLazyField {
683 | |     RealLazyField::new()
    | |     ^^^^^^^^^^^^^ use of undeclared type `RealLazyField`
684 | | }
    | |_- help: `RealLazyField` is defined here, but is not a type

error[E0433]: failed to resolve: use of undeclared type `ComplexLazyField`
   --> rustmath-rings/src/real_lazy.rs:688:5
    |
688 |     ComplexLazyField::new()
    |     ^^^^^^^^^^^^^^^^ use of undeclared type `ComplexLazyField`
    |
help: a struct with a similar name exists
    |
688 -     ComplexLazyField::new()
688 +     complex_lazy_field::new()
    |
help: `ComplexLazyField` is defined here, but is not a type
    |
687 - pub fn ComplexLazyField() -> ComplexLazyField {
688 -     ComplexLazyField::new()
689 - }
    |

warning: unused import: `Ring`
  --> rustmath-rings/src/abc.rs:24:21
   |
24 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/asymptotic.rs:44:21
   |
44 | use rustmath_core::{Ring, CommutativeRing};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/differential.rs:40:21
   |
40 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/divisor.rs:43:21
   |
43 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field.rs:12:21
   |
12 | use rustmath_core::{Ring, IntegralDomain, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field_element.rs:33:21
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field, EuclideanDomain};
   |                     ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field_element.rs:33:43
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field, EuclideanDomain};
   |                                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:21
   |
37 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                     ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:27
   |
37 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element.rs:31:21
   |
31 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                     ^^^^

warning: unused import: `Hasher`
  --> rustmath-rings/src/growth_group.rs:51:23
   |
51 | use std::hash::{Hash, Hasher};
   |                       ^^^^^^

warning: unused import: `GrowthGroup`
  --> rustmath-rings/src/growth_group_cartesian.rs:35:20
   |
35 |     GrowthElement, GrowthGroup, MonomialGrowthElement, MonomialGrowthGroup,
   |                    ^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/picard_group.rs:57:28
   |
57 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/padics/capped_relative.rs:44:80
   |
44 | use rustmath_core::{CommutativeRing, Field, IntegralDomain, MathError, Result, Ring};
   |                                                                                ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/padics/factory.rs:71:40
   |
71 | use rustmath_core::{MathError, Result, Ring};
   |                                        ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:34:28
   |
34 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/puiseux_series_ring.rs:40:28
   |
40 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/residue_field.rs:24:27
   |
24 | use rustmath_core::{Ring, Field, IntegralDomain, CommutativeRing};
   |                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/tate_algebra.rs:37:28
   |
37 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/semirings/non_negative_integer_semiring.rs:40:5
   |
40 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `place`
   --> rustmath-rings/src/differential.rs:122:29
    |
122 |     pub fn valuation(&self, place: &str) -> i64 {
    |                             ^^^^^ help: if this is intentional, prefix it with an underscore: `_place`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `function`
   --> rustmath-rings/src/divisor.rs:219:30
    |
219 |     pub fn principal_divisor(function: String) -> Self {
    |                              ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_function`

warning: unused variable: `x`
   --> rustmath-rings/src/fraction_field.rs:288:53
    |
288 | pub fn is_fraction_field_element<R: IntegralDomain>(x: &FractionFieldElement<R>) -> bool {
    |                                                     ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> rustmath-rings/src/fraction_field_element.rs:308:53
    |
308 | pub fn is_fraction_field_element<R: IntegralDomain>(x: &FractionFieldElement<R>) -> bool {
    |                                                     ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> rustmath-rings/src/function_field_element.rs:272:44
    |
272 | pub fn is_function_field_element<F: Field>(x: &FunctionFieldElement<F>) -> bool {
    |                                            ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `value`
   --> rustmath-rings/src/infinity.rs:332:32
    |
332 | pub fn is_infinite<T: 'static>(value: &T) -> bool {
    |                                ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`

warning: unused variable: `prev`
    --> rustmath-rings/src/padics/extension.rs:1047:17
     |
1047 |             let prev = automorphisms.last().unwrap();
     |                 ^^^^ help: if this is intentional, prefix it with an underscore: `_prev`

warning: unused variable: `ring2`
   --> rustmath-rings/src/ring_extension.rs:312:34
    |
312 | pub fn common_base<R>(ring1: &R, ring2: &R) -> Result<R, RingExtensionError>
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_ring2`

warning: unused variable: `sqrt_abs`
   --> rustmath-rings/src/universal_cyclotomic_field.rs:278:13
    |
278 |         let sqrt_abs = ucf_sqrt_int(-n)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sqrt_abs`

warning: unused variable: `d2`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:328:47
    |
328 |     pub fn add(&self, d1: &MumfordDivisor<F>, d2: &MumfordDivisor<F>) -> MumfordDivisor<F> {
    |                                               ^^ help: if this is intentional, prefix it with an underscore: `_d2`

warning: unused variable: `h`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:344:33
    |
344 |         let neg_v = if let Some(h) = self.curve.h() {
    |                                 ^ help: if this is intentional, prefix it with an underscore: `_h`

warning: unused variable: `d`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:386:28
    |
386 |     pub fn contains(&self, d: &MumfordDivisor<F>) -> bool {
    |                            ^ help: if this is intentional, prefix it with an underscore: `_d`

warning: unused variable: `a`
   --> rustmath-rings/src/invariants/reconstruction.rs:103:9
    |
103 |     let a = R::from(1);
    |         ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `b`
   --> rustmath-rings/src/invariants/reconstruction.rs:104:9
    |
104 |     let b = R::from(0);
    |         ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `element`
   --> rustmath-rings/src/power_series_poly.rs:279:23
    |
279 |     pub fn act(&self, element: &R, series: &PowerSeriesPoly<R>) -> PowerSeriesPoly<R> {
    |                       ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: unused variable: `other_exp`
   --> rustmath-rings/src/puiseux_series_ring_element.rs:222:24
    |
222 |         let (self_exp, other_exp) = self.to_common_ramification(&PuiseuxSeries::new(
    |                        ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_exp`

Some errors have detailed explanations: E0283, E0308, E0412, E0422, E0432, E0433, E0573, E0574.
For more information about an error, try `rustc --explain E0283`.
warning: `rustmath-rings` (lib) generated 118 warnings
error: could not compile `rustmath-rings` (lib) due to 275 previous errors; 118 warnings emitted
