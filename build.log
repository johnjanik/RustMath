warning: unused imports: `MathError` and `Result`
 --> rustmath-core/src/parent.rs:9:19
  |
9 | use crate::{Ring, MathError, Result};
  |                   ^^^^^^^^^  ^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::any::Any`
  --> rustmath-core/src/parent.rs:11:5
   |
11 | use std::any::Any;
   |     ^^^^^^^^^^^^^

warning: `rustmath-core` (lib) generated 2 warnings (run `cargo fix --lib -p rustmath-core` to apply 2 suggestions)
warning: unused import: `num_traits::Signed`
  --> rustmath-integers/src/ecm.rs:33:5
   |
33 | use num_traits::Signed;
   |     ^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `num_traits::ToPrimitive`
  --> rustmath-integers/src/quadratic_sieve.rs:33:5
   |
33 | use num_traits::ToPrimitive;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `u3`
   --> rustmath-integers/src/ecm.rs:342:9
    |
342 |     let u3 = (u.clone() * u.clone() * u.clone()) % n.clone();
    |         ^^ help: if this is intentional, prefix it with an underscore: `_u3`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `y_product`
   --> rustmath-integers/src/quadratic_sieve.rs:349:13
    |
349 |     let mut y_product = Integer::one();
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_y_product`

warning: variable does not need to be mutable
   --> rustmath-integers/src/quadratic_sieve.rs:349:9
    |
349 |     let mut y_product = Integer::one();
    |         ----^^^^^^^^^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: field `b` is never read
  --> rustmath-integers/src/ecm.rs:77:5
   |
75 | struct EllipticCurve {
   |        ------------- field in this struct
76 |     a: Integer,
77 |     b: Integer,
   |     ^
   |
   = note: `EllipticCurve` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `tonelli_shanks` is never used
  --> rustmath-integers/src/quadratic_sieve.rs:75:4
   |
75 | fn tonelli_shanks(n: &Integer, p: u64) -> Option<i64> {
   |    ^^^^^^^^^^^^^^

warning: `rustmath-integers` (lib) generated 7 warnings (run `cargo fix --lib -p rustmath-integers` to apply 1 suggestion)
warning: unused import: `DisplayMode`
   --> rustmath-rationals/src/rational.rs:186:36
    |
186 |         use rustmath_typesetting::{DisplayMode, OutputFormat};
    |                                    ^^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_core::NumericConversion`
   --> rustmath-rationals/src/rational.rs:423:13
    |
423 |         use rustmath_core::NumericConversion as _;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `rustmath-rationals` (lib) generated 2 warnings (run `cargo fix --lib -p rustmath-rationals` to apply 1 suggestion)
warning: unused import: `rustmath_integers::Integer`
   --> rustmath-polynomials/src/factorization.rs:379:9
    |
379 |     use rustmath_integers::Integer;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-polynomials/src/factorization.rs:897:9
    |
897 |     use rustmath_integers::Integer;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
    --> rustmath-polynomials/src/factorization.rs:1170:9
     |
1170 |     use rustmath_integers::Integer;
     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `NumericConversion`
 --> rustmath-polynomials/src/roots.rs:5:21
  |
5 | use rustmath_core::{NumericConversion, Result, MathError, Ring};
  |                     ^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-polynomials/src/roots.rs:338:9
    |
338 |     use rustmath_integers::Integer;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-polynomials/src/roots.rs:381:9
    |
381 |     use rustmath_integers::Integer;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::polynomial::Polynomial`
 --> rustmath-polynomials/src/roots.rs:3:5
  |
3 | use crate::polynomial::Polynomial;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `an_divisors`
   --> rustmath-polynomials/src/factorization.rs:289:9
    |
289 |     let an_divisors = if !an.is_zero() {
    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_an_divisors`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-polynomials/src/factorization.rs:562:21
    |
562 |                 let mut v_minus_a = v.clone();
    |                     ----^^^^^^^^^
    |                     |
    |                     help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `cmp`
   --> rustmath-polynomials/src/groebner.rs:297:9
    |
297 |     let cmp = get_comparison_fn(ordering);
    |         ^^^ help: if this is intentional, prefix it with an underscore: `_cmp`

warning: variable does not need to be mutable
   --> rustmath-polynomials/src/ideal.rs:179:13
    |
179 |         let mut remainder = p.clone();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `quotient_coeff`
   --> rustmath-polynomials/src/multivariate.rs:424:21
    |
424 |                 let quotient_coeff = r_lc.clone() * d_lc.clone(); // This is a placeholder
    |                     ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_quotient_coeff`

warning: unused variable: `lc`
   --> rustmath-polynomials/src/multivariate.rs:492:26
    |
492 |                 let (lm, lc) = remainder.leading_term(cmp).unwrap();
    |                          ^^ help: if this is intentional, prefix it with an underscore: `_lc`

warning: unused variable: `r`
   --> rustmath-polynomials/src/roots.rs:222:13
    |
222 |         let r = &rational_roots_found[0];
    |             ^ help: if this is intentional, prefix it with an underscore: `_r`

warning: variable does not need to be mutable
   --> rustmath-polynomials/src/univariate.rs:504:13
    |
504 |         let mut f = self.clone();
    |             ----^
    |             |
    |             help: remove this `mut`

warning: field `ordering` is never read
   --> rustmath-polynomials/src/algebraic_geometry.rs:258:5
    |
252 | pub struct ProjectiveVariety<R: Ring> {
    |            ----------------- field in this struct
...
258 |     ordering: MonomialOrdering,
    |     ^^^^^^^^
    |
    = note: `ProjectiveVariety` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `poly_add_mod` is never used
    --> rustmath-polynomials/src/factorization.rs:1110:4
     |
1110 | fn poly_add_mod(
     |    ^^^^^^^^^^^^

warning: unused import: `NumericConversion`
 --> rustmath-padics/src/padic_rational.rs:4:56
  |
4 | use rustmath_core::{CommutativeRing, Field, MathError, NumericConversion, Result, Ring};
  |                                                        ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: function `color_names` is never used
  --> rustmath-colors/src/named_colors.rs:71:8
   |
71 | pub fn color_names() -> Vec<&'static str> {
   |        ^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `parse_color_from_rgb` is never used
   --> rustmath-colors/src/parser.rs:130:8
    |
130 | pub fn parse_color_from_rgb(r: f64, g: f64, b: f64) -> Result<Color> {
    |        ^^^^^^^^^^^^^^^^^^^^

warning: function `parse_color_from_rgba` is never used
   --> rustmath-colors/src/parser.rs:135:8
    |
135 | pub fn parse_color_from_rgba(r: f64, g: f64, b: f64, a: f64) -> Result<Color> {
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: `rustmath-polynomials` (lib) generated 17 warnings (run `cargo fix --lib -p rustmath-polynomials` to apply 9 suggestions)
warning: `rustmath-padics` (lib) generated 1 warning
warning: `rustmath-colors` (lib) generated 3 warnings
warning: unused imports: `MathError` and `Result`
 --> rustmath-matrix/src/eigenvalues.rs:4:28
  |
4 | use rustmath_core::{Field, MathError, Result};
  |                            ^^^^^^^^^  ^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Vector`
 --> rustmath-matrix/src/inner_product.rs:6:21
  |
6 | use crate::{Matrix, Vector};
  |                     ^^^^^^

warning: unused import: `MathError`
 --> rustmath-matrix/src/integer_forms.rs:7:38
  |
7 | use rustmath_core::{EuclideanDomain, MathError, Result};
  |                                      ^^^^^^^^^

warning: unused import: `crate::Matrix`
 --> rustmath-matrix/src/polynomial_ops.rs:3:5
  |
3 | use crate::Matrix;
  |     ^^^^^^^^^^^^^

warning: unused imports: `Field`, `MathError`, and `Result`
 --> rustmath-matrix/src/polynomial_ops.rs:4:21
  |
4 | use rustmath_core::{Field, MathError, Result};
  |                     ^^^^^  ^^^^^^^^^  ^^^^^^

warning: unused import: `rustmath_polynomials::UnivariatePolynomial`
 --> rustmath-matrix/src/polynomial_ops.rs:5:5
  |
5 | use rustmath_polynomials::UnivariatePolynomial;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Vector`
 --> rustmath-matrix/src/vector_space.rs:3:21
  |
3 | use crate::{Matrix, Vector};
  |                     ^^^^^^

warning: variable does not need to be mutable
   --> rustmath-matrix/src/linear_solve.rs:205:13
    |
205 |         let mut pivot_cols: std::collections::HashSet<usize> =
    |             ----^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `r`
   --> rustmath-matrix/src/polynomial_matrix.rs:234:17
    |
234 |         let (q, r) = target.pseudo_div_rem(&pivot)?;
    |                 ^ help: if this is intentional, prefix it with an underscore: `_r`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `r`
   --> rustmath-matrix/src/polynomial_matrix.rs:261:17
    |
261 |         let (q, r) = target.pseudo_div_rem(&pivot)?;
    |                 ^ help: if this is intentional, prefix it with an underscore: `_r`

warning: unused variable: `q`
   --> rustmath-matrix/src/polynomial_matrix.rs:287:22
    |
287 |                 let (q, r) = d_next.pseudo_div_rem(&d_i)?;
    |                      ^ help: if this is intentional, prefix it with an underscore: `_q`

warning: unused variable: `left`
   --> rustmath-matrix/src/polynomial_matrix.rs:278:42
    |
278 |     fn ensure_divisibility(s: &mut Self, left: &mut Self, right: &mut Self) -> Result<()> {
    |                                          ^^^^ help: if this is intentional, prefix it with an underscore: `_left`

warning: unused variable: `right`
   --> rustmath-matrix/src/polynomial_matrix.rs:278:59
    |
278 |     fn ensure_divisibility(s: &mut Self, left: &mut Self, right: &mut Self) -> Result<()> {
    |                                                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_right`

warning: unused variable: `row_start`
   --> rustmath-matrix/src/sparse.rs:519:17
    |
519 |             let row_start = self.matrix.row_ptrs[self.row];
    |                 ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
519 |             let _row_start = self.matrix.row_ptrs[self.row];
    |                 +
help: you might have meant to pattern match on the similarly named constant `STRASSEN_THRESHOLD`
    |
519 -             let row_start = self.matrix.row_ptrs[self.row];
519 +             let strassen::STRASSEN_THRESHOLD = self.matrix.row_ptrs[self.row];
    |

warning: unused variable: `p`
   --> rustmath-matrix/src/special.rs:999:9
    |
999 |     let p = random_unimodular_matrix(size, 10);
    |         ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `combined_ambient_dim`
   --> rustmath-matrix/src/vector_space.rs:121:13
    |
121 |         let combined_ambient_dim = ambient_dim + other_ambient_dim;
    |             ^^^^^^^^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
121 |         let _combined_ambient_dim = ambient_dim + other_ambient_dim;
    |             +
help: you might have meant to pattern match on the similarly named constant `STRASSEN_THRESHOLD`
    |
121 -         let combined_ambient_dim = ambient_dim + other_ambient_dim;
121 +         let strassen::STRASSEN_THRESHOLD = ambient_dim + other_ambient_dim;
    |

warning: unused variable: `subspace_matrix`
   --> rustmath-matrix/src/vector_space.rs:181:13
    |
181 |         let subspace_matrix = Matrix::from_vec(ambient_dim, subspace.dimension, subspace_data)?;
    |             ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_subspace_matrix`

warning: method `scalar_mul` is never used
   --> rustmath-matrix/src/polynomial_matrix.rs:350:8
    |
346 | trait PolynomialExt<F: Field> {
    |       ------------- method in this trait
...
350 |     fn scalar_mul(&self, scalar: &F) -> Self;
    |        ^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused `Result` that must be used
  --> rustmath-matrix/src/integer_forms.rs:72:21
   |
72 |                     s.swap_rows(k, pi);
   |                     ^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
   = note: `#[warn(unused_must_use)]` (part of `#[warn(unused)]`) on by default
help: use `let _ = ...` to ignore the resulting value
   |
72 |                     let _ = s.swap_rows(k, pi);
   |                     +++++++

warning: unused `Result` that must be used
  --> rustmath-matrix/src/integer_forms.rs:73:21
   |
73 |                     p.swap_rows(k, pi);
   |                     ^^^^^^^^^^^^^^^^^^
   |
   = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
   |
73 |                     let _ = p.swap_rows(k, pi);
   |                     +++++++

warning: unused `Result` that must be used
   --> rustmath-matrix/src/integer_forms.rs:200:17
    |
200 |                 h.swap_rows(pivot_row, current_row);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
200 |                 let _ = h.swap_rows(pivot_row, current_row);
    |                 +++++++

warning: unused `Result` that must be used
   --> rustmath-matrix/src/integer_forms.rs:201:17
    |
201 |                 u.swap_rows(pivot_row, current_row);
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
201 |                 let _ = u.swap_rows(pivot_row, current_row);
    |                 +++++++

warning: unused `Result` that must be used
   --> rustmath-matrix/src/integer_forms.rs:241:21
    |
241 |                     h.swap_rows(current_row, smallest_row);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
241 |                     let _ = h.swap_rows(current_row, smallest_row);
    |                     +++++++

warning: unused `Result` that must be used
   --> rustmath-matrix/src/integer_forms.rs:242:21
    |
242 |                     u.swap_rows(current_row, smallest_row);
    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
242 |                     let _ = u.swap_rows(current_row, smallest_row);
    |                     +++++++

warning: unused imports: `CommutativeRing`, `Field`, `MathError`, `Result`, and `Ring`
  --> rustmath-complex/src/complex_arb.rs:12:21
   |
12 | use rustmath_core::{CommutativeRing, Field, MathError, Result, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^  ^^^^^^  ^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Real`
  --> rustmath-complex/src/complex_arb.rs:13:22
   |
13 | use rustmath_reals::{Real, RealMPFR};
   |                      ^^^^

warning: unused imports: `CommutativeRing`, `Field`, `MathError`, and `Result`
  --> rustmath-complex/src/complex_interval.rs:46:21
   |
46 | use rustmath_core::{CommutativeRing, Field, MathError, Result, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^  ^^^^^^

warning: unused import: `RealMPFR`
  --> rustmath-complex/src/complex_interval.rs:47:38
   |
47 | use rustmath_reals::{Interval, Real, RealMPFR};
   |                                      ^^^^^^^^

warning: unused import: `Real`
 --> rustmath-complex/src/complex_interval_field.rs:7:32
  |
7 | use rustmath_reals::{Interval, Real};
  |                                ^^^^

warning: type `ComplexIntervalField_class` should have an upper camel case name
  --> rustmath-complex/src/complex_interval_field.rs:28:12
   |
28 | pub struct ComplexIntervalField_class {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `ComplexIntervalFieldClass`
   |
   = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: type `MPComplexField_class` should have an upper camel case name
   --> rustmath-complex/src/complex_mpc_ext.rs:255:12
    |
255 | pub struct MPComplexField_class {
    |            ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `MpcomplexFieldClass`

warning: unused import: `NumericConversion`
 --> rustmath-complex/src/complex.rs:3:56
  |
3 | use rustmath_core::{CommutativeRing, Field, MathError, NumericConversion, Result, Ring};
  |                                                        ^^^^^^^^^^^^^^^^^

warning: variable does not need to be mutable
   --> rustmath-complex/src/complex_interval.rs:465:13
    |
465 |         let mut angles = vec![
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `elem` is never read
  --> rustmath-complex/src/complex_interval_field.rs:81:17
   |
81 |         let mut elem = ComplexIntervalFieldElement::point(real, imag);
   |                 ^^^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
  --> rustmath-complex/src/complex_interval_field.rs:99:13
   |
99 |         let mut elem = ComplexIntervalFieldElement::from_intervals(real, imag);
   |             ----^^^^
   |             |
   |             help: remove this `mut`

warning: function `ComplexIntervalField` should have a snake case name
   --> rustmath-complex/src/complex_interval_field.rs:181:8
    |
181 | pub fn ComplexIntervalField(precision: Option<u32>) -> ComplexIntervalField_class {
    |        ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `complex_interval_field`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: function `MPComplexField` should have a snake case name
   --> rustmath-complex/src/complex_mpc_ext.rs:236:8
    |
236 | pub fn MPComplexField(precision: Option<u32>) -> MPComplexField_class {
    |        ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `mpcomplex_field`

warning: unused variable: `rhs`
   --> rustmath-finitefields/src/extension_field.rs:291:18
    |
291 |     fn div(self, rhs: Self) -> Self::Output {
    |                  ^^^ help: if this is intentional, prefix it with an underscore: `_rhs`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::sync::Arc`
 --> rustmath-symbolic/src/differentiate.rs:6:5
  |
6 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `BinaryOp` and `UnaryOp`
 --> rustmath-symbolic/src/diffeq.rs:6:25
  |
6 | use crate::expression::{BinaryOp, Expr, UnaryOp};
  |                         ^^^^^^^^        ^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
 --> rustmath-symbolic/src/diffeq.rs:9:5
  |
9 | use rustmath_rationals::Rational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> rustmath-symbolic/src/diffeq.rs:10:5
   |
10 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
 --> rustmath-symbolic/src/expand.rs:5:5
  |
5 | use rustmath_integers::Integer;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::polynomial::*`
  --> rustmath-symbolic/src/expand.rs:99:13
   |
99 |         use crate::polynomial::*;
   |             ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
   --> rustmath-symbolic/src/expand.rs:100:13
    |
100 |         use std::collections::HashMap;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `NumericConversion`
 --> rustmath-symbolic/src/factor.rs:8:21
  |
8 | use rustmath_core::{NumericConversion, Ring};
  |                     ^^^^^^^^^^^^^^^^^

warning: unused import: `NumericConversion`
  --> rustmath-symbolic/src/inequalities.rs:13:21
   |
13 | use rustmath_core::{NumericConversion, Ring};
   |                     ^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> rustmath-symbolic/src/integrate.rs:10:5
   |
10 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> rustmath-symbolic/src/limits.rs:9:5
  |
9 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `crate::series::BigO`
   --> rustmath-symbolic/src/limits.rs:537:13
    |
537 |         use crate::series::BigO;
    |             ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
 --> rustmath-symbolic/src/operators.rs:8:5
  |
8 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused imports: `preceded` and `tuple`
  --> rustmath-symbolic/src/parser.rs:23:33
   |
23 |     sequence::{delimited, pair, preceded, tuple},
   |                                 ^^^^^^^^  ^^^^^

warning: unused import: `std::collections::HashMap`
 --> rustmath-symbolic/src/polynomial.rs:7:5
  |
7 | use std::collections::HashMap;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-symbolic/src/radical.rs:10:5
   |
10 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `BinaryOp` and `UnaryOp`
  --> rustmath-symbolic/src/random_tests.rs:26:25
   |
26 | use crate::expression::{BinaryOp, Expr, UnaryOp};
   |                         ^^^^^^^^        ^^^^^^^
   |
help: if this is a test module, consider adding a `#[cfg(test)]` to the containing module
  --> rustmath-symbolic/src/lib.rs:27:1
   |
27 | pub mod random_tests;
   | ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::symbol::Symbol`
  --> rustmath-symbolic/src/random_tests.rs:27:5
   |
27 | use crate::symbol::Symbol;
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
help: if this is a test module, consider adding a `#[cfg(test)]` to the containing module
  --> rustmath-symbolic/src/lib.rs:27:1
   |
27 | pub mod random_tests;
   | ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Weak`
 --> rustmath-symbolic/src/registry.rs:9:30
  |
9 | use std::sync::{Arc, RwLock, Weak};
  |                              ^^^^

warning: unused import: `UnaryOp`
 --> rustmath-symbolic/src/series.rs:5:41
  |
5 | use crate::expression::{BinaryOp, Expr, UnaryOp};
  |                                         ^^^^^^^

warning: unused import: `std::sync::Arc`
 --> rustmath-symbolic/src/series.rs:9:5
  |
9 | use std::sync::Arc;
  |     ^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-symbolic/src/specialfunctions/generalized.rs:33:40
   |
33 | use rustmath_core::{NumericConversion, Ring};
   |                                        ^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-symbolic/src/specialfunctions/generalized.rs:34:5
   |
34 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:38:5
   |
38 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-symbolic/src/specialfunctions/prime_pi.rs:29:40
   |
29 | use rustmath_core::{NumericConversion, Ring};
   |                                        ^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-symbolic/src/specialfunctions/prime_pi.rs:30:5
   |
30 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
   --> rustmath-symbolic/src/substitute.rs:348:9
    |
348 |     use std::f64::consts::PI;
    |         ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-symbolic/src/differentiate.rs:5:5
  |
5 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-symbolic/src/diffeq.rs:8:5
  |
8 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-symbolic/src/integrate.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `Ring`
 --> rustmath-symbolic/src/limits.rs:8:21
  |
8 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `Ring`
 --> rustmath-symbolic/src/series.rs:7:21
  |
7 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `rustmath_core::NumericConversion`
  --> rustmath-symbolic/src/specialfunctions/airy.rs:43:5
   |
43 | use rustmath_core::NumericConversion;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `NumericConversion`
  --> rustmath-symbolic/src/specialfunctions/generalized.rs:33:21
   |
33 | use rustmath_core::{NumericConversion, Ring};
   |                     ^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::NumericConversion`
  --> rustmath-symbolic/src/specialfunctions/min_max.rs:25:5
   |
25 | use rustmath_core::NumericConversion;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:37:40
   |
37 | use rustmath_core::{NumericConversion, Ring};
   |                                        ^^^^

warning: unused variable: `discriminant`
   --> rustmath-symbolic/src/diffeq.rs:332:13
    |
332 |         let discriminant = b.clone().pow(Expr::from(2))
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_discriminant`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `var`
   --> rustmath-symbolic/src/diffeq.rs:321:9
    |
321 |         var: &Symbol,
    |         ^^^ help: if this is intentional, prefix it with an underscore: `_var`

warning: unused variable: `dm_dy`
   --> rustmath-symbolic/src/diffeq.rs:351:13
    |
351 |         let dm_dy = m.differentiate(y_var);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dm_dy`

warning: unused variable: `dn_dx`
   --> rustmath-symbolic/src/diffeq.rs:352:13
    |
352 |         let dn_dx = n.differentiate(x_var);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dn_dx`

warning: unused variable: `degree`
   --> rustmath-symbolic/src/factor.rs:178:9
    |
178 |     let degree = degree.unwrap();
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `args`
  --> rustmath-symbolic/src/function.rs:23:26
   |
23 |     fn derivative(&self, args: &[Expr], arg_index: usize) -> Result<Expr, String> {
   |                          ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

warning: unused variable: `arg_index`
  --> rustmath-symbolic/src/function.rs:23:41
   |
23 |     fn derivative(&self, args: &[Expr], arg_index: usize) -> Result<Expr, String> {
   |                                         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_arg_index`

warning: unused variable: `initial_velocity`
   --> rustmath-symbolic/src/pde.rs:257:9
    |
257 |         initial_velocity: &Expr,
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_velocity`

warning: unused variable: `c2`
   --> rustmath-symbolic/src/specialfunctions/airy.rs:270:13
    |
270 |         let c2 = 0.258819403792807; // |Ai'(0)|
    |             ^^ help: if this is intentional, prefix it with an underscore: `_c2`

warning: function `expr_to_rational` is never used
    --> rustmath-symbolic/src/solve.rs:1535:4
     |
1535 | fn expr_to_rational(expr: &Expr) -> Option<Rational> {
     |    ^^^^^^^^^^^^^^^^
     |
     = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `expr_to_integer` is never used
    --> rustmath-symbolic/src/solve.rs:1562:4
     |
1562 | fn expr_to_integer(expr: &Expr) -> Option<i64> {
     |    ^^^^^^^^^^^^^^^

warning: function `try_expr_to_f64` is never used
  --> rustmath-symbolic/src/specialfunctions/other.rs:40:4
   |
40 | fn try_expr_to_f64(expr: &Expr) -> Option<f64> {
   |    ^^^^^^^^^^^^^^^

warning: variable `N` should have a snake case name
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:512:71
    |
512 | pub fn hahn_polynomial(n: &Expr, x: &Expr, alpha: &Expr, beta: &Expr, N: &Expr) -> Expr {
    |                                                                       ^ help: convert the identifier to snake case: `n`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `N` should have a snake case name
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:560:60
    |
560 | pub fn krawtchouk_polynomial(n: &Expr, x: &Expr, p: &Expr, N: &Expr) -> Expr {
    |                                                            ^ help: convert the identifier to snake case: `n`

warning: struct `BoundingBox3D` is never constructed
   --> rustmath-plot-core/src/bbox.rs:209:12
    |
209 | pub struct BoundingBox3D {
    |            ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: associated items `new`, `from_points`, `center`, `volume`, and `contains` are never used
   --> rustmath-plot-core/src/bbox.rs:220:12
    |
218 | impl BoundingBox3D {
    | ------------------ associated items in this implementation
219 |     /// Create a new 3D bounding box
220 |     pub fn new(xmin: f64, xmax: f64, ymin: f64, ymax: f64, zmin: f64, zmax: f64) -> Self {
    |            ^^^
...
236 |     pub fn from_points(points: &[Point3D]) -> Result<Self> {
    |            ^^^^^^^^^^^
...
270 |     pub fn center(&self) -> Point3D {
    |            ^^^^^^
...
279 |     pub fn volume(&self) -> f64 {
    |            ^^^^^^
...
284 |     pub fn contains(&self, point: &Point3D) -> bool {
    |            ^^^^^^^^

warning: `rustmath-matrix` (lib) generated 24 warnings (run `cargo fix --lib -p rustmath-matrix` to apply 10 suggestions)
warning: `rustmath-complex` (lib) generated 13 warnings (run `cargo fix --lib -p rustmath-complex` to apply 7 suggestions)
warning: `rustmath-finitefields` (lib) generated 1 warning
warning: `rustmath-symbolic` (lib) generated 50 warnings (run `cargo fix --lib -p rustmath-symbolic` to apply 27 suggestions)
warning: `rustmath-plot-core` (lib) generated 2 warnings
   Compiling rustmath-combinatorics v0.1.0 (/home/john/RustMath/rustmath-combinatorics)
warning: unexpected `cfg` condition value: `random`
   --> rustmath-graphs/src/generators/mod.rs:118:7
    |
118 | #[cfg(feature = "random")]
    |       ^^^^^^^^^^^^^^^^^^ help: remove the condition
    |
    = note: no expected values for `feature`
    = help: consider adding `random` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unnecessary parentheses around assigned value
   --> rustmath-graphs/src/generators/classical_geometries.rs:668:26
    |
668 |                 count *= (q2.pow((m - i) as u32) - 1);
    |                          ^                          ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
668 -                 count *= (q2.pow((m - i) as u32) - 1);
668 +                 count *= q2.pow((m - i) as u32) - 1;
    |

warning: unnecessary parentheses around assigned value
   --> rustmath-graphs/src/generators/classical_geometries.rs:669:26
    |
669 |                 count /= (q2.pow((i + 1) as u32) - 1);
    |                          ^                          ^
    |
help: remove these parentheses
    |
669 -                 count /= (q2.pow((i + 1) as u32) - 1);
669 +                 count /= q2.pow((i + 1) as u32) - 1;
    |

warning: unnecessary parentheses around `if` condition
   --> rustmath-graphs/src/generators/distance_regular.rs:742:16
    |
742 |             if (i % (s + 1) == j % (s + 1)) {
    |                ^                          ^
    |
help: remove these parentheses
    |
742 -             if (i % (s + 1) == j % (s + 1)) {
742 +             if i % (s + 1) == j % (s + 1) {
    |

warning: unnecessary parentheses around `if` condition
   --> rustmath-graphs/src/generators/distance_regular.rs:774:16
    |
774 |             if (i % (s + 1) == j % (s + 1)) {
    |                ^                          ^
    |
help: remove these parentheses
    |
774 -             if (i % (s + 1) == j % (s + 1)) {
774 +             if i % (s + 1) == j % (s + 1) {
    |

warning: unused imports: `HashMap`, `HashSet`, and `VecDeque`
 --> rustmath-graphs/src/generators/families.rs:7:24
  |
7 | use std::collections::{HashMap, HashSet, VecDeque};
  |                        ^^^^^^^  ^^^^^^^  ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `HashMap`
 --> rustmath-graphs/src/generators/intersection.rs:8:24
  |
8 | use std::collections::{HashMap, HashSet};
  |                        ^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-graphs/src/generators/yang_baxter.rs:10:33
   |
10 | use std::collections::{HashMap, HashSet, VecDeque};
   |                                 ^^^^^^^

warning: unused imports: `BinaryHeap` and `HashMap`
  --> rustmath-graphs/src/boost_graph.rs:16:24
   |
16 | use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};
   |                        ^^^^^^^^^^  ^^^^^^^

warning: unused imports: `Ordering` and `Reverse`
  --> rustmath-graphs/src/boost_graph.rs:17:16
   |
17 | use std::cmp::{Ordering, Reverse};
   |                ^^^^^^^^  ^^^^^^^

warning: unused import: `std::collections::HashSet`
 --> rustmath-graphs/src/backends/generic_backend.rs:5:5
  |
5 | use std::collections::HashSet;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::c_graph::CGraphBackend`
 --> rustmath-graphs/src/backends/dense_graph.rs:5:5
  |
5 | use super::c_graph::CGraphBackend;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `super::c_graph::CGraphBackend`
 --> rustmath-graphs/src/backends/static_sparse_backend.rs:8:5
  |
8 | use super::c_graph::CGraphBackend;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
 --> rustmath-graphs/src/cographs.rs:9:24
  |
9 | use std::collections::{HashSet, HashMap};
  |                        ^^^^^^^  ^^^^^^^

warning: unused import: `HashSet`
 --> rustmath-graphs/src/comparability.rs:8:33
  |
8 | use std::collections::{HashMap, HashSet};
  |                                 ^^^^^^^

warning: unused import: `HashSet`
 --> rustmath-graphs/src/distances_all_pairs.rs:6:33
  |
6 | use std::collections::{HashMap, HashSet, VecDeque};
  |                                 ^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-graphs/src/planarity.rs:15:33
   |
15 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-graphs/src/weakly_chordal.rs:12:24
   |
12 | use std::collections::{HashSet, VecDeque};
   |                        ^^^^^^^

warning: unused import: `VecDeque`
  --> rustmath-graphs/src/traversals.rs:11:24
   |
11 | use std::collections::{VecDeque, HashSet};
   |                        ^^^^^^^^

warning: unused import: `std::collections::HashSet`
 --> rustmath-graphs/src/ramsey.rs:9:5
  |
9 | use std::collections::HashSet;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unnecessary parentheses around block return value
   --> rustmath-graphs/src/ramsey.rs:219:5
    |
219 |     (s + t - 2)
    |     ^         ^
    |
help: remove these parentheses
    |
219 -     (s + t - 2)
219 +     s + t - 2
    |

warning: unused variable: `vertex_map`
    --> rustmath-graphs/src/graph.rs:1585:9
     |
1585 |     let vertex_map: Vec<usize> = (0..n)
     |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vertex_map`
     |
     = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `alpha`
   --> rustmath-graphs/src/generators/distance_regular.rs:921:60
    |
921 | pub fn graph_with_classical_parameters(d: usize, b: usize, alpha: i32, beta: i32) -> Graph {
    |                                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`

warning: unused variable: `beta`
   --> rustmath-graphs/src/generators/distance_regular.rs:921:72
    |
921 | pub fn graph_with_classical_parameters(d: usize, b: usize, alpha: i32, beta: i32) -> Graph {
    |                                                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: variable does not need to be mutable
   --> rustmath-graphs/src/generators/families.rs:651:9
    |
651 |     let mut g = biwheel_graph(n);
    |         ----^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `r`
   --> rustmath-graphs/src/generators/families.rs:946:35
    |
946 | pub fn fuzzy_ball_graph(n: usize, r: usize) -> Graph {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_r`

warning: unused variable: `graph`
  --> rustmath-graphs/src/cographs.rs:65:19
   |
65 | pub fn find_pivot(graph: &Graph, vertices: &[usize]) -> Option<usize> {
   |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_graph`

warning: unused variable: `current`
  --> rustmath-graphs/src/cographs.rs:75:18
   |
75 | pub fn next_tree(current: &CoTree) -> Option<CoTree> {
   |                  ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_current`

warning: unused variable: `count`
   --> rustmath-graphs/src/convexity_properties.rs:241:17
    |
241 |         let mut count = 0;
    |                 ^^^^^ help: if this is intentional, prefix it with an underscore: `_count`

warning: variable does not need to be mutable
   --> rustmath-graphs/src/convexity_properties.rs:241:13
    |
241 |         let mut count = 0;
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `start`
   --> rustmath-graphs/src/planarity.rs:166:30
    |
166 |     fn new(graph: &'a Graph, start: usize, visited: &'a mut Vec<bool>) -> Self {
    |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `n`
   --> rustmath-graphs/src/automorphisms.rs:109:20
    |
109 |     pub fn trivial(n: usize) -> Self {
    |                    ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: variable does not need to be mutable
   --> rustmath-graphs/src/automorphisms.rs:181:13
    |
181 |         let mut degrees: Vec<usize> = (0..n)
    |             ----^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `old_num_colors`
   --> rustmath-graphs/src/automorphisms.rs:234:17
    |
234 |             let old_num_colors = self.num_colors;
    |                 ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_old_num_colors`

warning: variable does not need to be mutable
   --> rustmath-graphs/src/automorphisms.rs:358:9
    |
358 |     let mut aut_group = automorphisms(g);
    |         ----^^^^^^^^^
    |         |
    |         help: remove this `mut`

warning: field `start` is never read
   --> rustmath-graphs/src/backends/c_graph.rs:218:5
    |
212 | pub struct SearchIterator {
    |            -------------- field in this struct
...
218 |     start: usize,
    |     ^^^^^
    |
    = note: `SearchIterator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `graph` is never read
  --> rustmath-graphs/src/edge_connectivity.rs:21:5
   |
19 | pub struct GabowEdgeConnectivity {
   |            --------------------- field in this struct
20 |     /// The directed graph to analyze
21 |     graph: DiGraph,
   |     ^^^^^

warning: method `is_descendant` is never used
   --> rustmath-graphs/src/planarity.rs:243:8
    |
165 | impl<'a> DfsTree<'a> {
    | -------------------- method in this implementation
...
243 |     fn is_descendant(&self, v: usize, ancestor: usize) -> bool {
    |        ^^^^^^^^^^^^^

warning: associated function `trivial` is never used
   --> rustmath-graphs/src/automorphisms.rs:171:8
    |
169 | impl ColorPartition {
    | ------------------- associated function in this implementation
170 |     /// Create initial partition with all vertices having the same color
171 |     fn trivial(n: usize) -> Self {
    |        ^^^^^^^

warning: function `lex_BFS` should have a snake case name
  --> rustmath-graphs/src/traversals.rs:41:8
   |
41 | pub fn lex_BFS(graph: &Graph, start: Option<usize>) -> Vec<usize> {
   |        ^^^^^^^ help: convert the identifier to snake case: `lex_bfs`
   |
   = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: function `lex_DFS` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:130:8
    |
130 | pub fn lex_DFS(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^^^ help: convert the identifier to snake case: `lex_dfs`

warning: function `lex_UP` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:193:8
    |
193 | pub fn lex_UP(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^^ help: convert the identifier to snake case: `lex_up`

warning: function `lex_DOWN` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:212:8
    |
212 | pub fn lex_DOWN(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^^^^ help: convert the identifier to snake case: `lex_down`

warning: function `lex_M` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:231:8
    |
231 | pub fn lex_M(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^ help: convert the identifier to snake case: `lex_m`

warning: function `lex_M_fast` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:248:8
    |
248 | pub fn lex_M_fast(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^^^^^^ help: convert the identifier to snake case: `lex_m_fast`

warning: function `lex_M_slow` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:313:8
    |
313 | pub fn lex_M_slow(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^^^^^^ help: convert the identifier to snake case: `lex_m_slow`

warning: function `is_valid_lex_M_order` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:331:8
    |
331 | pub fn is_valid_lex_M_order(graph: &Graph, order: &[usize]) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_valid_lex_m_order`

warning: function `maximum_cardinality_search_M` should have a snake case name
   --> rustmath-graphs/src/traversals.rs:443:8
    |
443 | pub fn maximum_cardinality_search_M(graph: &Graph, start: Option<usize>) -> Vec<usize> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `maximum_cardinality_search_m`

warning: function `is_mathon_PC_srg` should have a snake case name
  --> rustmath-graphs/src/strongly_regular_db.rs:75:8
   |
75 | pub fn is_mathon_PC_srg(params: &SRGParameters) -> bool {
   |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_mathon_pc_srg`

warning: function `is_muzychuk_S6` should have a snake case name
  --> rustmath-graphs/src/strongly_regular_db.rs:81:8
   |
81 | pub fn is_muzychuk_S6(params: &SRGParameters) -> bool {
   |        ^^^^^^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `is_muzychuk_s6`

warning: function `is_NO_F2` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:140:8
    |
140 | pub fn is_NO_F2(params: &SRGParameters) -> bool {
    |        ^^^^^^^^ help: convert the identifier to snake case: `is_no_f2`

warning: function `is_NO_F3` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:146:8
    |
146 | pub fn is_NO_F3(params: &SRGParameters) -> bool {
    |        ^^^^^^^^ help: convert the identifier to snake case: `is_no_f3`

warning: function `is_NOodd` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:151:8
    |
151 | pub fn is_NOodd(params: &SRGParameters) -> bool {
    |        ^^^^^^^^ help: convert the identifier to snake case: `is_noodd`

warning: function `is_NOperp_F5` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:156:8
    |
156 | pub fn is_NOperp_F5(params: &SRGParameters) -> bool {
    |        ^^^^^^^^^^^^ help: convert the identifier to snake case: `is_noperp_f5`

warning: function `is_NU` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:161:8
    |
161 | pub fn is_NU(params: &SRGParameters) -> bool {
    |        ^^^^^ help: convert the identifier to snake case: `is_nu`

warning: function `is_RSHCD` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:194:8
    |
194 | pub fn is_RSHCD(params: &SRGParameters) -> bool {
    |        ^^^^^^^^ help: convert the identifier to snake case: `is_rshcd`

warning: function `SRG_from_RSHCD` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:200:8
    |
200 | pub fn SRG_from_RSHCD(_n: usize, _e: i32) -> Option<Graph> {
    |        ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_from_rshcd`

warning: function `is_GQqmqp` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:206:8
    |
206 | pub fn is_GQqmqp(params: &SRGParameters) -> bool {
    |        ^^^^^^^^^ help: convert the identifier to snake case: `is_gqqmqp`

warning: function `is_switch_OA_srg` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:227:8
    |
227 | pub fn is_switch_OA_srg(params: &SRGParameters) -> bool {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_switch_oa_srg`

warning: function `SRG_100_44_18_20` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:277:8
    |
277 | pub fn SRG_100_44_18_20() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_100_44_18_20`

warning: function `SRG_100_45_20_20` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:282:8
    |
282 | pub fn SRG_100_45_20_20() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_100_45_20_20`

warning: function `SRG_105_32_4_12` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:286:8
    |
286 | pub fn SRG_105_32_4_12() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_105_32_4_12`

warning: function `SRG_120_63_30_36` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:290:8
    |
290 | pub fn SRG_120_63_30_36() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_120_63_30_36`

warning: function `SRG_120_77_52_44` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:294:8
    |
294 | pub fn SRG_120_77_52_44() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_120_77_52_44`

warning: function `SRG_126_25_8_4` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:298:8
    |
298 | pub fn SRG_126_25_8_4() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_126_25_8_4`

warning: function `SRG_126_50_13_24` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:302:8
    |
302 | pub fn SRG_126_50_13_24() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_126_50_13_24`

warning: function `SRG_1288_792_476_504` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:306:8
    |
306 | pub fn SRG_1288_792_476_504() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_1288_792_476_504`

warning: function `SRG_144_39_6_12` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:310:8
    |
310 | pub fn SRG_144_39_6_12() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_144_39_6_12`

warning: function `SRG_175_72_20_36` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:314:8
    |
314 | pub fn SRG_175_72_20_36() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_175_72_20_36`

warning: function `SRG_176_105_68_54` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:318:8
    |
318 | pub fn SRG_176_105_68_54() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_176_105_68_54`

warning: function `SRG_176_49_12_14` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:322:8
    |
322 | pub fn SRG_176_49_12_14() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_176_49_12_14`

warning: function `SRG_176_90_38_54` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:326:8
    |
326 | pub fn SRG_176_90_38_54() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_176_90_38_54`

warning: function `SRG_196_91_42_42` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:330:8
    |
330 | pub fn SRG_196_91_42_42() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_196_91_42_42`

warning: function `SRG_210_99_48_45` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:334:8
    |
334 | pub fn SRG_210_99_48_45() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_210_99_48_45`

warning: function `SRG_220_84_38_28` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:338:8
    |
338 | pub fn SRG_220_84_38_28() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_220_84_38_28`

warning: function `SRG_243_110_37_60` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:342:8
    |
342 | pub fn SRG_243_110_37_60() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_243_110_37_60`

warning: function `SRG_253_140_87_65` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:346:8
    |
346 | pub fn SRG_253_140_87_65() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_253_140_87_65`

warning: function `SRG_276_140_58_84` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:350:8
    |
350 | pub fn SRG_276_140_58_84() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_276_140_58_84`

warning: function `SRG_280_117_44_52` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:354:8
    |
354 | pub fn SRG_280_117_44_52() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_280_117_44_52`

warning: function `SRG_280_135_70_60` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:358:8
    |
358 | pub fn SRG_280_135_70_60() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_280_135_70_60`

warning: function `SRG_416_100_36_20` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:362:8
    |
362 | pub fn SRG_416_100_36_20() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_416_100_36_20`

warning: function `SRG_560_208_72_80` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:366:8
    |
366 | pub fn SRG_560_208_72_80() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_560_208_72_80`

warning: function `SRG_630_85_20_10` should have a snake case name
   --> rustmath-graphs/src/strongly_regular_db.rs:370:8
    |
370 | pub fn SRG_630_85_20_10() -> Option<Graph> {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `srg_630_85_20_10`

warning: unused import: `EuclideanDomain`
  --> rustmath-numberfields/src/lib.rs:24:21
   |
24 | use rustmath_core::{EuclideanDomain, NumericConversion, Ring};
   |                     ^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: `rustmath-graphs` (lib) generated 83 warnings (run `cargo fix --lib -p rustmath-graphs` to apply 24 suggestions)
warning: `rustmath-numberfields` (lib) generated 1 warning (run `cargo fix --lib -p rustmath-numberfields` to apply 1 suggestion)
   Compiling rustmath-rings v0.1.0 (/home/john/RustMath/rustmath-rings)
warning: unused import: `std::f64::consts::PI`
 --> rustmath-geometry/src/polygon.rs:4:5
  |
4 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::collections::HashSet`
 --> rustmath-geometry/src/triangulation.rs:4:5
  |
4 | use std::collections::HashSet;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-geometry/src/toric.rs:15:26
   |
15 | use std::ops::{Add, Sub, Mul};
   |                          ^^^

warning: unnecessary parentheses around block return value
   --> rustmath-geometry/src/toric.rs:911:9
    |
911 |         (sum.abs() / 2.0)
    |         ^               ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
911 -         (sum.abs() / 2.0)
911 +         sum.abs() / 2.0
    |

warning: unused import: `std::hash::Hash`
  --> rustmath-geometry/src/convex_set.rs:14:5
   |
14 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `std::cmp::Ordering`
  --> rustmath-geometry/src/newton_polygon.rs:20:5
   |
20 | use std::cmp::Ordering;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-geometry/src/integral_points.rs:20:5
   |
20 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `Inequality_generic` should have an upper camel case name
   --> rustmath-geometry/src/integral_points.rs:328:12
    |
328 | pub struct Inequality_generic {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `InequalityGeneric`
    |
    = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: type `Inequality_int` should have an upper camel case name
   --> rustmath-geometry/src/integral_points.rs:443:12
    |
443 | pub struct Inequality_int {
    |            ^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `InequalityInt`

warning: unused import: `crate::point::Point2D`
  --> rustmath-geometry/src/hyperplane_arrangement/plot.rs:18:5
   |
18 | use crate::point::Point2D;
   |     ^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-geometry/src/hyperplane_arrangement/plot.rs:19:5
   |
19 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-geometry/src/hyperplane_arrangement/plot.rs:20:5
   |
20 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-geometry/src/lattice_polytope.rs:24:5
   |
24 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `n`
   --> rustmath-geometry/src/hyperplane_arrangement/check_freeness.rs:219:9
    |
219 |     let n = hyperplanes.len();
    |         ^ help: if this is intentional, prefix it with an underscore: `_n`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `obj`
   --> rustmath-geometry/src/lattice_polytope.rs:540:28
    |
540 | pub fn is_lattice_polytope(obj: &LatticePolytopeClass) -> bool {
    |                            ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: associated function `empty` is never used
  --> rustmath-geometry/src/hyperplane_arrangement/arrangement.rs:88:8
   |
42 | impl<R: Ring> HyperplaneArrangementElement<R> {
   | --------------------------------------------- associated function in this implementation
...
88 |     fn empty(ambient_dim: usize) -> Self {
   |        ^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

   Compiling rustmath-ellipticcurves v0.1.0 (/home/john/RustMath/rustmath-ellipticcurves)
warning: unused import: `rustmath_integers::Integer`
  --> rustmath-numbertheory/src/bernoulli.rs:46:5
   |
46 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `num_bigint::BigInt`
  --> rustmath-numbertheory/src/bernoulli.rs:48:5
   |
48 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `FromPrimitive`
  --> rustmath-numbertheory/src/bernoulli.rs:49:31
   |
49 | use num_traits::{ToPrimitive, FromPrimitive};
   |                               ^^^^^^^^^^^^^

warning: unused import: `ToPrimitive`
  --> rustmath-numbertheory/src/bernoulli.rs:49:18
   |
49 | use num_traits::{ToPrimitive, FromPrimitive};
   |                  ^^^^^^^^^^^

warning: value assigned to `count` is never read
   --> rustmath-numbertheory/src/quadratic_forms.rs:432:17
    |
432 |         let mut count = Integer::zero();
    |                 ^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: creating a shared reference to mutable static
  --> rustmath-numbertheory/src/bernoulli.rs:89:12
   |
89 |         if CACHE.is_none() {
   |            ^^^^^^^^^^^^^^^ shared reference to mutable static
   |
   = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>
   = note: shared references to mutable statics are dangerous; it's undefined behavior if the static is mutated or if a mutable reference is created for it while the shared reference lives
   = note: `#[warn(static_mut_refs)]` (part of `#[warn(rust_2024_compatibility)]`) on by default

warning: creating a mutable reference to mutable static
  --> rustmath-numbertheory/src/bernoulli.rs:93:21
   |
93 |         let cache = CACHE.as_mut().unwrap();
   |                     ^^^^^^^^^^^^^^ mutable reference to mutable static
   |
   = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>
   = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives

warning: creating a mutable reference to mutable static
   --> rustmath-numbertheory/src/bernoulli.rs:126:9
    |
126 |         CACHE.as_mut().unwrap().insert(n, result.clone());
    |         ^^^^^^^^^^^^^^ mutable reference to mutable static
    |
    = note: for more information, see <https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html>
    = note: mutable references to mutable statics are dangerous; it's undefined behavior if any other pointer to the static is used or if any other reference is created for the static while the mutable reference lives

   Compiling rustmath-dynamics v0.1.0 (/home/john/RustMath/rustmath-dynamics)
   Compiling rustmath-special-functions v0.1.0 (/home/john/RustMath/rustmath-special-functions)
   Compiling rustmath-manifolds v0.1.0 (/home/john/RustMath/rustmath-manifolds)
   Compiling rustmath-calculus v0.1.0 (/home/john/RustMath/rustmath-calculus)
   Compiling rustmath-modular v0.1.0 (/home/john/RustMath/rustmath-modular)
   Compiling rustmath-algebraic v0.1.0 (/home/john/RustMath/rustmath-algebraic)
warning: `rustmath-geometry` (lib) generated 16 warnings (run `cargo fix --lib -p rustmath-geometry` to apply 11 suggestions)
warning: `rustmath-numbertheory` (lib) generated 8 warnings (run `cargo fix --lib -p rustmath-numbertheory` to apply 3 suggestions)
warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/quadratic_form.rs:6:27
  |
6 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `Ord` and `Ordering`
 --> rustmath-quadraticforms/src/quadratic_form.rs:8:16
  |
8 | use std::cmp::{Ord, Ordering};
  |                ^^^  ^^^^^^^^

warning: unused import: `EuclideanDomain`
 --> rustmath-quadraticforms/src/local_densities.rs:9:46
  |
9 | use rustmath_core::{Ring, NumericConversion, EuclideanDomain};
  |                                              ^^^^^^^^^^^^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/genus_theory.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/advanced.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/advanced.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused variable: `d`
  --> rustmath-quadraticforms/src/local_densities.rs:83:13
   |
83 |         let d = (-self.form.discriminant()).clone();
   |             ^ help: if this is intentional, prefix it with an underscore: `_d`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p_power`
   --> rustmath-quadraticforms/src/local_densities.rs:173:13
    |
173 |         let p_power = p_int.pow(k);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_p_power`

warning: unused variable: `n3`
  --> rustmath-quadraticforms/src/advanced.rs:96:42
   |
96 |             if let [(n1, a1), (n2, a2), (n3, a3)] = window {
   |                                          ^^ help: if this is intentional, prefix it with an underscore: `_n3`

warning: method `p_adic_equivalent` is never used
   --> rustmath-quadraticforms/src/genus_theory.rs:189:8
    |
 18 | impl GenusTheory {
    | ---------------- method in this implementation
...
189 |     fn p_adic_equivalent(&self, form1: &QuadraticForm, form2: &QuadraticForm, p: u64) -> bool {
    |        ^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/arc.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/arrow.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/circle.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/disk.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/line.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/point.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/polygon.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/primitives/text.rs:5:5
  |
5 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Color` and `LineStyle`
  --> rustmath-plot/src/primitives/bezier_path.rs:24:18
   |
24 |     BoundingBox, Color, GraphicPrimitive, LineStyle, PlotOptions, Point2D, Renderable,
   |                  ^^^^^                    ^^^^^^^^^

warning: unused import: `Color`
 --> rustmath-plot/src/primitives/hyperbolic/hyperbolic_polygon.rs:6:18
  |
6 |     BoundingBox, Color, GraphicPrimitive, PlotOptions, Point2D, Renderable, RenderBackend, Result,
  |                  ^^^^^

warning: unnecessary parentheses around assigned value
  --> rustmath-plot/src/primitives/hyperbolic/mod.rs:34:21
   |
34 |         let denom = (x * x + (y + 1.0) * (y + 1.0));
   |                     ^                             ^
   |
   = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
   |
34 -         let denom = (x * x + (y + 1.0) * (y + 1.0));
34 +         let denom = x * x + (y + 1.0) * (y + 1.0);
   |

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/plots/plot.rs:8:5
  |
8 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Point2D` and `Result`
 --> rustmath-plot/src/plots/plot.rs:9:39
  |
9 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                       ^^^^^^^  ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/parametric_plot.rs:7:48
  |
7 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/list_plot.rs:7:48
  |
7 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/scatter_plot.rs:8:61
  |
8 | use rustmath_plot_core::{MarkerStyle, PlotOptions, Point2D, Result};
  |                                                             ^^^^^^

warning: unused import: `Color`
 --> rustmath-plot/src/plots/contour_plot.rs:7:23
  |
7 | use rustmath_colors::{Color, Colormap};
  |                       ^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/contour_plot.rs:8:48
  |
8 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/density_plot.rs:9:48
  |
9 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/histogram.rs:7:48
  |
7 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/bar_chart.rs:8:48
  |
8 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/matrix_plot.rs:9:48
  |
9 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused import: `rustmath_colors::Color`
 --> rustmath-plot/src/plots/implicit_plot.rs:7:5
  |
7 | use rustmath_colors::Color;
  |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Result`
 --> rustmath-plot/src/plots/implicit_plot.rs:8:48
  |
8 | use rustmath_plot_core::{PlotOptions, Point2D, Result};
  |                                                ^^^^^^

warning: unused variable: `path`
   --> rustmath-plot/src/animation.rs:207:24
    |
207 |     fn save_gif(&self, path: &Path, options: &AnimationOptions) -> Result<()> {
    |                        ^^^^ help: if this is intentional, prefix it with an underscore: `_path`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `options`
   --> rustmath-plot/src/animation.rs:207:37
    |
207 |     fn save_gif(&self, path: &Path, options: &AnimationOptions) -> Result<()> {
    |                                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `path`
   --> rustmath-plot/src/animation.rs:219:25
    |
219 |     fn save_apng(&self, path: &Path, options: &AnimationOptions) -> Result<()> {
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_path`

warning: unused variable: `options`
   --> rustmath-plot/src/animation.rs:219:38
    |
219 |     fn save_apng(&self, path: &Path, options: &AnimationOptions) -> Result<()> {
    |                                      ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `path`
   --> rustmath-plot/src/animation.rs:227:26
    |
227 |     fn save_video(&self, path: &Path, format: &str, options: &AnimationOptions) -> Result<()> {
    |                          ^^^^ help: if this is intentional, prefix it with an underscore: `_path`

warning: unused variable: `options`
   --> rustmath-plot/src/animation.rs:227:53
    |
227 |     fn save_video(&self, path: &Path, format: &str, options: &AnimationOptions) -> Result<()> {
    |                                                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `tolerance`
   --> rustmath-plot/src/primitives/bezier_path.rs:235:77
    |
235 |     fn arc_length_cubic(p0: Point2D, p1: Point2D, p2: Point2D, p3: Point2D, tolerance: f64) -> f64 {
    |                                                                             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tolerance`

warning: unused variable: `tolerance`
   --> rustmath-plot/src/primitives/bezier_path.rs:254:68
    |
254 |     fn arc_length_quadratic(p0: Point2D, p1: Point2D, p2: Point2D, tolerance: f64) -> f64 {
    |                                                                    ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tolerance`

warning: unused variable: `colormap`
   --> rustmath-plot/src/plots/contour_plot.rs:127:5
    |
127 |     colormap: Option<Colormap>,
    |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_colormap`

warning: unused variable: `colormap`
  --> rustmath-plot/src/plots/density_plot.rs:55:5
   |
55 |     colormap: Option<Colormap>,
   |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_colormap`

warning: unused variable: `options`
  --> rustmath-plot/src/plots/density_plot.rs:56:5
   |
56 |     options: Option<PlotOptions>,
   |     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `options`
   --> rustmath-plot/src/plots/density_plot.rs:160:5
    |
160 |     options: Option<PlotOptions>,
    |     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `cols`
  --> rustmath-plot/src/plots/matrix_plot.rs:54:9
   |
54 |     let cols = matrix[0].len();
   |         ^^^^ help: if this is intentional, prefix it with an underscore: `_cols`

warning: unused variable: `colormap`
  --> rustmath-plot/src/plots/matrix_plot.rs:46:5
   |
46 |     colormap: Option<Colormap>,
   |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_colormap`

warning: unused variable: `options`
  --> rustmath-plot/src/plots/matrix_plot.rs:47:5
   |
47 |     options: Option<PlotOptions>,
   |     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `cols`
   --> rustmath-plot/src/plots/matrix_plot.rs:131:9
    |
131 |     let cols = matrix[0].len();
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_cols`

warning: unused variable: `colormap`
   --> rustmath-plot/src/plots/matrix_plot.rs:123:5
    |
123 |     colormap: Option<Colormap>,
    |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_colormap`

warning: unused variable: `options`
   --> rustmath-plot/src/plots/matrix_plot.rs:124:5
    |
124 |     options: Option<PlotOptions>,
    |     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_options`

warning: unused variable: `cols`
   --> rustmath-plot/src/plots/matrix_plot.rs:183:9
    |
183 |     let cols = matrix[0].len();
    |         ^^^^ help: if this is intentional, prefix it with an underscore: `_cols`

warning: unused variable: `primitive`
   --> rustmath-plot/src/plots/implicit_plot.rs:165:13
    |
165 |         for primitive in curve.primitives() {
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_primitive`

warning: variable does not need to be mutable
   --> rustmath-plot/src/plots/implicit_plot.rs:160:9
    |
160 |     let mut g = Graphics::new();
    |         ----^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: fields `width` and `height` are never read
  --> rustmath-plot/src/backends/svg_backend.rs:25:5
   |
20 | pub struct SvgBackend {
   |            ---------- fields in this struct
...
25 |     width: f64,
   |     ^^^^^
...
28 |     height: f64,
   |     ^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `plot_multiple` is never used
  --> rustmath-plot/src/plots/plot.rs:96:8
   |
96 | pub fn plot_multiple<F>(
   |        ^^^^^^^^^^^^^

warning: function `parametric_plot_adaptive` is never used
   --> rustmath-plot/src/plots/parametric_plot.rs:111:8
    |
111 | pub fn parametric_plot_adaptive<F, G>(
    |        ^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `list_plot_y` is never used
  --> rustmath-plot/src/plots/list_plot.rs:91:8
   |
91 | pub fn list_plot_y(
   |        ^^^^^^^^^^^

warning: function `list_plot_multiple` is never used
   --> rustmath-plot/src/plots/list_plot.rs:137:8
    |
137 | pub fn list_plot_multiple(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `scatter_plot_y` is never used
  --> rustmath-plot/src/plots/scatter_plot.rs:77:8
   |
77 | pub fn scatter_plot_y(
   |        ^^^^^^^^^^^^^^

warning: function `scatter_plot_colored` is never used
   --> rustmath-plot/src/plots/scatter_plot.rs:116:8
    |
116 | pub fn scatter_plot_colored(
    |        ^^^^^^^^^^^^^^^^^^^^

warning: function `scatter_plot_sized` is never used
   --> rustmath-plot/src/plots/scatter_plot.rs:160:8
    |
160 | pub fn scatter_plot_sized(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `contour_plot_filled` is never used
   --> rustmath-plot/src/plots/contour_plot.rs:122:8
    |
122 | pub fn contour_plot_filled<F>(
    |        ^^^^^^^^^^^^^^^^^^^

warning: function `density_plot_custom` is never used
   --> rustmath-plot/src/plots/density_plot.rs:154:8
    |
154 | pub fn density_plot_custom<F, C>(
    |        ^^^^^^^^^^^^^^^^^^^

warning: function `histogram_custom_bins` is never used
   --> rustmath-plot/src/plots/histogram.rs:132:8
    |
132 | pub fn histogram_custom_bins(
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: function `bar_chart_horizontal` is never used
  --> rustmath-plot/src/plots/bar_chart.rs:77:8
   |
77 | pub fn bar_chart_horizontal(
   |        ^^^^^^^^^^^^^^^^^^^^

warning: function `bar_chart_colored` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:122:8
    |
122 | pub fn bar_chart_colored(data: Vec<(f64, f64, Color)>, bar_width: Option<f64>) -> Graphics {
    |        ^^^^^^^^^^^^^^^^^

warning: function `bar_chart_grouped` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:166:8
    |
166 | pub fn bar_chart_grouped(
    |        ^^^^^^^^^^^^^^^^^

warning: function `bar_chart_stacked` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:232:8
    |
232 | pub fn bar_chart_stacked(data: Vec<(f64, Vec<f64>, Vec<Color>)>, bar_width: Option<f64>) -> Graphics {
    |        ^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_range` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:119:8
    |
119 | pub fn matrix_plot_range(
    |        ^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_binary` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:173:8
    |
173 | pub fn matrix_plot_binary(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_spy` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:222:8
    |
222 | pub fn matrix_plot_spy(matrix: Vec<Vec<f64>>, threshold: Option<f64>, color: Color) -> Graphics {
    |        ^^^^^^^^^^^^^^^

   Compiling rustmath-plot3d v0.1.0 (/home/john/RustMath/rustmath-plot3d)
   Compiling rustmath-numerical v0.1.0 (/home/john/RustMath/rustmath-numerical)
   Compiling rustmath-functions v0.1.0 (/home/john/RustMath/rustmath-functions)
warning: unused import: `std::convert::TryInto`
 --> rustmath-crypto/src/authenticated.rs:6:5
  |
6 | use std::convert::TryInto;
  |     ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `text`
   --> rustmath-crypto/src/classical.rs:212:21
    |
212 | pub fn hill_decrypt(text: &str, key_matrix: &Matrix<Integer>) -> Result<String> {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_text`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `key_matrix`
   --> rustmath-crypto/src/classical.rs:212:33
    |
212 | pub fn hill_decrypt(text: &str, key_matrix: &Matrix<Integer>) -> Result<String> {
    |                                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_key_matrix`

warning: variable does not need to be mutable
   --> rustmath-crypto/src/des.rs:162:13
    |
162 |         let mut key_state = Self::permute(key, &Self::PC1, 64);
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-crypto/src/des.rs:239:13
    |
239 |         let mut state = Self::permute(plaintext, &Self::IP, 64);
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> rustmath-crypto/src/des.rs:263:13
    |
263 |         let mut state = Self::permute(ciphertext, &Self::IP, 64);
    |             ----^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
  --> rustmath-crypto/src/kdf.rs:47:17
   |
47 |             let mut block = Self::derive_block(password, salt, iterations, block_num as u32);
   |                 ----^^^^^
   |                 |
   |                 help: remove this `mut`

warning: variable does not need to be mutable
   --> rustmath-crypto/src/kdf.rs:184:13
    |
184 |         let mut final_block = memory[memory_blocks - 1].clone();
    |             ----^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `j`
   --> rustmath-crypto/src/kdf.rs:213:17
    |
213 |             for j in 0..32 {
    |                 ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `challenge`
   --> rustmath-crypto/src/eddsa.rs:351:13
    |
351 |         let challenge = SHA256::hash(&challenge_input);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_challenge`

warning: unused variable: `s_point`
   --> rustmath-crypto/src/eddsa.rs:358:13
    |
358 |         let s_point = basepoint.scalar_mul(&signature.s);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_s_point`

warning: unused variable: `r_point`
   --> rustmath-crypto/src/eddsa.rs:359:13
    |
359 |         let r_point = basepoint.scalar_mul(&signature.r);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_r_point`

warning: unused variable: `verify_hash`
   --> rustmath-crypto/src/eddsa.rs:367:13
    |
367 |         let verify_hash = SHA256::hash(&verify_input);
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_verify_hash`

warning: associated function `quarter_round` is never used
   --> rustmath-crypto/src/stream_cipher.rs:144:8
    |
 88 | impl ChaCha20 {
    | ------------- associated function in this implementation
...
144 |     fn quarter_round(a: &mut u32, b: &mut u32, c: &mut u32, d: &mut u32) {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: associated items `P`, `from_bytes`, and `mul_small` are never used
   --> rustmath-crypto/src/eddsa.rs:52:11
    |
 50 | impl FieldElement {
    | ----------------- associated items in this implementation
 51 |     /// Prime for Curve25519: 2^255 - 19
 52 |     const P: [u64; 5] = [
    |           ^
...
 69 |     fn from_bytes(bytes: &[u8; 32]) -> Self {
    |        ^^^^^^^^^^
...
122 |     fn mul_small(&self, scalar: u64) -> FieldElement {
    |        ^^^^^^^^^

warning: unused import: `rustmath_finitefields::prime_field::PrimeField`
 --> rustmath-coding/src/linear_code.rs:5:5
  |
5 | use rustmath_finitefields::prime_field::PrimeField;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_matrix::matrix::Matrix`
 --> rustmath-coding/src/linear_code.rs:6:5
  |
6 | use rustmath_matrix::matrix::Matrix;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_finitefields::prime_field::PrimeField`
 --> rustmath-coding/src/hamming.rs:9:5
  |
9 | use rustmath_finitefields::prime_field::PrimeField;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_finitefields::prime_field::PrimeField`
 --> rustmath-coding/src/reed_solomon.rs:9:5
  |
9 | use rustmath_finitefields::prime_field::PrimeField;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_polynomials::univariate::UnivariatePolynomial`
  --> rustmath-coding/src/reed_solomon.rs:10:5
   |
10 | use rustmath_polynomials::univariate::UnivariatePolynomial;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-coding/src/reed_solomon.rs:11:5
   |
11 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `PrimeField`
 --> rustmath-coding/src/bch.rs:7:42
  |
7 | use rustmath_finitefields::prime_field::{PrimeField};
  |                                          ^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-coding/src/bch.rs:8:5
  |
8 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_finitefields::prime_field::PrimeField`
  --> rustmath-coding/src/golay.rs:11:5
   |
11 | use rustmath_finitefields::prime_field::PrimeField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_finitefields::prime_field::PrimeField`
 --> rustmath-coding/src/syndrome.rs:3:5
  |
3 | use rustmath_finitefields::prime_field::PrimeField;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-coding/src/linear_code.rs:7:5
  |
7 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `field_char`
   --> rustmath-coding/src/linear_code.rs:209:60
    |
209 |     fn compute_parity_check_matrix(generator: &[Vec<u64>], field_char: u64) -> Vec<Vec<u64>> {
    |                                                            ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_field_char`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
  --> rustmath-coding/src/hamming.rs:52:13
   |
52 |         let mut code = LinearCode::from_generator_matrix(g, 2);
   |             ----^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p`
   --> rustmath-coding/src/reed_solomon.rs:106:13
    |
106 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: variable does not need to be mutable
   --> rustmath-coding/src/reed_solomon.rs:109:13
    |
109 |         let mut message_poly = message.to_vec();
    |             ----^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `p`
   --> rustmath-coding/src/reed_solomon.rs:168:13
    |
168 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `k`
  --> rustmath-coding/src/bch.rs:65:38
   |
65 |     pub fn with_parameters(n: usize, k: usize, delta: usize) -> Result<Self, String> {
   |                                      ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `p`
   --> rustmath-coding/src/syndrome.rs:198:13
    |
198 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
   --> rustmath-coding/src/syndrome.rs:206:13
    |
206 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: field `eval_points` is never read
  --> rustmath-coding/src/reed_solomon.rs:26:5
   |
16 | pub struct ReedSolomonCode {
   |            --------------- field in this struct
...
26 |     eval_points: Vec<u64>,
   |     ^^^^^^^^^^^
   |
   = note: `ReedSolomonCode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: fields `m` and `field_char` are never read
  --> rustmath-coding/src/bch.rs:21:5
   |
13 | pub struct BCHCode {
   |            ------- fields in this struct
...
21 |     m: usize,
   |     ^
...
25 |     field_char: u64,
   |     ^^^^^^^^^^
   |
   = note: `BCHCode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `field_char` is never read
  --> rustmath-coding/src/syndrome.rs:13:5
   |
 9 | pub struct SyndromeTable {
   |            ------------- field in this struct
...
13 |     field_char: u64,
   |     ^^^^^^^^^^
   |
   = note: `SyndromeTable` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

   Compiling rustmath-stats v0.1.0 (/home/john/RustMath/rustmath-stats)
warning: unused variable: `max_digits`
   --> rustmath-constants/src/constants.rs:145:9
    |
145 |     let max_digits = PI_DIGITS.len().saturating_sub(2); // Subtract "3."
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_digits`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `max_digits`
   --> rustmath-constants/src/constants.rs:152:9
    |
152 |     let max_digits = E_DIGITS.len().saturating_sub(2); // Subtract "2."
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_digits`

warning: unused variable: `max_digits`
   --> rustmath-constants/src/constants.rs:159:9
    |
159 |     let max_digits = PHI_DIGITS.len().saturating_sub(2); // Subtract "1."
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_digits`

warning: unused variable: `max_digits`
   --> rustmath-constants/src/constants.rs:166:9
    |
166 |     let max_digits = SQRT2_DIGITS.len().saturating_sub(2); // Subtract "1."
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_digits`

warning: unused variable: `max_digits`
   --> rustmath-constants/src/constants.rs:173:9
    |
173 |     let max_digits = EULER_GAMMA_DIGITS.len().saturating_sub(2); // Subtract "0."
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_digits`

warning: unused import: `std::fmt`
  --> rustmath-sets/src/finite_set_maps.rs:32:5
   |
32 | use std::fmt;
   |     ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: hiding a lifetime that's elided elsewhere is confusing
   --> rustmath-sets/src/lib.rs:330:17
    |
330 |     pub fn iter(&self) -> CartesianProductIterator<T> {
    |                 ^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the same lifetime is hidden here
    |                 |
    |                 the lifetime is elided here
    |
    = help: the same lifetime is referred to in inconsistent ways, making the signature confusing
    = note: `#[warn(mismatched_lifetime_syntaxes)]` on by default
help: use `'_` for type paths
    |
330 |     pub fn iter(&self) -> CartesianProductIterator<'_, T> {
    |                                                    +++

warning: type `Monoid_class` should have an upper camel case name
  --> rustmath-monoids/src/monoid.rs:45:12
   |
45 | pub struct Monoid_class<T: Monoid> {
   |            ^^^^^^^^^^^^ help: convert the identifier to upper camel case: `MonoidClass`
   |
   = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: unused variable: `obj`
   --> rustmath-monoids/src/free_monoid.rs:149:22
    |
149 | pub fn is_FreeMonoid(obj: &FreeMonoid) -> bool {
    |                      ^^^ help: if this is intentional, prefix it with an underscore: `_obj`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `obj`
   --> rustmath-monoids/src/free_monoid.rs:155:29
    |
155 | pub fn is_FreeMonoidElement(obj: &FreeMonoidElement) -> bool {
    |                             ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: field `mult_table` is never read
  --> rustmath-monoids/src/automatic_semigroup.rs:35:5
   |
31 | pub struct AutomaticSemigroup {
   |            ------------------ field in this struct
...
35 |     mult_table: Option<HashMap<(usize, usize), usize>>,
   |     ^^^^^^^^^^
   |
   = note: `AutomaticSemigroup` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `is_FreeMonoid` should have a snake case name
   --> rustmath-monoids/src/free_monoid.rs:149:8
    |
149 | pub fn is_FreeMonoid(obj: &FreeMonoid) -> bool {
    |        ^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_free_monoid`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: function `is_FreeMonoidElement` should have a snake case name
   --> rustmath-monoids/src/free_monoid.rs:155:8
    |
155 | pub fn is_FreeMonoidElement(obj: &FreeMonoidElement) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_free_monoid_element`

warning: function `FreeAbelianMonoid_class` should have a snake case name
   --> rustmath-monoids/src/free_abelian_monoid.rs:398:8
    |
398 | pub fn FreeAbelianMonoid_class(generators: Vec<String>) -> FreeAbelianMonoid {
    |        ^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `free_abelian_monoid_class`

warning: function `is_FreeAbelianMonoid` should have a snake case name
   --> rustmath-monoids/src/free_abelian_monoid.rs:406:8
    |
406 | pub fn is_FreeAbelianMonoid(_obj: &FreeAbelianMonoid) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_free_abelian_monoid`

warning: function `is_FreeAbelianMonoidElement` should have a snake case name
   --> rustmath-monoids/src/free_abelian_monoid.rs:414:8
    |
414 | pub fn is_FreeAbelianMonoidElement(_obj: &FreeAbelianMonoidElement) -> bool {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `is_free_abelian_monoid_element`

warning: fields `states` and `input_alphabet` are never read
   --> rustmath-automata/src/lib.rs:492:5
    |
486 | pub struct MooreMachine<S, I, O>
    |            ------------ fields in this struct
...
492 |     states: HashSet<S>,
    |     ^^^^^^
493 |     input_alphabet: HashSet<I>,
    |     ^^^^^^^^^^^^^^
    |
    = note: `MooreMachine` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `states` is never read
   --> rustmath-automata/src/lib.rs:591:5
    |
585 | pub struct MealyMachine<S, I, O>
    |            ------------ field in this struct
...
591 |     states: HashSet<S>,
    |     ^^^^^^
    |
    = note: `MealyMachine` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: unused import: `HashMap`
 --> rustmath-logic/src/proof.rs:5:24
  |
5 | use std::collections::{HashMap, HashSet};
  |                        ^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: `rustmath-quadraticforms` (lib) generated 10 warnings (run `cargo fix --lib -p rustmath-quadraticforms` to apply 3 suggestions)
warning: `rustmath-plot` (lib) generated 63 warnings (run `cargo fix --lib -p rustmath-plot` to apply 25 suggestions)
warning: `rustmath-crypto` (lib) generated 15 warnings (run `cargo fix --lib -p rustmath-crypto` to apply 6 suggestions)
warning: `rustmath-coding` (lib) generated 22 warnings (run `cargo fix --lib -p rustmath-coding` to apply 12 suggestions)
warning: `rustmath-constants` (lib) generated 5 warnings
warning: `rustmath-sets` (lib) generated 2 warnings (run `cargo fix --lib -p rustmath-sets` to apply 2 suggestions)
warning: `rustmath-monoids` (lib) generated 9 warnings
warning: `rustmath-automata` (lib) generated 2 warnings
warning: `rustmath-logic` (lib) generated 1 warning (run `cargo fix --lib -p rustmath-logic` to apply 1 suggestion)
warning: type `Sagedoc_conf` should have an upper camel case name
 --> rustmath-misc/src/sagedoc_conf.rs:6:12
  |
6 | pub struct Sagedoc_conf;
  |            ^^^^^^^^^^^^ help: convert the identifier to upper camel case: `SagedocConf`
  |
  = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: unused import: `Write`
  --> rustmath-misc/src/temporary_file.rs:44:21
   |
44 | use std::io::{self, Write};
   |                     ^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: type `Test_nested_class` should have an upper camel case name
 --> rustmath-misc/src/test_nested_class.rs:6:12
  |
6 | pub struct Test_nested_class;
  |            ^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `TestNestedClass`

warning: type `Weak_dict` should have an upper camel case name
 --> rustmath-misc/src/weak_dict.rs:6:12
  |
6 | pub struct Weak_dict;
  |            ^^^^^^^^^ help: convert the identifier to upper camel case: `WeakDict`

warning: use of deprecated method `tempfile::TempDir::into_path`: use TempDir::keep()
   --> rustmath-misc/src/temporary_file.rs:275:14
    |
275 |         temp.into_path()
    |              ^^^^^^^^^
    |
    = note: `#[warn(deprecated)]` on by default

warning: use of deprecated method `tempfile::TempDir::into_path`: use TempDir::keep()
   --> rustmath-misc/src/temporary_file.rs:509:30
    |
509 |     let temp_path = temp_dir.into_path();
    |                              ^^^^^^^^^

warning: variable does not need to be mutable
  --> rustmath-misc/src/mrange.rs:60:13
   |
60 |         let mut current = self.current.as_mut().unwrap();
   |             ----^^^^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-misc/src/mrange.rs:141:13
    |
141 |         let mut indices = self.current_indices.as_mut().unwrap();
    |             ----^^^^^^^
    |             |
    |             help: remove this `mut`

warning: field `headers` is never read
 --> rustmath-misc/src/table.rs:7:5
  |
5 | pub struct Table {
  |            ----- field in this struct
6 |     rows: Vec<Vec<String>>,
7 |     headers: Option<Vec<String>>,
  |     ^^^^^^^
  |
  = note: `Table` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
  = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Path`
  --> rustmath-databases/src/cache.rs:31:17
   |
31 | use std::path::{Path, PathBuf};
   |                 ^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: field `count` is never read
   --> rustmath-databases/src/oeis.rs:114:5
    |
110 | struct OEISResponse {
    |        ------------ field in this struct
...
114 |     count: i32,
    |     ^^^^^
    |
    = note: `OEISResponse` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `data_path` is never read
   --> rustmath-databases/src/cunningham.rs:205:5
    |
201 | pub struct CunninghamTables {
    |            ---------------- field in this struct
...
205 |     data_path: Option<String>,
    |     ^^^^^^^^^

warning: field `data_path` is never read
   --> rustmath-databases/src/cremona.rs:385:5
    |
381 | pub struct CremonaDatabase {
    |            --------------- field in this struct
...
385 |     data_path: Option<String>,
    |     ^^^^^^^^^

warning: fields `base_url`, `client`, and `cache` are never read
   --> rustmath-databases/src/lmfdb.rs:115:5
    |
114 | pub struct LMFDBClient {
    |            ----------- fields in this struct
115 |     base_url: String,
    |     ^^^^^^^^
116 |     client: reqwest::blocking::Client,
    |     ^^^^^^
117 |     /// In-memory cache of queries
118 |     cache: std::sync::Mutex<HashMap<String, String>>,
    |     ^^^^^

error: this file contains an unclosed delimiter
    --> rustmath-combinatorics/src/lib.rs:1214:3
     |
 125 | pub use specht_module::{
     |                        - unclosed delimiter
...
 214 | pub use hall_polynomial::{
     |                          - unclosed delimiter
...
 259 | pub use partition_shifting_algebras::{
     |                                      - unclosed delimiter
...
 265 | pub use symmetric_group_representations::{
     |                                          - unclosed delimiter
...
 276 | pub use six_vertex_model::{
     |                           - unclosed delimiter
...
 281 | pub use ncsym::{
     |                - another 8 unclosed delimiters begin from here
...
1214 | }
     |  ^

warning: `rustmath-misc` (lib) generated 9 warnings (run `cargo fix --lib -p rustmath-misc` to apply 3 suggestions)
warning: `rustmath-databases` (lib) generated 5 warnings (run `cargo fix --lib -p rustmath-databases` to apply 1 suggestion)
error: could not compile `rustmath-combinatorics` (lib) due to 1 previous error
warning: build failed, waiting for other jobs to finish...
warning: unused imports: `Float`, `One`, and `Zero`
  --> rustmath-special-functions/src/lib.rs:12:18
   |
12 | use num_traits::{Float, One, Zero};
   |                  ^^^^^  ^^^  ^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused imports: `E` and `PI`
  --> rustmath-special-functions/src/lib.rs:13:24
   |
13 | use std::f64::consts::{E, PI};
   |                        ^  ^^

warning: unused import: `std::collections::HashSet`
 --> rustmath-ellipticcurves/src/descent.rs:8:5
  |
8 | use std::collections::HashSet;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Zero`
 --> rustmath-ellipticcurves/src/lfunction.rs:7:31
  |
7 | use num_traits::{ToPrimitive, Zero, One};
  |                               ^^^^

warning: unnecessary parentheses around method argument
   --> rustmath-ellipticcurves/src/modular.rs:192:40
    |
192 |                 result.set_coefficient((m * self.index as usize), new_coeff);
    |                                        ^                       ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
192 -                 result.set_coefficient((m * self.index as usize), new_coeff);
192 +                 result.set_coefficient(m * self.index as usize, new_coeff);
    |

warning: unused import: `num_rational::BigRational`
 --> rustmath-ellipticcurves/src/bsd.rs:9:5
  |
9 | use num_rational::BigRational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `One`
  --> rustmath-ellipticcurves/src/bsd.rs:10:37
   |
10 | use num_traits::{ToPrimitive, Zero, One, Signed};
   |                                     ^^^

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/function_field_element_polymod.rs:39:1
   |
39 | //! the defining polynomial.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
39 - //! the defining polynomial.
39 + // the defining polynomial.
   |

warning: unused imports: `ANBinaryExpr`, `ANRational`, and `BinaryOp`
 --> rustmath-algebraic/src/algebraic_real.rs:8:34
  |
8 |     AlgebraicDescriptor, ANRoot, ANRational, ANUnaryExpr, ANBinaryExpr, BinaryOp, UnaryOp,
  |                                  ^^^^^^^^^^               ^^^^^^^^^^^^  ^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `crate::algebraic_number::AlgebraicNumber`
 --> rustmath-algebraic/src/radicals.rs:6:5
  |
6 | use crate::algebraic_number::AlgebraicNumber;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `exponential::*`
  --> rustmath-functions/src/lib.rs:24:9
   |
24 | pub use exponential::*;
   |         ^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `hyperbolic::*`
  --> rustmath-functions/src/lib.rs:25:9
   |
25 | pub use hyperbolic::*;
   |         ^^^^^^^^^^^^^

warning: unused import: `power::*`
  --> rustmath-functions/src/lib.rs:26:9
   |
26 | pub use power::*;
   |         ^^^^^^^^

warning: unused import: `trigonometric::*`
  --> rustmath-functions/src/lib.rs:27:9
   |
27 | pub use trigonometric::*;
   |         ^^^^^^^^^^^^^^^^

warning: unused import: `utility::*`
  --> rustmath-functions/src/lib.rs:28:9
   |
28 | pub use utility::*;
   |         ^^^^^^^^^^

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:24:1
   |
24 | //! p-adic Power Computers
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
24 - //! p-adic Power Computers
24 + // p-adic Power Computers
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:25:1
   |
25 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
25 - //!
25 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:26:1
   |
26 | //! This module provides efficient power computation and caching for p-adic arithmetic.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
26 - //! This module provides efficient power computation and caching for p-adic arithmetic.
26 + // This module provides efficient power computation and caching for p-adic arithmetic.
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:27:1
   |
27 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
27 - //!
27 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:28:1
   |
28 | //! ## Modules
   | ^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
28 - //! ## Modules
28 + // ## Modules
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:29:1
   |
29 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
29 - //!
29 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:30:1
   |
30 | //! - [`pow_computer`]: Base power computer with efficient p-power caching
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
30 - //! - [`pow_computer`]: Base power computer with efficient p-power caching
30 + // - [`pow_computer`]: Base power computer with efficient p-power caching
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:31:1
   |
31 | //! - [`pow_computer_ext`]: Extended power computer for p-adic field extensions
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
31 - //! - [`pow_computer_ext`]: Extended power computer for p-adic field extensions
31 + // - [`pow_computer_ext`]: Extended power computer for p-adic field extensions
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:32:1
   |
32 | //!   with Frobenius endomorphism support
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
32 - //!   with Frobenius endomorphism support
32 + //   with Frobenius endomorphism support
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:33:1
   |
33 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
33 - //!
33 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:34:1
   |
34 | //! ## Quick Start
   | ^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
34 - //! ## Quick Start
34 + // ## Quick Start
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:35:1
   |
35 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
35 - //!
35 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:36:1
   |
36 | //! ```
   | ^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
36 - //! ```
36 + // ```
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:37:1
   |
37 | //! use rustmath_integers::Integer;
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
37 - //! use rustmath_integers::Integer;
37 + // use rustmath_integers::Integer;
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:38:1
   |
38 | //! use rustmath_rings::padics::{PowComputer, PowComputerExt};
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
38 - //! use rustmath_rings::padics::{PowComputer, PowComputerExt};
38 + // use rustmath_rings::padics::{PowComputer, PowComputerExt};
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:39:1
   |
39 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
39 - //!
39 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:40:1
   |
40 | //! // Basic power computer
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
40 - //! // Basic power computer
40 + // // Basic power computer
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:41:1
   |
41 | //! let pc = PowComputer::new(Integer::from(5), 10);
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
41 - //! let pc = PowComputer::new(Integer::from(5), 10);
41 + // let pc = PowComputer::new(Integer::from(5), 10);
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:42:1
   |
42 | //! let p_cubed = pc.pow(3); // Efficiently get 5^3
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
42 - //! let p_cubed = pc.pow(3); // Efficiently get 5^3
42 + // let p_cubed = pc.pow(3); // Efficiently get 5^3
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:43:1
   |
43 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
43 - //!
43 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:44:1
   |
44 | //! // For extensions with Frobenius
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
44 - //! // For extensions with Frobenius
44 + // // For extensions with Frobenius
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:45:1
   |
45 | //! let pc_ext = PowComputerExt::unramified(Integer::from(5), 10, 3);
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
45 - //! let pc_ext = PowComputerExt::unramified(Integer::from(5), 10, 3);
45 + // let pc_ext = PowComputerExt::unramified(Integer::from(5), 10, 3);
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:46:1
   |
46 | //! let frob_exp = pc_ext.frobenius(2); // Get Frobenius exponent
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
46 - //! let frob_exp = pc_ext.frobenius(2); // Get Frobenius exponent
46 + // let frob_exp = pc_ext.frobenius(2); // Get Frobenius exponent
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:47:1
   |
47 | //! ```
   | ^^^^^^^
48 |
49 | pub mod pow_computer;
   | --------------------- the inner doc comment doesn't annotate this module
   |
help: to annotate the module, change the doc comment from inner to outer style
   |
47 - //! ```
47 + /// ```
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:54:1
   |
54 | //! p-adic numbers and rings
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
54 - //! p-adic numbers and rings
54 + // p-adic numbers and rings
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:55:1
   |
55 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
55 - //!
55 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:56:1
   |
56 | //! This module provides implementations of p-adic numbers with various precision models.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
56 - //! This module provides implementations of p-adic numbers with various precision models.
56 + // This module provides implementations of p-adic numbers with various precision models.
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:57:1
   |
57 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
57 - //!
57 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:58:1
   |
58 | //! # Precision Models
   | ^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
58 - //! # Precision Models
58 + // # Precision Models
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:59:1
   |
59 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
59 - //!
59 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:60:1
   |
60 | //! - **Capped Relative Precision**: Elements track precision relative to their valuation.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
60 - //! - **Capped Relative Precision**: Elements track precision relative to their valuation.
60 + // - **Capped Relative Precision**: Elements track precision relative to their valuation.
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:61:1
   |
61 | //!   This is the most commonly used model and corresponds to Sage's default p-adic implementation.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
61 - //!   This is the most commonly used model and corresponds to Sage's default p-adic implementation.
61 + //   This is the most commonly used model and corresponds to Sage's default p-adic implementation.
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:62:1
   |
62 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
62 - //!
62 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:63:1
   |
63 | //! # Examples
   | ^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
63 - //! # Examples
63 + // # Examples
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:64:1
   |
64 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
64 - //!
64 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:65:1
   |
65 | //! ```rust
   | ^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
65 - //! ```rust
65 + // ```rust
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:66:1
   |
66 | //! use rustmath_integers::Integer;
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
66 - //! use rustmath_integers::Integer;
66 + // use rustmath_integers::Integer;
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:67:1
   |
67 | //! use rustmath_rings::padics::capped_relative::CappedRelativePadicElement;
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
67 - //! use rustmath_rings::padics::capped_relative::CappedRelativePadicElement;
67 + // use rustmath_rings::padics::capped_relative::CappedRelativePadicElement;
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:68:1
   |
68 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
68 - //!
68 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:69:1
   |
69 | //! // Create 7 + O(5^10) in Q_5
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
69 - //! // Create 7 + O(5^10) in Q_5
69 + // // Create 7 + O(5^10) in Q_5
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:70:1
   |
70 | //! let x = CappedRelativePadicElement::new(
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
70 - //! let x = CappedRelativePadicElement::new(
70 + // let x = CappedRelativePadicElement::new(
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:71:1
   |
71 | //!     Integer::from(7),
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
71 - //!     Integer::from(7),
71 + //     Integer::from(7),
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:72:1
   |
72 | //!     Integer::from(5),
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
72 - //!     Integer::from(5),
72 + //     Integer::from(5),
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:73:1
   |
73 | //!     10
   | ^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
73 - //!     10
73 + //     10
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:74:1
   |
74 | //! ).unwrap();
   | ^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
74 - //! ).unwrap();
74 + // ).unwrap();
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:75:1
   |
75 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
75 - //!
75 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:76:1
   |
76 | //! // Arithmetic operations track precision correctly
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
76 - //! // Arithmetic operations track precision correctly
76 + // // Arithmetic operations track precision correctly
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:77:1
   |
77 | //! let y = CappedRelativePadicElement::new(
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
77 - //! let y = CappedRelativePadicElement::new(
77 + // let y = CappedRelativePadicElement::new(
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:78:1
   |
78 | //!     Integer::from(3),
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
78 - //!     Integer::from(3),
78 + //     Integer::from(3),
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:79:1
   |
79 | //!     Integer::from(5),
   | ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
79 - //!     Integer::from(5),
79 + //     Integer::from(5),
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:80:1
   |
80 | //!     10
   | ^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
80 - //!     10
80 + //     10
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:81:1
   |
81 | //! ).unwrap();
   | ^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
81 - //! ).unwrap();
81 + // ).unwrap();
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:82:1
   |
82 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
82 - //!
82 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:83:1
   |
83 | //! let sum = x.clone() + y.clone();
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
83 - //! let sum = x.clone() + y.clone();
83 + // let sum = x.clone() + y.clone();
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:84:1
   |
84 | //! let prod = x * y;
   | ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
84 - //! let prod = x * y;
84 + // let prod = x * y;
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:85:1
   |
85 | //! ```
   | ^^^^^^^
86 |
87 | pub mod capped_relative;
   | ------------------------ the inner doc comment doesn't annotate this module
   |
help: to annotate the module, change the doc comment from inner to outer style
   |
85 - //! ```
85 + /// ```
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:90:1
   |
90 | //! p-adic rings and fields
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
90 - //! p-adic rings and fields
90 + // p-adic rings and fields
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:91:1
   |
91 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
91 - //!
91 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:92:1
   |
92 | //! This module provides factory functions and types for working with p-adic numbers,
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
92 - //! This module provides factory functions and types for working with p-adic numbers,
92 + // This module provides factory functions and types for working with p-adic numbers,
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:93:1
   |
93 | //! mirroring SageMath's `sage.rings.padics` functionality.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
93 - //! mirroring SageMath's `sage.rings.padics` functionality.
93 + // mirroring SageMath's `sage.rings.padics` functionality.
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:94:1
   |
94 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
94 - //!
94 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:95:1
   |
95 | //! ## Overview
   | ^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
95 - //! ## Overview
95 + // ## Overview
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:96:1
   |
96 | //!
   | ^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
96 - //!
96 + //
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:97:1
   |
97 | //! p-adic numbers extend the usual notion of integers and rationals by introducing
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
97 - //! p-adic numbers extend the usual notion of integers and rationals by introducing
97 + // p-adic numbers extend the usual notion of integers and rationals by introducing
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:98:1
   |
98 | //! a different metric based on a prime p. The p-adic integers Z_p form a ring, and
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
98 - //! a different metric based on a prime p. The p-adic integers Z_p form a ring, and
98 + // a different metric based on a prime p. The p-adic integers Z_p form a ring, and
   |

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/padics/mod.rs:99:1
   |
99 | //! the p-adic numbers Q_p form a field.
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
99 - //! the p-adic numbers Q_p form a field.
99 + // the p-adic numbers Q_p form a field.
   |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:100:1
    |
100 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
100 - //!
100 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:101:1
    |
101 | //! ## Modules
    | ^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
101 - //! ## Modules
101 + // ## Modules
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:102:1
    |
102 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
102 - //!
102 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:103:1
    |
103 | //! - `factory`: Factory functions for creating p-adic structures (Zp, Qp, Zq, Qq)
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
103 - //! - `factory`: Factory functions for creating p-adic structures (Zp, Qp, Zq, Qq)
103 + // - `factory`: Factory functions for creating p-adic structures (Zp, Qp, Zq, Qq)
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:104:1
    |
104 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
104 - //!
104 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:105:1
    |
105 | //! ## Examples
    | ^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
105 - //! ## Examples
105 + // ## Examples
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:106:1
    |
106 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
106 - //!
106 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:107:1
    |
107 | //! ```rust
    | ^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
107 - //! ```rust
107 + // ```rust
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:108:1
    |
108 | //! use rustmath_rings::padics::factory::{Zp, Qp, PrecisionModel};
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
108 - //! use rustmath_rings::padics::factory::{Zp, Qp, PrecisionModel};
108 + // use rustmath_rings::padics::factory::{Zp, Qp, PrecisionModel};
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:109:1
    |
109 | //! use rustmath_integers::Integer;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
109 - //! use rustmath_integers::Integer;
109 + // use rustmath_integers::Integer;
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:110:1
    |
110 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
110 - //!
110 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:111:1
    |
111 | //! # fn main() -> Result<(), Box<dyn std::error::Error>> {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
111 - //! # fn main() -> Result<(), Box<dyn std::error::Error>> {
111 + // # fn main() -> Result<(), Box<dyn std::error::Error>> {
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:112:1
    |
112 | //! // Create 5-adic integers with precision 20
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
112 - //! // Create 5-adic integers with precision 20
112 + // // Create 5-adic integers with precision 20
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:113:1
    |
113 | //! let zp = Zp(Integer::from(5), 20, PrecisionModel::CappedRelative)?;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
113 - //! let zp = Zp(Integer::from(5), 20, PrecisionModel::CappedRelative)?;
113 + // let zp = Zp(Integer::from(5), 20, PrecisionModel::CappedRelative)?;
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:114:1
    |
114 | //! let x = zp.from_int(42)?;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
114 - //! let x = zp.from_int(42)?;
114 + // let x = zp.from_int(42)?;
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:115:1
    |
115 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
115 - //!
115 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:116:1
    |
116 | //! // Create 7-adic field
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
116 - //! // Create 7-adic field
116 + // // Create 7-adic field
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:117:1
    |
117 | //! let qp = Qp(Integer::from(7), 15, PrecisionModel::CappedAbsolute)?;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
117 - //! let qp = Qp(Integer::from(7), 15, PrecisionModel::CappedAbsolute)?;
117 + // let qp = Qp(Integer::from(7), 15, PrecisionModel::CappedAbsolute)?;
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:118:1
    |
118 | //! let y = qp.from_rational_nums(3, 7)?;
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
118 - //! let y = qp.from_rational_nums(3, 7)?;
118 + // let y = qp.from_rational_nums(3, 7)?;
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:119:1
    |
119 | //! # Ok(())
    | ^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
119 - //! # Ok(())
119 + // # Ok(())
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:120:1
    |
120 | //! # }
    | ^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
120 - //! # }
120 + // # }
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/padics/mod.rs:121:1
    |
121 | //! ```
    | ^^^^^^^
122 |
123 | pub mod factory;
    | ---------------- the inner doc comment doesn't annotate this module
    |
help: to annotate the module, change the doc comment from inner to outer style
    |
121 - //! ```
121 + /// ```
    |

warning: unused import: `std::f64::consts::PI`
 --> rustmath-stats/src/hypothesis.rs:6:5
  |
6 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `variance`
 --> rustmath-stats/src/regression.rs:5:31
  |
5 | use crate::statistics::{mean, variance};
  |                               ^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-calculus/src/expr.rs:228:29
    |
228 |                         use rustmath_core::Ring;
    |                             ^^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-calculus/src/functional.rs:44:29
   |
44 |                         use rustmath_integers::Integer;
   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `linear_interp`
 --> rustmath-calculus/src/interpolators.rs:6:41
  |
6 | use crate::interpolation::{CubicSpline, linear_interp};
  |                                         ^^^^^^^^^^^^^

warning: unused import: `UnaryOp`
 --> rustmath-calculus/src/limits.rs:6:41
  |
6 | use rustmath_symbolic::{BinaryOp, Expr, UnaryOp};
  |                                         ^^^^^^^

warning: unused import: `num_rational::BigRational`
 --> rustmath-modular/src/arithgroup.rs:9:5
  |
9 | use num_rational::BigRational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Signed`
  --> rustmath-modular/src/arithgroup.rs:10:29
   |
10 | use num_traits::{Zero, One, Signed};
   |                             ^^^^^^

warning: unused imports: `CongruenceSubgroup`, `Gamma0`, and `Gamma1`
 --> rustmath-modular/src/modform.rs:5:45
  |
5 | use crate::arithgroup::{ArithmeticSubgroup, CongruenceSubgroup, Gamma0, Gamma1};
  |                                             ^^^^^^^^^^^^^^^^^^  ^^^^^^  ^^^^^^

warning: unused import: `crate::cusps::Cusp`
 --> rustmath-modular/src/modform.rs:6:5
  |
6 | use crate::cusps::Cusp;
  |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `CongruenceSubgroup`
 --> rustmath-modular/src/modsym.rs:7:45
  |
7 | use crate::arithgroup::{ArithmeticSubgroup, CongruenceSubgroup};
  |                                             ^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-modular/src/modsym.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CongruenceSubgroup`
 --> rustmath-modular/src/abvar.rs:6:25
  |
6 | use crate::arithgroup::{CongruenceSubgroup, Gamma0, Gamma1};
  |                         ^^^^^^^^^^^^^^^^^^

warning: unused import: `Zero`
  --> rustmath-modular/src/abvar.rs:11:18
   |
11 | use num_traits::{Zero, One};
   |                  ^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-modular/src/abvar.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `ModularAbelianVariety_modsym` should have an upper camel case name
   --> rustmath-modular/src/abvar.rs:451:12
    |
451 | pub struct ModularAbelianVariety_modsym {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `ModularAbelianVarietyModsym`
    |
    = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: type `FiniteSubgroup_lattice` should have an upper camel case name
   --> rustmath-modular/src/abvar.rs:574:12
    |
574 | pub struct FiniteSubgroup_lattice {
    |            ^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FiniteSubgroupLattice`

warning: type `Lseries_complex` should have an upper camel case name
   --> rustmath-modular/src/abvar.rs:676:12
    |
676 | pub struct Lseries_complex {
    |            ^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `LseriesComplex`

warning: type `Lseries_padic` should have an upper camel case name
   --> rustmath-modular/src/abvar.rs:698:12
    |
698 | pub struct Lseries_padic {
    |            ^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `LseriesPadic`

warning: type `Homology_over_base` should have an upper camel case name
   --> rustmath-modular/src/abvar.rs:793:12
    |
793 | pub struct Homology_over_base {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `HomologyOverBase`

warning: type `Homology_submodule` should have an upper camel case name
   --> rustmath-modular/src/abvar.rs:822:12
    |
822 | pub struct Homology_submodule {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `HomologySubmodule`

warning: unused import: `ToPrimitive`
  --> rustmath-modular/src/dims.rs:19:29
   |
19 | use num_traits::{Zero, One, ToPrimitive};
   |                             ^^^^^^^^^^^

warning: unused import: `Zero`
  --> rustmath-modular/src/dirichlet.rs:10:18
   |
10 | use num_traits::{Zero, One, ToPrimitive};
   |                  ^^^^

warning: unused import: `std::f64::consts::PI`
  --> rustmath-modular/src/dirichlet.rs:13:5
   |
13 | use std::f64::consts::PI;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `One`
  --> rustmath-modular/src/lfunction.rs:23:18
   |
23 | use num_traits::{One, ToPrimitive, Zero};
   |                  ^^^

warning: unused import: `ToPrimitive`
  --> rustmath-modular/src/etaproducts.rs:11:29
   |
11 | use num_traits::{Zero, One, ToPrimitive};
   |                             ^^^^^^^^^^^

warning: unused variable: `mu`
  --> rustmath-special-functions/src/bessel.rs:64:9
   |
64 |     let mu = 4.0 * (n as f64).powi(2);
   |         ^^
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
   |
64 |     let _mu = 4.0 * (n as f64).powi(2);
   |         +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
   |
64 -     let mu = 4.0 * (n as f64).powi(2);
64 +     let error::erfc_continued_fraction::EPSILON = 4.0 * (n as f64).powi(2);
   |

warning: unused import: `std::f64::consts::PI`
 --> rustmath-plot3d/src/transform.rs:4:5
  |
4 | use std::f64::consts::PI;
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Vector3D`
 --> rustmath-plot3d/src/shapes.rs:6:78
  |
6 | use crate::base::{Graphics3dPrimitive, IndexFaceSet, BoundingBox3D, Point3D, Vector3D};
  |                                                                              ^^^^^^^^

warning: unused import: `Vector3D`
 --> rustmath-plot3d/src/plots/scatter_plot3d.rs:6:54
  |
6 | use crate::base::{Graphics3d, IndexFaceSet, Point3D, Vector3D};
  |                                                      ^^^^^^^^

warning: unused variable: `k_f`
   --> rustmath-special-functions/src/bessel.rs:120:13
    |
120 |         let k_f = k as f64;
    |             ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
120 |         let _k_f = k as f64;
    |             +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
    |
120 -         let k_f = k as f64;
120 +         let error::erfc_continued_fraction::EPSILON = k as f64;
    |

warning: unused import: `Vector3D`
 --> rustmath-plot3d/src/plots/implicit_plot3d.rs:6:54
  |
6 | use crate::base::{Graphics3d, IndexFaceSet, Point3D, Vector3D};
  |                                                      ^^^^^^^^

warning: unused import: `Point3D`
 --> rustmath-plot3d/src/export.rs:6:45
  |
6 | use crate::base::{Graphics3d, IndexFaceSet, Point3D, Vector3D};
  |                                             ^^^^^^^

warning: unused import: `Plot3DError`
 --> rustmath-plot3d/src/export.rs:7:13
  |
7 | use crate::{Plot3DError, Result};
  |             ^^^^^^^^^^^

warning: unused variable: `x2`
  --> rustmath-special-functions/src/error.rs:69:9
   |
69 |     let x2 = x * x;
   |         ^^
   |
help: if this is intentional, prefix it with an underscore
   |
69 |     let _x2 = x * x;
   |         +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
   |
69 -     let x2 = x * x;
69 +     let error::erfc_continued_fraction::EPSILON = x * x;
   |

warning: value assigned to `a` is never read
  --> rustmath-special-functions/src/error.rs:93:13
   |
93 |     let mut a = 1.0;
   |             ^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

error[E0753]: expected outer doc comment
  --> rustmath-rings/src/function_field/ideal.rs:60:1
   |
60 | //! - Valuation: v_P(I) for each place P
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
   |
60 - //! - Valuation: v_P(I) for each place P
60 + // - Valuation: v_P(I) for each place P
   |

error[E0282]: type annotations needed
  --> rustmath-dynamics/src/discrete.rs:62:50
   |
62 |                 if !fixed_points.iter().any(|fp| (fp - x).abs() < tolerance) {
   |                                                  ^^^^^^^^ cannot infer type

warning: unused imports: `ManifoldError`, `ManifoldPoint`, `Result`, and `TopologicalManifold`
 --> rustmath-manifolds/src/vector_bundle.rs:7:13
  |
7 | use crate::{TopologicalManifold, ManifoldPoint, ManifoldError, Result};
  |             ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `ManifoldPoint`
 --> rustmath-manifolds/src/vector_bundle_fiber.rs:7:13
  |
7 | use crate::{ManifoldPoint, ManifoldError, Result};
  |             ^^^^^^^^^^^^^

warning: unused import: `crate::chart::Chart`
 --> rustmath-manifolds/src/transition.rs:6:5
  |
6 | use crate::chart::Chart;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
 --> rustmath-manifolds/src/transition.rs:9:5
  |
9 | use rustmath_matrix::Matrix;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> rustmath-manifolds/src/transition.rs:12:5
   |
12 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-manifolds/src/traits.rs:14:5
   |
14 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `crate::scalar_field::ScalarFieldEnhanced as ScalarField`
  --> rustmath-manifolds/src/diff_form.rs:14:5
   |
14 | use crate::scalar_field::ScalarFieldEnhanced as ScalarField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::scalar_field::ScalarFieldEnhanced`
 --> rustmath-manifolds/src/riemannian.rs:7:5
  |
7 | use crate::scalar_field::ScalarFieldEnhanced;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tensor_field::TensorField`
 --> rustmath-manifolds/src/riemannian.rs:8:5
  |
8 | use crate::tensor_field::TensorField;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::diff_form::DiffForm`
  --> rustmath-manifolds/src/lie_group.rs:10:5
   |
10 | use crate::diff_form::DiffForm;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `TangentSpace`
  --> rustmath-manifolds/src/lie_algebra.rs:10:43
   |
10 | use crate::tangent_space::{TangentVector, TangentSpace};
   |                                           ^^^^^^^^^^^^

warning: unused import: `crate::chart::Chart`
  --> rustmath-manifolds/src/lie_algebra.rs:12:5
   |
12 | use crate::chart::Chart;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-manifolds/src/lie_algebra.rs:13:5
   |
13 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-manifolds/src/lie_algebra.rs:14:5
   |
14 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_symbolic::Expr`
  --> rustmath-manifolds/src/lie_algebra.rs:15:5
   |
15 | use rustmath_symbolic::Expr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-manifolds/src/lie_algebra.rs:17:5
   |
17 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::diff_form::DiffForm`
  --> rustmath-manifolds/src/fiber_bundles.rs:16:5
   |
16 | use crate::diff_form::DiffForm;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::scalar_field::ScalarFieldEnhanced as ScalarField`
  --> rustmath-manifolds/src/integration.rs:14:5
   |
14 | use crate::scalar_field::ScalarFieldEnhanced as ScalarField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_reals::Real`
  --> rustmath-manifolds/src/integration.rs:18:5
   |
18 | use rustmath_reals::Real;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
  --> rustmath-manifolds/src/integration.rs:20:5
   |
20 | use std::f64::consts::PI;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tensor_field::TensorField`
  --> rustmath-manifolds/src/topology.rs:15:5
   |
15 | use crate::tensor_field::TensorField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_symbolic::Expr`
  --> rustmath-manifolds/src/topology.rs:17:5
   |
17 | use rustmath_symbolic::Expr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-manifolds/src/topology.rs:19:5
   |
19 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Covector`
  --> rustmath-manifolds/src/maps.rs:16:43
   |
16 | use crate::tangent_space::{TangentVector, Covector};
   |                                           ^^^^^^^^

warning: unused import: `ManifoldError`
 --> rustmath-manifolds/src/symmetries.rs:9:21
  |
9 | use crate::errors::{ManifoldError, Result};
  |                     ^^^^^^^^^^^^^

warning: unused import: `crate::maps::Diffeomorphism`
  --> rustmath-manifolds/src/symmetries.rs:15:5
   |
15 | use crate::maps::Diffeomorphism;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-manifolds/src/symmetries.rs:19:5
   |
19 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
  --> rustmath-manifolds/src/catalog.rs:16:5
   |
16 | use std::f64::consts::PI;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::manifold::TopologicalManifold`
  --> rustmath-manifolds/src/complex_manifold.rs:23:5
   |
23 | use crate::manifold::TopologicalManifold;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CoordinateFunction`
  --> rustmath-manifolds/src/complex_manifold.rs:24:27
   |
24 | use crate::chart::{Chart, CoordinateFunction};
   |                           ^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-manifolds/src/almost_complex.rs:32:5
   |
32 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-manifolds/src/almost_complex.rs:33:5
   |
33 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tensor_field::TensorField`
  --> rustmath-manifolds/src/kahler.rs:29:5
   |
29 | use crate::tensor_field::TensorField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-manifolds/src/finsler.rs:32:5
   |
32 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-manifolds/src/finsler.rs:33:5
   |
33 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tangent_space::TangentVector`
  --> rustmath-manifolds/src/subriemannian.rs:32:5
   |
32 | use crate::tangent_space::TangentVector;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tensor_field::TensorField`
  --> rustmath-manifolds/src/spin.rs:37:5
   |
37 | use crate::tensor_field::TensorField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_symbolic::Expr`
  --> rustmath-manifolds/src/spin.rs:38:5
   |
38 | use rustmath_symbolic::Expr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ManifoldError`
  --> rustmath-manifolds/src/dirac.rs:36:21
   |
36 | use crate::errors::{ManifoldError, Result};
   |                     ^^^^^^^^^^^^^

warning: unused import: `RiemannianMetric`
  --> rustmath-manifolds/src/dirac.rs:38:25
   |
38 | use crate::riemannian::{RiemannianMetric, LeviCivitaConnection};
   |                         ^^^^^^^^^^^^^^^^

error[E0277]: the size for values of type `Self` cannot be known at compilation time
   --> rustmath-stats/src/lib.rs:243:22
    |
243 |     fn sqrt(self) -> Option<Self>;
    |                      ^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
note: required by an implicit `Sized` bound in `Option`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:594:17
    |
594 | pub enum Option<T> {
    |                 ^ required by the implicit `Sized` requirement on this type parameter in `Option`
help: consider further restricting `Self`
    |
243 |     fn sqrt(self) -> Option<Self> where Self: Sized;
    |                                   +++++++++++++++++

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:873:1
    |
873 | //! # Number Field Module
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
873 - //! # Number Field Module
873 + // # Number Field Module
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:874:1
    |
874 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
874 - //!
874 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:875:1
    |
875 | //! This module provides functionality for working with algebraic number fields,
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
875 - //! This module provides functionality for working with algebraic number fields,
875 + // This module provides functionality for working with algebraic number fields,
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:876:1
    |
876 | //! extending the capabilities in rustmath-numberfields with morphisms and
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
876 - //! extending the capabilities in rustmath-numberfields with morphisms and
876 + // extending the capabilities in rustmath-numberfields with morphisms and
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:877:1
    |
877 | //! Galois theory computations.
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
877 - //! Galois theory computations.
877 + // Galois theory computations.
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:878:1
    |
878 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
878 - //!
878 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:879:1
    |
879 | //! ## Submodules
    | ^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
879 - //! ## Submodules
879 + // ## Submodules
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:880:1
    |
880 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
880 - //!
880 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:881:1
    |
881 | //! - `morphisms`: Homomorphisms, embeddings, automorphisms, and Galois groups
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
881 - //! - `morphisms`: Homomorphisms, embeddings, automorphisms, and Galois groups
881 + // - `morphisms`: Homomorphisms, embeddings, automorphisms, and Galois groups
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:882:1
    |
882 | //! - `tests`: Comprehensive test suite for splitting fields and Galois theory
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
883 |
884 | pub mod morphisms;
    | ------------------ the inner doc comment doesn't annotate this module
    |
help: to annotate the module, change the doc comment from inner to outer style
    |
882 - //! - `tests`: Comprehensive test suite for splitting fields and Galois theory
882 + /// - `tests`: Comprehensive test suite for splitting fields and Galois theory
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:903:1
    |
903 | //! Number Field Orders
    | ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
903 - //! Number Field Orders
903 + // Number Field Orders
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:904:1
    |
904 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
904 - //!
904 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:905:1
    |
905 | //! This module implements orders (rings of integers) in algebraic number fields,
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
905 - //! This module implements orders (rings of integers) in algebraic number fields,
905 + // This module implements orders (rings of integers) in algebraic number fields,
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:906:1
    |
906 | //! corresponding to sage.rings.number_field.order.
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
907 |
908 | pub mod order;
    | -------------- the inner doc comment doesn't annotate this module
    |
help: to annotate the module, change the doc comment from inner to outer style
    |
906 - //! corresponding to sage.rings.number_field.order.
906 + /// corresponding to sage.rings.number_field.order.
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:911:1
    |
911 | //! Number Field Module
    | ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
911 - //! Number Field Module
911 + // Number Field Module
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:912:1
    |
912 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
912 - //!
912 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:913:1
    |
913 | //! This module provides functionality for algebraic number fields, including:
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
913 - //! This module provides functionality for algebraic number fields, including:
913 + // This module provides functionality for algebraic number fields, including:
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:914:1
    |
914 | //! - S-unit equation solving
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
914 - //! - S-unit equation solving
914 + // - S-unit equation solving
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:915:1
    |
915 | //! - Fundamental units computation
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
915 - //! - Fundamental units computation
915 + // - Fundamental units computation
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:916:1
    |
916 | //! - Regulator calculation
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
916 - //! - Regulator calculation
916 + // - Regulator calculation
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:917:1
    |
917 | //! - S-unit group structure
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
918 |
919 | pub mod s_unit_solver;
    | ---------------------- the inner doc comment doesn't annotate this module
    |
help: to annotate the module, change the doc comment from inner to outer style
    |
917 - //! - S-unit group structure
917 + /// - S-unit group structure
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:932:1
    |
932 | //! # Number Field Module
    | ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
932 - //! # Number Field Module
932 + // # Number Field Module
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:933:1
    |
933 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
933 - //!
933 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:934:1
    |
934 | //! This module provides functionality for working with algebraic number fields,
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
934 - //! This module provides functionality for working with algebraic number fields,
934 + // This module provides functionality for working with algebraic number fields,
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:935:1
    |
935 | //! extending the capabilities in rustmath-numberfields with morphisms and
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
935 - //! extending the capabilities in rustmath-numberfields with morphisms and
935 + // extending the capabilities in rustmath-numberfields with morphisms and
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:936:1
    |
936 | //! Galois theory computations.
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
936 - //! Galois theory computations.
936 + // Galois theory computations.
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:937:1
    |
937 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
937 - //!
937 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:938:1
    |
938 | //! ## Submodules
    | ^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
938 - //! ## Submodules
938 + // ## Submodules
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:939:1
    |
939 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
939 - //!
939 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:940:1
    |
940 | //! - `morphisms`: Homomorphisms, embeddings, automorphisms, and Galois groups
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
940 - //! - `morphisms`: Homomorphisms, embeddings, automorphisms, and Galois groups
940 + // - `morphisms`: Homomorphisms, embeddings, automorphisms, and Galois groups
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:941:1
    |
941 | //! - `tests`: Comprehensive test suite for splitting fields and Galois theory
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
942 |
943 | pub mod morphisms;
    | ------------------ the inner doc comment doesn't annotate this module
    |
help: to annotate the module, change the doc comment from inner to outer style
    |
941 - //! - `tests`: Comprehensive test suite for splitting fields and Galois theory
941 + /// - `tests`: Comprehensive test suite for splitting fields and Galois theory
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:962:1
    |
962 | //! Number Field Orders
    | ^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
962 - //! Number Field Orders
962 + // Number Field Orders
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:963:1
    |
963 | //!
    | ^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
963 - //!
963 + //
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:964:1
    |
964 | //! This module implements orders (rings of integers) in algebraic number fields,
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: inner doc comments like this (starting with `//!` or `/*!`) can only appear before items
help: you might have meant to write a regular comment
    |
964 - //! This module implements orders (rings of integers) in algebraic number fields,
964 + // This module implements orders (rings of integers) in algebraic number fields,
    |

error[E0753]: expected outer doc comment
   --> rustmath-rings/src/number_field/mod.rs:965:1
    |
965 | //! corresponding to sage.rings.number_field.order.
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
966 |
967 | pub mod order;
    | -------------- the inner doc comment doesn't annotate this module
    |
help: to annotate the module, change the doc comment from inner to outer style
    |
965 - //! corresponding to sage.rings.number_field.order.
965 + /// corresponding to sage.rings.number_field.order.
    |

error[E0599]: no method named `inverse` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-algebraic/src/descriptor.rs:218:50
    |
218 | ...                   if let Ok(inv) = rat.inverse() {
    |                                            ^^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Field` which provides `inverse` is implemented but not in scope; perhaps you want to import it
    |
 10 + use rustmath_core::Field;
    |

error[E0053]: method `to_mesh` has an incompatible type for trait
   --> rustmath-plot3d/src/transform.rs:303:26
    |
303 |     fn to_mesh(&self) -> IndexFaceSet {
    |                          ^^^^^^^^^^^^ expected `Result<IndexFaceSet, Plot3DError>`, found `IndexFaceSet`
    |
note: type in trait
   --> rustmath-plot3d/src/base.rs:335:26
    |
335 |     fn to_mesh(&self) -> crate::Result<IndexFaceSet>;
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected signature `fn(&TransformGroup) -> std::result::Result<IndexFaceSet, Plot3DError>`
               found signature `fn(&TransformGroup) -> IndexFaceSet`
help: change the output type to match the trait
    |
303 -     fn to_mesh(&self) -> IndexFaceSet {
303 +     fn to_mesh(&self) -> std::result::Result<IndexFaceSet, Plot3DError> {
    |

error[E0599]: no method named `is_zero` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-algebraic/src/descriptor.rs:251:35
    |
251 | ...                   if !r.is_zero() {
    |                             ^^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
    |
 10 + use rustmath_core::Ring;
    |

warning: `rustmath-special-functions` (lib) generated 6 warnings (run `cargo fix --lib -p rustmath-special-functions` to apply 5 suggestions)
error[E0107]: struct takes 0 generic arguments but 1 generic argument was supplied
   --> rustmath-plot3d/src/shapes.rs:64:28
    |
 64 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
    |                            ^^^------------------------- help: remove the unnecessary generics
    |                            |
    |                            expected 0 generic arguments
    |
note: struct defined here, with 0 generic parameters
   --> rustmath-plot3d/src/shapes.rs:122:12
    |
122 | pub struct Box {
    |            ^^^

error[E0053]: method `clone_box` has an incompatible type for trait
   --> rustmath-plot3d/src/shapes.rs:64:28
    |
 64 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<dyn Graphics3dPrimitive>`, found `shapes::Box`
    |
note: type in trait
   --> rustmath-plot3d/src/base.rs:338:28
    |
338 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive>;
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected signature `fn(&Sphere) -> std::boxed::Box<(dyn Graphics3dPrimitive + 'static)>`
               found signature `fn(&Sphere) -> shapes::Box`
help: change the output type to match the trait
    |
 64 -     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
 64 +     fn clone_box(&self) -> std::boxed::Box<(dyn Graphics3dPrimitive + 'static)> {
    |

error[E0107]: struct takes 0 generic arguments but 1 generic argument was supplied
   --> rustmath-plot3d/src/shapes.rs:180:28
    |
180 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
    |                            ^^^------------------------- help: remove the unnecessary generics
    |                            |
    |                            expected 0 generic arguments
    |
note: struct defined here, with 0 generic parameters
   --> rustmath-plot3d/src/shapes.rs:122:12
    |
122 | pub struct Box {
    |            ^^^

error[E0053]: method `clone_box` has an incompatible type for trait
   --> rustmath-plot3d/src/shapes.rs:180:28
    |
180 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box<dyn Graphics3dPrimitive>`, found `shapes::Box`
    |
note: type in trait
   --> rustmath-plot3d/src/base.rs:338:28
    |
338 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive>;
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected signature `fn(&shapes::Box) -> std::boxed::Box<(dyn Graphics3dPrimitive + 'static)>`
               found signature `fn(&shapes::Box) -> shapes::Box`
help: change the output type to match the trait
    |
180 -     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
180 +     fn clone_box(&self) -> std::boxed::Box<(dyn Graphics3dPrimitive + 'static)> {
    |

warning: `rustmath-functions` (lib) generated 5 warnings (run `cargo fix --lib -p rustmath-functions` to apply 5 suggestions)
error[E0599]: no function or associated item named `from_i64` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-algebraic/src/algebraic_number.rs:37:39
   |
37 |         Self::from_rational(Rational::from_i64(n))
   |                                       ^^^^^^^^ function or associated item not found in `rustmath_rationals::Rational`
   |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
  --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
   |
18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `NumericConversion` which provides `from_i64` is implemented but not in scope; perhaps you want to import it
   |
 6 + use rustmath_core::NumericConversion;
   |
help: there is an associated function `from_u64` with a similar name
   |
37 -         Self::from_rational(Rational::from_i64(n))
37 +         Self::from_rational(Rational::from_u64(n))
   |

error[E0308]: mismatched types
   --> rustmath-algebraic/src/algebraic_number.rs:55:26
    |
 55 |             Complex::new(r.to_f64(), 0.0)
    |             ------------ ^^^^^^^^^^ expected `f64`, found `Option<f64>`
    |             |
    |             arguments to this function are incorrect
    |
    = note: expected type `f64`
               found enum `Option<f64>`
note: associated function defined here
   --> /home/john/RustMath/rustmath-complex/src/complex.rs:128:12
    |
128 |     pub fn new(real: f64, imag: f64) -> Self {
    |            ^^^
help: consider using `Option::expect` to unwrap the `Option<f64>` value, panicking if the value is an `Option::None`
    |
 55 |             Complex::new(r.to_f64().expect("REASON"), 0.0)
    |                                    +++++++++++++++++

error[E0428]: the name `morphisms` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:943:1
    |
884 | pub mod morphisms;
    | ------------------ previous definition of the module `morphisms` here
...
943 | pub mod morphisms;
    | ^^^^^^^^^^^^^^^^^^ `morphisms` redefined here
    |
    = note: `morphisms` must be defined only once in the type namespace of this module

error[E0428]: the name `order` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:967:1
    |
908 | pub mod order;
    | -------------- previous definition of the module `order` here
...
967 | pub mod order;
    | ^^^^^^^^^^^^^^ `order` redefined here
    |
    = note: `order` must be defined only once in the type namespace of this module

error[E0428]: the name `padics` is defined multiple times
  --> rustmath-rings/src/lib.rs:94:1
   |
60 | pub mod padics;
   | --------------- previous definition of the module `padics` here
...
94 | pub mod padics;
   | ^^^^^^^^^^^^^^^ `padics` redefined here
   |
   = note: `padics` must be defined only once in the type namespace of this module

error[E0689]: can't call method `abs` on ambiguous numeric type `{float}`
   --> rustmath-numerical/src/integration/gauss_legendre.rs:113:21
    |
113 |         while delta.abs() > 1e-15 {
    |                     ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
112 |         let mut delta: f32 = 1.0;
    |                      +++++

error[E0599]: no function or associated item named `from_i64` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-algebraic/src/algebraic_real.rs:38:39
   |
38 |         Self::from_rational(Rational::from_i64(n))
   |                                       ^^^^^^^^ function or associated item not found in `rustmath_rationals::Rational`
   |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
  --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
   |
18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `NumericConversion` which provides `from_i64` is implemented but not in scope; perhaps you want to import it
   |
 6 + use rustmath_core::NumericConversion;
   |
help: there is an associated function `from_u64` with a similar name
   |
38 -         Self::from_rational(Rational::from_i64(n))
38 +         Self::from_rational(Rational::from_u64(n))
   |

warning: value assigned to `x_prev` is never read
   --> rustmath-dynamics/src/chaos.rs:169:13
    |
169 |     let mut x_prev = x;
    |             ^^^^^^
    |
    = help: maybe it is overwritten before being read?
    = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

warning: value assigned to `x_prev` is never read
   --> rustmath-dynamics/src/chaos.rs:173:9
    |
173 |         x_prev = x;
    |         ^^^^^^
    |
    = help: maybe it is overwritten before being read?

error[E0252]: the name `NumberFieldMorphism` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:949:5
    |
890 |     NumberFieldMorphism,
    |     ------------------- previous import of the trait `NumberFieldMorphism` here
...
949 |     NumberFieldMorphism,
    |     ^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `NumberFieldMorphism` reimported here
    |     help: remove unnecessary import
    |
    = note: `NumberFieldMorphism` must be defined only once in the type namespace of this module

error[E0252]: the name `compute_automorphisms` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:953:5
    |
894 |     compute_automorphisms,
    |     --------------------- previous import of the value `compute_automorphisms` here
...
953 |     compute_automorphisms,
    |     ^^^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `compute_automorphisms` reimported here
    |     help: remove unnecessary import
    |
    = note: `compute_automorphisms` must be defined only once in the value namespace of this module

error[E0252]: the name `is_galois_extension` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:954:5
    |
895 |     is_galois_extension,
    |     ------------------- previous import of the value `is_galois_extension` here
...
954 |     is_galois_extension,
    |     ^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `is_galois_extension` reimported here
    |     help: remove unnecessary import
    |
    = note: `is_galois_extension` must be defined only once in the value namespace of this module

error[E0252]: the name `is_normal_extension` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:955:5
    |
896 |     is_normal_extension,
    |     ------------------- previous import of the value `is_normal_extension` here
...
955 |     is_normal_extension,
    |     ^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `is_normal_extension` reimported here
    |     help: remove unnecessary import
    |
    = note: `is_normal_extension` must be defined only once in the value namespace of this module

error[E0252]: the name `is_separable_extension` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:956:5
    |
897 |     is_separable_extension,
    |     ---------------------- previous import of the value `is_separable_extension` here
...
956 |     is_separable_extension,
    |     ^^^^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `is_separable_extension` reimported here
    |     help: remove unnecessary import
    |
    = note: `is_separable_extension` must be defined only once in the value namespace of this module

error[E0252]: the name `splitting_field` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:957:5
    |
898 |     splitting_field,
    |     --------------- previous import of the value `splitting_field` here
...
957 |     splitting_field,
    |     ^^^^^^^^^^^^^^^-
    |     |
    |     `splitting_field` reimported here
    |     help: remove unnecessary import
    |
    = note: `splitting_field` must be defined only once in the value namespace of this module

error[E0252]: the name `galois_group` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:958:5
    |
899 |     galois_group,
    |     ------------ previous import of the value `galois_group` here
...
958 |     galois_group,
    |     ^^^^^^^^^^^^-
    |     |
    |     `galois_group` reimported here
    |     help: remove unnecessary import
    |
    = note: `galois_group` must be defined only once in the value namespace of this module

error[E0252]: the name `MorphismResult` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:960:5
    |
901 |     Result as MorphismResult,
    |     ------------------------ previous import of the type `MorphismResult` here
...
960 |     Result as MorphismResult,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `MorphismResult` reimported here
    |     help: remove unnecessary import
    |
    = note: `MorphismResult` must be defined only once in the type namespace of this module

error[E0599]: no function or associated item named `from_f64` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-algebraic/src/algebraic_real.rs:77:31
   |
77 |         let lower = Rational::from_f64(approx - epsilon).unwrap();
   |                               ^^^^^^^^ function or associated item not found in `rustmath_rationals::Rational`
   |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
  --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
   |
18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function `from_i64` with a similar name
   |
77 -         let lower = Rational::from_f64(approx - epsilon).unwrap();
77 +         let lower = Rational::from_i64(approx - epsilon).unwrap();
   |

error[E0599]: no function or associated item named `from_f64` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-algebraic/src/algebraic_real.rs:78:31
   |
78 |         let upper = Rational::from_f64(approx + epsilon).unwrap();
   |                               ^^^^^^^^ function or associated item not found in `rustmath_rationals::Rational`
   |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
  --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
   |
18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function `from_i64` with a similar name
   |
78 -         let upper = Rational::from_f64(approx + epsilon).unwrap();
78 +         let upper = Rational::from_i64(approx + epsilon).unwrap();
   |

For more information about this error, try `rustc --explain E0282`.
error[E0599]: no function or associated item named `from_f64` found for struct `rustmath_rationals::Rational` in the current scope
   --> rustmath-algebraic/src/algebraic_real.rs:128:31
    |
128 |         let lower = Rational::from_f64(approx - epsilon).unwrap();
    |                               ^^^^^^^^ function or associated item not found in `rustmath_rationals::Rational`
    |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
   --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
    |
 18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function `from_i64` with a similar name
    |
128 -         let lower = Rational::from_f64(approx - epsilon).unwrap();
128 +         let lower = Rational::from_i64(approx - epsilon).unwrap();
    |

error[E0599]: no function or associated item named `from_f64` found for struct `rustmath_rationals::Rational` in the current scope
   --> rustmath-algebraic/src/algebraic_real.rs:129:31
    |
129 |         let upper = Rational::from_f64(approx + epsilon).unwrap();
    |                               ^^^^^^^^ function or associated item not found in `rustmath_rationals::Rational`
    |
note: if you're trying to build a new `rustmath_rationals::Rational` consider using one of the following associated functions:
      rustmath_rationals::Rational::new
      rustmath_rationals::Rational::from_integer
   --> /home/john/RustMath/rustmath-rationals/src/rational.rs:18:5
    |
 18 |     pub fn new<T: Into<Integer>>(numerator: T, denominator: T) -> Result<Self> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn from_integer<T: Into<Integer>>(n: T) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is an associated function `from_i64` with a similar name
    |
129 -         let upper = Rational::from_f64(approx + epsilon).unwrap();
129 +         let upper = Rational::from_i64(approx + epsilon).unwrap();
    |

error[E0308]: mismatched types
   --> rustmath-algebraic/src/algebraic_real.rs:151:13
    |
149 |     pub fn to_f64(&self, precision: usize) -> f64 {
    |                                               --- expected `f64` because of return type
150 |         if let Some(r) = self.to_rational() {
151 |             r.to_f64()
    |             ^^^^^^^^^^ expected `f64`, found `Option<f64>`
    |
    = note: expected type `f64`
               found enum `Option<f64>`
help: consider using `Option::expect` to unwrap the `Option<f64>` value, panicking if the value is an `Option::None`
    |
151 |             r.to_f64().expect("REASON")
    |                       +++++++++++++++++

warning: `rustmath-dynamics` (lib) generated 2 warnings
error: could not compile `rustmath-dynamics` (lib) due to 1 previous error; 2 warnings emitted
error[E0599]: no function or associated item named `zero` found for struct `AlgebraicNumber` in the current scope
  --> rustmath-algebraic/src/algebraic_field.rs:32:26
   |
32 |         AlgebraicNumber::zero()
   |                          ^^^^ function or associated item not found in `AlgebraicNumber`
   |
  ::: rustmath-algebraic/src/algebraic_number.rs:17:1
   |
17 | pub struct AlgebraicNumber {
   | -------------------------- function or associated item `zero` not found for this struct
   |
note: if you're trying to build a new `AlgebraicNumber` consider using one of the following associated functions:
      AlgebraicNumber::new
      AlgebraicNumber::from_rational
      AlgebraicNumber::from_i64
  --> rustmath-algebraic/src/algebraic_number.rs:24:5
   |
24 |     pub fn new(descriptor: AlgebraicDescriptor) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
29 |     pub fn from_rational(r: Rational) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
36 |     pub fn from_i64(n: i64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
   |
 3 + use rustmath_core::Ring;
   |
help: there is a method `is_zero` with a similar name
   |
32 |         AlgebraicNumber::is_zero()
   |                          +++

warning: unused variable: `x`
   --> rustmath-numerical/src/lib.rs:121:24
    |
121 |     fn gradient(&self, x: T) -> Option<T> {
    |                        ^ help: if this is intentional, prefix it with an underscore: `_x`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no method named `sqrt` found for type parameter `Self` in the current scope
   --> rustmath-stats/src/lib.rs:233:55
    |
221 | pub trait StatisticalMoments: Sized {
    | ----------------------------------- method `sqrt` not found for this type parameter
...
233 |         Self::variance(data, bias).and_then(|var| var.sqrt())
    |                                                       ^^^^ method not found in `Self`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following traits define an item `sqrt`, perhaps you need to add another supertrait for one of them:
    |
221 | pub trait StatisticalMoments: Sized + SquareRoot {
    |                                     ++++++++++++
221 | pub trait StatisticalMoments: Sized + basic_stats::SquareRoot {
    |                                     +++++++++++++++++++++++++

error[E0061]: this function takes 2 arguments but 0 arguments were supplied
   --> rustmath-plot3d/src/transform.rs:304:28
    |
304 |         let mut combined = IndexFaceSet::new();
    |                            ^^^^^^^^^^^^^^^^^-- two arguments of type `Vec<Point3D>` and `Vec<[usize; 3]>` are missing
    |
note: associated function defined here
   --> rustmath-plot3d/src/base.rs:205:12
    |
205 |     pub fn new(vertices: Vec<Point3D>, faces: Vec<[usize; 3]>) -> Self {
    |            ^^^ ----------------------  ----------------------
help: provide the arguments
    |
304 |         let mut combined = IndexFaceSet::new(/* Vec<Point3D> */, /* Vec<[usize; 3]> */);
    |                                              +++++++++++++++++++++++++++++++++++++++++

error[E0599]: no function or associated item named `one` found for struct `AlgebraicNumber` in the current scope
   --> rustmath-algebraic/src/algebraic_field.rs:37:26
    |
 37 |         AlgebraicNumber::one()
    |                          ^^^ function or associated item not found in `AlgebraicNumber`
    |
   ::: rustmath-algebraic/src/algebraic_number.rs:17:1
    |
 17 | pub struct AlgebraicNumber {
    | -------------------------- function or associated item `one` not found for this struct
    |
note: if you're trying to build a new `AlgebraicNumber` consider using one of the following associated functions:
      AlgebraicNumber::new
      AlgebraicNumber::from_rational
      AlgebraicNumber::from_i64
   --> rustmath-algebraic/src/algebraic_number.rs:24:5
    |
 24 |     pub fn new(descriptor: AlgebraicDescriptor) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 29 |     pub fn from_rational(r: Rational) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn from_i64(n: i64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Ring` which provides `one` is implemented but not in scope; perhaps you want to import it
    |
  3 + use rustmath_core::Ring;
    |

warning: value assigned to `fb` is never read
  --> rustmath-numerical/src/root_finding/methods.rs:60:13
   |
60 |             fb = fc;
   |             ^^
   |
   = help: maybe it is overwritten before being read?
   = note: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no function or associated item named `zero` found for struct `AlgebraicNumber` in the current scope
  --> rustmath-algebraic/src/algebraic_field.rs:44:26
   |
44 |         AlgebraicNumber::zero()
   |                          ^^^^ function or associated item not found in `AlgebraicNumber`
   |
  ::: rustmath-algebraic/src/algebraic_number.rs:17:1
   |
17 | pub struct AlgebraicNumber {
   | -------------------------- function or associated item `zero` not found for this struct
   |
note: if you're trying to build a new `AlgebraicNumber` consider using one of the following associated functions:
      AlgebraicNumber::new
      AlgebraicNumber::from_rational
      AlgebraicNumber::from_i64
  --> rustmath-algebraic/src/algebraic_number.rs:24:5
   |
24 |     pub fn new(descriptor: AlgebraicDescriptor) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
29 |     pub fn from_rational(r: Rational) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
36 |     pub fn from_i64(n: i64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
   |
 3 + use rustmath_core::Ring;
   |
help: there is a method `is_zero` with a similar name
   |
44 |         AlgebraicNumber::is_zero()
   |                          +++

error[E0599]: no function or associated item named `zero` found for struct `AlgebraicReal` in the current scope
  --> rustmath-algebraic/src/algebraic_real_field.rs:31:24
   |
31 |         AlgebraicReal::zero()
   |                        ^^^^ function or associated item not found in `AlgebraicReal`
   |
  ::: rustmath-algebraic/src/algebraic_real.rs:23:1
   |
23 | pub struct AlgebraicReal {
   | ------------------------ function or associated item `zero` not found for this struct
   |
note: if you're trying to build a new `AlgebraicReal` consider using one of the following associated functions:
      AlgebraicReal::from_rational
      AlgebraicReal::from_i64
      AlgebraicReal::sqrt
      AlgebraicReal::nth_root
  --> rustmath-algebraic/src/algebraic_real.rs:30:5
   |
30 |     pub fn from_rational(r: Rational) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
37 |     pub fn from_i64(n: i64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
56 |     pub fn sqrt(n: i64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
88 |     pub fn nth_root(n: i64, degree: u32) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
   |
 3 + use rustmath_core::Ring;
   |
help: there is a method `is_zero` with a similar name
   |
31 |         AlgebraicReal::is_zero()
   |                        +++

error[E0599]: no function or associated item named `one` found for struct `AlgebraicReal` in the current scope
   --> rustmath-algebraic/src/algebraic_real_field.rs:36:24
    |
 36 |         AlgebraicReal::one()
    |                        ^^^ function or associated item not found in `AlgebraicReal`
    |
   ::: rustmath-algebraic/src/algebraic_real.rs:23:1
    |
 23 | pub struct AlgebraicReal {
    | ------------------------ function or associated item `one` not found for this struct
    |
note: if you're trying to build a new `AlgebraicReal` consider using one of the following associated functions:
      AlgebraicReal::from_rational
      AlgebraicReal::from_i64
      AlgebraicReal::sqrt
      AlgebraicReal::nth_root
   --> rustmath-algebraic/src/algebraic_real.rs:30:5
    |
 30 |     pub fn from_rational(r: Rational) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 37 |     pub fn from_i64(n: i64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 56 |     pub fn sqrt(n: i64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 88 |     pub fn nth_root(n: i64, degree: u32) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Ring` which provides `one` is implemented but not in scope; perhaps you want to import it
    |
  3 + use rustmath_core::Ring;
    |

warning: variable does not need to be mutable
   --> rustmath-numerical/src/optimization/brent.rs:172:13
    |
172 |         let mut s;
    |             ----^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no function or associated item named `zero` found for struct `Integer` in the current scope
  --> rustmath-algebraic/src/minimal_polynomial.rs:40:53
   |
40 |             UnivariatePolynomial::new(vec![Integer::zero(), Integer::one()])
   |                                                     ^^^^ function or associated item not found in `Integer`
   |
note: if you're trying to build a new `Integer`, consider using `Integer::new` which returns `Integer`
  --> /home/john/RustMath/rustmath-integers/src/integer.rs:19:5
   |
19 |     pub fn new(value: BigInt) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
   |
 5 + use rustmath_core::Ring;
   |
help: there is a method `is_zero` with a similar name
   |
40 |             UnivariatePolynomial::new(vec![Integer::is_zero(), Integer::one()])
   |                                                     +++

error[E0599]: no function or associated item named `one` found for struct `Integer` in the current scope
   --> rustmath-algebraic/src/minimal_polynomial.rs:40:70
    |
 40 |             UnivariatePolynomial::new(vec![Integer::zero(), Integer::one()])
    |                                                                      ^^^ function or associated item not found in `Integer`
    |
note: if you're trying to build a new `Integer`, consider using `Integer::new` which returns `Integer`
   --> /home/john/RustMath/rustmath-integers/src/integer.rs:19:5
    |
 19 |     pub fn new(value: BigInt) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Ring` which provides `one` is implemented but not in scope; perhaps you want to import it
    |
  5 + use rustmath_core::Ring;
    |

error[E0308]: mismatched types
   --> rustmath-plot3d/src/transform.rs:308:51
    |
308 |             let transformed = self.transform_mesh(&child_mesh);
    |                                    -------------- ^^^^^^^^^^^ expected `&IndexFaceSet`, found `&Result<IndexFaceSet, Plot3DError>`
    |                                    |
    |                                    arguments to this method are incorrect
    |
    = note: expected reference `&IndexFaceSet`
               found reference `&std::result::Result<IndexFaceSet, Plot3DError>`
note: method defined here
   --> rustmath-plot3d/src/transform.rs:256:8
    |
256 |     fn transform_mesh(&self, mesh: &IndexFaceSet) -> IndexFaceSet {
    |        ^^^^^^^^^^^^^^        -------------------

error[E0599]: no method named `is_zero` found for struct `rustmath_rationals::Rational` in the current scope
  --> rustmath-algebraic/src/radicals.rs:27:14
   |
27 |         if r.is_zero() {
   |              ^^^^^^^ method not found in `rustmath_rationals::Rational`
   |
  ::: /home/john/RustMath/rustmath-core/src/traits.rs:63:8
   |
63 |     fn is_zero(&self) -> bool;
   |        ------- the method is available for `rustmath_rationals::Rational` here
   |
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
   |
 5 + use rustmath_core::Ring;
   |

warning: variable `N` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:228:13
    |
228 |         let N = self.conductor.to_f64().unwrap_or(1.0);
    |             ^ help: convert the identifier to snake case: `n`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `L_value` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:231:13
    |
231 |         let L_value = self.evaluate(s, 1000);
    |             ^^^^^^^ help: convert the identifier to snake case: `l_value`

warning: variable `N_to_s_half` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:233:13
    |
233 |         let N_to_s_half = N.powf(s.re / 2.0) * ComplexNum::new(
    |             ^^^^^^^^^^^ help: convert the identifier to snake case: `n_to_s_half`

error[E0599]: no function or associated item named `zero` found for struct `AlgebraicReal` in the current scope
  --> rustmath-algebraic/src/radicals.rs:28:35
   |
28 |             return AlgebraicReal::zero();
   |                                   ^^^^ function or associated item not found in `AlgebraicReal`
   |
  ::: rustmath-algebraic/src/algebraic_real.rs:23:1
   |
23 | pub struct AlgebraicReal {
   | ------------------------ function or associated item `zero` not found for this struct
   |
note: if you're trying to build a new `AlgebraicReal` consider using one of the following associated functions:
      AlgebraicReal::from_rational
      AlgebraicReal::from_i64
      AlgebraicReal::sqrt
      AlgebraicReal::nth_root
  --> rustmath-algebraic/src/algebraic_real.rs:30:5
   |
30 |     pub fn from_rational(r: Rational) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
37 |     pub fn from_i64(n: i64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
56 |     pub fn sqrt(n: i64) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
88 |     pub fn nth_root(n: i64, degree: u32) -> Self {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `zero` is implemented but not in scope; perhaps you want to import it
   |
 5 + use rustmath_core::Ring;
   |
help: there is a method `is_zero` with a similar name
   |
28 |             return AlgebraicReal::is_zero();
   |                                   +++

error[E0599]: no method named `to_i64` found for reference `&Integer` in the current scope
  --> rustmath-algebraic/src/radicals.rs:34:37
   |
34 |             let num = r.numerator().to_i64().unwrap_or(0);
   |                                     ^^^^^^
   |
   = help: items from traits can only be used if the trait is in scope
help: trait `NumericConversion` which provides `to_i64` is implemented but not in scope; perhaps you want to import it
   |
 5 + use rustmath_core::NumericConversion;
   |
help: there is a method `to_f64` with a similar name
   |
34 -             let num = r.numerator().to_i64().unwrap_or(0);
34 +             let num = r.numerator().to_f64().unwrap_or(0);
   |

error[E0599]: no method named `abs` found for struct `Ratio<T>` in the current scope
   --> rustmath-modular/src/hecke.rs:166:50
    |
166 |                 if (t_n_f[i].clone() - expected).abs() > BigRational::new(
    |                                                  ^^^ method not found in `Ratio<BigInt>`
    |
   ::: /home/john/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/sign.rs:14:8
    |
 14 |     fn abs(&self) -> Self;
    |        --- the method is available for `Ratio<BigInt>` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Signed` which provides `abs` is implemented but not in scope; perhaps you want to import it
    |
  6 + use num_traits::Signed;
    |

error[E0252]: the name `ExtensionType` is defined multiple times
  --> rustmath-rings/src/padics/mod.rs:53:28
   |
19 |     ExtensionType, GaloisGroup, PadicEmbedding, PadicExtension, PadicExtensionElement,
   |     ------------- previous import of the type `ExtensionType` here
...
53 | pub use pow_computer_ext::{ExtensionType, PowComputerExt};
   |                            ^^^^^^^^^^^^^ `ExtensionType` reimported here
   |
   = note: `ExtensionType` must be defined only once in the type namespace of this module
help: you can use `as` to change the binding name of the import
   |
53 | pub use pow_computer_ext::{ExtensionType as OtherExtensionType, PowComputerExt};
   |                                          +++++++++++++++++++++

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> rustmath-plot3d/src/shapes.rs:65:9
    |
 65 |         Box::new(self.clone())
    |         ^^^^^^^^--------------
    |                 ||
    |                 |expected `Point3D`, found `Sphere`
    |                 argument #2 of type `Point3D` is missing
    |
note: associated function defined here
   --> rustmath-plot3d/src/shapes.rs:133:12
    |
133 |     pub fn new(min_corner: Point3D, max_corner: Point3D) -> Self {
    |            ^^^ -------------------  -------------------
help: provide the argument
    |
 65 -         Box::new(self.clone())
 65 +         Box::new(/* Point3D */, /* Point3D */)
    |

error[E0252]: the name `NumberFieldEmbedding` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:950:5
    |
891 |     NumberFieldEmbedding,
    |     -------------------- previous import of the type `NumberFieldEmbedding` here
...
950 |     NumberFieldEmbedding,
    |     ^^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `NumberFieldEmbedding` reimported here
    |     help: remove unnecessary import
    |
    = note: `NumberFieldEmbedding` must be defined only once in the type namespace of this module

error[E0252]: the name `NumberFieldAutomorphism` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:951:5
    |
892 |     NumberFieldAutomorphism,
    |     ----------------------- previous import of the type `NumberFieldAutomorphism` here
...
951 |     NumberFieldAutomorphism,
    |     ^^^^^^^^^^^^^^^^^^^^^^^-
    |     |
    |     `NumberFieldAutomorphism` reimported here
    |     help: remove unnecessary import
    |
    = note: `NumberFieldAutomorphism` must be defined only once in the type namespace of this module

error[E0252]: the name `GaloisGroup` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:952:5
    |
893 |     GaloisGroup,
    |     ----------- previous import of the type `GaloisGroup` here
...
952 |     GaloisGroup,
    |     ^^^^^^^^^^^-
    |     |
    |     `GaloisGroup` reimported here
    |     help: remove unnecessary import
    |
    = note: `GaloisGroup` must be defined only once in the type namespace of this module

error[E0252]: the name `MorphismError` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:959:5
    |
900 |     MorphismError,
    |     ------------- previous import of the type `MorphismError` here
...
959 |     MorphismError,
    |     ^^^^^^^^^^^^^-
    |     |
    |     `MorphismError` reimported here
    |     help: remove unnecessary import
    |
    = note: `MorphismError` must be defined only once in the type namespace of this module

error[E0252]: the name `Order` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:969:17
    |
910 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                 ----- previous import of the type `Order` here
...
969 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                 ^^^^^--
    |                 |
    |                 `Order` reimported here
    |                 help: remove unnecessary import
    |
    = note: `Order` must be defined only once in the type namespace of this module

error[E0252]: the name `OrderElement` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:969:24
    |
910 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                        ------------ previous import of the type `OrderElement` here
...
969 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                        ^^^^^^^^^^^^--
    |                        |
    |                        `OrderElement` reimported here
    |                        help: remove unnecessary import
    |
    = note: `OrderElement` must be defined only once in the type namespace of this module

error[E0252]: the name `OrderIdeal` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:969:38
    |
910 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                                      ---------- previous import of the type `OrderIdeal` here
...
969 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                                      ^^^^^^^^^^--
    |                                      |
    |                                      `OrderIdeal` reimported here
    |                                      help: remove unnecessary import
    |
    = note: `OrderIdeal` must be defined only once in the type namespace of this module

error[E0252]: the name `OrderError` is defined multiple times
   --> rustmath-rings/src/number_field/mod.rs:969:50
    |
910 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                                                  ---------- previous import of the type `OrderError` here
...
969 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                                                  ^^^^^^^^^^ `OrderError` reimported here
    |
    = note: `OrderError` must be defined only once in the type namespace of this module

error[E0308]: mismatched types
   --> rustmath-plot3d/src/shapes.rs:181:9
    |
180 |     fn clone_box(&self) -> Box<dyn Graphics3dPrimitive> {
    |                            ---------------------------- expected `shapes::Box` because of return type
181 |         std::boxed::Box::new(self.clone())
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Box`, found `Box<Box>`
    |
    = note: `std::boxed::Box<shapes::Box>` and `shapes::Box` have similar names, but are actually distinct types
note: `std::boxed::Box<shapes::Box>` is defined in crate `alloc`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:231:1
    |
231 | / pub struct Box<
232 | |     T: ?Sized,
233 | |     #[unstable(feature = "allocator_api", issue = "32838")] A: Allocator = Global,
234 | | >(Unique<T>, A);
    | |_^
note: `shapes::Box` is defined in the current crate
   --> rustmath-plot3d/src/shapes.rs:122:1
    |
122 | pub struct Box {
    | ^^^^^^^^^^^^^^
help: consider unboxing the value
    |
181 |         *std::boxed::Box::new(self.clone())
    |         +

error[E0599]: no method named `index` found for struct `Gamma0` in the current scope
   --> rustmath-modular/src/abvar.rs:86:28
    |
 86 |         let index = gamma0.index().unwrap_or(1);
    |                            ^^^^^ method not found in `Gamma0`
    |
   ::: rustmath-modular/src/arithgroup.rs:127:8
    |
127 |     fn index(&self) -> Option<u64>;
    |        ----- the method is available for `Gamma0` here
...
198 | pub struct Gamma0 {
    | ----------------- method `index` not found for this struct
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ArithmeticSubgroup` which provides `index` is implemented but not in scope; perhaps you want to import it
    |
  6 + use crate::arithgroup::ArithmeticSubgroup;
    |

error[E0599]: no method named `index` found for struct `Gamma1` in the current scope
   --> rustmath-modular/src/abvar.rs:141:28
    |
141 |         let index = gamma1.index().unwrap_or(1);
    |                            ^^^^^ method not found in `Gamma1`
    |
   ::: rustmath-modular/src/arithgroup.rs:127:8
    |
127 |     fn index(&self) -> Option<u64>;
    |        ----- the method is available for `Gamma1` here
...
296 | pub struct Gamma1 {
    | ----------------- method `index` not found for this struct
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ArithmeticSubgroup` which provides `index` is implemented but not in scope; perhaps you want to import it
    |
  6 + use crate::arithgroup::ArithmeticSubgroup;
    |

warning: unused variable: `b`
  --> rustmath-numerical/src/linear_programming.rs:20:5
   |
20 |     b: &[f64],
   |     ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `max_iter`
  --> rustmath-numerical/src/linear_programming.rs:21:5
   |
21 |     max_iter: usize,
   |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_iter`

warning: unused variable: `alpha`
   --> rustmath-stats/src/hypothesis.rs:195:21
    |
195 | fn t_critical_value(alpha: f64, df: usize) -> f64 {
    |                     ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0432]: unresolved import `rustmath_matrix`
  --> rustmath-rings/src/function_field/theta_functions.rs:74:5
   |
74 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `rustmath_matrix`
   |
help: there is a crate or module with a similar name
   |
74 - use rustmath_matrix::Matrix;
74 + use rustmath_core::Matrix;
   |

error[E0432]: unresolved import `rustmath_matrix`
  --> rustmath-rings/src/number_field/order.rs:56:5
   |
56 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `rustmath_matrix`
   |
help: there is a crate or module with a similar name
   |
56 - use rustmath_matrix::Matrix;
56 + use rustmath_core::Matrix;
   |

warning: unused variable: `min_poly`
  --> rustmath-algebraic/src/conjugates.rs:18:9
   |
18 |     let min_poly = minimal_polynomial(alpha);
   |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_poly`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0432]: unresolved import `rustmath_matrix`
  --> rustmath-rings/src/number_field/s_unit_solver.rs:80:5
   |
80 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `rustmath_matrix`
   |
help: there is a crate or module with a similar name
   |
80 - use rustmath_matrix::Matrix;
80 + use rustmath_core::Matrix;
   |

warning: unused import: `rustmath_core::Ring`
  --> rustmath-calculus/src/riemann.rs:26:5
   |
26 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::NumericConversion`
 --> rustmath-calculus/src/sum.rs:6:5
  |
6 | use rustmath_core::NumericConversion;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `n_features`
   --> rustmath-stats/src/regression.rs:131:13
    |
131 |         let n_features = x_matrix[0].len();
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_features`

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
For more information about this error, try `rustc --explain E0689`.
warning: variable does not need to be mutable
   --> rustmath-stats/src/regression.rs:134:13
    |
134 |         let mut x_with_intercept: Vec<Vec<f64>> = x_matrix
    |             ----^^^^^^^^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0599]: no method named `abs` found for struct `BigInt` in the current scope
   --> rustmath-modular/src/dirichlet.rs:252:31
    |
252 |     DirichletCharacter::new(d.abs(), HashMap::new())
    |                               ^^^ method not found in `BigInt`
    |
   ::: /home/john/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-traits-0.2.19/src/sign.rs:14:8
    |
 14 |     fn abs(&self) -> Self;
    |        --- the method is available for `BigInt` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Signed` which provides `abs` is implemented but not in scope; perhaps you want to import it
    |
  9 + use num_traits::Signed;
    |

warning: `rustmath-numerical` (lib) generated 5 warnings
error: could not compile `rustmath-numerical` (lib) due to 1 previous error; 5 warnings emitted
warning: `rustmath-algebraic` (lib) generated 3 warnings
error: could not compile `rustmath-algebraic` (lib) due to 20 previous errors; 3 warnings emitted
error[E0599]: no method named `powc` found for type `f64` in the current scope
   --> rustmath-modular/src/lfunction.rs:214:38
    |
214 |             let n_to_minus_s = (n_f).powc(-s);
    |                                      ^^^^
    |
   ::: /home/john/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-complex-0.4.6/src/complex_float.rs:56:8
    |
 56 |     fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
    |        ---- the method is available for `f64` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ComplexFloat` which provides `powc` is implemented but not in scope; perhaps you want to import it
    |
 20 + use num_complex::ComplexFloat;
    |
help: there is a method `pow` with a similar name
    |
214 -             let n_to_minus_s = (n_f).powc(-s);
214 +             let n_to_minus_s = (n_f).pow(-s);
    |

Some errors have detailed explanations: E0277, E0599.
For more information about an error, try `rustc --explain E0277`.
error[E0599]: no method named `powc` found for type `f64` in the current scope
   --> rustmath-modular/src/lfunction.rs:220:25
    |
220 |         let N_power = N.powc(0.5 - s);
    |                         ^^^^
    |
   ::: /home/john/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-complex-0.4.6/src/complex_float.rs:56:8
    |
 56 |     fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
    |        ---- the method is available for `f64` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ComplexFloat` which provides `powc` is implemented but not in scope; perhaps you want to import it
    |
 20 + use num_complex::ComplexFloat;
    |
help: there is a method `pow` with a similar name
    |
220 -         let N_power = N.powc(0.5 - s);
220 +         let N_power = N.pow(0.5 - s);
    |

error[E0308]: mismatched types
   --> rustmath-plot3d/src/plots/marching_cubes_tri_table.inc:20:5
    |
 20 |     [9, 8, 10, 10, 8, 11, 255, 255, 255, 255, 255, 255, 255, 255, 255],
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an array with a size of 16, found one with a size of 15
    |
   ::: rustmath-plot3d/src/plots/implicit_plot3d.rs:285:44
    |
285 | const MARCHING_CUBES_TRI_TABLE: [[u8; 16]; 256] = include!("marching_cubes_tri_table.inc");
    |                                            --- help: consider specifying the actual array length: `15`

error[E0599]: no method named `powc` found for type `f64` in the current scope
   --> rustmath-modular/src/lfunction.rs:230:47
    |
230 |             let n_to_minus_one_plus_s = (n_f).powc(-one_minus_s);
    |                                               ^^^^
    |
   ::: /home/john/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/num-complex-0.4.6/src/complex_float.rs:56:8
    |
 56 |     fn powc(self, exp: Complex<Self::Real>) -> Complex<Self::Real>;
    |        ---- the method is available for `f64` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `ComplexFloat` which provides `powc` is implemented but not in scope; perhaps you want to import it
    |
 20 + use num_complex::ComplexFloat;
    |
help: there is a method `pow` with a similar name
    |
230 -             let n_to_minus_one_plus_s = (n_f).powc(-one_minus_s);
230 +             let n_to_minus_one_plus_s = (n_f).pow(-one_minus_s);
    |

warning: `rustmath-stats` (lib) generated 5 warnings
error: could not compile `rustmath-stats` (lib) due to 2 previous errors; 5 warnings emitted
error[E0609]: no field `vertices` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:114:46
    |
114 |         writeln!(file, "# {} vertices", mesh.vertices.len())?;
    |                                              ^^^^^^^^ unknown field

error[E0609]: no field `vertices` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:115:24
    |
115 |         for v in &mesh.vertices {
    |                        ^^^^^^^^ unknown field

error[E0609]: no field `normals` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:121:38
    |
121 |         if let Some(normals) = &mesh.normals {
    |                                      ^^^^^^^ unknown field

error[E0609]: no field `faces` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:130:43
    |
130 |         writeln!(file, "# {} faces", mesh.faces.len())?;
    |                                           ^^^^^ unknown field

error[E0609]: no field `normals` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:131:17
    |
131 |         if mesh.normals.is_some() {
    |                 ^^^^^^^ unknown field

error[E0609]: no field `faces` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:132:31
    |
132 |             for face in &mesh.faces {
    |                               ^^^^^ unknown field

error[E0609]: no field `normals` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:141:35
    |
141 |             normal_offset += mesh.normals.as_ref().unwrap().len();
    |                                   ^^^^^^^ unknown field

error[E0609]: no field `faces` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:143:31
    |
143 |             for face in &mesh.faces {
    |                               ^^^^^ unknown field

error[E0609]: no field `vertices` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:154:31
    |
154 |         vertex_offset += mesh.vertices.len();
    |                               ^^^^^^^^ unknown field

error[E0609]: no field `faces` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:256:64
    |
256 |     let total_faces: usize = graphics.objects.iter().map(|m| m.faces.len()).sum();
    |                                                                ^^^^^ unknown field

error[E0609]: no field `faces` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:267:38
    |
267 |         for (face_idx, face) in mesh.faces.iter().enumerate() {
    |                                      ^^^^^ unknown field

error[E0609]: no field `vertices` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:268:28
    |
268 |             let v0 = &mesh.vertices[face[0]];
    |                            ^^^^^^^^ unknown field

error[E0609]: no field `vertices` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:269:28
    |
269 |             let v1 = &mesh.vertices[face[1]];
    |                            ^^^^^^^^ unknown field

error[E0609]: no field `vertices` on type `&std::boxed::Box<dyn Graphics3dPrimitive>`
   --> rustmath-plot3d/src/export.rs:270:28
    |
270 |             let v2 = &mesh.vertices[face[2]];
    |                            ^^^^^^^^ unknown field

error[E0282]: type annotations needed for `&mut _`
   --> rustmath-manifolds/src/utilities.rs:154:34
    |
154 |                     .and_modify(|e| *e = e.clone() + final_expr.clone())
    |                                  ^         ----- type must be known at this point
    |
help: consider giving this closure parameter an explicit type, where the placeholders `_` are specified
    |
154 |                     .and_modify(|e: &mut V| *e = e.clone() + final_expr.clone())
    |                                   ++++++++

warning: unused variable: `dy`
   --> rustmath-calculus/src/riemann.rs:182:17
    |
182 |             let dy = if i == 0 {
    |                 ^^ help: if this is intentional, prefix it with an underscore: `_dy`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-calculus/src/riemann.rs:309:9
    |
309 |     let mut result = Complex::new(t.cos(), t.sin());
    |         ----^^^^^^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0507]: cannot move out of `self.color` as enum variant `Some` which is behind a shared reference
   --> rustmath-plot3d/src/shapes.rs:112:30
    |
112 |         if let Some(color) = self.color {
    |                     -----    ^^^^^^^^^^
    |                     |
    |                     data moved here
    |                     move occurs because `color` has type `Color`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
112 |         if let Some(color) = &self.color {
    |                              +

error[E0507]: cannot move out of `self.color` as enum variant `Some` which is behind a shared reference
   --> rustmath-plot3d/src/shapes.rs:220:30
    |
220 |         if let Some(color) = self.color {
    |                     -----    ^^^^^^^^^^
    |                     |
    |                     data moved here
    |                     move occurs because `color` has type `Color`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
220 |         if let Some(color) = &self.color {
    |                              +

error[E0507]: cannot move out of `self.color` as enum variant `Some` which is behind a shared reference
   --> rustmath-plot3d/src/shapes.rs:349:30
    |
349 |         if let Some(color) = self.color {
    |                     -----    ^^^^^^^^^^
    |                     |
    |                     data moved here
    |                     move occurs because `color` has type `Color`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
349 |         if let Some(color) = &self.color {
    |                              +

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/algebraic_closure.rs:25:21
   |
25 | use rustmath_core::{CommutativeRing, Field, IntegralDomain};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `CommutativeRing`
  --> rustmath-rings/src/asymptotic.rs:44:27
   |
44 | use rustmath_core::{Ring, CommutativeRing};
   |                           ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-rings/src/asymptotic.rs:45:5
   |
45 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/asymptotic.rs:47:5
   |
47 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/category_methods.rs:23:27
   |
23 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain, EuclideanDomain, MathError, Result};
   |                           ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `std::fmt::Debug`
  --> rustmath-rings/src/category_methods.rs:24:5
   |
24 | use std::fmt::Debug;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/cfinite_sequence.rs:42:5
   |
42 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `IntegralDomain` and `Ring`
  --> rustmath-rings/src/constructor.rs:33:21
   |
33 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                     ^^^^         ^^^^^^^^^^^^^^

warning: unused import: `EuclideanDomain`
  --> rustmath-rings/src/derivation.rs:11:27
   |
11 | use rustmath_core::{Ring, EuclideanDomain};
   |                           ^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-rings/src/derivation.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-rings/src/differential.rs:43:21
   |
43 | use std::ops::{Add, Mul, Neg, Div};
   |                     ^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field.rs:12:43
   |
12 | use rustmath_core::{Ring, IntegralDomain, Field};
   |                                           ^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/fraction_field.rs:15:17
   |
15 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `EuclideanDomain`
  --> rustmath-rings/src/fraction_field_element.rs:33:50
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field, EuclideanDomain};
   |                                                  ^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/fraction_field_element.rs:35:5
   |
35 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/fraction_field_element.rs:36:17
   |
36 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: type `FractionFieldElement_1poly_field` should have an upper camel case name
   --> rustmath-rings/src/fraction_field_element.rs:284:10
    |
284 | pub type FractionFieldElement_1poly_field<P> = FractionFieldElement<P>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FractionFieldElement1polyField`
    |
    = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: unused import: `IntegralDomain`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:34
   |
37 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                                  ^^^^^^^^^^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/fraction_field_fpt.rs:40:17
   |
40 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `IntegralDomain`
  --> rustmath-rings/src/function_field_element.rs:31:34
   |
31 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                                  ^^^^^^^^^^^^^^

warning: type `FunctionFieldElement_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field_element_polymod.rs:53:12
   |
53 | pub struct FunctionFieldElement_polymod<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldElementPolymod`

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/function_field_element_rational.rs:29:5
   |
29 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `FunctionFieldElement_rational` should have an upper camel case name
  --> rustmath-rings/src/function_field_element_rational.rs:45:12
   |
45 | pub struct FunctionFieldElement_rational<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldElementRational`

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/growth_group.rs:46:5
   |
46 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Signed`
  --> rustmath-rings/src/growth_group.rs:48:29
   |
48 | use num_traits::{Zero, One, Signed};
   |                             ^^^^^^

warning: unused imports: `ExponentialGrowthElement`, `ExponentialGrowthGroup`, `MonomialGrowthElement`, and `MonomialGrowthGroup`
  --> rustmath-rings/src/growth_group_cartesian.rs:35:33
   |
35 |     GrowthElement, GrowthGroup, MonomialGrowthElement, MonomialGrowthGroup,
   |                                 ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^
36 |     ExponentialGrowthElement, ExponentialGrowthGroup, Variable, GrowthGroupFactor,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/growth_group_cartesian.rs:38:5
   |
38 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `num_rational::BigRational`
  --> rustmath-rings/src/growth_group_cartesian.rs:39:5
   |
39 | use num_rational::BigRational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `One` and `Zero`
  --> rustmath-rings/src/growth_group_cartesian.rs:40:18
   |
40 | use num_traits::{Zero, One};
   |                  ^^^^  ^^^

warning: unused import: `std::sync::Arc`
  --> rustmath-rings/src/growth_group_cartesian.rs:43:5
   |
43 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

error[E0507]: cannot move out of `self.color` as enum variant `Some` which is behind a shared reference
   --> rustmath-plot3d/src/shapes.rs:463:30
    |
463 |         if let Some(color) = self.color {
    |                     -----    ^^^^^^^^^^
    |                     |
    |                     data moved here
    |                     move occurs because `color` has type `Color`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
463 |         if let Some(color) = &self.color {
    |                              +

warning: unused imports: `MorphismError` and `RingHomomorphismFromQuotient`
  --> rustmath-rings/src/homset.rs:40:41
   |
40 | use crate::morphism::{RingHomomorphism, RingHomomorphismFromQuotient, MorphismError};
   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `CommutativeRing`
  --> rustmath-rings/src/homset.rs:41:27
   |
41 | use rustmath_core::{Ring, CommutativeRing};
   |                           ^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `Ring`
  --> rustmath-rings/src/infinity.rs:46:21
   |
46 | use rustmath_core::{Ring, Field, CommutativeRing};
   |                     ^^^^  ^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `Add`, `Div`, `Mul`, and `Sub`
  --> rustmath-rings/src/infinity.rs:49:16
   |
49 | use std::ops::{Add, Sub, Mul, Div, Neg};
   |                ^^^  ^^^  ^^^  ^^^

warning: unused import: `std::collections::HashSet`
  --> rustmath-rings/src/monomials.rs:38:5
   |
38 | use std::collections::HashSet;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `IdealMonoid_nc` should have an upper camel case name
  --> rustmath-rings/src/noncommutative_ideals.rs:57:12
   |
57 | pub struct IdealMonoid_nc {
   |            ^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `IdealMonoidNc`

warning: type `Ideal_nc` should have an upper camel case name
   --> rustmath-rings/src/noncommutative_ideals.rs:179:12
    |
179 | pub struct Ideal_nc {
    |            ^^^^^^^^ help: convert the identifier to upper camel case: `IdealNc`

warning: unused import: `Field`
  --> rustmath-rings/src/padics/extension.rs:59:38
   |
59 | use rustmath_core::{CommutativeRing, Field, MathError, Result, Ring};
   |                                      ^^^^^

warning: unused import: `Div`
  --> rustmath-rings/src/padics/extension.rs:64:21
   |
64 | use std::ops::{Add, Div, Mul, Neg, Sub};
   |                     ^^^

warning: unused import: `ExtensionType`
  --> rustmath-rings/src/padics/mod.rs:53:28
   |
53 | pub use pow_computer_ext::{ExtensionType, PowComputerExt};
   |                            ^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/padics/capped_relative.rs:44:21
   |
44 | use rustmath_core::{CommutativeRing, Field, IntegralDomain, MathError, Result, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^

warning: unused imports: `Field` and `IntegralDomain`
  --> rustmath-rings/src/quotient_ring.rs:45:44
   |
45 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain};
   |                                            ^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Field`
  --> rustmath-rings/src/real_interval_absolute.rs:42:5
   |
42 | use rustmath_core::Field;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/real_mpfi.rs:51:5
   |
51 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing` and `IntegralDomain`
  --> rustmath-rings/src/residue_field.rs:24:34
   |
24 | use rustmath_core::{Ring, Field, IntegralDomain, CommutativeRing};
   |                                  ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^

warning: unused imports: `Hash` and `Hasher`
  --> rustmath-rings/src/residue_field.rs:27:17
   |
27 | use std::hash::{Hash, Hasher};
   |                 ^^^^  ^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/residue_field.rs:364:13
    |
364 |         use rustmath_integers::Integer;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/residue_field.rs:445:13
    |
445 |         use rustmath_integers::Integer;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/residue_field.rs:543:13
    |
543 |         use rustmath_integers::Integer;
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::morphism::RingHomomorphism`
  --> rustmath-rings/src/ring_extension.rs:38:5
   |
38 | use crate::morphism::RingHomomorphism;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing` and `Field`
  --> rustmath-rings/src/ring_extension.rs:39:27
   |
39 | use rustmath_core::{Ring, CommutativeRing, Field};
   |                           ^^^^^^^^^^^^^^^  ^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-rings/src/ring_extension.rs:40:5
   |
40 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0507]: cannot move out of `self.color` as enum variant `Some` which is behind a shared reference
   --> rustmath-plot3d/src/shapes.rs:574:30
    |
574 |         if let Some(color) = self.color {
    |                     -----    ^^^^^^^^^^
    |                     |
    |                     data moved here
    |                     move occurs because `color` has type `Color`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
574 |         if let Some(color) = &self.color {
    |                              +

warning: unused import: `std::fmt`
  --> rustmath-rings/src/ring_extension_morphism.rs:14:5
   |
14 | use std::fmt;
   |     ^^^^^^^^

warning: unused imports: `GrowthGroup`, `MonomialGrowthElement`, and `Variable`
  --> rustmath-rings/src/term_monoid.rs:38:42
   |
38 | use crate::growth_group::{GrowthElement, GrowthGroup, MonomialGrowthElement, Variable};
   |                                          ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-rings/src/term_monoid.rs:39:5
   |
39 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Signed`
  --> rustmath-rings/src/term_monoid.rs:41:29
   |
41 | use num_traits::{Zero, One, Signed};
   |                             ^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/universal_cyclotomic_field.rs:41:21
   |
41 | use rustmath_core::{Field, Ring};
   |                     ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:34:21
   |
34 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: type `DrinfeldModule_charzero` should have an upper camel case name
  --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:67:12
   |
67 | pub struct DrinfeldModule_charzero<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `DrinfeldModuleCharzero`

warning: type `DrinfeldModule_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/drinfeld_modules/charzero_drinfeld_module.rs:182:12
    |
182 | pub struct DrinfeldModule_rational<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `DrinfeldModuleRational`

warning: unused import: `std::collections::HashMap`
  --> rustmath-rings/src/function_field/drinfeld_modules/drinfeld_module.rs:42:5
   |
42 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:39:5
   |
39 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `DrinfeldModule_finite` should have an upper camel case name
  --> rustmath-rings/src/function_field/drinfeld_modules/finite_drinfeld_module.rs:61:12
   |
61 | pub struct DrinfeldModule_finite<F: Field, R: Ring> {
   |            ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `DrinfeldModuleFinite`

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/extensions.rs:38:21
   |
38 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/ideal.rs:42:21
   |
42 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused variable: `obj`
   --> rustmath-modular/src/abvar.rs:491:35
    |
491 | pub fn is_modular_abelian_variety(obj: &ModularAbelianVariety) -> bool {
    |                                   ^^^ help: if this is intentional, prefix it with an underscore: `_obj`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: type `FunctionFieldPlace_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field/place_polymod.rs:45:12
   |
45 | pub struct FunctionFieldPlace_polymod<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldPlacePolymod`

warning: type `FunctionFieldPlace_rational` should have an upper camel case name
  --> rustmath-rings/src/function_field/place_rational.rs:57:12
   |
57 | pub struct FunctionFieldPlace_rational<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldPlaceRational`

warning: type `FunctionFieldValuation_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/valuation.rs:121:12
    |
121 | pub struct FunctionFieldValuation_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldValuationBase`

warning: type `ClassicalFunctionFieldValuation_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/valuation.rs:182:12
    |
182 | pub struct ClassicalFunctionFieldValuation_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `ClassicalFunctionFieldValuationBase`

warning: type `RationalFunctionFieldValuation_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/valuation.rs:281:12
    |
281 | pub struct RationalFunctionFieldValuation_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RationalFunctionFieldValuationBase`

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/function_field_polymod.rs:53:28
   |
53 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: type `FunctionField_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field/function_field_polymod.rs:80:12
   |
80 | pub struct FunctionField_polymod<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldPolymod`

warning: type `FunctionField_simple` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:168:12
    |
168 | pub struct FunctionField_simple<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldSimple`

warning: type `FunctionField_char_zero` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:219:12
    |
219 | pub struct FunctionField_char_zero<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldCharZero`

warning: type `FunctionField_integral` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:252:12
    |
252 | pub struct FunctionField_integral<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIntegral`

warning: type `FunctionField_char_zero_integral` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:286:12
    |
286 | pub struct FunctionField_char_zero_integral<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldCharZeroIntegral`

warning: type `FunctionField_global` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:321:12
    |
321 | pub struct FunctionField_global<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldGlobal`

warning: type `FunctionField_global_integral` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:375:12
    |
375 | pub struct FunctionField_global_integral<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldGlobalIntegral`

warning: type `RationalFunctionField_char_zero` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_rational.rs:166:12
    |
166 | pub struct RationalFunctionField_char_zero<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RationalFunctionFieldCharZero`

warning: type `RationalFunctionField_global` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_rational.rs:231:12
    |
231 | pub struct RationalFunctionField_global<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RationalFunctionFieldGlobal`

warning: unused imports: `EuclideanDomain` and `Ring`
  --> rustmath-rings/src/function_field/hermite_form_polynomial.rs:43:21
   |
43 | use rustmath_core::{EuclideanDomain, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^

warning: unused import: `std::fmt::Debug`
  --> rustmath-rings/src/function_field/hermite_form_polynomial.rs:44:5
   |
44 | use std::fmt::Debug;
   |     ^^^^^^^^^^^^^^^

warning: type `FunctionFieldIdeal_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field/ideal_polymod.rs:70:12
   |
70 | pub struct FunctionFieldIdeal_polymod<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealPolymod`

warning: type `FunctionFieldIdealInfinite_polymod` should have an upper camel case name
   --> rustmath-rings/src/function_field/ideal_polymod.rs:227:12
    |
227 | pub struct FunctionFieldIdealInfinite_polymod<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealInfinitePolymod`

warning: type `FunctionFieldIdeal_global` should have an upper camel case name
   --> rustmath-rings/src/function_field/ideal_polymod.rs:284:12
    |
284 | pub struct FunctionFieldIdeal_global<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealGlobal`

warning: type `FunctionFieldIdeal_rational` should have an upper camel case name
  --> rustmath-rings/src/function_field/ideal_rational.rs:73:12
   |
73 | pub struct FunctionFieldIdeal_rational<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealRational`

warning: type `FunctionFieldIdealInfinite_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/ideal_rational.rs:254:12
    |
254 | pub struct FunctionFieldIdealInfinite_rational<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealInfiniteRational`

warning: type `FunctionFieldMorphism_polymod` should have an upper camel case name
   --> rustmath-rings/src/function_field/maps.rs:138:12
    |
138 | pub struct FunctionFieldMorphism_polymod<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMorphismPolymod`

warning: type `FunctionFieldMorphism_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/maps.rs:180:12
    |
180 | pub struct FunctionFieldMorphism_rational<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMorphismRational`

warning: type `FunctionFieldOrder_base` should have an upper camel case name
  --> rustmath-rings/src/function_field/order.rs:66:12
   |
66 | pub struct FunctionFieldOrder_base<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldOrderBase`

warning: type `FunctionFieldOrder_basis` should have an upper camel case name
  --> rustmath-rings/src/function_field/order_basis.rs:85:12
   |
85 | pub struct FunctionFieldOrder_basis<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldOrderBasis`

warning: type `FunctionFieldOrderInfinite_basis` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_basis.rs:233:12
    |
233 | pub struct FunctionFieldOrderInfinite_basis<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldOrderInfiniteBasis`

warning: type `FunctionFieldMaximalOrder_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field/order_polymod.rs:94:12
   |
94 | pub struct FunctionFieldMaximalOrder_polymod<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderPolymod`

warning: type `FunctionFieldMaximalOrder_global` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_polymod.rs:274:12
    |
274 | pub struct FunctionFieldMaximalOrder_global<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderGlobal`

warning: type `FunctionFieldMaximalOrderInfinite_polymod` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_polymod.rs:401:12
    |
401 | pub struct FunctionFieldMaximalOrderInfinite_polymod<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderInfinitePolymod`

warning: unused variable: `space`
   --> rustmath-modular/src/abvar.rs:520:24
    |
520 | pub fn modsym_lattices(space: &ModularSymbolSpace) -> Vec<Vec<BigRational>> {
    |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_space`

warning: type `FunctionFieldMaximalOrder_rational` should have an upper camel case name
  --> rustmath-rings/src/function_field/order_rational.rs:91:12
   |
91 | pub struct FunctionFieldMaximalOrder_rational<F: Field> {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderRational`

warning: type `FunctionFieldMaximalOrderInfinite_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_rational.rs:311:12
    |
311 | pub struct FunctionFieldMaximalOrderInfinite_rational<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderInfiniteRational`

warning: type `JacobianPoint_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_base.rs:101:12
    |
101 | pub struct JacobianPoint_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianPointBase`

warning: type `JacobianGroup_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_base.rs:203:12
    |
203 | pub struct JacobianGroup_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianGroupBase`

warning: type `Jacobian_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_base.rs:309:12
    |
309 | pub struct Jacobian_base<F: Field> {
    |            ^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianBase`

warning: type `JacobianPoint_finite_field_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_base.rs:400:12
    |
400 | pub struct JacobianPoint_finite_field_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianPointFiniteFieldBase`

warning: type `JacobianGroup_finite_field_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_base.rs:476:12
    |
476 | pub struct JacobianGroup_finite_field_base<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianGroupFiniteFieldBase`

warning: type `Jacobian_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_hess.rs:342:12
    |
342 | pub struct Jacobian_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianFiniteField`

warning: type `JacobianPoint_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_hess.rs:401:12
    |
401 | pub struct JacobianPoint_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianPointFiniteField`

warning: type `JacobianGroup_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_hess.rs:459:12
    |
459 | pub struct JacobianGroup_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianGroupFiniteField`

warning: type `JacobianGroupEmbedding_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_hess.rs:511:12
    |
511 | pub struct JacobianGroupEmbedding_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianGroupEmbeddingFiniteField`

warning: type `Jacobian_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:399:12
    |
399 | pub struct Jacobian_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianFiniteField`

warning: type `JacobianPoint_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:460:12
    |
460 | pub struct JacobianPoint_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianPointFiniteField`

warning: type `JacobianGroup_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:519:12
    |
519 | pub struct JacobianGroup_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianGroupFiniteField`

warning: unused variable: `coeffs`
   --> rustmath-modular/src/abvar.rs:532:18
    |
532 | pub fn sqrt_poly(coeffs: &[BigRational]) -> Option<Vec<BigRational>> {
    |                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: type `JacobianGroupEmbedding_finite_field` should have an upper camel case name
   --> rustmath-rings/src/function_field/jacobian_khuri_makdisi.rs:578:12
    |
578 | pub struct JacobianGroupEmbedding_finite_field<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `JacobianGroupEmbeddingFiniteField`

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:70:5
   |
70 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `KhuriMakdisi_base` should have an upper camel case name
  --> rustmath-rings/src/function_field/khuri_makdisi.rs:98:12
   |
98 | pub struct KhuriMakdisi_base<F: Field> {
   |            ^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `KhuriMakdisiBase`

warning: type `KhuriMakdisi_small` should have an upper camel case name
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:245:12
    |
245 | pub struct KhuriMakdisi_small<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `KhuriMakdisiSmall`

warning: type `KhuriMakdisi_medium` should have an upper camel case name
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:329:12
    |
329 | pub struct KhuriMakdisi_medium<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `KhuriMakdisiMedium`

warning: type `KhuriMakdisi_large` should have an upper camel case name
   --> rustmath-rings/src/function_field/khuri_makdisi.rs:441:12
    |
441 | pub struct KhuriMakdisi_large<F: Field> {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `KhuriMakdisiLarge`

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-rings/src/function_field/picard_group.rs:58:5
   |
58 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Field`
  --> rustmath-rings/src/function_field/theta_functions.rs:73:5
   |
73 | use rustmath_core::Field;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing` and `Field`
  --> rustmath-rings/src/invariants/invariant_theory.rs:25:27
   |
25 | use rustmath_core::{Ring, Field, CommutativeRing};
   |                           ^^^^^  ^^^^^^^^^^^^^^^

warning: unused import: `std::fmt`
  --> rustmath-rings/src/invariants/invariant_theory.rs:26:5
   |
26 | use std::fmt;
   |     ^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/invariants/invariant_theory.rs:27:5
   |
27 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/invariants/reconstruction.rs:27:27
   |
27 | use rustmath_core::{Ring, Field};
   |                           ^^^^^

warning: unused import: `Mul`
  --> rustmath-rings/src/laurent_series_ring_element.rs:39:26
   |
39 | use std::ops::{Add, Sub, Mul};
   |                          ^^^

warning: unused import: `std::fmt`
  --> rustmath-rings/src/lazy_series.rs:30:5
   |
30 | use std::fmt;
   |     ^^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-rings/src/lazy_series.rs:31:5
   |
31 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-rings/src/multi_power_series_ring_element.rs:29:26
   |
29 | use std::ops::{Add, Sub, Mul};
   |                          ^^^

warning: unused import: `Div`
  --> rustmath-rings/src/power_series_poly.rs:34:21
   |
34 | use std::ops::{Add, Div, Mul, Neg, Sub};
   |                     ^^^

warning: unused import: `std::cmp::Ordering`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:35:5
   |
35 | use std::cmp::Ordering;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `Div`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:37:21
   |
37 | use std::ops::{Add, Div, Mul, Neg, Sub};
   |                     ^^^

warning: unused import: `Field`
  --> rustmath-rings/src/real_arb.rs:41:21
   |
41 | use rustmath_core::{Field, Ring};
   |                     ^^^^^

error[E0308]: `match` arms have incompatible types
   --> rustmath-manifolds/src/vector_field.rs:148:42
    |
146 |               let val = match comp {
    |  _______________________-
147 | |                 Expr::Integer(ref n) => n.to_f64().unwrap_or(0.0),
    | |                                         ------------------------- this is found to be of type `f64`
148 | |                 Expr::Rational(ref r) => r.to_f64(),
    | |                                          ^^^^^^^^^^ expected `f64`, found `Option<f64>`
149 | |                 _ => 0.0, // For now, treat other expressions as 0
150 | |             };
    | |_____________- `match` arms have incompatible types
    |
    = note: expected type `f64`
               found enum `Option<f64>`
help: consider using `Option::expect` to unwrap the `Option<f64>` value, panicking if the value is an `Option::None`
    |
148 |                 Expr::Rational(ref r) => r.to_f64().expect("REASON"),
    |                                                    +++++++++++++++++

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-rings/src/sum_of_squares.rs:29:5
   |
29 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `DiscreteValuation`
 --> rustmath-rings/src/valuation/scaled_valuation.rs:5:49
  |
5 | use super::valuation::{DiscretePseudoValuation, DiscreteValuation, ValuationValue};
  |                                                 ^^^^^^^^^^^^^^^^^

warning: unused import: `ValuationValue`
 --> rustmath-rings/src/valuation/gauss_valuation.rs:5:49
  |
5 | use super::valuation::{DiscretePseudoValuation, ValuationValue};
  |                                                 ^^^^^^^^^^^^^^

warning: unused import: `DiscreteValuation`
 --> rustmath-rings/src/valuation/mapped_valuation.rs:5:49
  |
5 | use super::valuation::{DiscretePseudoValuation, DiscreteValuation, ValuationValue};
  |                                                 ^^^^^^^^^^^^^^^^^

warning: unused imports: `CommutativeRing`, `Field`, and `IntegralDomain`
  --> rustmath-rings/src/qqbar.rs:43:21
   |
43 | use rustmath_core::{CommutativeRing, Field, IntegralDomain, Ring};
   |                     ^^^^^^^^^^^^^^^  ^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
   --> rustmath-rings/src/number_field/mod.rs:147:5
    |
147 | use rustmath_integers::Integer;
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CommutativeRing`
  --> rustmath-rings/src/number_field/morphisms.rs:85:21
   |
85 | use rustmath_core::{CommutativeRing, Field, Ring};
   |                     ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_complex::Complex`
  --> rustmath-rings/src/number_field/morphisms.rs:86:5
   |
86 | use rustmath_complex::Complex;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-rings/src/number_field/morphisms.rs:87:5
   |
87 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_reals::Real`
  --> rustmath-rings/src/number_field/morphisms.rs:91:5
   |
91 | use rustmath_reals::Real;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-rings/src/number_field/morphisms.rs:92:24
   |
92 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `IntegralDomain`
  --> rustmath-rings/src/number_field/order.rs:52:27
   |
52 | use rustmath_core::{Ring, IntegralDomain, EuclideanDomain, NumericConversion};
   |                           ^^^^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/number_field/s_unit_solver.rs:76:27
   |
76 | use rustmath_core::{Ring, Field};
   |                           ^^^^^

warning: unused import: `UnitGroup`
  --> rustmath-rings/src/number_field/s_unit_solver.rs:79:62
   |
79 | use rustmath_numberfields::{NumberField, NumberFieldElement, UnitGroup};
   |                                                              ^^^^^^^^^

warning: unused import: `std::collections::HashSet`
  --> rustmath-rings/src/number_field/s_unit_solver.rs:81:5
   |
81 | use std::collections::HashSet;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `GaloisGroup`, `MorphismError`, `NumberFieldAutomorphism`, `NumberFieldEmbedding`, `NumberFieldMorphism`, `Result as MorphismResult`, `compute_automorphisms`, `galois_group`, `is_galois_extension`, `is_normal_extension`, `is_separable_extension`, and `splitting_field`
   --> rustmath-rings/src/number_field/mod.rs:949:5
    |
949 |     NumberFieldMorphism,
    |     ^^^^^^^^^^^^^^^^^^^
950 |     NumberFieldEmbedding,
    |     ^^^^^^^^^^^^^^^^^^^^
951 |     NumberFieldAutomorphism,
    |     ^^^^^^^^^^^^^^^^^^^^^^^
952 |     GaloisGroup,
    |     ^^^^^^^^^^^
953 |     compute_automorphisms,
    |     ^^^^^^^^^^^^^^^^^^^^^
954 |     is_galois_extension,
    |     ^^^^^^^^^^^^^^^^^^^
955 |     is_normal_extension,
    |     ^^^^^^^^^^^^^^^^^^^
956 |     is_separable_extension,
    |     ^^^^^^^^^^^^^^^^^^^^^^
957 |     splitting_field,
    |     ^^^^^^^^^^^^^^^
958 |     galois_group,
    |     ^^^^^^^^^^^^
959 |     MorphismError,
    |     ^^^^^^^^^^^^^
960 |     Result as MorphismResult,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `OrderElement`, `OrderError`, `OrderIdeal`, and `Order`
   --> rustmath-rings/src/number_field/mod.rs:969:17
    |
969 | pub use order::{Order, OrderElement, OrderIdeal, OrderError};
    |                 ^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^

warning: unused imports: `ExtensionType`, `GaloisGroup`, `PadicEmbedding`, `PadicExtensionElement`, and `PadicExtension`
  --> rustmath-rings/src/padics/mod.rs:19:5
   |
19 |     ExtensionType, GaloisGroup, PadicEmbedding, PadicExtension, PadicExtensionElement,
   |     ^^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `PadicInteger` and `PadicRational`
  --> rustmath-rings/src/padics/mod.rs:23:27
   |
23 | pub use rustmath_padics::{PadicInteger, PadicRational};
   |                           ^^^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `pow_computer::PowComputer`
  --> rustmath-rings/src/padics/mod.rs:52:9
   |
52 | pub use pow_computer::PowComputer;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `ExtensionType` and `PowComputerExt`
  --> rustmath-rings/src/padics/mod.rs:53:28
   |
53 | pub use pow_computer_ext::{ExtensionType, PowComputerExt};
   |                            ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^

warning: unused import: `capped_relative::CappedRelativePadicElement`
  --> rustmath-rings/src/padics/mod.rs:89:9
   |
89 | pub use capped_relative::CappedRelativePadicElement;
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `PadicFieldExtension`, `PadicField`, `PadicIntegerExtension`, `PadicIntegerRing`, `PrecisionModel`, `Qp`, `Qq`, `Zp`, and `Zq`
   --> rustmath-rings/src/padics/mod.rs:127:5
    |
127 |     PadicField, PadicFieldExtension, PadicIntegerExtension, PadicIntegerRing, PrecisionModel, Qp,
    |     ^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^  ^^
128 |     Qq, Zp, Zq,
    |     ^^  ^^  ^^

warning: unused variable: `m`
   --> rustmath-calculus/src/transforms/dwt.rs:371:9
    |
371 |     let m = filter.len();
    |         ^ help: if this is intentional, prefix it with an underscore: `_m`

warning: unused variable: `h_subgroup`
   --> rustmath-modular/src/abvar.rs:936:27
    |
936 |     pub fn jh(level: u64, h_subgroup: Vec<u64>) -> ModularAbelianVariety {
    |                           ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_h_subgroup`

error[E0507]: cannot move out of index of `Vec<Color>`
   --> rustmath-plot3d/src/plots/scatter_plot3d.rs:103:17
    |
103 |                 colors[i]
    |                 ^^^^^^^^^ move occurs because value has type `Color`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
103 |                 &colors[i]
    |                 +
help: consider cloning the value if the performance cost is acceptable
    |
103 |                 colors[i].clone()
    |                          ++++++++

error[E0382]: use of moved value: `opts.color`
   --> rustmath-plot3d/src/plots/scatter_plot3d.rs:105:17
    |
105 |                 opts.color.unwrap_or(Color::rgb(0.0, 0.5, 1.0))
    |                 ^^^^^^^^^^ value moved here, in previous iteration of loop
...
108 |             opts.color.unwrap_or(Color::rgb(0.0, 0.5, 1.0))
    |             ---------- value moved here, in previous iteration of loop
    |
    = note: move occurs because `opts.color` has type `Option<Color>`, which does not implement the `Copy` trait

warning: unused variable: `obj`
   --> rustmath-modular/src/dirichlet.rs:214:30
    |
214 | pub fn is_DirichletCharacter(obj: &DirichletCharacter) -> bool {
    |                              ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `obj`
   --> rustmath-modular/src/dirichlet.rs:220:26
    |
220 | pub fn is_DirichletGroup(obj: &DirichletGroup) -> bool {
    |                          ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: field `wavelet` is never read
  --> rustmath-calculus/src/transforms/dwt.rs:36:5
   |
34 | pub struct DiscreteWaveletTransform {
   |            ------------------------ field in this struct
35 |     /// Wavelet family
36 |     wavelet: WaveletFamily,
   |     ^^^^^^^
   |
   = note: `DiscreteWaveletTransform` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: methods `fft_recursive` and `dft_fallback` are never used
   --> rustmath-calculus/src/transforms/fft.rs:67:8
    |
 32 | impl FastFourierTransformComplex {
    | -------------------------------- methods in this implementation
...
 67 |     fn fft_recursive(&self, input: &[Complex]) -> Vec<Complex> {
    |        ^^^^^^^^^^^^^
...
116 |     fn dft_fallback(&self, input: &[Complex]) -> Vec<Complex> {
    |        ^^^^^^^^^^^^

error[E0382]: use of moved value
   --> rustmath-plot3d/src/plots/vector_field_plot3d.rs:172:29
    |
172 |                 if let Some(color) = opts.color {
    |                             ^^^^^ value moved here, in previous iteration of loop
    |
    = note: move occurs because value has type `Color`, which does not implement the `Copy` trait
help: borrow this binding in the pattern to avoid moving the value
    |
172 |                 if let Some(ref color) = opts.color {
    |                             +++

warning: unused variable: `face_idx`
   --> rustmath-plot3d/src/export.rs:207:10
    |
207 |     for (face_idx, face) in mesh.faces.iter().enumerate() {
    |          ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_face_idx`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `N`
   --> rustmath-modular/src/etaproducts.rs:323:5
    |
323 |     N: &BigInt,
    |     ^ help: if this is intentional, prefix it with an underscore: `_N`

warning: unused variable: `degree`
   --> rustmath-modular/src/etaproducts.rs:324:5
    |
324 |     degree: usize,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `p`
 --> rustmath-modular/src/btquotients/btquotient.rs:6:16
  |
6 |     pub fn new(p: u64, level: u64) -> Self {
  |                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `level`
 --> rustmath-modular/src/btquotients/btquotient.rs:6:24
  |
6 |     pub fn new(p: u64, level: u64) -> Self {
  |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_level`

warning: unused variable: `weight`
 --> rustmath-modular/src/btquotients/pautomorphicform.rs:6:16
  |
6 |     pub fn new(weight: i32) -> Self {
  |                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_weight`

warning: unused variable: `coeffs`
 --> rustmath-modular/src/drinfeld_modform/element.rs:6:16
  |
6 |     pub fn new(coeffs: Vec<f64>) -> Self {
  |                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: unused variable: `rank`
 --> rustmath-modular/src/drinfeld_modform/ring.rs:6:16
  |
6 |     pub fn new(rank: usize) -> Self {
  |                ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`

Some errors have detailed explanations: E0053, E0061, E0107, E0308, E0382, E0507, E0609.
For more information about an error, try `rustc --explain E0053`.
warning: unused variable: `level`
 --> rustmath-modular/src/quatalg/brandt.rs:6:16
  |
6 |     pub fn new(level: u64) -> Self {
  |                ^^^^^ help: if this is intentional, prefix it with an underscore: `_level`

warning: unused variable: `p`
 --> rustmath-modular/src/ssmod/ssmod.rs:6:16
  |
6 |     pub fn new(p: u64) -> Self {
  |                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `alpha`
  --> rustmath-modular/src/hypergeometric_motive.rs:29:26
   |
29 |     fn compute_conductor(alpha: &[f64], beta: &[f64]) -> u64 {
   |                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`

warning: unused variable: `beta`
  --> rustmath-modular/src/hypergeometric_motive.rs:29:41
   |
29 |     fn compute_conductor(alpha: &[f64], beta: &[f64]) -> u64 {
   |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `p`
  --> rustmath-modular/src/hypergeometric_motive.rs:35:32
   |
35 |     pub fn euler_factor(&self, p: u64) -> Vec<f64> {
   |                                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
  --> rustmath-modular/src/hypergeometric_motive.rs:41:38
   |
41 |     pub fn is_wildly_ramified(&self, p: u64) -> bool {
   |                                      ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `precision`
  --> rustmath-modular/src/multiple_zeta.rs:30:35
   |
30 |     pub fn numerical_value(&self, precision: usize) -> f64 {
   |                                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`

For more information about this error, try `rustc --explain E0599`.
warning: `rustmath-plot3d` (lib) generated 7 warnings
error: could not compile `rustmath-plot3d` (lib) due to 32 previous errors; 7 warnings emitted
warning: `rustmath-modular` (lib) generated 40 warnings
error: could not compile `rustmath-modular` (lib) due to 7 previous errors; 40 warnings emitted
error[E0282]: type annotations needed for `Arc<_>`
  --> rustmath-manifolds/src/symplectic.rs:95:13
   |
95 |         let manifold = Arc::new(EuclideanSpace::new(2 * n).into());
   |             ^^^^^^^^
96 |         let symplectic_form = SymplecticForm::standard_form(manifold.clone(), n)?;
   |                                                                      ----- type must be known at this point
   |
help: consider giving `manifold` an explicit type, where the placeholders `_` are specified
   |
95 |         let manifold: Arc<T> = Arc::new(EuclideanSpace::new(2 * n).into());
   |                     ++++++++

error[E0599]: no function or associated item named `from_components` found for struct `DiffForm` in the current scope
   --> rustmath-manifolds/src/symplectic.rs:201:30
    |
201 |         let form = DiffForm::from_components(
    |                              ^^^^^^^^^^^^^^^ function or associated item not found in `DiffForm`
    |
   ::: rustmath-manifolds/src/diff_form.rs:25:1
    |
 25 | pub struct DiffForm {
    | ------------------- function or associated item `from_components` not found for this struct
    |
note: if you're trying to build a new `DiffForm` consider using one of the following associated functions:
      DiffForm::new
      DiffForm::from_tensor
      DiffForm::coordinate_form
      DiffForm::zero
   --> rustmath-manifolds/src/diff_form.rs:34:5
    |
 34 |       pub fn new(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 40 |       pub fn from_tensor(tensor: TensorField, degree: usize) -> Result<Self> {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 70 | /     pub fn coordinate_form(
 71 | |         manifold: Arc<DifferentiableManifold>,
 72 | |         chart: &Chart,
 73 | |         index: usize,
 74 | |     ) -> Result<Self> {
    | |_____________________^
...
231 |       pub fn zero(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `det` found for struct `Matrix<R>` in the current scope
   --> rustmath-manifolds/src/symplectic.rs:243:20
    |
243 |         Ok(!matrix.det().is_zero())
    |                    ^^^
    |
help: there is a method `get` with a similar name, but with different arguments
   --> /home/john/RustMath/rustmath-matrix/src/matrix.rs:62:5
    |
 62 |     pub fn get(&self, i: usize, j: usize) -> Result<&R> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `rustmath-ellipticcurves` (lib) generated 8 warnings (run `cargo fix --lib -p rustmath-ellipticcurves` to apply 5 suggestions)
error[E0308]: mismatched types
   --> rustmath-manifolds/src/symplectic.rs:261:12
    |
261 |         Ok(Matrix::from_vec(n, n, data))
    |         -- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Matrix<Rational>`, found `Result<Matrix<Rational>, MathError>`
    |         |
    |         arguments to this enum variant are incorrect
    |
    = note: expected struct `Matrix<_>`
                 found enum `std::result::Result<Matrix<_>, MathError>`
help: the type constructed contains `std::result::Result<Matrix<rustmath_rationals::Rational>, MathError>` due to the type of the argument passed
   --> rustmath-manifolds/src/symplectic.rs:261:9
    |
261 |         Ok(Matrix::from_vec(n, n, data))
    |         ^^^----------------------------^
    |            |
    |            this argument influences the type of `Ok`
note: tuple variant defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:554:5
    |
554 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^
help: use the `?` operator to extract the `std::result::Result<Matrix<rustmath_rationals::Rational>, MathError>` value, propagating a `Result::Err` value to the caller
    |
261 |         Ok(Matrix::from_vec(n, n, data)?)
    |                                        +

error[E0599]: no method named `to_f64` found for enum `std::result::Result<T, E>` in the current scope
   --> rustmath-manifolds/src/symplectic.rs:291:52
    |
291 |                 let matrix_elem = matrix.get(i, j).to_f64().unwrap_or(0.0);
    |                                                    ^^^^^^ method not found in `std::result::Result<&rustmath_rationals::Rational, MathError>`
    |
note: the method `to_f64` exists on the type `&rustmath_rationals::Rational`
   --> /home/john/RustMath/rustmath-rationals/src/rational.rs:141:5
    |
141 |     pub fn to_f64(&self) -> Option<f64> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use the `?` operator to extract the `&rustmath_rationals::Rational` value, propagating a `Result::Err` value to the caller
    |
291 |                 let matrix_elem = matrix.get(i, j)?.to_f64().unwrap_or(0.0);
    |                                                   +

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> rustmath-manifolds/src/symplectic.rs:361:30
    |
361 |         let dh = hamiltonian.differential()?;
    |                              ^^^^^^^^^^^^-- argument #1 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/scalar_field.rs:143:12
    |
143 |     pub fn differential(&self, chart: &Chart) -> Result<Vec<Expr>> {
    |            ^^^^^^^^^^^^        -------------
help: provide the argument
    |
361 |         let dh = hamiltonian.differential(/* &Chart */)?;
    |                                           ++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/symplectic.rs:409:27
    |
409 |         self.vector_field.apply_to_scalar(f)
    |                           ^^^^^^^^^^^^^^^--- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/vector_field.rs:161:12
    |
161 |     pub fn apply_to_scalar(&self, field: &ScalarField, chart: &Chart) -> Result<ScalarField> {
    |            ^^^^^^^^^^^^^^^                             -------------
help: provide the argument
    |
409 |         self.vector_field.apply_to_scalar(f, /* &Chart */)
    |                                            ++++++++++++++

error[E0308]: mismatched types
   --> rustmath-manifolds/src/integration.rs:184:51
    |
184 |         let det_expr = compute_matrix_determinant(&metric_components, n)?;
    |                        -------------------------- ^^^^^^^^^^^^^^^^^^ expected `&[Expr]`, found `&&Vec<Vec<Expr>>`
    |                        |
    |                        arguments to this function are incorrect
    |
    = note: expected reference `&[rustmath_symbolic::Expr]`
               found reference `&&Vec<Vec<rustmath_symbolic::Expr>>`
note: function defined here
   --> rustmath-manifolds/src/integration.rs:428:4
    |
428 | fn compute_matrix_determinant(components: &[Expr], n: usize) -> Result<Expr> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^ -------------------

error[E0277]: the trait bound `String: Borrow<rustmath_symbolic::Symbol>` is not satisfied
   --> rustmath-manifolds/src/integration.rs:498:31
    |
498 |             substitutions.get(s).cloned().unwrap_or_else(|| expr.clone())
    |                           --- ^ the trait `Borrow<rustmath_symbolic::Symbol>` is not implemented for `String`
    |                           |
    |                           required by a bound introduced by this call
    |
    = help: the trait `Borrow<rustmath_symbolic::Symbol>` is not implemented for `String`
            but trait `Borrow<str>` is implemented for it
    = help: for that trait implementation, expected `str`, found `rustmath_symbolic::Symbol`
note: required by a bound in `HashMap::<K, V, S>::get`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:911:12
    |
909 |     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
    |            --- required by a bound in this associated function
910 |     where
911 |         K: Borrow<Q>,
    |            ^^^^^^^^^ required by this bound in `HashMap::<K, V, S>::get`

error[E0599]: no variant or associated item named `Real` found for enum `rustmath_symbolic::Expr` in the current scope
   --> rustmath-manifolds/src/integration.rs:524:15
    |
524 |         Expr::Real(r) => Ok(r.to_f64()),
    |               ^^^^ variant or associated item not found in `rustmath_symbolic::Expr`

error[E0308]: mismatched types
   --> rustmath-manifolds/src/integration.rs:522:32
    |
522 |         Expr::Integer(i) => Ok(i.to_f64()),
    |                             -- ^^^^^^^^^^ expected `f64`, found `Option<f64>`
    |                             |
    |                             arguments to this enum variant are incorrect
    |
    = note: expected type `f64`
               found enum `Option<f64>`
help: the type constructed contains `Option<f64>` due to the type of the argument passed
   --> rustmath-manifolds/src/integration.rs:522:29
    |
522 |         Expr::Integer(i) => Ok(i.to_f64()),
    |                             ^^^----------^
    |                                |
    |                                this argument influences the type of `Ok`
note: tuple variant defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:554:5
    |
554 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^
help: consider using `Option::expect` to unwrap the `Option<f64>` value, panicking if the value is an `Option::None`
    |
522 |         Expr::Integer(i) => Ok(i.to_f64().expect("REASON")),
    |                                          +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-manifolds/src/integration.rs:523:33
    |
523 |         Expr::Rational(r) => Ok(r.to_f64()),
    |                              -- ^^^^^^^^^^ expected `f64`, found `Option<f64>`
    |                              |
    |                              arguments to this enum variant are incorrect
    |
    = note: expected type `f64`
               found enum `Option<f64>`
help: the type constructed contains `Option<f64>` due to the type of the argument passed
   --> rustmath-manifolds/src/integration.rs:523:30
    |
523 |         Expr::Rational(r) => Ok(r.to_f64()),
    |                              ^^^----------^
    |                                 |
    |                                 this argument influences the type of `Ok`
note: tuple variant defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:554:5
    |
554 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^
help: consider using `Option::expect` to unwrap the `Option<f64>` value, panicking if the value is an `Option::None`
    |
523 |         Expr::Rational(r) => Ok(r.to_f64().expect("REASON")),
    |                                           +++++++++++++++++

error[E0599]: no variant or associated item named `Mod` found for enum `BinaryOp` in the current scope
   --> rustmath-manifolds/src/integration.rs:536:27
    |
536 |                 BinaryOp::Mod => left_val % right_val,
    |                           ^^^ variant or associated item not found in `BinaryOp`

error[E0308]: mismatched types
   --> rustmath-manifolds/src/maps.rs:126:53
    |
126 |                 let derivative = expr.differentiate(&var.name());
    |                                       ------------- ^^^^^^^^^^^ expected `&Symbol`, found `&&str`
    |                                       |
    |                                       arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&&str`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0061]: this method takes 0 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/maps.rs:183:35
    |
183 |         let v_components = vector.components(source_chart)?;
    |                                   ^^^^^^^^^^ ------------ unexpected argument of type `&Chart`
    |
note: method defined here
   --> rustmath-manifolds/src/tangent_space.rs:89:12
    |
 89 |     pub fn components(&self) -> &[f64] {
    |            ^^^^^^^^^^
help: remove the extra argument
    |
183 -         let v_components = vector.components(source_chart)?;
183 +         let v_components = vector.components()?;
    |

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> rustmath-manifolds/src/maps.rs:183:28
    |
183 |         let v_components = vector.components(source_chart)?;
    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `&[f64]`
    |
    = help: the trait `Try` is not implemented for `&[f64]`

error[E0061]: this function takes 3 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/maps.rs:194:12
    |
194 |         Ok(TangentVector::new(pushed))
    |            ^^^^^^^^^^^^^^^^^^--------
    |                              ||
    |                              |argument #1 of type `ManifoldPoint` is missing
    |                              argument #3 of type `Arc<DifferentiableManifold>` is missing
    |
note: associated function defined here
   --> rustmath-manifolds/src/tangent_space.rs:33:12
    |
 33 |     pub fn new(
    |            ^^^
 34 |         base_point: ManifoldPoint,
    |         -------------------------
 35 |         components: Vec<f64>,
 36 |         manifold: Arc<DifferentiableManifold>,
    |         -------------------------------------
help: provide the arguments
    |
194 -         Ok(TangentVector::new(pushed))
194 +         Ok(TangentVector::new(/* ManifoldPoint */, pushed, /* Arc<DifferentiableManifold> */))
    |

error[E0308]: mismatched types
   --> rustmath-manifolds/src/maps.rs:194:12
    |
194 |         Ok(TangentVector::new(pushed))
    |         -- ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `TangentVector`, found `Result<TangentVector, ManifoldError>`
    |         |
    |         arguments to this enum variant are incorrect
    |
    = note: expected struct `TangentVector`
                 found enum `std::result::Result<TangentVector, ManifoldError>`
help: the type constructed contains `std::result::Result<TangentVector, ManifoldError>` due to the type of the argument passed
   --> rustmath-manifolds/src/maps.rs:194:9
    |
194 |         Ok(TangentVector::new(pushed))
    |         ^^^--------------------------^
    |            |
    |            this argument influences the type of `Ok`
note: tuple variant defined here
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:554:5
    |
554 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ^^
help: use the `?` operator to extract the `std::result::Result<TangentVector, ManifoldError>` value, propagating a `Result::Err` value to the caller
    |
194 |         Ok(TangentVector::new(pushed)?)
    |                                      +

error[E0308]: mismatched types
   --> rustmath-manifolds/src/maps.rs:269:9
    |
252 |     ) -> Result<ScalarField> {
    |          ------------------- expected `std::result::Result<ScalarFieldEnhanced, ManifoldError>` because of return type
...
269 |         ScalarField::from_expr(self.map.source.clone(), source_chart, substituted)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Result<ScalarFieldEnhanced, ...>`, found `ScalarFieldEnhanced`
    |
    = note: expected enum `std::result::Result<ScalarFieldEnhanced, ManifoldError>`
             found struct `ScalarFieldEnhanced`
help: try wrapping the expression in `Ok`
    |
269 |         Ok(ScalarField::from_expr(self.map.source.clone(), source_chart, substituted))
    |         +++                                                                          +

error[E0107]: struct takes 0 generic arguments but 1 generic argument was supplied
   --> rustmath-rings/src/real_lazy.rs:174:13
    |
174 |     Complex(Complex<f64>),
    |             ^^^^^^^----- help: remove the unnecessary generics
    |             |
    |             expected 0 generic arguments
    |
note: struct defined here, with 0 generic parameters
   --> /home/john/RustMath/rustmath-complex/src/complex.rs:18:12
    |
 18 | pub struct Complex {
    |            ^^^^^^^

error[E0277]: can't compare `rustmath_symbolic::Symbol` with `str`
   --> rustmath-manifolds/src/maps.rs:771:30
    |
771 |         Expr::Symbol(s) if s == var_name => value.clone(),
    |                              ^^ no implementation for `rustmath_symbolic::Symbol == str`
    |
    = help: the trait `PartialEq<str>` is not implemented for `rustmath_symbolic::Symbol`
            but trait `PartialEq<rustmath_symbolic::Symbol>` is implemented for it
    = help: for that trait implementation, expected `rustmath_symbolic::Symbol`, found `str`
    = note: required for `&rustmath_symbolic::Symbol` to implement `PartialEq<&str>`

error[E0599]: no method named `is_approximately_zero` found for struct `TensorField` in the current scope
  --> rustmath-manifolds/src/symmetries.rs:86:41
   |
86 |         let is_killing = lie_derivative.is_approximately_zero(chart, tolerance)?;
   |                                         ^^^^^^^^^^^^^^^^^^^^^ method not found in `TensorField`
   |
  ::: rustmath-manifolds/src/tensor_field.rs:67:1
   |
67 | pub struct TensorField {
   | ---------------------- method `is_approximately_zero` not found for this struct

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:116:56
    |
116 |                     let dg_ij_dxk = g_ij.differentiate(&coord_k.name());
    |                                          ------------- ^^^^^^^^^^^^^^^ expected `&Symbol`, found `&&str`
    |                                          |
    |                                          arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&&str`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:125:54
    |
125 |                     let dx_k_dxi = x_k.differentiate(&coord_i.name());
    |                                        ------------- ^^^^^^^^^^^^^^^ expected `&Symbol`, found `&&str`
    |                                        |
    |                                        arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&&str`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:134:54
    |
134 |                     let dx_k_dxj = x_k.differentiate(&coord_j.name());
    |                                        ------------- ^^^^^^^^^^^^^^^ expected `&Symbol`, found `&&str`
    |                                        |
    |                                        arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&&str`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/symmetries.rs:156:34
    |
156 |         let bracket = self.field.lie_bracket(other.field())?;
    |                                  ^^^^^^^^^^^--------------- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/vector_field.rs:182:12
    |
182 |     pub fn lie_bracket(&self, other: &VectorField, chart: &Chart) -> Result<VectorField> {
    |            ^^^^^^^^^^^                             -------------
help: provide the argument
    |
156 |         let bracket = self.field.lie_bracket(other.field(), /* &Chart */)?;
    |                                                           ++++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/symmetries.rs:162:34
    |
162 |         let bracket = self.field.lie_bracket(other.field())?;
    |                                  ^^^^^^^^^^^--------------- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/vector_field.rs:182:12
    |
182 |     pub fn lie_bracket(&self, other: &VectorField, chart: &Chart) -> Result<VectorField> {
    |            ^^^^^^^^^^^                             -------------
help: provide the argument
    |
162 |         let bracket = self.field.lie_bracket(other.field(), /* &Chart */)?;
    |                                                           ++++++++++++++

error[E0599]: no method named `is_approximately_zero` found for struct `VectorField` in the current scope
   --> rustmath-manifolds/src/symmetries.rs:163:17
    |
163 |         bracket.is_approximately_zero(chart, tolerance)
    |                 ^^^^^^^^^^^^^^^^^^^^^ method not found in `VectorField`
    |
   ::: rustmath-manifolds/src/vector_field.rs:29:1
    |
 29 | pub struct VectorField {
    | ---------------------- method `is_approximately_zero` not found for this struct

error[E0038]: the trait `Field` is not dyn compatible
   --> rustmath-rings/src/ring.rs:234:48
    |
234 |     fn fraction_field(&self) -> Result<Box<dyn Field>, RingError> {
    |                                                ^^^^^ `Field` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> /home/john/RustMath/rustmath-core/src/traits.rs:50:7
    |
 50 |     + PartialEq
    |       ^^^^^^^^^ the trait is not dyn compatible because it uses `Self` as a type parameter
 51 |     + Add<Output = Self>
    |       ^^^^^^^^^^^^^^^^^^
    |       |   |
    |       |   the trait is not dyn compatible because it uses `Self` as a type parameter
    |       the trait is not dyn compatible because it uses `Self` as a type parameter
 52 |     + Sub<Output = Self>
    |       ^^^^^^^^^^^^^^^^^^
    |       |   |
    |       |   the trait is not dyn compatible because it uses `Self` as a type parameter
    |       the trait is not dyn compatible because it uses `Self` as a type parameter
 53 |     + Mul<Output = Self>
    |       ^^^^^^^^^^^^^^^^^^
    |       |   |
    |       |   the trait is not dyn compatible because it uses `Self` as a type parameter
    |       the trait is not dyn compatible because it uses `Self` as a type parameter
...
152 | pub trait Field: CommutativeRing + Div<Output = Self> {
    |                                    ^^^^^^^^^^^^^^^^^^
    |                                    |   |
    |                                    |   the trait is not dyn compatible because it uses `Self` as a type parameter
    |                                    the trait is not dyn compatible because it uses `Self` as a type parameter
    = help: the following types implement `Field`:
              rustmath_rationals::Rational
              rustmath_padics::PadicRational
              rustmath_complex::Complex
              rustmath_complex::ComplexMPFR
              rustmath_reals::RealMPFR
              rustmath_reals::Real
              rustmath_finitefields::ExtensionField
              rustmath_finitefields::PrimeField
            consider defining an enum where each variant holds one of these types,
            implementing `Field` for this new enum and using it instead
help: consider using an opaque type instead
    |
234 -     fn fraction_field(&self) -> Result<Box<dyn Field>, RingError> {
234 +     fn fraction_field(&self) -> Result<Box<impl Field>, RingError> {
    |

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:253:71
    |
253 |                     lambda_expr = Some(lie_comps[i * n + j].clone() / g_ij.clone());
    |                                        ----------------------------   ^^^^^^^^^^^^ expected `Expr`, found `Vec<Expr>`
    |                                        |
    |                                        expected because this is `rustmath_symbolic::Expr`
    |
    = note: expected enum `rustmath_symbolic::Expr`
             found struct `Vec<rustmath_symbolic::Expr>`

error[E0277]: the `?` operator can only be applied to values that implement `Try`
   --> rustmath-manifolds/src/symmetries.rs:264:35
    |
264 |               let conformal_field = ScalarField::from_expr(
    |  ___________________________________^
265 | |                 self.field.manifold().clone(),
266 | |                 chart,
267 | |                 lambda.clone(),
268 | |             )?;
    | |______________^ the `?` operator cannot be applied to type `ScalarFieldEnhanced`
    |
help: the trait `Try` is not implemented for `ScalarFieldEnhanced`
   --> rustmath-manifolds/src/scalar_field.rs:27:1
    |
 27 | pub struct ScalarFieldEnhanced {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:274:49
    |
274 |                 let expected = lambda.clone() * g_comps[idx].clone();
    |                                --------------   ^^^^^^^^^^^^^^^^^^^^ expected `Expr`, found `Vec<Expr>`
    |                                |
    |                                expected because this is `rustmath_symbolic::Expr`
    |
    = note: expected enum `rustmath_symbolic::Expr`
             found struct `Vec<rustmath_symbolic::Expr>`

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:424:59
    |
424 |         let metric = Arc::new(RiemannianMetric::euclidean(manifold.clone()));
    |                               --------------------------- ^^^^^^^^^^^^^^^^ expected `Arc<DifferentiableManifold>`, found `Arc<EuclideanSpace>`
    |                               |
    |                               arguments to this function are incorrect
    |
    = note: expected struct `Arc<DifferentiableManifold>`
               found struct `Arc<EuclideanSpace>`
note: associated function defined here
   --> rustmath-manifolds/src/riemannian.rs:84:12
    |
 84 |     pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |            ^^^^^^^^^ -------------------------------------

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:426:35
    |
426 |         let mut group = Self::new(manifold, metric);
    |                         --------- ^^^^^^^^ expected `Arc<DifferentiableManifold>`, found `Arc<EuclideanSpace>`
    |                         |
    |                         arguments to this function are incorrect
    |
    = note: expected struct `Arc<DifferentiableManifold>`
               found struct `Arc<EuclideanSpace>`
note: associated function defined here
   --> rustmath-manifolds/src/symmetries.rs:319:12
    |
319 |     pub fn new(manifold: Arc<DifferentiableManifold>, metric: Arc<RiemannianMetric>) -> Self {
    |            ^^^ -------------------------------------

error[E0599]: no function or associated item named `round_sphere` found for struct `RiemannianMetric` in the current scope
   --> rustmath-manifolds/src/symmetries.rs:438:49
    |
438 |         let metric = Arc::new(RiemannianMetric::round_sphere(manifold.clone()));
    |                                                 ^^^^^^^^^^^^ function or associated item not found in `RiemannianMetric`
    |
   ::: rustmath-manifolds/src/riemannian.rs:28:1
    |
 28 | pub struct RiemannianMetric {
    | --------------------------- function or associated item `round_sphere` not found for this struct
    |
note: if you're trying to build a new `RiemannianMetric` consider using one of the following associated functions:
      RiemannianMetric::new
      RiemannianMetric::from_components
      RiemannianMetric::euclidean
   --> rustmath-manifolds/src/riemannian.rs:40:5
    |
 40 |       pub fn new(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 55 | /     pub fn from_components(
 56 | |         manifold: Arc<DifferentiableManifold>,
 57 | |         chart: &Chart,
 58 | |         components: Vec<Vec<Expr>>,
 59 | |     ) -> Result<Self> {
    | |_____________________^
...
 84 |       pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:440:35
    |
440 |         let mut group = Self::new(manifold, metric);
    |                         --------- ^^^^^^^^ expected `Arc<DifferentiableManifold>`, found `Arc<Sphere2>`
    |                         |
    |                         arguments to this function are incorrect
    |
    = note: expected struct `Arc<DifferentiableManifold>`
               found struct `Arc<Sphere2>`
note: associated function defined here
   --> rustmath-manifolds/src/symmetries.rs:319:12
    |
319 |     pub fn new(manifold: Arc<DifferentiableManifold>, metric: Arc<RiemannianMetric>) -> Self {
    |            ^^^ -------------------------------------

error[E0599]: no function or associated item named `hyperbolic` found for struct `RiemannianMetric` in the current scope
   --> rustmath-manifolds/src/symmetries.rs:452:49
    |
452 |         let metric = Arc::new(RiemannianMetric::hyperbolic(manifold.clone()));
    |                                                 ^^^^^^^^^^ function or associated item not found in `RiemannianMetric`
    |
   ::: rustmath-manifolds/src/riemannian.rs:28:1
    |
 28 | pub struct RiemannianMetric {
    | --------------------------- function or associated item `hyperbolic` not found for this struct
    |
note: if you're trying to build a new `RiemannianMetric` consider using one of the following associated functions:
      RiemannianMetric::new
      RiemannianMetric::from_components
      RiemannianMetric::euclidean
   --> rustmath-manifolds/src/riemannian.rs:40:5
    |
 40 |       pub fn new(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 55 | /     pub fn from_components(
 56 | |         manifold: Arc<DifferentiableManifold>,
 57 | |         chart: &Chart,
 58 | |         components: Vec<Vec<Expr>>,
 59 | |     ) -> Result<Self> {
    | |_____________________^
...
 84 |       pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/symmetries.rs:454:35
    |
454 |         let mut group = Self::new(manifold, metric);
    |                         --------- ^^^^^^^^ expected `Arc<DifferentiableManifold>`, found `Arc<EuclideanSpace>`
    |                         |
    |                         arguments to this function are incorrect
    |
    = note: expected struct `Arc<DifferentiableManifold>`
               found struct `Arc<EuclideanSpace>`
note: associated function defined here
   --> rustmath-manifolds/src/symmetries.rs:319:12
    |
319 |     pub fn new(manifold: Arc<DifferentiableManifold>, metric: Arc<RiemannianMetric>) -> Self {
    |            ^^^ -------------------------------------

error[E0599]: no function or associated item named `from_tensor` found for struct `RiemannianMetric` in the current scope
  --> rustmath-manifolds/src/catalog.rs:76:39
   |
76 |         Ok(Arc::new(RiemannianMetric::from_tensor(metric_tensor)?))
   |                                       ^^^^^^^^^^^ function or associated item not found in `RiemannianMetric`
   |
  ::: rustmath-manifolds/src/riemannian.rs:28:1
   |
28 | pub struct RiemannianMetric {
   | --------------------------- function or associated item `from_tensor` not found for this struct
   |
note: if you're trying to build a new `RiemannianMetric` consider using one of the following associated functions:
      RiemannianMetric::new
      RiemannianMetric::from_components
      RiemannianMetric::euclidean
  --> rustmath-manifolds/src/riemannian.rs:40:5
   |
40 |       pub fn new(manifold: Arc<DifferentiableManifold>) -> Self {
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
55 | /     pub fn from_components(
56 | |         manifold: Arc<DifferentiableManifold>,
57 | |         chart: &Chart,
58 | |         components: Vec<Vec<Expr>>,
59 | |     ) -> Result<Self> {
   | |_____________________^
...
84 |       pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:241:20
    |
241 |     basis: Vec<Box<dyn RingDerivation<R>>>,
    |                    ^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

warning: `rustmath-calculus` (lib) generated 11 warnings (run `cargo fix --lib -p rustmath-calculus` to apply 5 suggestions)
error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:316:26
    |
316 |     derivations: Vec<Box<dyn RingDerivation<R>>>,
    |                          ^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0308]: mismatched types
   --> rustmath-manifolds/src/catalog.rs:189:92
    |
189 |         let one_minus_2m_over_r = Expr::from(1) - Expr::from(2) * m.clone() / Expr::Symbol(r.name().to_string());
    |                                                                               ------------ ^^^^^^^^^^^^^^^^^^^^ expected `Symbol`, found `String`
    |                                                                               |
    |                                                                               arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:56:5
    |
 56 |     Symbol(Symbol),
    |     ^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/catalog.rs:192:38
    |
192 |         let r_squared = Expr::Symbol(r.name().to_string()).clone()
    |                         ------------ ^^^^^^^^^^^^^^^^^^^^ expected `Symbol`, found `String`
    |                         |
    |                         arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:56:5
    |
 56 |     Symbol(Symbol),
    |     ^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/catalog.rs:193:28
    |
193 |             * Expr::Symbol(r.name().to_string()).clone();
    |               ------------ ^^^^^^^^^^^^^^^^^^^^ expected `Symbol`, found `String`
    |               |
    |               arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:56:5
    |
 56 |     Symbol(Symbol),
    |     ^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/catalog.rs:196:86
    |
196 |         let sin_theta = Expr::Function("sin".to_string(), vec![Arc::new(Expr::Symbol(theta.name().to_string()))]);
    |                                                                         ------------ ^^^^^^^^^^^^^^^^^^^^^^^^ expected `Symbol`, found `String`
    |                                                                         |
    |                                                                         arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:56:5
    |
 56 |     Symbol(Symbol),
    |     ^^^^^^

error[E0599]: no function or associated item named `from_tensor` found for struct `RiemannianMetric` in the current scope
   --> rustmath-manifolds/src/catalog.rs:228:39
    |
228 |         Ok(Arc::new(RiemannianMetric::from_tensor(metric_tensor)?))
    |                                       ^^^^^^^^^^^ function or associated item not found in `RiemannianMetric`
    |
   ::: rustmath-manifolds/src/riemannian.rs:28:1
    |
 28 | pub struct RiemannianMetric {
    | --------------------------- function or associated item `from_tensor` not found for this struct
    |
note: if you're trying to build a new `RiemannianMetric` consider using one of the following associated functions:
      RiemannianMetric::new
      RiemannianMetric::from_components
      RiemannianMetric::euclidean
   --> rustmath-manifolds/src/riemannian.rs:40:5
    |
 40 |       pub fn new(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 55 | /     pub fn from_components(
 56 | |         manifold: Arc<DifferentiableManifold>,
 57 | |         chart: &Chart,
 58 | |         components: Vec<Vec<Expr>>,
 59 | |     ) -> Result<Self> {
    | |_____________________^
...
 84 |       pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/catalog.rs:331:35
    |
331 |         let r_expr = Expr::Symbol(r.name().to_string());
    |                      ------------ ^^^^^^^^^^^^^^^^^^^^ expected `Symbol`, found `String`
    |                      |
    |                      arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:56:5
    |
 56 |     Symbol(Symbol),
    |     ^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/catalog.rs:332:39
    |
332 |         let theta_expr = Expr::Symbol(theta.name().to_string());
    |                          ------------ ^^^^^^^^^^^^^^^^^^^^^^^^ expected `Symbol`, found `String`
    |                          |
    |                          arguments to this enum variant are incorrect
    |
note: tuple variant defined here
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:56:5
    |
 56 |     Symbol(Symbol),
    |     ^^^^^^

error[E0599]: no function or associated item named `from_tensor` found for struct `RiemannianMetric` in the current scope
   --> rustmath-manifolds/src/catalog.rs:366:39
    |
366 |         Ok(Arc::new(RiemannianMetric::from_tensor(metric_tensor)?))
    |                                       ^^^^^^^^^^^ function or associated item not found in `RiemannianMetric`
    |
   ::: rustmath-manifolds/src/riemannian.rs:28:1
    |
 28 | pub struct RiemannianMetric {
    | --------------------------- function or associated item `from_tensor` not found for this struct
    |
note: if you're trying to build a new `RiemannianMetric` consider using one of the following associated functions:
      RiemannianMetric::new
      RiemannianMetric::from_components
      RiemannianMetric::euclidean
   --> rustmath-manifolds/src/riemannian.rs:40:5
    |
 40 |       pub fn new(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 55 | /     pub fn from_components(
 56 | |         manifold: Arc<DifferentiableManifold>,
 57 | |         chart: &Chart,
 58 | |         components: Vec<Vec<Expr>>,
 59 | |     ) -> Result<Self> {
    | |_____________________^
...
 84 |       pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this function takes 4 arguments but 2 arguments were supplied
   --> rustmath-manifolds/src/catalog.rs:658:25
    |
658 |         let lie_group = LieGroup::new(manifold.clone(), dim);
    |                         ^^^^^^^^^^^^^-----------------------
    |                                      |                  |
    |                                      |                  expected `ManifoldPoint`, found `usize`
    |                                      two arguments of type `Arc<(dyn for<'a, 'b> Fn(&'a ManifoldPoint, &'b ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)>` and `Arc<(dyn for<'a> Fn(&'a ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)>` are missing
    |
note: associated function defined here
   --> rustmath-manifolds/src/lie_group.rs:63:12
    |
 63 |     pub fn new(
    |            ^^^
 64 |         manifold: Arc<DifferentiableManifold>,
 65 |         identity: ManifoldPoint,
    |         -----------------------
 66 |         multiplication: Arc<dyn Fn(&ManifoldPoint, &ManifoldPoint) -> Result<ManifoldPoint> + Send + Sync>,
    |         --------------------------------------------------------------------------------------------------
 67 |         inversion: Arc<dyn Fn(&ManifoldPoint) -> Result<ManifoldPoint> + Send + Sync>,
    |         -----------------------------------------------------------------------------
help: provide the arguments
    |
658 -         let lie_group = LieGroup::new(manifold.clone(), dim);
658 +         let lie_group = LieGroup::new(manifold.clone(), /* ManifoldPoint */, /* Arc<(dyn for<'a, 'b> Fn(&'a ManifoldPoint, &'b ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)> */, /* Arc<(dyn for<'a> Fn(&'a ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)> */);
    |

error[E0061]: this function takes 4 arguments but 2 arguments were supplied
   --> rustmath-manifolds/src/catalog.rs:736:25
    |
736 |         let lie_group = LieGroup::new(manifold.clone(), dim);
    |                         ^^^^^^^^^^^^^-----------------------
    |                                      |                  |
    |                                      |                  expected `ManifoldPoint`, found `usize`
    |                                      two arguments of type `Arc<(dyn for<'a, 'b> Fn(&'a ManifoldPoint, &'b ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)>` and `Arc<(dyn for<'a> Fn(&'a ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)>` are missing
    |
note: associated function defined here
   --> rustmath-manifolds/src/lie_group.rs:63:12
    |
 63 |     pub fn new(
    |            ^^^
 64 |         manifold: Arc<DifferentiableManifold>,
 65 |         identity: ManifoldPoint,
    |         -----------------------
 66 |         multiplication: Arc<dyn Fn(&ManifoldPoint, &ManifoldPoint) -> Result<ManifoldPoint> + Send + Sync>,
    |         --------------------------------------------------------------------------------------------------
 67 |         inversion: Arc<dyn Fn(&ManifoldPoint) -> Result<ManifoldPoint> + Send + Sync>,
    |         -----------------------------------------------------------------------------
help: provide the arguments
    |
736 -         let lie_group = LieGroup::new(manifold.clone(), dim);
736 +         let lie_group = LieGroup::new(manifold.clone(), /* ManifoldPoint */, /* Arc<(dyn for<'a, 'b> Fn(&'a ManifoldPoint, &'b ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)> */, /* Arc<(dyn for<'a> Fn(&'a ManifoldPoint) -> std::result::Result<ManifoldPoint, ManifoldError> + Send + Sync + 'static)> */);
    |

error[E0277]: `dyn Fn(&ManifoldPoint) -> Result<Complex, ManifoldError> + Send + Sync` doesn't implement `Debug`
  --> rustmath-manifolds/src/complex_manifold.rs:44:5
   |
35 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
...
44 |     coordinate_functions: Vec<Arc<dyn Fn(&ManifoldPoint) -> Result<Complex> + Send + Sync>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `dyn Fn(&ManifoldPoint) -> Result<Complex, ManifoldError> + Send + Sync`
   |
   = note: the full name for the type has been written to '/home/john/RustMath/target/debug/deps/rustmath_manifolds-d43af460fdefee9d.long-type-12679183982405704208.txt'
   = note: consider using `--verbose` to print the full type name to the console

error[E0061]: this function takes 3 arguments but 2 arguments were supplied
  --> rustmath-manifolds/src/complex_manifold.rs:78:26
   |
78 |         let real_chart = Chart::new(name, 2 * complex_dim);
   |                          ^^^^^^^^^^----------------------- argument #3 of type `Vec<_>` is missing
   |
note: associated function defined here
  --> rustmath-manifolds/src/chart.rs:44:12
   |
44 |     pub fn new(
   |            ^^^
...
47 |         coordinate_names: Vec<impl Into<String>>,
   |         ----------------------------------------
help: provide the argument
   |
78 |         let real_chart = Chart::new(name, 2 * complex_dim, /* coordinate_names */);
   |                                                          ++++++++++++++++++++++++

error[E0308]: mismatched types
  --> rustmath-manifolds/src/complex_manifold.rs:85:13
   |
85 |             real_chart,
   |             ^^^^^^^^^^ expected `Chart`, found `Result<Chart, ManifoldError>`
   |
   = note: expected struct `Chart`
                found enum `std::result::Result<Chart, ManifoldError>`
help: consider using `Result::expect` to unwrap the `std::result::Result<Chart, ManifoldError>` value, panicking if the value is a `Result::Err`
   |
85 |             real_chart: real_chart.expect("REASON"),
   |                       +++++++++++++++++++++++++++++

error[E0277]: `TensorField` doesn't implement `Debug`
  --> rustmath-manifolds/src/almost_complex.rs:45:5
   |
39 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
...
45 |     tensor: TensorField,
   |     ^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `TensorField`
   |
   = note: add `#[derive(Debug)]` to `TensorField` or manually `impl Debug for TensorField`
help: consider annotating `TensorField` with `#[derive(Debug)]`
  --> rustmath-manifolds/src/tensor_field.rs:67:1
   |
67 + #[derive(Debug)]
68 | pub struct TensorField {
   |

error[E0308]: arguments to this function are incorrect
   --> rustmath-manifolds/src/almost_complex.rs:127:22
    |
127 |         let tensor = TensorField::from_components(
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
128 |             manifold.clone(),
129 |             chart,
    |             ----- expected `usize`, found `&Chart`
130 |             1,  // contravariant rank
131 |             1,  // covariant rank
    |             - expected `&Chart`, found `{integer}`
    |
note: associated function defined here
   --> rustmath-manifolds/src/tensor_field.rs:98:12
    |
 98 |     pub fn from_components(
    |            ^^^^^^^^^^^^^^^
help: swap these arguments
    |
127 ~         let tensor = TensorField::from_components(
128 +             manifold.clone(),
129 +             1,
130 +             1,
131 +             chart,
132 +             components,
133 ~         ).unwrap();
    |

error[E0308]: arguments to this function are incorrect
   --> rustmath-manifolds/src/almost_complex.rs:167:22
    |
167 |         let tensor = TensorField::from_components(
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
168 |             manifold.clone(),
169 |             chart,
    |             ----- expected `usize`, found `&Chart`
170 |             1,
171 |             1,
    |             - expected `&Chart`, found `{integer}`
    |
note: associated function defined here
   --> rustmath-manifolds/src/tensor_field.rs:98:12
    |
 98 |     pub fn from_components(
    |            ^^^^^^^^^^^^^^^
help: swap these arguments
    |
167 ~         let tensor = TensorField::from_components(
168 +             manifold.clone(),
169 +             1,
170 +             1,
171 +             chart,
172 +             components,
173 ~         )?;
    |

error[E0308]: arguments to this function are incorrect
   --> rustmath-manifolds/src/almost_complex.rs:228:9
    |
228 |         TensorField::from_components(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
229 |             self.manifold.clone(),
230 |             chart,
    |             ----- expected `usize`, found `&Chart`
231 |             1,  // contravariant
232 |             2,  // covariant
    |             - expected `&Chart`, found `{integer}`
    |
note: associated function defined here
   --> rustmath-manifolds/src/tensor_field.rs:98:12
    |
 98 |     pub fn from_components(
    |            ^^^^^^^^^^^^^^^
help: swap these arguments
    |
228 ~         TensorField::from_components(
229 +             self.manifold.clone(),
230 +             2,
231 +             1,
232 +             chart,
233 +             components,
234 +         )
    |

error[E0277]: `DiffForm` doesn't implement `Debug`
  --> rustmath-manifolds/src/kahler.rs:53:5
   |
44 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
...
53 |     kahler_form: DiffForm,
   |     ^^^^^^^^^^^^^^^^^^^^^ unsatisfied trait bound
   |
help: the trait `Debug` is not implemented for `DiffForm`
  --> rustmath-manifolds/src/diff_form.rs:25:1
   |
25 | pub struct DiffForm {
   | ^^^^^^^^^^^^^^^^^^^
   = note: add `#[derive(Debug)]` to `DiffForm` or manually `impl Debug for DiffForm`

error[E0599]: no method named `is_closed` found for struct `DiffForm` in the current scope
  --> rustmath-manifolds/src/kahler.rs:93:25
   |
93 |         if !kahler_form.is_closed()? {
   |                         ^^^^^^^^^
   |
  ::: rustmath-manifolds/src/diff_form.rs:25:1
   |
25 | pub struct DiffForm {
   | ------------------- method `is_closed` not found for this struct
   |
   = help: items from traits can only be used if the trait is implemented and in scope
note: `ManifoldSubsetTrait` defines an item `is_closed`, perhaps you need to implement it
  --> rustmath-manifolds/src/traits.rs:25:1
   |
25 | pub trait ManifoldSubsetTrait {
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `clone` with a similar name
   |
93 -         if !kahler_form.is_closed()? {
93 +         if !kahler_form.clone()? {
   |

error[E0599]: no function or associated item named `from_components` found for struct `DiffForm` in the current scope
   --> rustmath-manifolds/src/kahler.rs:124:19
    |
124 |         DiffForm::from_components(
    |                   ^^^^^^^^^^^^^^^ function or associated item not found in `DiffForm`
    |
   ::: rustmath-manifolds/src/diff_form.rs:25:1
    |
 25 | pub struct DiffForm {
    | ------------------- function or associated item `from_components` not found for this struct
    |
note: if you're trying to build a new `DiffForm` consider using one of the following associated functions:
      DiffForm::new
      DiffForm::from_tensor
      DiffForm::coordinate_form
      DiffForm::zero
   --> rustmath-manifolds/src/diff_form.rs:34:5
    |
 34 |       pub fn new(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 40 |       pub fn from_tensor(tensor: TensorField, degree: usize) -> Result<Self> {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 70 | /     pub fn coordinate_form(
 71 | |         manifold: Arc<DifferentiableManifold>,
 72 | |         chart: &Chart,
 73 | |         index: usize,
 74 | |     ) -> Result<Self> {
    | |_____________________^
...
231 |       pub fn zero(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `from_components` found for struct `DiffForm` in the current scope
   --> rustmath-manifolds/src/kahler.rs:176:19
    |
176 |         DiffForm::from_components(
    |                   ^^^^^^^^^^^^^^^ function or associated item not found in `DiffForm`
    |
   ::: rustmath-manifolds/src/diff_form.rs:25:1
    |
 25 | pub struct DiffForm {
    | ------------------- function or associated item `from_components` not found for this struct
    |
note: if you're trying to build a new `DiffForm` consider using one of the following associated functions:
      DiffForm::new
      DiffForm::from_tensor
      DiffForm::coordinate_form
      DiffForm::zero
   --> rustmath-manifolds/src/diff_form.rs:34:5
    |
 34 |       pub fn new(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 40 |       pub fn from_tensor(tensor: TensorField, degree: usize) -> Result<Self> {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 70 | /     pub fn coordinate_form(
 71 | |         manifold: Arc<DifferentiableManifold>,
 72 | |         chart: &Chart,
 73 | |         index: usize,
 74 | |     ) -> Result<Self> {
    | |_____________________^
...
231 |       pub fn zero(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no method named `is_closed` found for struct `DiffForm` in the current scope
   --> rustmath-manifolds/src/kahler.rs:253:15
    |
253 |         omega.is_closed()
    |               ^^^^^^^^^
    |
   ::: rustmath-manifolds/src/diff_form.rs:25:1
    |
 25 | pub struct DiffForm {
    | ------------------- method `is_closed` not found for this struct
    |
    = help: items from traits can only be used if the trait is implemented and in scope
note: `ManifoldSubsetTrait` defines an item `is_closed`, perhaps you need to implement it
   --> rustmath-manifolds/src/traits.rs:25:1
    |
 25 | pub trait ManifoldSubsetTrait {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `clone` with a similar name
    |
253 -         omega.is_closed()
253 +         omega.clone()
    |

error[E0308]: mismatched types
   --> rustmath-manifolds/src/finsler.rs:156:54
    |
156 |                 let deriv1 = f_squared.differentiate(&v_i);
    |                                        ------------- ^^^^ expected `&Symbol`, found `&Expr`
    |                                        |
    |                                        arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&rustmath_symbolic::Expr`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/finsler.rs:157:51
    |
157 |                 let deriv2 = deriv1.differentiate(&v_j);
    |                                     ------------- ^^^^ expected `&Symbol`, found `&Expr`
    |                                     |
    |                                     arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&rustmath_symbolic::Expr`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0599]: no variant or associated item named `from_rational` found for enum `rustmath_symbolic::Expr` in the current scope
   --> rustmath-manifolds/src/finsler.rs:160:48
    |
160 |                 let component = deriv2 * Expr::from_rational(1, 2);
    |                                                ^^^^^^^^^^^^^ variant or associated item not found in `rustmath_symbolic::Expr`
    |
note: if you're trying to build a new `rustmath_symbolic::Expr` consider using one of the following associated functions:
      rustmath_symbolic::Expr::symbol
      rustmath_symbolic::Expr::function
      rustmath_symbolic::Expr::bessel_j
      rustmath_symbolic::Expr::bessel_y
      and 4 others
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:68:5
    |
 68 |     pub fn symbol(name: impl Into<String>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
228 |     pub fn function(name: impl Into<String>, args: Vec<Expr>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
238 |     pub fn bessel_j(order: Expr, x: Expr) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
245 |     pub fn bessel_y(order: Expr, x: Expr) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `eval_rational` with a similar name, but with different arguments
   --> /home/john/RustMath/rustmath-symbolic/src/substitute.rs:74:5
    |
 74 |     pub fn eval_rational(&self) -> Option<Rational> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: arguments to this function are incorrect
   --> rustmath-manifolds/src/finsler.rs:165:9
    |
165 |         TensorField::from_components(
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
166 |             self.manifold.clone(),
167 |             chart,
    |             ----- expected `usize`, found `&Chart`
168 |             0, // covariant only
169 |             2,
    |             - expected `&Chart`, found `{integer}`
    |
note: associated function defined here
   --> rustmath-manifolds/src/tensor_field.rs:98:12
    |
 98 |     pub fn from_components(
    |            ^^^^^^^^^^^^^^^
help: swap these arguments
    |
165 ~         TensorField::from_components(
166 +             self.manifold.clone(),
167 +             2,
168 +             0,
169 +             chart,
170 +             components,
171 +         )
    |

error[E0277]: `TensorField` doesn't implement `Debug`
   --> rustmath-manifolds/src/finsler.rs:280:5
    |
277 | #[derive(Debug, Clone)]
    |          ----- in this derive macro expansion
...
280 |     tensor: TensorField,
    |     ^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `TensorField`
    |
    = note: add `#[derive(Debug)]` to `TensorField` or manually `impl Debug for TensorField`
help: consider annotating `TensorField` with `#[derive(Debug)]`
   --> rustmath-manifolds/src/tensor_field.rs:67:1
    |
 67 + #[derive(Debug)]
 68 | pub struct TensorField {
    |

error[E0308]: mismatched types
   --> rustmath-manifolds/src/finsler.rs:302:58
    |
302 |                     let deriv1 = f_squared.differentiate(&v_i);
    |                                            ------------- ^^^^ expected `&Symbol`, found `&Expr`
    |                                            |
    |                                            arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&rustmath_symbolic::Expr`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/finsler.rs:303:55
    |
303 |                     let deriv2 = deriv1.differentiate(&v_j);
    |                                         ------------- ^^^^ expected `&Symbol`, found `&Expr`
    |                                         |
    |                                         arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&rustmath_symbolic::Expr`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> rustmath-manifolds/src/finsler.rs:304:55
    |
304 |                     let deriv3 = deriv2.differentiate(&v_k);
    |                                         ------------- ^^^^ expected `&Symbol`, found `&Expr`
    |                                         |
    |                                         arguments to this method are incorrect
    |
    = note: expected reference `&rustmath_symbolic::Symbol`
               found reference `&rustmath_symbolic::Expr`
note: method defined here
   --> /home/john/RustMath/rustmath-symbolic/src/differentiate.rs:22:12
    |
 22 |     pub fn differentiate(&self, var: &Symbol) -> Self {
    |            ^^^^^^^^^^^^^

error[E0599]: no variant or associated item named `from_rational` found for enum `rustmath_symbolic::Expr` in the current scope
   --> rustmath-manifolds/src/finsler.rs:307:52
    |
307 |                     let component = deriv3 * Expr::from_rational(1, 4);
    |                                                    ^^^^^^^^^^^^^ variant or associated item not found in `rustmath_symbolic::Expr`
    |
note: if you're trying to build a new `rustmath_symbolic::Expr` consider using one of the following associated functions:
      rustmath_symbolic::Expr::symbol
      rustmath_symbolic::Expr::function
      rustmath_symbolic::Expr::bessel_j
      rustmath_symbolic::Expr::bessel_y
      and 4 others
   --> /home/john/RustMath/rustmath-symbolic/src/expression.rs:68:5
    |
 68 |     pub fn symbol(name: impl Into<String>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
228 |     pub fn function(name: impl Into<String>, args: Vec<Expr>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
238 |     pub fn bessel_j(order: Expr, x: Expr) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
245 |     pub fn bessel_y(order: Expr, x: Expr) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `eval_rational` with a similar name, but with different arguments
   --> /home/john/RustMath/rustmath-symbolic/src/substitute.rs:74:5
    |
 74 |     pub fn eval_rational(&self) -> Option<Rational> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: arguments to this function are incorrect
   --> rustmath-manifolds/src/finsler.rs:313:22
    |
313 |         let tensor = TensorField::from_components(
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
314 |             finsler.manifold().clone(),
315 |             chart,
    |             ----- expected `usize`, found `&Chart`
316 |             0,
317 |             3,
    |             - expected `&Chart`, found `{integer}`
    |
note: associated function defined here
   --> rustmath-manifolds/src/tensor_field.rs:98:12
    |
 98 |     pub fn from_components(
    |            ^^^^^^^^^^^^^^^
help: swap these arguments
    |
313 ~         let tensor = TensorField::from_components(
314 +             finsler.manifold().clone(),
315 +             3,
316 +             0,
317 +             chart,
318 +             components,
319 ~         )?;
    |

error[E0277]: `VectorField` doesn't implement `Debug`
  --> rustmath-manifolds/src/subriemannian.rs:47:5
   |
40 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
...
47 |     frame: Vec<VectorField>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `VectorField`
   |
   = note: add `#[derive(Debug)]` to `VectorField` or manually `impl Debug for VectorField`
   = help: the trait `Debug` is implemented for `Vec<T, A>`
help: consider annotating `VectorField` with `#[derive(Debug)]`
  --> rustmath-manifolds/src/vector_field.rs:29:1
   |
29 + #[derive(Debug)]
30 | pub struct VectorField {
   |

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/subriemannian.rs:114:45
    |
114 |                 let bracket = self.frame[i].lie_bracket(&self.frame[j])?;
    |                                             ^^^^^^^^^^^---------------- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/vector_field.rs:182:12
    |
182 |     pub fn lie_bracket(&self, other: &VectorField, chart: &Chart) -> Result<VectorField> {
    |            ^^^^^^^^^^^                             -------------
help: provide the argument
    |
114 |                 let bracket = self.frame[i].lie_bracket(&self.frame[j], /* &Chart */)?;
    |                                                                       ++++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/subriemannian.rs:143:52
    |
143 |                     let bracket = current_frame[i].lie_bracket(&current_frame[j])?;
    |                                                    ^^^^^^^^^^^------------------- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/vector_field.rs:182:12
    |
182 |     pub fn lie_bracket(&self, other: &VectorField, chart: &Chart) -> Result<VectorField> {
    |            ^^^^^^^^^^^                             -------------
help: provide the argument
    |
143 |                     let bracket = current_frame[i].lie_bracket(&current_frame[j], /* &Chart */)?;
    |                                                                                 ++++++++++++++

error[E0277]: `TensorField` doesn't implement `Debug`
   --> rustmath-manifolds/src/subriemannian.rs:182:5
    |
175 | #[derive(Debug, Clone)]
    |          ----- in this derive macro expansion
...
182 |     metric: TensorField,
    |     ^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `TensorField`
    |
    = note: add `#[derive(Debug)]` to `TensorField` or manually `impl Debug for TensorField`
help: consider annotating `TensorField` with `#[derive(Debug)]`
   --> rustmath-manifolds/src/tensor_field.rs:67:1
    |
 67 + #[derive(Debug)]
 68 | pub struct TensorField {
    |

error[E0308]: arguments to this function are incorrect
   --> rustmath-manifolds/src/subriemannian.rs:255:22
    |
255 |         let metric = TensorField::from_components(
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
256 |             base.clone(),
257 |             chart,
    |             ----- expected `usize`, found `&Chart`
258 |             0,
259 |             2,
    |             - expected `&Chart`, found `{integer}`
    |
note: associated function defined here
   --> rustmath-manifolds/src/tensor_field.rs:98:12
    |
 98 |     pub fn from_components(
    |            ^^^^^^^^^^^^^^^
help: swap these arguments
    |
255 ~         let metric = TensorField::from_components(
256 +             base.clone(),
257 +             2,
258 +             0,
259 +             chart,
260 +             metric_components,
261 ~         )?;
    |

error[E0277]: `DiffForm` doesn't implement `Debug`
  --> rustmath-manifolds/src/contact.rs:45:5
   |
40 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
...
45 |     form: DiffForm,
   |     ^^^^^^^^^^^^^^ unsatisfied trait bound
   |
help: the trait `Debug` is not implemented for `DiffForm`
  --> rustmath-manifolds/src/diff_form.rs:25:1
   |
25 | pub struct DiffForm {
   | ^^^^^^^^^^^^^^^^^^^
   = note: add `#[derive(Debug)]` to `DiffForm` or manually `impl Debug for DiffForm`

error[E0599]: no function or associated item named `from_components` found for struct `DiffForm` in the current scope
   --> rustmath-manifolds/src/contact.rs:121:30
    |
121 |         let form = DiffForm::from_components(
    |                              ^^^^^^^^^^^^^^^ function or associated item not found in `DiffForm`
    |
   ::: rustmath-manifolds/src/diff_form.rs:25:1
    |
 25 | pub struct DiffForm {
    | ------------------- function or associated item `from_components` not found for this struct
    |
note: if you're trying to build a new `DiffForm` consider using one of the following associated functions:
      DiffForm::new
      DiffForm::from_tensor
      DiffForm::coordinate_form
      DiffForm::zero
   --> rustmath-manifolds/src/diff_form.rs:34:5
    |
 34 |       pub fn new(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 40 |       pub fn from_tensor(tensor: TensorField, degree: usize) -> Result<Self> {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 70 | /     pub fn coordinate_form(
 71 | |         manifold: Arc<DifferentiableManifold>,
 72 | |         chart: &Chart,
 73 | |         index: usize,
 74 | |     ) -> Result<Self> {
    | |_____________________^
...
231 |       pub fn zero(manifold: Arc<DifferentiableManifold>, degree: usize) -> Self {
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> rustmath-manifolds/src/contact.rs:146:33
    |
146 |         let d_alpha = self.form.exterior_derivative()?;
    |                                 ^^^^^^^^^^^^^^^^^^^-- argument #1 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/diff_form.rs:101:12
    |
101 |     pub fn exterior_derivative(&self, chart: &Chart) -> Result<DiffForm> {
    |            ^^^^^^^^^^^^^^^^^^^        -------------
help: provide the argument
    |
146 |         let d_alpha = self.form.exterior_derivative(/* &Chart */)?;
    |                                                     ++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/contact.rs:153:27
    |
153 |             power = power.wedge(&d_alpha)?;
    |                           ^^^^^---------- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/diff_form.rs:148:12
    |
148 |     pub fn wedge(&self, other: &DiffForm, chart: &Chart) -> Result<DiffForm> {
    |            ^^^^^                          -------------
help: provide the argument
    |
153 |             power = power.wedge(&d_alpha, /* &Chart */)?;
    |                                         ++++++++++++++

error[E0061]: this method takes 2 arguments but 1 argument was supplied
   --> rustmath-manifolds/src/contact.rs:157:40
    |
157 |         let contact_volume = self.form.wedge(&power)?;
    |                                        ^^^^^-------- argument #2 of type `&Chart` is missing
    |
note: method defined here
   --> rustmath-manifolds/src/diff_form.rs:148:12
    |
148 |     pub fn wedge(&self, other: &DiffForm, chart: &Chart) -> Result<DiffForm> {
    |            ^^^^^                          -------------
help: provide the argument
    |
157 |         let contact_volume = self.form.wedge(&power, /* &Chart */)?;
    |                                                    ++++++++++++++

error[E0061]: this function takes 1 argument but 2 arguments were supplied
   --> rustmath-manifolds/src/spin.rs:132:22
    |
132 |         let metric = RiemannianMetric::euclidean(manifold.clone(), n);
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^                   - unexpected argument #2 of type `usize`
    |
note: associated function defined here
   --> rustmath-manifolds/src/riemannian.rs:84:12
    |
 84 |     pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |            ^^^^^^^^^
help: remove the extra argument
    |
132 -         let metric = RiemannianMetric::euclidean(manifold.clone(), n);
132 +         let metric = RiemannianMetric::euclidean(manifold.clone());
    |

error[E0061]: this function takes 1 argument but 2 arguments were supplied
   --> rustmath-manifolds/src/spin.rs:148:22
    |
148 |         let metric = RiemannianMetric::euclidean(manifold.clone(), n); // TODO: Round metric
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^                   - unexpected argument #2 of type `usize`
    |
note: associated function defined here
   --> rustmath-manifolds/src/riemannian.rs:84:12
    |
 84 |     pub fn euclidean(manifold: Arc<DifferentiableManifold>) -> Self {
    |            ^^^^^^^^^
help: remove the extra argument
    |
148 -         let metric = RiemannianMetric::euclidean(manifold.clone(), n); // TODO: Round metric
148 +         let metric = RiemannianMetric::euclidean(manifold.clone()); // TODO: Round metric
    |

error[E0308]: mismatched types
   --> rustmath-manifolds/src/dirac.rs:66:61
    |
 66 |         let levi_civita = LeviCivitaConnection::from_metric(spin_structure.metric().clone());
    |                           --------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Arc<RiemannianMetric>`, found `RiemannianMetric`
    |                           |
    |                           arguments to this function are incorrect
    |
    = note: expected struct `Arc<RiemannianMetric>`
               found struct `RiemannianMetric`
note: associated function defined here
   --> rustmath-manifolds/src/riemannian.rs:254:12
    |
254 |     pub fn from_metric(metric: Arc<RiemannianMetric>) -> Result<Self> {
    |            ^^^^^^^^^^^ -----------------------------
help: call `Into::into` on this expression to convert `RiemannianMetric` into `Arc<RiemannianMetric>`
    |
 66 |         let levi_civita = LeviCivitaConnection::from_metric(spin_structure.metric().clone().into());
    |                                                                                            +++++++

error[E0308]: mismatched types
   --> rustmath-manifolds/src/dirac.rs:67:61
    |
 67 |         let connection = SpinorConnection::from_levi_civita(levi_civita);
    |                          ---------------------------------- ^^^^^^^^^^^ expected `LeviCivitaConnection`, found `Result<LeviCivitaConnection, ...>`
    |                          |
    |                          arguments to this function are incorrect
    |
    = note: expected struct `LeviCivitaConnection`
                 found enum `std::result::Result<LeviCivitaConnection, ManifoldError>`
note: associated function defined here
   --> rustmath-manifolds/src/dirac.rs:145:12
    |
145 |     pub fn from_levi_civita(levi_civita: LeviCivitaConnection) -> Self {
    |            ^^^^^^^^^^^^^^^^ ---------------------------------
help: consider using `Result::expect` to unwrap the `std::result::Result<LeviCivitaConnection, ManifoldError>` value, panicking if the value is a `Result::Err`
    |
 67 |         let connection = SpinorConnection::from_levi_civita(levi_civita.expect("REASON"));
    |                                                                        +++++++++++++++++

warning: unused import: `rustmath_core::NumericConversion`
 --> rustmath-manifolds/src/transition.rs:8:5
  |
8 | use rustmath_core::NumericConversion;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-manifolds/src/modules.rs:22:46
   |
22 | use rustmath_core::{Parent, ParentWithBasis, Ring};
   |                                              ^^^^

error[E0107]: struct takes 0 generic arguments but 1 generic argument was supplied
   --> rustmath-rings/src/real_lazy.rs:223:28
    |
223 |     pub fn from_complex(c: Complex<f64>) -> Self {
    |                            ^^^^^^^----- help: remove the unnecessary generics
    |                            |
    |                            expected 0 generic arguments
    |
note: struct defined here, with 0 generic parameters
   --> /home/john/RustMath/rustmath-complex/src/complex.rs:18:12
    |
 18 | pub struct Complex {
    |            ^^^^^^^

error[E0107]: struct takes 0 generic arguments but 1 generic argument was supplied
   --> rustmath-rings/src/real_lazy.rs:461:38
    |
461 |     pub fn eval_to_complex(&self) -> Complex<f64> {
    |                                      ^^^^^^^----- help: remove the unnecessary generics
    |                                      |
    |                                      expected 0 generic arguments
    |
note: struct defined here, with 0 generic parameters
   --> /home/john/RustMath/rustmath-complex/src/complex.rs:18:12
    |
 18 | pub struct Complex {
    |            ^^^^^^^

warning: unused variable: `expr`
   --> rustmath-manifolds/src/scalar_field.rs:119:13
    |
119 |         let expr = self.expr(chart)?;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_expr`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `components`
   --> rustmath-manifolds/src/tensor_field.rs:233:13
    |
233 |         let components = self.components(chart)?;
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_components`

error[E0382]: borrow of moved value: `components`
  --> rustmath-manifolds/src/tangent_space.rs:79:68
   |
69 |         components: Vec<f64>,
   |         ---------- move occurs because `components` has type `Vec<f64>`, which does not implement the `Copy` trait
...
77 |             components,
   |             ---------- value moved here
78 |             // This is a temporary workaround - we need the manifold reference
79 |             manifold: Arc::new(DifferentiableManifold::new("temp", components.len())),
   |                                                                    ^^^^^^^^^^ value borrowed here after move
   |
help: consider cloning the value if the performance cost is acceptable
   |
77 |             components: components.clone(),
   |                       ++++++++++++++++++++

error[E0599]: no variant or associated item named `NotDivisible` found for enum `MathError` in the current scope
   --> rustmath-rings/src/category_methods.rs:127:28
    |
127 |             Err(MathError::NotDivisible)
    |                            ^^^^^^^^^^^^ variant or associated item not found in `MathError`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/tangent_space.rs:253:36
    |
253 |     pub fn coordinate_basis(&self, chart: &Chart) -> Vec<TangentVector> {
    |                                    ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `comps`
   --> rustmath-manifolds/src/riemannian.rs:125:13
    |
125 |         let comps = self.components(chart)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_comps`

error[E0505]: cannot move out of `manifold` because it is borrowed
   --> rustmath-manifolds/src/riemannian.rs:321:38
    |
315 |         let manifold = self.connection.manifold().clone();
    |             -------- binding `manifold` declared here
316 |         let chart = manifold.default_chart()
    |                     -------- borrow of `manifold` occurs here
...
321 |         VectorField::from_components(manifold, chart, zero_comps)
    |                                      ^^^^^^^^  ----- borrow later used here
    |                                      |
    |                                      move out of `manifold` occurs here

error[E0308]: mismatched types
  --> rustmath-rings/src/derivation.rs:33:20
   |
21 | pub trait RingDerivation<R: Ring>: Clone {
   | ---------------------------------------- expected type parameter
...
28 |     fn compose<D: RingDerivation<R>>(&self, other: &D) -> ComposedDerivation<R, Self, D>
   |                - found type parameter
...
33 |             first: other.clone(),
   |                    ^^^^^^^^^^^^^ expected type parameter `Self`, found type parameter `D`
   |
   = note: expected type parameter `Self`
              found type parameter `D`
   = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound
   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters

error[E0308]: mismatched types
  --> rustmath-rings/src/derivation.rs:34:21
   |
21 | pub trait RingDerivation<R: Ring>: Clone {
   | ---------------------------------------- found type parameter
...
28 |     fn compose<D: RingDerivation<R>>(&self, other: &D) -> ComposedDerivation<R, Self, D>
   |                - expected type parameter
...
34 |             second: self.clone(),
   |                     ^^^^^^^^^^^^ expected type parameter `D`, found type parameter `Self`
   |
   = note: expected type parameter `D`
              found type parameter `Self`
   = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound
   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:249:20
    |
249 |             basis: Vec::new(),
    |                    ^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:249:20
    |
249 |             basis: Vec::new(),
    |                    ^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:256:9
    |
256 |         self.basis.push(Box::new(d));
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:261:9
    |
261 |         self.basis.len()
    |         ^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:324:26
    |
324 |             derivations: Vec::new(),
    |                          ^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:324:26
    |
324 |             derivations: Vec::new(),
    |                          ^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:332:9
    |
332 |         self.derivations.push(Box::new(deriv));
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:347:26
    |
347 |             derivations: Vec::new(),
    |                          ^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:347:26
    |
347 |             derivations: Vec::new(),
    |                          ^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:356:60
    |
356 |         for (coeff, deriv) in self.coefficients.iter().zip(self.derivations.iter()) {
    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:356:31
    |
356 |         for (coeff, deriv) in self.coefficients.iter().zip(self.derivations.iter()) {
    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:364:9
    |
364 |         self.derivations.is_empty() ||
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

error[E0038]: the trait `RingDerivation` is not dyn compatible
   --> rustmath-rings/src/derivation.rs:371:59
    |
371 |         write!(f, "Linear combination of {} derivations", self.derivations.len())
    |                                                           ^^^^^^^^^^^^^^^^^^^^^^ `RingDerivation` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> rustmath-rings/src/derivation.rs:21:29
    |
 21 | pub trait RingDerivation<R: Ring>: Clone {
    |           --------------    ^^^^   ^^^^^ ...because it requires `Self: Sized`
    |           |                 |
    |           |                 ...because it requires `Self: Sized`
    |           this trait is not dyn compatible...

warning: unused variable: `chart`
   --> rustmath-manifolds/src/lie_group.rs:124:13
    |
124 |         let chart = self.manifold.default_chart()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/lie_group.rs:175:13
    |
175 |         let chart = self.manifold.default_chart()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
  --> rustmath-rings/src/fraction_field_fpt.rs:52:24
   |
52 |         *c = c.clone().modulo(p);
   |                        ^^^^^^
   |
help: there is a method `mul` with a similar name
   |
52 -         *c = c.clone().modulo(p);
52 +         *c = c.clone().mul(p);
   |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
  --> rustmath-rings/src/fraction_field_fpt.rs:90:31
   |
90 |         result[i] = (ai + bi).modulo(p);
   |                               ^^^^^^
   |
help: there is a method `mul` with a similar name
   |
90 -         result[i] = (ai + bi).modulo(p);
90 +         result[i] = (ai + bi).mul(p);
   |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:106:50
    |
106 |             let prod = (ai.clone() * bj.clone()).modulo(p);
    |                                                  ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
106 -             let prod = (ai.clone() * bj.clone()).modulo(p);
106 +             let prod = (ai.clone() * bj.clone()).mul(p);
    |

warning: unused variable: `p`
   --> rustmath-manifolds/src/fiber_bundles.rs:392:41
    |
392 |     pub fn horizontal_projection(&self, p: &ManifoldPoint, v: &TangentVector) -> Result<TangentVector> {
    |                                         ^ help: if this is intentional, prefix it with an underscore: `_p`

error[E0382]: use of moved value: `connection`
   --> rustmath-manifolds/src/fiber_bundles.rs:444:13
    |
431 |     pub fn from_connection(connection: ConnectionForm) -> Result<Self> {
    |                            ---------- move occurs because `connection` has type `ConnectionForm`, which does not implement the `Copy` trait
...
436 |             move |_p: &ManifoldPoint, _v: &TangentVector, _w: &TangentVector| -> Result<Vec<f64>> {
    |             ------------------------------------------------------------------------------------- value moved into closure here
437 |                 // Placeholder: return zero curvature
438 |                 let dim = connection.principal_bundle().structure_group().dimension();
    |                           ---------- variable moved due to use in closure
...
444 |             connection,
    |             ^^^^^^^^^^ value used here after move
    |
help: consider cloning the value before moving it into the closure
    |
435 ~         let value = connection.clone();
436 ~         let form = Arc::new(
437 |             move |_p: &ManifoldPoint, _v: &TangentVector, _w: &TangentVector| -> Result<Vec<f64>> {
438 |                 // Placeholder: return zero curvature
439 ~                 let dim = value.principal_bundle().structure_group().dimension();
    |

warning: unused variable: `tolerance`
   --> rustmath-manifolds/src/fiber_bundles.rs:462:27
    |
462 |     pub fn is_flat(&self, tolerance: f64) -> Result<bool> {
    |                           ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tolerance`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:107:60
    |
107 |             result[i + j] = (result[i + j].clone() + prod).modulo(p);
    |                                                            ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
107 -             result[i + j] = (result[i + j].clone() + prod).modulo(p);
107 +             result[i + j] = (result[i + j].clone() + prod).mul(p);
    |

warning: unused variable: `factorial`
   --> rustmath-manifolds/src/symplectic.rs:313:13
    |
313 |         let factorial = (1..=n).product::<usize>() as f64;
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_factorial`

warning: unused variable: `term1`
   --> rustmath-manifolds/src/symplectic.rs:459:13
    |
459 |         let term1 = self.bracket(f, &gh)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_term1`

warning: unused variable: `term2`
   --> rustmath-manifolds/src/symplectic.rs:460:13
    |
460 |         let term2 = self.bracket(g, &hf)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_term2`

warning: unused variable: `term3`
   --> rustmath-manifolds/src/symplectic.rs:461:13
    |
461 |         let term3 = self.bracket(h, &fg)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_term3`

error[E0599]: no method named `mod_inverse` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:128:28
    |
128 |             let inv = lead.mod_inverse(p);
    |                            ^^^^^^^^^^^ method not found in `rustmath_integers::Integer`

warning: unused variable: `n`
   --> rustmath-manifolds/src/integration.rs:297:13
    |
297 |         let n = form.manifold().dimension();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:131:56
    |
131 |                     *c = (c.clone() * inv_val.clone()).modulo(p);
    |                                                        ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
131 -                     *c = (c.clone() * inv_val.clone()).modulo(p);
131 +                     *c = (c.clone() * inv_val.clone()).mul(p);
    |

warning: unused variable: `remaining_bounds`
   --> rustmath-manifolds/src/integration.rs:611:9
    |
611 |     let remaining_bounds = &bounds[1..];
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_remaining_bounds`

error[E0599]: no method named `mod_inverse` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:151:41
    |
151 |     let divisor_lead_inv = divisor_lead.mod_inverse(p).expect("Divisor leading coefficient must be invertible");
    |                                         ^^^^^^^^^^^ method not found in `rustmath_integers::Integer`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:158:65
    |
158 |         let coeff = (remainder_lead * divisor_lead_inv.clone()).modulo(p);
    |                                                                 ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
158 -         let coeff = (remainder_lead * divisor_lead_inv.clone()).modulo(p);
158 +         let coeff = (remainder_lead * divisor_lead_inv.clone()).mul(p);
    |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:170:57
    |
170 |             subtrahend.push((c.clone() * coeff.clone()).modulo(p));
    |                                                         ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
170 -             subtrahend.push((c.clone() * coeff.clone()).modulo(p));
170 +             subtrahend.push((c.clone() * coeff.clone()).mul(p));
    |

error[E0308]: mismatched types
   --> rustmath-rings/src/fraction_field_fpt.rs:176:80
    |
176 |                 remainder[i] = (remainder[i].clone() - subtrahend[i].clone() + p).modulo(p);
    |                                 --------------------------------------------   ^ expected `Integer`, found `&Integer`
    |                                 |
    |                                 expected because this is `rustmath_integers::Integer`
    |
help: consider using clone here
    |
176 |                 remainder[i] = (remainder[i].clone() - subtrahend[i].clone() + p.clone()).modulo(p);
    |                                                                                 ++++++++

warning: unused variable: `chart`
   --> rustmath-manifolds/src/topology.rs:349:60
    |
349 |     pub fn from_curvature(&mut self, curvature: &DiffForm, chart: &Chart) -> Result<()> {
    |                                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `metric`
   --> rustmath-manifolds/src/topology.rs:537:9
    |
537 |         metric: &RiemannianMetric,
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_metric`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/topology.rs:538:9
    |
538 |         chart: &Chart,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:176:83
    |
176 |                 remainder[i] = (remainder[i].clone() - subtrahend[i].clone() + p).modulo(p);
    |                                                                                   ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
176 -                 remainder[i] = (remainder[i].clone() - subtrahend[i].clone() + p).modulo(p);
176 +                 remainder[i] = (remainder[i].clone() - subtrahend[i].clone() + p).mul(p);
    |

warning: unused variable: `jacobian`
   --> rustmath-manifolds/src/maps.rs:146:13
    |
146 |         let jacobian = self.jacobian(source_chart, target_chart)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian`

warning: unused variable: `point_coords`
   --> rustmath-manifolds/src/maps.rs:144:9
    |
144 |         point_coords: &[f64],
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_point_coords`

warning: unused variable: `jacobian`
   --> rustmath-manifolds/src/maps.rs:387:13
    |
387 |         let jacobian = map.jacobian(source_chart, target_chart)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian`

warning: unused variable: `n_source`
   --> rustmath-manifolds/src/maps.rs:396:13
    |
396 |         let n_source = self.map.source.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_source`

warning: unused variable: `n_target`
   --> rustmath-manifolds/src/maps.rs:397:13
    |
397 |         let n_target = self.map.target.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_target`

error[E0599]: no method named `mod_inverse` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:226:32
    |
226 |                 let inv = lead.mod_inverse(&p).expect("Leading coefficient must be invertible");
    |                                ^^^^^^^^^^^ method not found in `rustmath_integers::Integer`

warning: unused variable: `jacobian`
   --> rustmath-manifolds/src/maps.rs:470:13
    |
470 |         let jacobian = map.jacobian(source_chart, target_chart)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian`

warning: unused variable: `n_source`
   --> rustmath-manifolds/src/maps.rs:479:13
    |
479 |         let n_source = self.map.source.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_source`

warning: unused variable: `n_target`
   --> rustmath-manifolds/src/maps.rs:480:13
    |
480 |         let n_target = self.map.target.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_target`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:228:52
    |
228 |                     *c = (c.clone() * inv.clone()).modulo(&p);
    |                                                    ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
228 -                     *c = (c.clone() * inv.clone()).modulo(&p);
228 +                     *c = (c.clone() * inv.clone()).mul(&p);
    |

warning: unused variable: `inv_self`
   --> rustmath-manifolds/src/maps.rs:744:19
    |
744 |             (Some(inv_self), Some(inv_other)) => {
    |                   ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inv_self`

warning: unused variable: `inv_other`
   --> rustmath-manifolds/src/maps.rs:744:35
    |
744 |             (Some(inv_self), Some(inv_other)) => {
    |                                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inv_other`

warning: variable does not need to be mutable
   --> rustmath-manifolds/src/maps.rs:745:21
    |
745 |                 let mut inv = SmoothMap::new(
    |                     ----^^^
    |                     |
    |                     help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `factor`
   --> rustmath-manifolds/src/symmetries.rs:290:21
    |
290 |         if let Some(factor) = &self.conformal_factor {
    |                     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_factor`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:231:52
    |
231 |                     *c = (c.clone() * inv.clone()).modulo(&p);
    |                                                    ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
231 -                     *c = (c.clone() * inv.clone()).modulo(&p);
231 +                     *c = (c.clone() * inv.clone()).mul(&p);
    |

warning: unused variable: `bracket`
   --> rustmath-manifolds/src/symmetries.rs:400:21
    |
400 |                 let bracket = self.killing_fields[i].lie_bracket(&self.killing_fields[j])?;
    |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bracket`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/symmetries.rs:393:39
    |
393 |     pub fn structure_constants(&self, chart: &Chart) -> Result<Vec<Vec<Vec<f64>>>> {
    |                                       ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: variable does not need to be mutable
   --> rustmath-manifolds/src/symmetries.rs:395:13
    |
395 |         let mut constants = vec![vec![vec![0.0; n]; n]; n];
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/catalog.rs:108:32
    |
108 |     pub fn is_spacelike(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                                ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `vector_components`
   --> rustmath-manifolds/src/catalog.rs:108:47
    |
108 |     pub fn is_spacelike(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                                               ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vector_components`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/catalog.rs:114:27
    |
114 |     pub fn is_null(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `vector_components`
   --> rustmath-manifolds/src/catalog.rs:114:42
    |
114 |     pub fn is_null(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                                          ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vector_components`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:354:55
    |
354 |                 *c = (self.prime.clone() - c.clone()).modulo(&self.prime);
    |                                                       ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
354 -                 *c = (self.prime.clone() - c.clone()).modulo(&self.prime);
354 +                 *c = (self.prime.clone() - c.clone()).mul(&self.prime);
    |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/fraction_field_fpt.rs:468:33
    |
468 |         self.element(vec![value.modulo(&self.prime)], vec![Integer::one()])
    |                                 ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
468 -         self.element(vec![value.modulo(&self.prime)], vec![Integer::one()])
468 +         self.element(vec![value.mul(&self.prime)], vec![Integer::one()])
    |

warning: unused variable: `expr`
   --> rustmath-manifolds/src/complex_manifold.rs:318:25
    |
318 |             if let Some(expr) = self.chart_expressions.get(chart.name()) {
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_expr`

warning: unused variable: `point`
   --> rustmath-manifolds/src/complex_manifold.rs:315:27
    |
315 |     pub fn eval_at(&self, point: &ManifoldPoint) -> Result<Complex> {
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_point`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/complex_manifold.rs:335:30
    |
335 |     pub fn derivative(&self, chart: &ComplexChart) -> Option<HolomorphicFunction> {
    |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `metric`
   --> rustmath-manifolds/src/almost_complex.rs:248:45
    |
248 |     pub fn is_compatible_with_metric(&self, metric: &RiemannianMetric) -> bool {
    |                                             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_metric`

warning: unused variable: `point`
   --> rustmath-manifolds/src/finsler.rs:124:24
    |
124 |     pub fn eval(&self, point: &ManifoldPoint, tangent_vector: &TangentVector) -> Result<f64> {
    |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_point`

warning: unused variable: `tangent_vector`
   --> rustmath-manifolds/src/finsler.rs:124:47
    |
124 |     pub fn eval(&self, point: &ManifoldPoint, tangent_vector: &TangentVector) -> Result<f64> {
    |                                               ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tangent_vector`

warning: unused variable: `p`
   --> rustmath-manifolds/src/subriemannian.rs:288:28
    |
288 |     pub fn distance(&self, p: &ManifoldPoint, q: &ManifoldPoint) -> Result<f64> {
    |                            ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `q`
   --> rustmath-manifolds/src/subriemannian.rs:288:47
    |
288 |     pub fn distance(&self, p: &ManifoldPoint, q: &ManifoldPoint) -> Result<f64> {
    |                                               ^ help: if this is intentional, prefix it with an underscore: `_q`

warning: unused variable: `spinor`
  --> rustmath-manifolds/src/dirac.rs:80:25
   |
80 |     pub fn apply(&self, spinor: &SpinorField) -> Result<SpinorField> {
   |                         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_spinor`

Some errors have detailed explanations: E0061, E0277, E0282, E0308, E0382, E0505, E0599.
For more information about an error, try `rustc --explain E0061`.
warning: `rustmath-manifolds` (lib) generated 87 warnings
error: could not compile `rustmath-manifolds` (lib) due to 88 previous errors; 87 warnings emitted
error[E0599]: no function or associated item named `one` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/pow_computer.rs:114:34
    |
114 |         assert!(prime > Integer::one(), "Prime must be > 1");
    |                                  ^^^ function or associated item not found in `rustmath_integers::Integer`
    |
note: if you're trying to build a new `rustmath_integers::Integer`, consider using `rustmath_integers::Integer::new` which returns `rustmath_integers::Integer`
   --> /home/john/RustMath/rustmath-integers/src/integer.rs:19:5
    |
 19 |     pub fn new(value: BigInt) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Ring` which provides `one` is implemented but not in scope; perhaps you want to import it
    |
 42 + use rustmath_core::Ring;
    |

error[E0599]: no function or associated item named `one` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/pow_computer.rs:118:30
    |
118 |         powers.push(Integer::one()); // p^0 = 1
    |                              ^^^ function or associated item not found in `rustmath_integers::Integer`
    |
note: if you're trying to build a new `rustmath_integers::Integer`, consider using `rustmath_integers::Integer::new` which returns `rustmath_integers::Integer`
   --> /home/john/RustMath/rustmath-integers/src/integer.rs:19:5
    |
 19 |     pub fn new(value: BigInt) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Ring` which provides `one` is implemented but not in scope; perhaps you want to import it
    |
 42 + use rustmath_core::Ring;
    |

error[E0599]: no method named `pow` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/pow_computer.rs:185:24
    |
185 |             self.prime.pow(n as u32)
    |                        ^^^ method not found in `rustmath_integers::Integer`
    |
   ::: /home/john/RustMath/rustmath-core/src/traits.rs:69:8
    |
 69 |     fn pow(&self, n: u32) -> Self {
    |        --- the method is available for `rustmath_integers::Integer` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `pow` is implemented but not in scope; perhaps you want to import it
    |
 42 + use rustmath_core::Ring;
    |

error[E0599]: no function or associated item named `one` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/pow_computer_ext.rs:309:22
    |
309 |             Integer::one()
    |                      ^^^ function or associated item not found in `rustmath_integers::Integer`
    |
note: if you're trying to build a new `rustmath_integers::Integer`, consider using `rustmath_integers::Integer::new` which returns `rustmath_integers::Integer`
   --> /home/john/RustMath/rustmath-integers/src/integer.rs:19:5
    |
 19 |     pub fn new(value: BigInt) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: trait `Ring` which provides `one` is implemented but not in scope; perhaps you want to import it
    |
 44 + use rustmath_core::Ring;
    |

error[E0599]: no method named `pow` found for reference `&rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/pow_computer_ext.rs:311:31
    |
311 |             self.base.prime().pow(k as u32)
    |             ---------         ^^^ method not found in `&rustmath_integers::Integer`
    |             |
    |             method `pow` is available on `&padics::pow_computer::PowComputer`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `pow` is implemented but not in scope; perhaps you want to import it
    |
 44 + use rustmath_core::Ring;
    |

error[E0277]: a value of type `rustmath_integers::Integer` cannot be made by summing an iterator over elements of type `&rustmath_integers::Integer`
    --> rustmath-rings/src/padics/pow_computer_ext.rs:399:49
     |
 399 |         self.frobenius_trace_exponents().iter().sum()
     |                                                 ^^^ value of type `rustmath_integers::Integer` cannot be made by summing a `std::iter::Iterator<Item=&rustmath_integers::Integer>`
     |
     = help: the trait `Sum<&rustmath_integers::Integer>` is not implemented for `rustmath_integers::Integer`
     = help: the following other types implement trait `Sum<A>`:
               `BigInt` implements `Sum<T>`
               `BigUint` implements `Sum<T>`
               `Duration` implements `Sum<&'a Duration>`
               `Duration` implements `Sum`
               `Option<T>` implements `Sum<Option<U>>`
               `Ratio<T>` implements `Sum<&'a Ratio<T>>`
               `Ratio<T>` implements `Sum`
               `Simd<f32, N>` implements `Sum<&'a Simd<f32, N>>`
             and 93 others
note: required by a bound in `std::iter::Iterator::sum`
    --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:3578:12
     |
3575 |     fn sum<S>(self) -> S
     |        --- required by a bound in this associated function
...
3578 |         S: Sum<Self::Item>,
     |            ^^^^^^^^^^^^^^^ required by this bound in `Iterator::sum`

error[E0599]: no method named `is_prime` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/capped_relative.rs:106:46
    |
106 |         if prime <= Integer::one() || !prime.is_prime() {
    |                                              ^^^^^^^^
    |
   ::: /home/john/RustMath/rustmath-integers/src/sage_wrapper.rs:330:8
    |
330 |     fn is_prime(&self) -> bool;
    |        -------- the method is available for `rustmath_integers::Integer` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `SageInteger` which provides `is_prime` is implemented but not in scope; perhaps you want to import it
    |
 44 + use rustmath_integers::SageInteger;
    |
help: there is a method `is_prime_power` with a similar name
    |
106 |         if prime <= Integer::one() || !prime.is_prime_power() {
    |                                                      ++++++

error[E0599]: no method named `is_prime` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/capped_relative.rs:175:46
    |
175 |         if prime <= Integer::one() || !prime.is_prime() {
    |                                              ^^^^^^^^
    |
   ::: /home/john/RustMath/rustmath-integers/src/sage_wrapper.rs:330:8
    |
330 |     fn is_prime(&self) -> bool;
    |        -------- the method is available for `rustmath_integers::Integer` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `SageInteger` which provides `is_prime` is implemented but not in scope; perhaps you want to import it
    |
 44 + use rustmath_integers::SageInteger;
    |
help: there is a method `is_prime_power` with a similar name
    |
175 |         if prime <= Integer::one() || !prime.is_prime_power() {
    |                                                      ++++++

error[E0599]: no method named `is_prime` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/capped_relative.rs:341:46
    |
341 |         if prime <= Integer::one() || !prime.is_prime() {
    |                                              ^^^^^^^^
    |
   ::: /home/john/RustMath/rustmath-integers/src/sage_wrapper.rs:330:8
    |
330 |     fn is_prime(&self) -> bool;
    |        -------- the method is available for `rustmath_integers::Integer` here
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `SageInteger` which provides `is_prime` is implemented but not in scope; perhaps you want to import it
    |
 44 + use rustmath_integers::SageInteger;
    |
help: there is a method `is_prime_power` with a similar name
    |
341 |         if prime <= Integer::one() || !prime.is_prime_power() {
    |                                                      ++++++

error[E0599]: no method named `modpow` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/padics/capped_relative.rs:371:31
    |
371 |             current = current.modpow(&prime, &modulus);
    |                               ^^^^^^
    |
help: there is a method `mod_pow` with a similar name
    |
371 |             current = current.mod_pow(&prime, &modulus);
    |                                  +

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:232:20
    |
232 |             lower: lower_bound,
    |                    ^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:233:20
    |
233 |             upper: upper_bound,
    |                    ^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:299:9
    |
298 |     pub fn width(&self) -> Float {
    |                            ----- expected `rug::Float` because of return type
299 |         Float::with_val_round(self.precision, &self.upper - &self.lower, Round::Up)
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:383:13
    |
383 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:384:13
    |
384 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:408:13
    |
408 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:409:13
    |
409 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:421:20
    |
421 |             lower: Float::with_val_round(self.precision, &self.lower, Round::Down),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:422:20
    |
422 |             upper: Float::with_val_round(self.precision, &mid, Round::Up),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:427:20
    |
427 |             lower: Float::with_val_round(self.precision, &mid, Round::Down),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:428:20
    |
428 |             upper: Float::with_val_round(self.precision, &self.upper, Round::Up),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:455:24
    |
455 |                 upper: Float::with_val_round(self.precision, max_abs, Round::Up),
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0599]: no method named `sqrt` found for tuple `(rug::Float, std::cmp::Ordering)` in the current scope
   --> rustmath-rings/src/real_mpfi.rs:474:85
    |
474 |         let lower = Float::with_val_round(self.precision, &self.lower, Round::Down).sqrt();
    |                                                                                     ^^^^ method not found in `(rug::Float, std::cmp::Ordering)`
    |
help: one of the expressions' fields has a method of the same name
    |
474 |         let lower = Float::with_val_round(self.precision, &self.lower, Round::Down).0.sqrt();
    |                                                                                     ++

error[E0599]: no method named `sqrt` found for tuple `(rug::Float, std::cmp::Ordering)` in the current scope
   --> rustmath-rings/src/real_mpfi.rs:475:83
    |
475 |         let upper = Float::with_val_round(self.precision, &self.upper, Round::Up).sqrt();
    |                                                                                   ^^^^ method not found in `(rug::Float, std::cmp::Ordering)`
    |
help: one of the expressions' fields has a method of the same name
    |
475 |         let upper = Float::with_val_round(self.precision, &self.upper, Round::Up).0.sqrt();
    |                                                                                   ++

error[E0369]: cannot divide `(rug::Float, std::cmp::Ordering)` by `&rug::Float`
   --> rustmath-rings/src/real_mpfi.rs:493:77
    |
493 |         let lower = Float::with_val_round(self.precision, 1.0, Round::Down) / &self.upper;
    |                     ------------------------------------------------------- ^ ----------- &rug::Float
    |                     |
    |                     (rug::Float, std::cmp::Ordering)

error[E0369]: cannot divide `(rug::Float, std::cmp::Ordering)` by `&rug::Float`
   --> rustmath-rings/src/real_mpfi.rs:494:75
    |
494 |         let upper = Float::with_val_round(self.precision, 1.0, Round::Up) / &self.lower;
    |                     ----------------------------------------------------- ^ ----------- &rug::Float
    |                     |
    |                     (rug::Float, std::cmp::Ordering)

error[E0599]: no method named `exp` found for tuple `(rug::Float, std::cmp::Ordering)` in the current scope
   --> rustmath-rings/src/real_mpfi.rs:505:85
    |
505 |         let lower = Float::with_val_round(self.precision, &self.lower, Round::Down).exp();
    |                                                                                     ^^^ method not found in `(rug::Float, std::cmp::Ordering)`
    |
help: one of the expressions' fields has a method of the same name
    |
505 |         let lower = Float::with_val_round(self.precision, &self.lower, Round::Down).0.exp();
    |                                                                                     ++

error[E0599]: no method named `exp` found for tuple `(rug::Float, std::cmp::Ordering)` in the current scope
   --> rustmath-rings/src/real_mpfi.rs:506:83
    |
506 |         let upper = Float::with_val_round(self.precision, &self.upper, Round::Up).exp();
    |                                                                                   ^^^ method not found in `(rug::Float, std::cmp::Ordering)`
    |
help: one of the expressions' fields has a method of the same name
    |
506 |         let upper = Float::with_val_round(self.precision, &self.upper, Round::Up).0.exp();
    |                                                                                   ++

error[E0599]: no method named `ln` found for tuple `(rug::Float, std::cmp::Ordering)` in the current scope
    --> rustmath-rings/src/real_mpfi.rs:523:85
     |
 523 |         let lower = Float::with_val_round(self.precision, &self.lower, Round::Down).ln();
     |                                                                                     ^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1417:5
     |
1417 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: one of the expressions' fields has a method of the same name
     |
 523 |         let lower = Float::with_val_round(self.precision, &self.lower, Round::Down).0.ln();
     |                                                                                     ++

error[E0599]: no method named `ln` found for tuple `(rug::Float, std::cmp::Ordering)` in the current scope
    --> rustmath-rings/src/real_mpfi.rs:524:83
     |
 524 |         let upper = Float::with_val_round(self.precision, &self.upper, Round::Up).ln();
     |                                                                                   ^^
     |
help: there is a method `le` with a similar name, but with different arguments
    --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:1417:5
     |
1417 |     fn le(&self, other: &Rhs) -> bool {
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: one of the expressions' fields has a method of the same name
     |
 524 |         let upper = Float::with_val_round(self.precision, &self.upper, Round::Up).0.ln();
     |                                                                                   ++

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:556:20
    |
556 |             lower: Float::with_val_round(self.precision, min, Round::Down),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:557:20
    |
557 |             upper: Float::with_val_round(self.precision, max, Round::Up),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:580:20
    |
580 |             lower: Float::with_val_round(self.precision, min, Round::Down),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:581:20
    |
581 |             upper: Float::with_val_round(self.precision, max, Round::Up),
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:628:13
    |
628 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:629:13
    |
629 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:645:13
    |
645 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:646:13
    |
646 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:665:13
    |
665 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:666:13
    |
666 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:682:13
    |
682 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:683:13
    |
683 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:712:13
    |
712 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:713:13
    |
713 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:737:13
    |
737 |             lower,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0308]: mismatched types
   --> rustmath-rings/src/real_mpfi.rs:738:13
    |
738 |             upper,
    |             ^^^^^ expected `Float`, found `(Float, Ordering)`
    |
    = note: expected struct `rug::Float`
                found tuple `(rug::Float, std::cmp::Ordering)`

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/residue_field.rs:367:29
    |
367 |         let reduced = value.modulo(&self.prime);
    |                             ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
367 -         let reduced = value.modulo(&self.prime);
367 +         let reduced = value.mul(&self.prime);
    |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/residue_field.rs:405:40
    |
405 |             let rem = (-value.clone()).modulo(&prime);
    |                                        ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
405 -             let rem = (-value.clone()).modulo(&prime);
405 +             let rem = (-value.clone()).mul(&prime);
    |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/residue_field.rs:412:19
    |
412 |             value.modulo(&prime)
    |                   ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
412 -             value.modulo(&prime)
412 +             value.mul(&prime)
    |

error[E0308]: mismatched types
   --> rustmath-rings/src/residue_field.rs:478:39
    |
478 |         ResidueFieldPrimeElement::new(result, self.prime.clone())
    |         ----------------------------- ^^^^^^ expected `Integer`, found `Result<Integer, MathError>`
    |         |
    |         arguments to this function are incorrect
    |
    = note: expected struct `rustmath_integers::Integer`
                 found enum `std::result::Result<rustmath_integers::Integer, MathError>`
note: associated function defined here
   --> rustmath-rings/src/residue_field.rs:400:8
    |
400 |     fn new(value: rustmath_integers::Integer, prime: rustmath_integers::Integer) -> Self {
    |        ^^^ ---------------------------------
help: consider using `Result::expect` to unwrap the `std::result::Result<rustmath_integers::Integer, MathError>` value, panicking if the value is a `Result::Err`
    |
478 |         ResidueFieldPrimeElement::new(result.expect("REASON"), self.prime.clone())
    |                                             +++++++++++++++++

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/residue_field.rs:496:46
    |
496 |         let sum = (self.value + other.value).modulo(&self.prime);
    |                                              ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
496 -         let sum = (self.value + other.value).modulo(&self.prime);
496 +         let sum = (self.value + other.value).mul(&self.prime);
    |

error[E0599]: no method named `modulo` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/residue_field.rs:520:50
    |
520 |         let product = (self.value * other.value).modulo(&self.prime);
    |                                                  ^^^^^^
    |
help: there is a method `mul` with a similar name
    |
520 -         let product = (self.value * other.value).modulo(&self.prime);
520 +         let product = (self.value * other.value).mul(&self.prime);
    |

error[E0369]: cannot calculate the remainder of `Option<usize>` divided by `{integer}`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:121:22
    |
121 |             if deg_f % 2 == 1 {
    |                ----- ^ - {integer}
    |                |
    |                Option<usize>
    |
note: the foreign item type `Option<usize>` doesn't implement `Rem<{integer}>`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:594:1
    |
594 | pub enum Option<T> {
    | ^^^^^^^^^^^^^^^^^^ not implement `Rem<{integer}>`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:121:29
    |
114 | impl<F: Field> HyperellipticCurve<F> {
    |      - expected this type parameter
...
121 |             if deg_f % 2 == 1 {
    |                             ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0369]: cannot subtract `{integer}` from `Option<usize>`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:122:24
    |
122 |                 (deg_f - 1) / 2
    |                  ----- ^ - {integer}
    |                  |
    |                  Option<usize>
    |
note: the foreign item type `Option<usize>` doesn't implement `Sub<{integer}>`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:594:1
    |
594 | pub enum Option<T> {
    | ^^^^^^^^^^^^^^^^^^ not implement `Sub<{integer}>`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:122:31
    |
114 | impl<F: Field> HyperellipticCurve<F> {
    |      - expected this type parameter
...
122 |                 (deg_f - 1) / 2
    |                               ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0369]: cannot subtract `{integer}` from `Option<usize>`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:124:24
    |
124 |                 (deg_f - 2) / 2
    |                  ----- ^ - {integer}
    |                  |
    |                  Option<usize>
    |
note: the foreign item type `Option<usize>` doesn't implement `Sub<{integer}>`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:594:1
    |
594 | pub enum Option<T> {
    | ^^^^^^^^^^^^^^^^^^ not implement `Sub<{integer}>`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:124:31
    |
114 | impl<F: Field> HyperellipticCurve<F> {
    |      - expected this type parameter
...
124 |                 (deg_f - 2) / 2
    |                               ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0369]: cannot subtract `{integer}` from `Option<usize>`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:128:20
    |
128 |             (deg_f - 2) / 2
    |              ----- ^ - {integer}
    |              |
    |              Option<usize>
    |
note: the foreign item type `Option<usize>` doesn't implement `Sub<{integer}>`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:594:1
    |
594 | pub enum Option<T> {
    | ^^^^^^^^^^^^^^^^^^ not implement `Sub<{integer}>`

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:128:27
    |
114 | impl<F: Field> HyperellipticCurve<F> {
    |      - expected this type parameter
...
128 |             (deg_f - 2) / 2
    |                           ^ expected type parameter `F`, found integer
    |
    = note: expected type parameter `F`
                         found type `{integer}`

error[E0599]: no method named `evaluate` found for struct `UnivariatePolynomial<R>` in the current scope
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:161:16
    |
161 |         self.f.evaluate(x)
    |                ^^^^^^^^
    |
help: there is a method `eval` with a similar name
    |
161 -         self.f.evaluate(x)
161 +         self.f.eval(x)
    |

error[E0599]: no function or associated item named `one` found for struct `UnivariatePolynomial<R>` in the current scope
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:221:38
    |
221 |             u: UnivariatePolynomial::one(),
    |                                      ^^^ function or associated item not found in `UnivariatePolynomial<_>`
    |
note: if you're trying to build a new `UnivariatePolynomial<_>` consider using one of the following associated functions:
      UnivariatePolynomial::<R>::new
      UnivariatePolynomial::<R>::constant
      UnivariatePolynomial::<R>::var
   --> /home/john/RustMath/rustmath-polynomials/src/univariate.rs:17:5
    |
 17 |     pub fn new(mut coeffs: Vec<R>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 31 |     pub fn constant(c: R) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn var() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
note: `RingExt` defines an item `one`, perhaps you need to implement it
   --> rustmath-rings/src/ring.rs:206:1
    |
206 | pub trait RingExt: Ring {
    | ^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `ne` with a similar name, but with different arguments
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/cmp.rs:264:5
    |
264 |     fn ne(&self, other: &Rhs) -> bool {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no function or associated item named `zero` found for struct `UnivariatePolynomial<R>` in the current scope
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:222:38
    |
222 |             v: UnivariatePolynomial::zero(),
    |                                      ^^^^ function or associated item not found in `UnivariatePolynomial<_>`
    |
note: if you're trying to build a new `UnivariatePolynomial<_>` consider using one of the following associated functions:
      UnivariatePolynomial::<R>::new
      UnivariatePolynomial::<R>::constant
      UnivariatePolynomial::<R>::var
   --> /home/john/RustMath/rustmath-polynomials/src/univariate.rs:17:5
    |
 17 |     pub fn new(mut coeffs: Vec<R>) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 31 |     pub fn constant(c: R) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 36 |     pub fn var() -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is implemented and in scope
    = note: the following traits define an item `zero`, perhaps you need to implement one of them:
            candidate #1: `RingExt`
            candidate #2: `RingHomsetTrait`
help: there is a method `is_zero` with a similar name
    |
222 |             v: UnivariatePolynomial::is_zero(),
    |                                      +++

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:238:9
    |
237 |     pub fn degree(&self) -> usize {
    |                             ----- expected `usize` because of return type
238 |         self.u.degree()
    |         ^^^^^^^^^^^^^^^ expected `usize`, found `Option<usize>`
    |
    = note: expected type `usize`
               found enum `Option<usize>`
help: consider using `Option::expect` to unwrap the `Option<usize>` value, panicking if the value is an `Option::None`
    |
238 |         self.u.degree().expect("REASON")
    |                        +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:243:28
    |
243 |         self.u.degree() == 0 && self.v.is_zero()
    |         ---------------    ^ expected `Option<usize>`, found integer
    |         |
    |         expected because this is `Option<usize>`
    |
    = note: expected enum `Option<usize>`
               found type `{integer}`
help: try wrapping the expression in `Some`
    |
243 |         self.u.degree() == Some(0) && self.v.is_zero()
    |                            +++++ +

error[E0308]: mismatched types
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:248:28
    |
248 |         self.u.degree() <= genus && self.v.degree() < self.u.degree()
    |         ---------------    ^^^^^ expected `Option<usize>`, found `usize`
    |         |
    |         expected because this is `Option<usize>`
    |
    = note: expected enum `Option<usize>`
               found type `usize`
help: try wrapping the expression in `Some`
    |
248 |         self.u.degree() <= Some(genus) && self.v.degree() < self.u.degree()
    |                            +++++     +

error[E0599]: no method named `leading_coefficient` found for struct `UnivariatePolynomial<R>` in the current scope
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:253:27
    |
253 |         let lead = self.u.leading_coefficient();
    |                           ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `leading_coeff` with a similar name
    |
253 -         let lead = self.u.leading_coefficient();
253 +         let lead = self.u.leading_coeff();
    |

error[E0599]: no method named `negate` found for struct `UnivariatePolynomial<R>` in the current scope
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:345:29
    |
345 |             result = result.negate();
    |                             ^^^^^^
    |
help: there is a method `integrate` with a similar name
    |
345 -             result = result.negate();
345 +             result = result.integrate();
    |

error[E0599]: no method named `negate` found for reference `&UnivariatePolynomial<F>` in the current scope
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:350:19
    |
350 |             d.v().negate()
    |                   ^^^^^^
    |
help: there is a method `integrate` with a similar name
    |
350 -             d.v().negate()
350 +             d.v().integrate()
    |

error[E0599]: no function or associated item named `from_usize` found for type parameter `R` in the current scope
   --> rustmath-rings/src/power_series_pari.rs:149:49
    |
 52 | impl<R: Ring> PowerSeriesPari<R> {
    |      - function or associated item `from_usize` not found for this type parameter
...
149 |             new_coeffs.push(coeff.clone() * &R::from_usize(i));
    |                                                 ^^^^^^^^^^ function or associated item not found in `R`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `from_usize`, perhaps you need to restrict type parameter `R` with it:
    |
 52 | impl<R: Ring + FromPrimitive> PowerSeriesPari<R> {
    |              +++++++++++++++

error[E0599]: no function or associated item named `from_usize` found for type parameter `R` in the current scope
   --> rustmath-rings/src/power_series_pari.rs:159:39
    |
 52 | impl<R: Ring> PowerSeriesPari<R> {
    |      - function or associated item `from_usize` not found for this type parameter
...
159 |             if let Some(divisor) = R::from_usize(i + 1) {
    |                                       ^^^^^^^^^^ function or associated item not found in `R`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `from_usize`, perhaps you need to restrict type parameter `R` with it:
    |
 52 | impl<R: Ring + FromPrimitive> PowerSeriesPari<R> {
    |              +++++++++++++++

error[E0599]: no function or associated item named `from_usize` found for type parameter `R` in the current scope
   --> rustmath-rings/src/power_series_poly.rs:148:49
    |
 47 | impl<R: Ring> PowerSeriesPoly<R> {
    |      - function or associated item `from_usize` not found for this type parameter
...
148 |             new_coeffs.push(coeff.clone() * &R::from_usize(i));
    |                                                 ^^^^^^^^^^ function or associated item not found in `R`
    |
    = help: items from traits can only be used if the type parameter is bounded by the trait
help: the following trait defines an item `from_usize`, perhaps you need to restrict type parameter `R` with it:
    |
 47 | impl<R: Ring + FromPrimitive> PowerSeriesPoly<R> {
    |              +++++++++++++++

error[E0599]: no method named `log2` found for enum `Option<T>` in the current scope
   --> rustmath-rings/src/real_arb.rs:202:41
    |
202 |             Some(-(self.radius.to_f64().log2() as i64))
    |                                         ^^^^ method not found in `Option<f64>`
    |
note: the method `log2` exists on the type `f64`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/num/f64.rs:527:5
    |
527 |     pub fn log2(self) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^
help: use the `?` operator to extract the `f64` value, propagating an `Option::None` value to the caller
    |
202 |             Some(-(self.radius.to_f64()?.log2() as i64))
    |                                        +

error[E0308]: `match` arms have incompatible types
   --> rustmath-rings/src/real_lazy.rs:417:46
    |
415 | /         match self {
416 | |             LazyFieldElement::Integer(n) => *n as f64,
    | |                                             --------- this is found to be of type `f64`
417 | |             LazyFieldElement::Rational(r) => r.to_f64(),
    | |                                              ^^^^^^^^^^ expected `f64`, found `Option<f64>`
418 | |             LazyFieldElement::Float(f) => *f,
...   |
456 | |             LazyFieldElement::Algebraic { approx, .. } => *approx,
457 | |         }
    | |_________- `match` arms have incompatible types
    |
    = note: expected type `f64`
               found enum `Option<f64>`
help: consider using `Option::expect` to unwrap the `Option<f64>` value, panicking if the value is an `Option::None`
    |
417 |             LazyFieldElement::Rational(r) => r.to_f64().expect("REASON"),
    |                                                        +++++++++++++++++

error[E0599]: no method named `is_zero` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-rings/src/real_lazy.rs:495:48
    |
495 |             LazyFieldElement::Rational(r) => r.is_zero(),
    |                                                ^^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_zero` is implemented but not in scope; perhaps you want to import it
    |
 38 + use rustmath_core::Ring;
    |

error[E0599]: no method named `is_one` found for reference `&rustmath_rationals::Rational` in the current scope
   --> rustmath-rings/src/real_lazy.rs:505:48
    |
505 |             LazyFieldElement::Rational(r) => r.is_one(),
    |                                                ^^^^^^ method not found in `&rustmath_rationals::Rational`
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `Ring` which provides `is_one` is implemented but not in scope; perhaps you want to import it
    |
 38 + use rustmath_core::Ring;
    |

error[E0308]: mismatched types
   --> rustmath-rings/src/real_lazy.rs:564:41
    |
564 |         LazyFieldElement::from_rational(Rational::new(num.into(), den.into()))
    |         ------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Rational`, found `Result<Rational, MathError>`
    |         |
    |         arguments to this function are incorrect
    |
    = note: expected struct `rustmath_rationals::Rational`
                 found enum `std::result::Result<rustmath_rationals::Rational, MathError>`
note: associated function defined here
   --> rustmath-rings/src/real_lazy.rs:213:12
    |
213 |     pub fn from_rational(r: Rational) -> Self {
    |            ^^^^^^^^^^^^^ -----------
help: consider using `Result::expect` to unwrap the `std::result::Result<rustmath_rationals::Rational, MathError>` value, panicking if the value is a `Result::Err`
    |
564 |         LazyFieldElement::from_rational(Rational::new(num.into(), den.into()).expect("REASON"))
    |                                                                              +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-rings/src/real_lazy.rs:635:41
    |
635 |         LazyFieldElement::from_rational(Rational::new(num.into(), den.into()))
    |         ------------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Rational`, found `Result<Rational, MathError>`
    |         |
    |         arguments to this function are incorrect
    |
    = note: expected struct `rustmath_rationals::Rational`
                 found enum `std::result::Result<rustmath_rationals::Rational, MathError>`
note: associated function defined here
   --> rustmath-rings/src/real_lazy.rs:213:12
    |
213 |     pub fn from_rational(r: Rational) -> Self {
    |            ^^^^^^^^^^^^^ -----------
help: consider using `Result::expect` to unwrap the `std::result::Result<rustmath_rationals::Rational, MathError>` value, panicking if the value is a `Result::Err`
    |
635 |         LazyFieldElement::from_rational(Rational::new(num.into(), den.into()).expect("REASON"))
    |                                                                              +++++++++++++++++

error[E0282]: type annotations needed for `&mut _`
   --> rustmath-rings/src/tate_algebra.rs:263:34
    |
263 |                     .and_modify(|c| *c = c.clone() + new_coeff.clone())
    |                                  ^         ----- type must be known at this point
    |
help: consider giving this closure parameter an explicit type, where the placeholders `_` are specified
    |
263 |                     .and_modify(|c: &mut V| *c = c.clone() + new_coeff.clone())
    |                                   ++++++++

error[E0277]: `(dyn DiscretePseudoValuation<R> + 'static)` doesn't implement `Debug`
   --> rustmath-rings/src/valuation/valuation.rs:161:5
    |
158 | #[derive(Debug, Clone)]
    |          ----- in this derive macro expansion
...
161 |     pub valuation: Box<dyn DiscretePseudoValuation<R>>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `(dyn DiscretePseudoValuation<R> + 'static)`
    |
    = help: the following other types implement trait `Debug`:
              dyn Any + Send + Sync
              dyn Any + Send
              dyn Any

error[E0277]: the trait bound `dyn DiscretePseudoValuation<R>: Clone` is not satisfied
   --> rustmath-rings/src/valuation/valuation.rs:161:5
    |
158 | #[derive(Debug, Clone)]
    |                 ----- in this derive macro expansion
...
161 |     pub valuation: Box<dyn DiscretePseudoValuation<R>>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `dyn DiscretePseudoValuation<R>`
    |
    = note: required for `Box<dyn DiscretePseudoValuation<R>>` to implement `Clone`

error[E0277]: `(dyn DiscretePseudoValuation<R> + 'static)` doesn't implement `Debug`
  --> rustmath-rings/src/valuation/scaled_valuation.rs:11:5
   |
 9 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
10 | pub struct ScaledValuation<R: Ring> {
11 |     base_valuation: Box<dyn DiscretePseudoValuation<R>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `(dyn DiscretePseudoValuation<R> + 'static)`
   |
   = help: the following other types implement trait `Debug`:
             dyn Any + Send + Sync
             dyn Any + Send
             dyn Any

error[E0277]: the trait bound `dyn DiscretePseudoValuation<R>: Clone` is not satisfied
  --> rustmath-rings/src/valuation/scaled_valuation.rs:11:5
   |
 9 | #[derive(Debug, Clone)]
   |                 ----- in this derive macro expansion
10 | pub struct ScaledValuation<R: Ring> {
11 |     base_valuation: Box<dyn DiscretePseudoValuation<R>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `dyn DiscretePseudoValuation<R>`
   |
   = note: required for `Box<dyn DiscretePseudoValuation<R>>` to implement `Clone`

error[E0277]: `(dyn DiscretePseudoValuation<R> + 'static)` doesn't implement `Debug`
  --> rustmath-rings/src/valuation/gauss_valuation.rs:11:5
   |
 9 | #[derive(Debug, Clone)]
   |          ----- in this derive macro expansion
10 | pub struct GaussValuation<R: Ring> {
11 |     base_valuation: Box<dyn DiscretePseudoValuation<R>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Debug` is not implemented for `(dyn DiscretePseudoValuation<R> + 'static)`
   |
   = help: the following other types implement trait `Debug`:
             dyn Any + Send + Sync
             dyn Any + Send
             dyn Any

error[E0277]: the trait bound `dyn DiscretePseudoValuation<R>: Clone` is not satisfied
  --> rustmath-rings/src/valuation/gauss_valuation.rs:11:5
   |
 9 | #[derive(Debug, Clone)]
   |                 ----- in this derive macro expansion
10 | pub struct GaussValuation<R: Ring> {
11 |     base_valuation: Box<dyn DiscretePseudoValuation<R>>,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `dyn DiscretePseudoValuation<R>`
   |
   = note: required for `Box<dyn DiscretePseudoValuation<R>>` to implement `Clone`

error[E0369]: cannot divide `Option<f64>` by `Option<f64>`
   --> rustmath-rings/src/qqbar.rs:210:50
    |
210 |                 let val = r.numerator().to_f64() / r.denominator().to_f64();
    |                           ---------------------- ^ ------------------------ Option<f64>
    |                           |
    |                           Option<f64>
    |
note: the foreign item type `Option<f64>` doesn't implement `Div`
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:594:1
    |
594 | pub enum Option<T> {
    | ^^^^^^^^^^^^^^^^^^ not implement `Div`

error[E0034]: multiple applicable items in scope
   --> rustmath-rings/src/qqbar.rs:580:14
    |
580 |         self.to_f64().unwrap_or(0.0)
    |              ^^^^^^ multiple `to_f64` found
    |
note: candidate #1 is defined in an impl of the trait `ToF64` for the type `BigInt`
   --> rustmath-rings/src/qqbar.rs:578:5
    |
578 |     fn to_f64(&self) -> f64 {
    |     ^^^^^^^^^^^^^^^^^^^^^^^
    = note: candidate #2 is defined in an impl of the trait `ToPrimitive` for the type `BigInt`
help: disambiguate the method for candidate #1
    |
580 -         self.to_f64().unwrap_or(0.0)
580 +         ToF64::to_f64(&self).unwrap_or(0.0)
    |
help: disambiguate the method for candidate #2
    |
580 -         self.to_f64().unwrap_or(0.0)
580 +         ToPrimitive::to_f64(&self).unwrap_or(0.0)
    |

error[E0277]: the trait bound `NumberFieldError: Clone` is not satisfied
   --> rustmath-rings/src/number_field/morphisms.rs:124:30
    |
 97 | #[derive(Debug, Clone, Error, PartialEq)]
    |                 ----- in this derive macro expansion
...
124 |     NumberFieldError(#[from] NumberFieldError),
    |                              ^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `NumberFieldError`

error[E0369]: binary operation `==` cannot be applied to type `&NumberFieldError`
   --> rustmath-rings/src/number_field/morphisms.rs:124:30
    |
 97 | #[derive(Debug, Clone, Error, PartialEq)]
    |                               --------- in this derive macro expansion
...
124 |     NumberFieldError(#[from] NumberFieldError),
    |                              ^^^^^^^^^^^^^^^^
    |
note: the foreign item type `NumberFieldError` doesn't implement `PartialEq`
   --> /home/john/RustMath/rustmath-numberfields/src/lib.rs:32:1
    |
 32 | pub enum NumberFieldError {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ not implement `PartialEq`

error[E0282]: type annotations needed for `Vec<_>`
   --> rustmath-rings/src/number_field/morphisms.rs:224:13
    |
224 |         let mut embeddings = Vec::with_capacity(degree);
    |             ^^^^^^^^^^^^^^   -------------------------- type must be known at this point
    |
help: consider giving `embeddings` an explicit type, where the type for type parameter `T` is specified
    |
224 |         let mut embeddings: Vec<T> = Vec::with_capacity(degree);
    |                           ++++++++

error[E0308]: mismatched types
   --> rustmath-rings/src/number_field/order.rs:330:25
    |
330 |                 n = n / &p;
    |                     -   ^^ expected `Integer`, found `&Integer`
    |                     |
    |                     expected because this is `rustmath_integers::Integer`
    |
help: consider removing the borrow
    |
330 -                 n = n / &p;
330 +                 n = n / p;
    |

error[E0277]: the trait bound `rustmath_rationals::Rational: From<rustmath_integers::Integer>` is not satisfied
   --> rustmath-rings/src/number_field/order.rs:416:34
    |
416 |             let rational_coeff = Rational::from(coeff.clone());
    |                                  ^^^^^^^^ the trait `From<rustmath_integers::Integer>` is not implemented for `rustmath_rationals::Rational`
    |
    = help: the following other types implement trait `From<T>`:
              `rustmath_rationals::Rational` implements `From<SageRational>`
              `rustmath_rationals::Rational` implements `From<i32>`
              `rustmath_rationals::Rational` implements `From<i64>`

error[E0308]: mismatched types
   --> rustmath-rings/src/number_field/order.rs:432:9
    |
427 |     pub fn norm(&self) -> Integer {
    |                           ------- expected `rustmath_integers::Integer` because of return type
...
432 |         norm_rational.numerator()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Integer`, found `&Integer`
    |
help: consider using clone here
    |
432 |         norm_rational.numerator().clone()
    |                                  ++++++++

error[E0308]: mismatched types
   --> rustmath-rings/src/number_field/order.rs:441:9
    |
436 |     pub fn trace(&self) -> Integer {
    |                            ------- expected `rustmath_integers::Integer` because of return type
...
441 |         trace_rational.numerator()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Integer`, found `&Integer`
    |
help: consider using clone here
    |
441 |         trace_rational.numerator().clone()
    |                                   ++++++++

error[E0308]: mismatched types
   --> rustmath-rings/src/number_field/order.rs:566:16
    |
566 |         if n % Integer::from_i64(2) == Integer::zero() {
    |                ^^^^^^^^^^^^^^^^^^^^ expected `&Integer`, found `Integer`
    |
help: consider dereferencing the borrow
    |
566 |         if *n % Integer::from_i64(2) == Integer::zero() {
    |            +

error[E0599]: no method named `to_i64` found for reference `&rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/number_field/s_unit_solver.rs:232:36
    |
232 |     let d = d_rational.numerator().to_i64()
    |                                    ^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `NumericConversion` which provides `to_i64` is implemented but not in scope; perhaps you want to import it
    |
 76 + use rustmath_core::NumericConversion;
    |
help: there is a method `to_f64` with a similar name
    |
232 -     let d = d_rational.numerator().to_i64()
232 +     let d = d_rational.numerator().to_f64()
    |

error[E0624]: method `signature` is private
   --> rustmath-rings/src/number_field/s_unit_solver.rs:308:26
    |
308 |     let (r1, r2) = field.signature();
    |                          ^^^^^^^^^ private method
    |
   ::: /home/john/RustMath/rustmath-numberfields/src/lib.rs:455:5
    |
455 |     fn signature(&self) -> (usize, usize) {
    |     ------------------------------------- private method defined here

error[E0599]: no method named `is_prime` found for reference `&rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/number_field/s_unit_solver.rs:412:15
    |
412 |         if !p.is_prime() {
    |               ^^^^^^^^
    |
    = help: items from traits can only be used if the trait is in scope
help: trait `SageInteger` which provides `is_prime` is implemented but not in scope; perhaps you want to import it
    |
 76 + use rustmath_integers::SageInteger;
    |
help: there is a method `is_prime_power` with a similar name
    |
412 |         if !p.is_prime_power() {
    |                       ++++++

error[E0689]: can't call method `max` on ambiguous numeric type `{float}`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:582:31
    |
582 |         max_coeff = max_coeff.max(c_f64.abs());
    |                               ^^^
    |
help: you must specify a type for this binding, like `f32`
    |
578 |     let mut max_coeff: f32 = 0.0;
    |                      +++++

error[E0689]: can't call method `ln` on ambiguous numeric type `{float}`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:585:15
    |
585 |     max_coeff.ln().max(0.0)
    |               ^^
    |
help: you must specify a type for this binding, like `f32`
    |
578 |     let mut max_coeff: f32 = 0.0;
    |                      +++++

error[E0599]: no function or associated item named `from_i64` found for struct `rustmath_integers::Integer` in the current scope
   --> rustmath-rings/src/number_field/s_unit_solver.rs:629:26
    |
629 |         let p = Integer::from_i64(p_val);
    |                          ^^^^^^^^ function or associated item not found in `rustmath_integers::Integer`
    |
note: if you're trying to build a new `rustmath_integers::Integer`, consider using `rustmath_integers::Integer::new` which returns `rustmath_integers::Integer`
   --> /home/john/RustMath/rustmath-integers/src/integer.rs:19:5
    |
 19 |     pub fn new(value: BigInt) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = help: items from traits can only be used if the trait is in scope
help: trait `NumericConversion` which provides `from_i64` is implemented but not in scope; perhaps you want to import it
    |
 76 + use rustmath_core::NumericConversion;
    |
help: there is an associated function `from_u64` with a similar name
    |
629 -         let p = Integer::from_i64(p_val);
629 +         let p = Integer::from_u64(p_val);
    |

warning: unused import: `Ring`
  --> rustmath-rings/src/abc.rs:24:21
   |
24 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/asymptotic.rs:44:21
   |
44 | use rustmath_core::{Ring, CommutativeRing};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/differential.rs:40:21
   |
40 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/divisor.rs:43:21
   |
43 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field.rs:12:21
   |
12 | use rustmath_core::{Ring, IntegralDomain, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field_element.rs:33:21
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field, EuclideanDomain};
   |                     ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field_element.rs:33:43
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field, EuclideanDomain};
   |                                           ^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:27
   |
37 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element.rs:31:21
   |
31 | use rustmath_core::{Ring, Field, IntegralDomain};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element_polymod.rs:31:21
   |
31 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element_rational.rs:27:21
   |
27 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Hasher`
  --> rustmath-rings/src/growth_group.rs:51:23
   |
51 | use std::hash::{Hash, Hasher};
   |                       ^^^^^^

warning: unused import: `EuclideanDomain`
  --> rustmath-rings/src/number_field/order.rs:52:43
   |
52 | use rustmath_core::{Ring, IntegralDomain, EuclideanDomain, NumericConversion};
   |                                           ^^^^^^^^^^^^^^^

warning: unused import: `GrowthGroup`
  --> rustmath-rings/src/growth_group_cartesian.rs:35:20
   |
35 |     GrowthElement, GrowthGroup, MonomialGrowthElement, MonomialGrowthGroup,
   |                    ^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/number_field/morphisms.rs:85:38
   |
85 | use rustmath_core::{CommutativeRing, Field, Ring};
   |                                      ^^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/residue_field.rs:24:27
   |
24 | use rustmath_core::{Ring, Field, IntegralDomain, CommutativeRing};
   |                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/ideal_polymod.rs:48:28
   |
48 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/picard_group.rs:57:28
   |
57 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/puiseux_series_ring.rs:40:28
   |
40 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:34:28
   |
34 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/semirings/non_negative_integer_semiring.rs:40:5
   |
40 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/tate_algebra.rs:37:28
   |
37 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused variable: `place`
   --> rustmath-rings/src/differential.rs:122:29
    |
122 |     pub fn valuation(&self, place: &str) -> i64 {
    |                             ^^^^^ help: if this is intentional, prefix it with an underscore: `_place`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `function`
   --> rustmath-rings/src/divisor.rs:219:30
    |
219 |     pub fn principal_divisor(function: String) -> Self {
    |                              ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_function`

warning: unused variable: `x`
   --> rustmath-rings/src/fraction_field.rs:288:53
    |
288 | pub fn is_fraction_field_element<R: IntegralDomain>(x: &FractionFieldElement<R>) -> bool {
    |                                                     ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> rustmath-rings/src/fraction_field_element.rs:308:51
    |
308 | pub fn is_FractionFieldElement<R: IntegralDomain>(x: &FractionFieldElement<R>) -> bool {
    |                                                   ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> rustmath-rings/src/function_field_element.rs:272:42
    |
272 | pub fn is_FunctionFieldElement<F: Field>(x: &FunctionFieldElement<F>) -> bool {
    |                                          ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `num_val`
   --> rustmath-rings/src/function_field_element_rational.rs:154:13
    |
154 |         let num_val = self.eval_poly(&self.numerator, point);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_val`

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/homset.rs:224:5
    |
224 |     std::any::TypeId::of::<T>() == std::any::TypeId::of::<RingHomsetGeneric<i32, i32>>()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |     |
    |     the parameter type `T` must be valid for the static lifetime...
    |     ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
221 | pub fn is_ring_homset<T: 'static>() -> bool {
    |                        +++++++++

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/homset.rs:225:12
    |
225 |         || std::any::TypeId::of::<T>() == std::any::TypeId::of::<RingHomsetQuoRing<i32, i32>>()
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |            |
    |            the parameter type `T` must be valid for the static lifetime...
    |            ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
221 | pub fn is_ring_homset<T: 'static>() -> bool {
    |                        +++++++++

warning: unused variable: `value`
   --> rustmath-rings/src/infinity.rs:332:23
    |
332 | pub fn is_infinite<T>(value: &T) -> bool {
    |                       ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/infinity.rs:334:5
    |
334 |     std::any::TypeId::of::<T>() == std::any::TypeId::of::<Infinity>()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |     |
    |     the parameter type `T` must be valid for the static lifetime...
    |     ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
332 | pub fn is_infinite<T: 'static>(value: &T) -> bool {
    |                     +++++++++

warning: unused variable: `prev`
    --> rustmath-rings/src/padics/extension.rs:1047:17
     |
1047 |             let prev = automorphisms.last().unwrap();
     |                 ^^^^ help: if this is intentional, prefix it with an underscore: `_prev`

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/quotient_ring.rs:342:5
    |
342 |     std::any::TypeId::of::<T>() == std::any::TypeId::of::<QuotientRingGeneric<i32>>()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |     |
    |     the parameter type `T` must be valid for the static lifetime...
    |     ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
340 | pub fn is_quotient_ring<T: 'static>() -> bool {
    |                          +++++++++

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/quotient_ring.rs:343:12
    |
343 |         || std::any::TypeId::of::<T>() == std::any::TypeId::of::<QuotientRingNc<i32>>()
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |            |
    |            the parameter type `T` must be valid for the static lifetime...
    |            ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
340 | pub fn is_quotient_ring<T: 'static>() -> bool {
    |                          +++++++++

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/ring.rs:200:5
    |
200 |     std::any::TypeId::of::<T>() == std::any::TypeId::of::<i32>()
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |     |
    |     the parameter type `T` must be valid for the static lifetime...
    |     ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
198 | pub fn is_ring<T: 'static>() -> bool {
    |                 +++++++++

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/ring.rs:201:12
    |
201 |         || std::any::TypeId::of::<T>() == std::any::TypeId::of::<i64>()
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |            |
    |            the parameter type `T` must be valid for the static lifetime...
    |            ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
198 | pub fn is_ring<T: 'static>() -> bool {
    |                 +++++++++

error[E0310]: the parameter type `T` may not live long enough
   --> rustmath-rings/src/ring.rs:202:12
    |
202 |         || std::any::TypeId::of::<T>() == std::any::TypeId::of::<f64>()
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |            |
    |            the parameter type `T` must be valid for the static lifetime...
    |            ...so that the type `T` will meet its required lifetime bounds
    |
help: consider adding an explicit lifetime bound
    |
198 | pub fn is_ring<T: 'static>() -> bool {
    |                 +++++++++

warning: unused variable: `ring2`
   --> rustmath-rings/src/ring_extension.rs:312:34
    |
312 | pub fn common_base<R>(ring1: &R, ring2: &R) -> Result<R, RingExtensionError>
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_ring2`

warning: unused variable: `sqrt_abs`
   --> rustmath-rings/src/universal_cyclotomic_field.rs:278:13
    |
278 |         let sqrt_abs = ucf_sqrt_int(-n)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sqrt_abs`

warning: unused variable: `element`
   --> rustmath-rings/src/function_field/valuation.rs:241:25
    |
241 |     fn valuation(&self, element: &str) -> i64 {
    |                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: unused variable: `element`
   --> rustmath-rings/src/function_field/valuation.rs:352:25
    |
352 |     fn valuation(&self, element: &str) -> i64 {
    |                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: unused variable: `g`
   --> rustmath-rings/src/function_field/order_polymod.rs:336:13
    |
336 |         let g = self.genus();
    |             ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `d2`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:326:47
    |
326 |     pub fn add(&self, d1: &MumfordDivisor<F>, d2: &MumfordDivisor<F>) -> MumfordDivisor<F> {
    |                                               ^^ help: if this is intentional, prefix it with an underscore: `_d2`

warning: unused variable: `d`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:384:28
    |
384 |     pub fn contains(&self, d: &MumfordDivisor<F>) -> bool {
    |                            ^ help: if this is intentional, prefix it with an underscore: `_d`

error[E0507]: cannot move out of `*sum` which is behind a mutable reference
   --> rustmath-rings/src/function_field/theta_functions.rs:340:20
    |
340 |             *sum = *sum + term;
    |                    ^^^^-------
    |                    |
    |                    `*sum` moved due to usage in operator
    |                    move occurs because `*sum` has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
note: calling this operator moves the left-hand side
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:92:12
    |
 92 |     fn add(self, rhs: Rhs) -> Self::Output;
    |            ^^^^
help: consider cloning the value if the performance cost is acceptable
    |
340 -             *sum = *sum + term;
340 +             *sum = sum.clone() + term;
    |

error[E0508]: cannot move out of type `[rustmath_complex::Complex]`, a non-copy slice
   --> rustmath-rings/src/function_field/theta_functions.rs:372:27
    |
372 |             z_plus_b[i] = z[i] + Complex::new(b[i], 0.0);
    |                           ^^^^
    |                           |
    |                           cannot move out of here
    |                           move occurs because `z[_]` has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
help: consider cloning the value if the performance cost is acceptable
    |
372 |             z_plus_b[i] = z[i].clone() + Complex::new(b[i], 0.0);
    |                               ++++++++

error[E0507]: cannot move out of index of `Vec<rustmath_complex::Complex>`
   --> rustmath-rings/src/function_field/theta_functions.rs:380:45
    |
380 |                     quad_form = quad_form + n_plus_a[i] * *omega_ij * n_plus_a[j];
    |                                             ^^^^^^^^^^^------------
    |                                             |
    |                                             value moved due to usage in operator
    |                                             move occurs because value has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
note: calling this operator moves the left-hand side
   --> /home/john/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/arith.rs:339:12
    |
339 |     fn mul(self, rhs: Rhs) -> Self::Output;
    |            ^^^^
help: consider cloning the value if the performance cost is acceptable
    |
380 |                     quad_form = quad_form + n_plus_a[i].clone() * *omega_ij * n_plus_a[j];
    |                                                        ++++++++

error[E0507]: cannot move out of `*omega_ij` which is behind a shared reference
   --> rustmath-rings/src/function_field/theta_functions.rs:380:59
    |
380 |                     quad_form = quad_form + n_plus_a[i] * *omega_ij * n_plus_a[j];
    |                                                           ^^^^^^^^^ move occurs because `*omega_ij` has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
help: consider cloning the value if the performance cost is acceptable
    |
380 -                     quad_form = quad_form + n_plus_a[i] * *omega_ij * n_plus_a[j];
380 +                     quad_form = quad_form + n_plus_a[i] * omega_ij.clone() * n_plus_a[j];
    |

error[E0507]: cannot move out of index of `Vec<rustmath_complex::Complex>`
   --> rustmath-rings/src/function_field/theta_functions.rs:380:71
    |
380 |                     quad_form = quad_form + n_plus_a[i] * *omega_ij * n_plus_a[j];
    |                                                                       ^^^^^^^^^^^ move occurs because value has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
help: consider cloning the value if the performance cost is acceptable
    |
380 |                     quad_form = quad_form + n_plus_a[i] * *omega_ij * n_plus_a[j].clone();
    |                                                                                  ++++++++

error[E0507]: cannot move out of index of `Vec<rustmath_complex::Complex>`
   --> rustmath-rings/src/function_field/theta_functions.rs:388:39
    |
388 |             inner_prod = inner_prod + n_plus_a[i] * z_plus_b[i];
    |                                       ^^^^^^^^^^^ move occurs because value has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
help: consider cloning the value if the performance cost is acceptable
    |
388 |             inner_prod = inner_prod + n_plus_a[i].clone() * z_plus_b[i];
    |                                                  ++++++++

error[E0507]: cannot move out of index of `Vec<rustmath_complex::Complex>`
   --> rustmath-rings/src/function_field/theta_functions.rs:388:53
    |
388 |             inner_prod = inner_prod + n_plus_a[i] * z_plus_b[i];
    |                                                     ^^^^^^^^^^^ move occurs because value has type `rustmath_complex::Complex`, which does not implement the `Copy` trait
    |
help: consider cloning the value if the performance cost is acceptable
    |
388 |             inner_prod = inner_prod + n_plus_a[i] * z_plus_b[i].clone();
    |                                                                ++++++++

warning: unused variable: `a`
   --> rustmath-rings/src/invariants/reconstruction.rs:103:9
    |
103 |     let a = R::from(1);
    |         ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `b`
   --> rustmath-rings/src/invariants/reconstruction.rs:104:9
    |
104 |     let b = R::from(0);
    |         ^ help: if this is intentional, prefix it with an underscore: `_b`

error[E0515]: cannot return reference to temporary value
  --> rustmath-rings/src/power_series_pari.rs:95:13
   |
95 |             &R::zero()
   |             ^---------
   |             ||
   |             |temporary value created here
   |             returns a reference to data owned by the current function

error[E0515]: cannot return reference to temporary value
  --> rustmath-rings/src/power_series_poly.rs:77:13
   |
77 |             &R::zero()
   |             ^---------
   |             ||
   |             |temporary value created here
   |             returns a reference to data owned by the current function

warning: unused variable: `element`
   --> rustmath-rings/src/power_series_poly.rs:274:23
    |
274 |     pub fn act(&self, element: &R, series: &PowerSeriesPoly<R>) -> PowerSeriesPoly<R> {
    |                       ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: variable does not need to be mutable
  --> rustmath-rings/src/puiseux_series_ring_element.rs:77:9
   |
77 |         mut coefficients: Vec<F>,
   |         ----^^^^^^^^^^^^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0596]: cannot borrow `coefficients` as mutable, as it is not declared as mutable
  --> rustmath-rings/src/puiseux_series_ring_element.rs:91:9
   |
91 |         coefficients.truncate(precision);
   |         ^^^^^^^^^^^^ cannot borrow as mutable
   |
help: consider changing this to be mutable
   |
87 |         let (valuation, ramification, mut coefficients) =
   |                                       +++

error[E0515]: cannot return reference to temporary value
   --> rustmath-rings/src/puiseux_series_ring_element.rs:136:13
    |
136 |             &F::zero()
    |             ^---------
    |             ||
    |             |temporary value created here
    |             returns a reference to data owned by the current function

error[E0515]: cannot return reference to temporary value
   --> rustmath-rings/src/puiseux_series_ring_element.rs:163:13
    |
163 |             &F::zero()
    |             ^---------
    |             ||
    |             |temporary value created here
    |             returns a reference to data owned by the current function

warning: unused variable: `other_exp`
   --> rustmath-rings/src/puiseux_series_ring_element.rs:222:24
    |
222 |         let (self_exp, other_exp) = self.to_common_ramification(&PuiseuxSeries::new(
    |                        ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_exp`

warning: unused variable: `domain`
   --> rustmath-rings/src/number_field/morphisms.rs:203:9
    |
203 |         domain: NumberField,
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_domain`

warning: unused variable: `root_index`
   --> rustmath-rings/src/number_field/morphisms.rs:204:9
    |
204 |         root_index: usize,
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_root_index`

warning: unused variable: `domain`
   --> rustmath-rings/src/number_field/morphisms.rs:236:28
    |
236 |     pub fn real_embeddings(domain: &NumberField) -> Result<Vec<Self>> {
    |                            ^^^^^^ help: if this is intentional, prefix it with an underscore: `_domain`

warning: unused variable: `domain`
   --> rustmath-rings/src/number_field/morphisms.rs:248:31
    |
248 |     pub fn complex_embeddings(domain: &NumberField) -> Result<Vec<Self>> {
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_domain`

warning: unused variable: `discriminant`
   --> rustmath-rings/src/number_field/morphisms.rs:479:9
    |
479 |     let discriminant = field.discriminant();
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_discriminant`

warning: unused variable: `field`
   --> rustmath-rings/src/number_field/morphisms.rs:504:28
    |
504 | pub fn is_normal_extension(field: &NumberField) -> Result<bool> {
    |                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_field`

warning: unused variable: `field`
   --> rustmath-rings/src/number_field/morphisms.rs:517:31
    |
517 | pub fn is_separable_extension(field: &NumberField) -> bool {
    |                               ^^^^^ help: if this is intentional, prefix it with an underscore: `_field`

warning: unused variable: `min_poly`
   --> rustmath-rings/src/number_field/order.rs:309:13
    |
309 |         let min_poly = self.field.minimal_polynomial();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_poly`

warning: unused variable: `p`
   --> rustmath-rings/src/number_field/order.rs:307:34
    |
307 |     fn prime_ideals_above(&self, p: Integer) -> Result<Vec<(OrderIdeal, usize)>, OrderError> {
    |                                  ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `elem`
   --> rustmath-rings/src/number_field/order.rs:364:28
    |
364 |     pub fn contains(&self, elem: &NumberFieldElement) -> bool {
    |                            ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`

warning: unused variable: `embedding2`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:363:9
    |
363 |     let embedding2 = a - b * d.sqrt();
    |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_embedding2`

warning: unused variable: `s_unit_group`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:525:5
    |
525 |     s_unit_group: &SUnitGroup,
    |     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_s_unit_group`

warning: unused variable: `coefficients`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:526:5
    |
526 |     coefficients: &[NumberFieldElement],
    |     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_coefficients`

warning: unused variable: `rhs`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:527:5
    |
527 |     rhs: &NumberFieldElement,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_rhs`

warning: unused variable: `s_unit_group`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:543:5
    |
543 |     s_unit_group: &SUnitGroup,
    |     ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_s_unit_group`

warning: unused variable: `rhs`
   --> rustmath-rings/src/number_field/s_unit_solver.rs:545:5
    |
545 |     rhs: &NumberFieldElement,
    |     ^^^ help: if this is intentional, prefix it with an underscore: `_rhs`

Some errors have detailed explanations: E0034, E0038, E0107, E0252, E0277, E0282, E0308, E0310, E0369...
For more information about an error, try `rustc --explain E0034`.
warning: `rustmath-rings` (lib) generated 223 warnings (13 duplicates)
error: could not compile `rustmath-rings` (lib) due to 325 previous errors; 223 warnings emitted
