warning: method `scalar_mul` is never used
   --> rustmath-matrix/src/polynomial_matrix.rs:350:8
    |
346 | trait PolynomialExt<F: Field> {
    |       ------------- method in this trait
...
350 |     fn scalar_mul(&self, scalar: &F) -> Self;
    |        ^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `discriminant`
   --> rustmath-symbolic/src/diffeq.rs:329:13
    |
329 |         let discriminant = b.clone().pow(Expr::from(2))
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_discriminant`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `var`
   --> rustmath-symbolic/src/diffeq.rs:318:9
    |
318 |         var: &Symbol,
    |         ^^^ help: if this is intentional, prefix it with an underscore: `_var`

warning: unused variable: `dm_dy`
   --> rustmath-symbolic/src/diffeq.rs:348:13
    |
348 |         let dm_dy = m.differentiate(y_var);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dm_dy`

warning: unused variable: `dn_dx`
   --> rustmath-symbolic/src/diffeq.rs:349:13
    |
349 |         let dn_dx = n.differentiate(x_var);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_dn_dx`

warning: unused variable: `degree`
   --> rustmath-symbolic/src/factor.rs:177:9
    |
177 |     let degree = degree.unwrap();
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `args`
  --> rustmath-symbolic/src/function.rs:23:26
   |
23 |     fn derivative(&self, args: &[Expr], arg_index: usize) -> Result<Expr, String> {
   |                          ^^^^ help: if this is intentional, prefix it with an underscore: `_args`

warning: unused variable: `arg_index`
  --> rustmath-symbolic/src/function.rs:23:41
   |
23 |     fn derivative(&self, args: &[Expr], arg_index: usize) -> Result<Expr, String> {
   |                                         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_arg_index`

warning: unused variable: `initial_velocity`
   --> rustmath-symbolic/src/pde.rs:257:9
    |
257 |         initial_velocity: &Expr,
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_initial_velocity`

warning: unused variable: `c2`
   --> rustmath-symbolic/src/specialfunctions/airy.rs:269:13
    |
269 |         let c2 = 0.258819403792807; // |Ai'(0)|
    |             ^^ help: if this is intentional, prefix it with an underscore: `_c2`

warning: function `expr_to_rational` is never used
    --> rustmath-symbolic/src/solve.rs:1529:4
     |
1529 | fn expr_to_rational(expr: &Expr) -> Option<Rational> {
     |    ^^^^^^^^^^^^^^^^
     |
     = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `expr_to_integer` is never used
    --> rustmath-symbolic/src/solve.rs:1556:4
     |
1556 | fn expr_to_integer(expr: &Expr) -> Option<i64> {
     |    ^^^^^^^^^^^^^^^

warning: function `try_expr_to_f64` is never used
  --> rustmath-symbolic/src/specialfunctions/other.rs:40:4
   |
40 | fn try_expr_to_f64(expr: &Expr) -> Option<f64> {
   |    ^^^^^^^^^^^^^^^

warning: variable `N` should have a snake case name
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:505:71
    |
505 | pub fn hahn_polynomial(n: &Expr, x: &Expr, alpha: &Expr, beta: &Expr, N: &Expr) -> Expr {
    |                                                                       ^ help: convert the identifier to snake case: `n`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `N` should have a snake case name
   --> rustmath-symbolic/src/specialfunctions/orthogonal_polys.rs:553:60
    |
553 | pub fn krawtchouk_polynomial(n: &Expr, x: &Expr, p: &Expr, N: &Expr) -> Expr {
    |                                                            ^ help: convert the identifier to snake case: `n`

warning: `rustmath-matrix` (lib) generated 1 warning
warning: `rustmath-symbolic` (lib) generated 14 warnings
warning: unused `#[macro_use]` import
 --> rustmath-combinatorics/src/lib.rs:6:1
  |
6 | #[macro_use]
  | ^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unnecessary parentheses around closure body
   --> rustmath-combinatorics/src/affine_permutations.rs:136:63
    |
136 |         let mut remainders: Vec<i64> = window.iter().map(|&x| ((x - 1).rem_euclid(n1))).collect();
    |                                                               ^                      ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
136 -         let mut remainders: Vec<i64> = window.iter().map(|&x| ((x - 1).rem_euclid(n1))).collect();
136 +         let mut remainders: Vec<i64> = window.iter().map(|&x| (x - 1).rem_euclid(n1)).collect();
    |

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-combinatorics/src/cluster_complex.rs:21:5
   |
21 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-combinatorics/src/cluster_complex.rs:22:24
   |
22 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `Polynomial`
  --> rustmath-combinatorics/src/cyclic_sieving.rs:29:28
   |
29 | use rustmath_polynomials::{Polynomial, UnivariatePolynomial};
   |                            ^^^^^^^^^^

warning: unused import: `crate::permutations::Permutation`
  --> rustmath-combinatorics/src/constellation.rs:37:5
   |
37 | use crate::permutations::Permutation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-combinatorics/src/constellation.rs:38:24
   |
38 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-combinatorics/src/interval_posets.rs:12:33
   |
12 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `crate::partitions::Partition`
  --> rustmath-combinatorics/src/gelfand_tsetlin.rs:32:5
   |
32 | use crate::partitions::Partition;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `OrderedTreeNode`
  --> rustmath-combinatorics/src/grossman_larson.rs:26:40
   |
26 | use crate::ordered_tree::{OrderedTree, OrderedTreeNode};
   |                                        ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-combinatorics/src/grossman_larson.rs:28:5
   |
28 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
 --> rustmath-combinatorics/src/plane_partition.rs:9:5
  |
9 | use rustmath_rationals::Rational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unexpected `cfg` condition value: `random`
  --> rustmath-combinatorics/src/ranking.rs:73:11
   |
73 |     #[cfg(feature = "random")]
   |           ^^^^^^^^^^^^^^^^^^ help: remove the condition
   |
   = note: no expected values for `feature`
   = help: consider adding `random` as a feature in `Cargo.toml`
   = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
   = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `AutomaticSequence`
  --> rustmath-combinatorics/src/regular_sequences.rs:29:19
   |
29 | use crate::word::{AutomaticSequence, Morphism, Word};
   |                   ^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-combinatorics/src/regular_sequences.rs:30:5
   |
30 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-combinatorics/src/regular_sequences.rs:31:33
   |
31 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `HashMap`
 --> rustmath-combinatorics/src/set_system.rs:7:24
  |
7 | use std::collections::{HashMap, HashSet};
  |                        ^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-combinatorics/src/triangles_fhm.rs:13:5
   |
13 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/alternating_sign_matrix.rs:12:5
   |
12 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/fully_packed_loop.rs:506:9
    |
506 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/fully_packed_loop.rs:526:9
    |
526 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/key_polynomial.rs:23:5
   |
23 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/lib.rs:345:5
    |
345 | use rustmath_core::Ring;
    |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/hall_polynomial.rs:42:5
   |
42 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-combinatorics/src/integer_vectors.rs:19:40
   |
19 | use rustmath_core::{NumericConversion, Ring};
   |                                        ^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/integer_matrices.rs:20:5
   |
20 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/kazhdan_lusztig.rs:18:5
   |
18 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/triangles_fhm.rs:10:5
   |
10 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/tiling.rs:19:5
   |
19 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-combinatorics/src/symmetric_group_representations.rs:15:21
   |
15 | use rustmath_core::{Ring, NumericConversion};
   |                     ^^^^

warning: unused import: `rustmath_core::Ring`
 --> rustmath-combinatorics/src/plane_partition.rs:7:5
  |
7 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/q_analogue.rs:31:5
   |
31 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/t_sequences.rs:38:5
   |
38 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-combinatorics/src/six_vertex_model.rs:39:5
   |
39 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/set_partition.rs:325:9
    |
325 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
   --> rustmath-combinatorics/src/set_partition.rs:369:9
    |
369 |     use rustmath_core::Ring;
    |         ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `num_orbits_x`
   --> rustmath-combinatorics/src/bijectionist.rs:304:14
    |
304 |         let (num_orbits_x, fixed_x) = burnside_count(action_x, elements_x, group);
    |              ^^^^^^^^^^^^
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default
help: if this is intentional, prefix it with an underscore
    |
304 |         let (_num_orbits_x, fixed_x) = burnside_count(action_x, elements_x, group);
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
304 -         let (num_orbits_x, fixed_x) = burnside_count(action_x, elements_x, group);
304 +         let (permutation_simd::inverse_avx2::SIMD_WIDTH, fixed_x) = burnside_count(action_x, elements_x, group);
    |

warning: unused variable: `num_orbits_y`
   --> rustmath-combinatorics/src/bijectionist.rs:308:14
    |
308 |         let (num_orbits_y, fixed_y) = burnside_count(action_y, elements_y, group);
    |              ^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
308 |         let (_num_orbits_y, fixed_y) = burnside_count(action_y, elements_y, group);
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
308 -         let (num_orbits_y, fixed_y) = burnside_count(action_y, elements_y, group);
308 +         let (permutation_simd::inverse_avx2::SIMD_WIDTH, fixed_y) = burnside_count(action_y, elements_y, group);
    |

warning: unused variable: `n`
   --> rustmath-combinatorics/src/cluster_complex.rs:413:34
    |
413 |             ClusterCartanType::A(n) => {
    |                                  ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `heights`
   --> rustmath-combinatorics/src/dyck_word.rs:389:13
    |
389 |         let heights = self.heights();
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_heights`

warning: unused variable: `reflected_height`
   --> rustmath-combinatorics/src/dyck_word.rs:403:17
    |
403 |             let reflected_height = 2 * nu_at_next - bounce[i + 1];
    |                 ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_reflected_height`

warning: unused variable: `lower`
   --> rustmath-combinatorics/src/interval_posets.rs:291:13
    |
291 |         let lower: Vec<usize> = elements
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_lower`

warning: unused variable: `upper`
   --> rustmath-combinatorics/src/interval_posets.rs:300:13
    |
300 |         let upper: Vec<usize> = elements
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_upper`

warning: unused variable: `shape`
   --> rustmath-combinatorics/src/growth_diagram.rs:110:13
    |
110 |         let shape = &self.grid[self.n][self.n];
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_shape`

warning: unused variable: `binom`
   --> rustmath-combinatorics/src/hall_polynomial.rs:404:13
    |
404 |         let binom = q_binomial(l2 as u32, (l2 - m2) as u32);
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_binom`

warning: unused variable: `u_len`
  --> rustmath-combinatorics/src/kazhdan_lusztig.rs:46:9
   |
46 |     let u_len = length(u);
   |         ^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
46 |     let _u_len = length(u);
   |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
46 -     let u_len = length(u);
46 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = length(u);
   |

warning: unused variable: `n`
  --> rustmath-combinatorics/src/kazhdan_lusztig.rs:40:64
   |
40 | pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, n: usize) -> Vec<Permutation> {
   |                                                                ^
   |
help: if this is intentional, prefix it with an underscore
   |
40 | pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, _n: usize) -> Vec<Permutation> {
   |                                                                +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
40 - pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, n: usize) -> Vec<Permutation> {
40 + pub fn bruhat_covers_between(u: &Permutation, v: &Permutation, permutation_simd::inverse_avx2::SIMD_WIDTH: usize) -> Vec<Permutation> {
   |

warning: unused variable: `u_len`
   --> rustmath-combinatorics/src/kazhdan_lusztig.rs:250:9
    |
250 |     let u_len = length(u);
    |         ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
250 |     let _u_len = length(u);
    |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
250 -     let u_len = length(u);
250 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = length(u);
    |

warning: unused variable: `v_len`
   --> rustmath-combinatorics/src/kazhdan_lusztig.rs:251:9
    |
251 |     let v_len = length(v);
    |         ^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
251 |     let _v_len = length(v);
    |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
251 -     let v_len = length(v);
251 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = length(v);
    |

warning: unused variable: `interval`
   --> rustmath-combinatorics/src/kazhdan_lusztig.rs:278:9
    |
278 |     let interval = bruhat_interval(u, v);
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_interval`

warning: variable does not need to be mutable
  --> rustmath-combinatorics/src/ordered_tree.rs:87:13
   |
87 |         let mut tree = OrderedTree {
   |             ----^^^^
   |             |
   |             help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `n`
   --> rustmath-combinatorics/src/partitions.rs:162:13
    |
162 |         let n = self.sum();
    |             ^
    |
help: if this is intentional, prefix it with an underscore
    |
162 |         let _n = self.sum();
    |             +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
162 -         let n = self.sum();
162 +         let permutation_simd::inverse_avx2::SIMD_WIDTH = self.sum();
    |

warning: unused variable: `expected_beta`
   --> rustmath-combinatorics/src/partitions.rs:238:17
    |
238 |             let expected_beta = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
    |                 ^^^^^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
238 |             let _expected_beta = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
    |                 +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
238 -             let expected_beta = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
238 +             let permutation_simd::inverse_avx2::SIMD_WIDTH = (i * t + runner + t - i % t) % t + (i / t) * t + runner;
    |

warning: unused variable: `beta_i`
   --> rustmath-combinatorics/src/partitions.rs:247:17
    |
247 |             let beta_i = (i / t) * t + runner + t * (pos / abacus.len());
    |                 ^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
247 |             let _beta_i = (i / t) * t + runner + t * (pos / abacus.len());
    |                 +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
247 -             let beta_i = (i / t) * t + runner + t * (pos / abacus.len());
247 +             let permutation_simd::inverse_avx2::SIMD_WIDTH = (i / t) * t + runner + t * (pos / abacus.len());
    |

warning: unused variable: `j`
   --> rustmath-combinatorics/src/partitions.rs:318:22
    |
318 |                 for (j, &hook) in row.iter().enumerate() {
    |                      ^
    |
help: if this is intentional, prefix it with an underscore
    |
318 |                 for (_j, &hook) in row.iter().enumerate() {
    |                      +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
318 -                 for (j, &hook) in row.iter().enumerate() {
318 +                 for (permutation_simd::inverse_avx2::SIMD_WIDTH, &hook) in row.iter().enumerate() {
    |

warning: unused variable: `core_beads`
   --> rustmath-combinatorics/src/partitions.rs:403:17
    |
403 |             let core_beads = &core_abacus[runner_idx];
    |                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_core_beads`

warning: unused variable: `gap`
   --> rustmath-combinatorics/src/partitions.rs:430:17
    |
430 |             for gap in gaps {
    |                 ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
430 |             for _gap in gaps {
    |                 +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
430 -             for gap in gaps {
430 +             for permutation_simd::inverse_avx2::SIMD_WIDTH in gaps {
    |

warning: variable does not need to be mutable
   --> rustmath-combinatorics/src/partitions.rs:560:17
    |
560 |             let mut new_parts = self.parts.clone();
    |                 ----^^^^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `remainder`
  --> rustmath-combinatorics/src/permutation_simd.rs:61:9
   |
61 |     let remainder = n % SIMD_WIDTH;
   |         ^^^^^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
61 |     let _remainder = n % SIMD_WIDTH;
   |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
61 -     let remainder = n % SIMD_WIDTH;
61 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = n % SIMD_WIDTH;
   |

warning: unused variable: `remainder`
   --> rustmath-combinatorics/src/permutation_simd.rs:134:9
    |
134 |     let remainder = n % SIMD_WIDTH;
    |         ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
134 |     let _remainder = n % SIMD_WIDTH;
    |         +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
134 -     let remainder = n % SIMD_WIDTH;
134 +     let permutation_simd::inverse_avx2::SIMD_WIDTH = n % SIMD_WIDTH;
    |

warning: unused variable: `i`
   --> rustmath-combinatorics/src/q_analogue.rs:314:14
    |
314 |         for (i, c) in q.coefficients().iter().enumerate() {
    |              ^
    |
help: if this is intentional, prefix it with an underscore
    |
314 |         for (_i, c) in q.coefficients().iter().enumerate() {
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
314 -         for (i, c) in q.coefficients().iter().enumerate() {
314 +         for (permutation_simd::inverse_avx2::SIMD_WIDTH, c) in q.coefficients().iter().enumerate() {
    |

warning: unused variable: `left_size`
   --> rustmath-combinatorics/src/ranking.rs:450:60
    |
450 | fn combine_tree_ranks(left_rank: usize, right_rank: usize, left_size: usize, right_size: usize) -> usize {
    |                                                            ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
450 | fn combine_tree_ranks(left_rank: usize, right_rank: usize, _left_size: usize, right_size: usize) -> usize {
    |                                                            +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
450 - fn combine_tree_ranks(left_rank: usize, right_rank: usize, left_size: usize, right_size: usize) -> usize {
450 + fn combine_tree_ranks(left_rank: usize, right_rank: usize, permutation_simd::inverse_avx2::SIMD_WIDTH: usize, right_size: usize) -> usize {
    |

warning: unused variable: `i`
   --> rustmath-combinatorics/src/t_sequences.rs:594:14
    |
594 |         for (i, c) in q.coefficients().iter().enumerate() {
    |              ^
    |
help: if this is intentional, prefix it with an underscore
    |
594 |         for (_i, c) in q.coefficients().iter().enumerate() {
    |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
594 -         for (i, c) in q.coefficients().iter().enumerate() {
594 +         for (permutation_simd::inverse_avx2::SIMD_WIDTH, c) in q.coefficients().iter().enumerate() {
    |

warning: unused variable: `cells`
   --> rustmath-combinatorics/src/ribbon_tableau.rs:287:9
    |
287 |     let cells = shape.cells();
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_cells`

warning: unused variable: `i`
  --> rustmath-combinatorics/src/restricted_growth.rs:57:14
   |
57 |         for (i, &value) in sequence.iter().enumerate().skip(1) {
   |              ^
   |
help: if this is intentional, prefix it with an underscore
   |
57 |         for (_i, &value) in sequence.iter().enumerate().skip(1) {
   |              +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
   |
57 -         for (i, &value) in sequence.iter().enumerate().skip(1) {
57 +         for (permutation_simd::inverse_avx2::SIMD_WIDTH, &value) in sequence.iter().enumerate().skip(1) {
   |

warning: unused variable: `input`
   --> rustmath-combinatorics/src/similarity_class_type.rs:515:22
    |
515 | pub fn input_parsing(input: &str) -> Result<Vec<(usize, Partition)>, String> {
    |                      ^^^^^ help: if this is intentional, prefix it with an underscore: `_input`

warning: unused variable: `q`
   --> rustmath-combinatorics/src/similarity_class_type.rs:533:44
    |
533 | pub fn matrix_similarity_classes(n: usize, q: &Integer) -> Vec<SimilarityClassType> {
    |                                            ^ help: if this is intentional, prefix it with an underscore: `_q`

warning: unused variable: `left_in`
   --> rustmath-combinatorics/src/six_vertex_model.rs:185:22
    |
185 |                 let (left_in, right_out, up_in, down_out) = vertex.arrows();
    |                      ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_left_in`

warning: unused variable: `up_in`
   --> rustmath-combinatorics/src/six_vertex_model.rs:185:42
    |
185 |                 let (left_in, right_out, up_in, down_out) = vertex.arrows();
    |                                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_up_in`

warning: unused variable: `row`
   --> rustmath-combinatorics/src/skew_partition.rs:695:43
    |
695 |     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
    |                                           ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
695 |     fn compute_shape_after_removal(&self, _row: usize, col: usize) -> Option<SkewPartition> {
    |                                           +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
695 -     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
695 +     fn compute_shape_after_removal(&self, permutation_simd::inverse_avx2::SIMD_WIDTH: usize, col: usize) -> Option<SkewPartition> {
    |

warning: unused variable: `col`
   --> rustmath-combinatorics/src/skew_partition.rs:695:55
    |
695 |     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
    |                                                       ^^^
    |
help: if this is intentional, prefix it with an underscore
    |
695 |     fn compute_shape_after_removal(&self, row: usize, _col: usize) -> Option<SkewPartition> {
    |                                                       +
help: you might have meant to pattern match on the similarly named constant `SIMD_WIDTH`
    |
695 -     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
695 +     fn compute_shape_after_removal(&self, row: usize, permutation_simd::inverse_avx2::SIMD_WIDTH: usize) -> Option<SkewPartition> {
    |

warning: variable does not need to be mutable
  --> rustmath-combinatorics/src/specht_module.rs:42:13
   |
42 |         let mut rows: Vec<Vec<usize>> = tableau
   |             ----^^^^
   |             |
   |             help: remove this `mut`

warning: unused variable: `new_tabloid`
   --> rustmath-combinatorics/src/specht_module.rs:446:17
    |
446 |             let new_tabloid = tabloid.apply_permutation(perm);
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_new_tabloid`

warning: unused variable: `rep1`
   --> rustmath-combinatorics/src/symmetric_group_representations.rs:528:17
    |
528 |         for (i, rep1) in self.representations.iter().enumerate() {
    |                 ^^^^ help: if this is intentional, prefix it with an underscore: `_rep1`

warning: unused variable: `rep2`
   --> rustmath-combinatorics/src/symmetric_group_representations.rs:529:21
    |
529 |             for (j, rep2) in self.representations.iter().enumerate() {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_rep2`

warning: unused variable: `param`
   --> rustmath-combinatorics/src/tableaux.rs:806:56
    |
806 | fn hecke_insert_value(tableau: &Tableau, value: usize, param: u8) -> Tableau {
    |                                                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_param`

warning: unused variable: `path_to_index`
   --> rustmath-combinatorics/src/tamari.rs:283:9
    |
283 |         path_to_index: &HashMap<Vec<bool>, usize>,
    |         ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_path_to_index`

warning: unused variable: `count`
   --> rustmath-combinatorics/src/ncsym.rs:249:13
    |
249 |     let mut count = 0;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_count`

warning: variable does not need to be mutable
   --> rustmath-combinatorics/src/ncsym.rs:249:9
    |
249 |     let mut count = 0;
    |         ----^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `swapped_mon`
   --> rustmath-combinatorics/src/key_polynomial.rs:357:17
    |
357 |             let swapped_mon = mon.swap_variables(i);
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_swapped_mon`

warning: field `index` is never read
   --> rustmath-combinatorics/src/dlx.rs:101:5
    |
 99 | struct ColumnHeader {
    |        ------------ field in this struct
100 |     /// Column index
101 |     index: usize,
    |     ^^^^^
    |
    = note: `ColumnHeader` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `n` is never read
   --> rustmath-combinatorics/src/enumeration.rs:701:5
    |
700 | pub struct PartitionIterator {
    |            ----------------- field in this struct
701 |     n: usize,
    |     ^

warning: fields `n` and `current` are never read
   --> rustmath-combinatorics/src/enumeration.rs:741:5
    |
740 | pub struct CompositionIterator {
    |            ------------------- fields in this struct
741 |     n: usize,
    |     ^
742 |     current: Option<Vec<usize>>,
    |     ^^^^^^^

warning: function `compute_northeast_partition` is never used
   --> rustmath-combinatorics/src/growth_diagram.rs:242:4
    |
242 | fn compute_northeast_partition(
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: struct `GenerationState` is never constructed
   --> rustmath-combinatorics/src/integer_lists.rs:251:8
    |
251 | struct GenerationState {
    |        ^^^^^^^^^^^^^^^

warning: fields `constraints`, `current_length`, `max_length`, `current_sum`, `max_sum`, and `stack` are never read
   --> rustmath-combinatorics/src/integer_lists.rs:573:5
    |
572 | pub struct IntegerListIterator {
    |            ------------------- fields in this struct
573 |     constraints: IntegerListConstraints,
    |     ^^^^^^^^^^^
574 |     current_length: usize,
    |     ^^^^^^^^^^^^^^
575 |     max_length: usize,
    |     ^^^^^^^^^^
576 |     current_sum: usize,
    |     ^^^^^^^^^^^
577 |     max_sum: usize,
    |     ^^^^^^^
578 |     stack: Vec<(Vec<usize>, usize)>, // (current list, position)
    |     ^^^^^

warning: field `cache` is never read
  --> rustmath-combinatorics/src/regular_sequences.rs:99:5
   |
95 | pub struct MorphicSequence<T: Clone + Ord + Hash> {
   |            --------------- field in this struct
...
99 |     cache: HashMap<usize, usize>,
   |     ^^^^^

warning: field `n` is never read
   --> rustmath-combinatorics/src/similarity_class_type.rs:381:5
    |
380 | pub struct SimilarityClassTypes {
    |            -------------------- field in this struct
381 |     n: usize,
    |     ^

warning: method `compute_shape_after_removal` is never used
   --> rustmath-combinatorics/src/skew_partition.rs:695:8
    |
398 | impl SkewTableau {
    | ---------------- method in this implementation
...
695 |     fn compute_shape_after_removal(&self, row: usize, col: usize) -> Option<SkewPartition> {
    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: fields `col`, `start_row`, and `end_row` are never read
   --> rustmath-combinatorics/src/specht_module.rs:265:5
    |
263 | pub struct GarnirSet {
    |            --------- fields in this struct
264 |     /// First column index
265 |     col: usize,
    |     ^^^
266 |     /// Starting row index
267 |     start_row: usize,
    |     ^^^^^^^^^
268 |     /// Ending row index (inclusive)
269 |     end_row: usize,
    |     ^^^^^^^
    |
    = note: `GarnirSet` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `is_molecular` is never read
   --> rustmath-combinatorics/src/species.rs:421:5
    |
418 | pub struct MolecularSpecies {
    |            ---------------- field in this struct
...
421 |     is_molecular: bool,
    |     ^^^^^^^^^^^^
    |
    = note: `MolecularSpecies` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `n` and `k` are never read
   --> rustmath-combinatorics/src/subset.rs:524:5
    |
523 | pub struct KSubsetIterator {
    |            --------------- fields in this struct
524 |     n: usize,
    |     ^
525 |     k: usize,
    |     ^

warning: field `current_indices` is never read
   --> rustmath-combinatorics/src/subset.rs:716:5
    |
712 | pub struct PairwiseDisjointFamilyIterator {
    |            ------------------------------ field in this struct
...
716 |     current_indices: Vec<usize>,
    |     ^^^^^^^^^^^^^^^

warning: function `hillman_grassl_insert` is never used
   --> rustmath-combinatorics/src/tableaux.rs:646:4
    |
646 | fn hillman_grassl_insert(tableau: &Tableau, value: usize) -> Tableau {
    |    ^^^^^^^^^^^^^^^^^^^^^

warning: function `generate_parts_up_to` is never used
   --> rustmath-combinatorics/src/vector_partition.rs:197:4
    |
197 | fn generate_parts_up_to(max_vec: &[usize], constraint: &[usize]) -> Vec<Vec<usize>> {
    |    ^^^^^^^^^^^^^^^^^^^^

warning: field `states` is never read
   --> rustmath-combinatorics/src/word.rs:764:5
    |
760 | pub struct AutomaticSequence {
    |            ----------------- field in this struct
...
764 |     states: Vec<String>,
    |     ^^^^^^
    |
    = note: `AutomaticSequence` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `slope_p`, `slope_q`, and `rho` are never read
   --> rustmath-combinatorics/src/words.rs:714:5
    |
710 | pub struct SturmianWord {
    |            ------------ fields in this struct
...
714 |     slope_p: usize,
    |     ^^^^^^^
715 |     slope_q: usize,
    |     ^^^^^^^
716 |     /// The intercept parameter rho
717 |     rho: f64,
    |     ^^^
    |
    = note: `SturmianWord` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `num_states` is never read
   --> rustmath-combinatorics/src/words.rs:971:5
    |
969 | pub struct AutomaticSequence {
    |            ----------------- field in this struct
970 |     /// Number of states
971 |     num_states: usize,
    |     ^^^^^^^^^^
    |
    = note: `AutomaticSequence` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: unexpected `cfg` condition value: `random`
   --> rustmath-graphs/src/generators/mod.rs:118:7
    |
118 | #[cfg(feature = "random")]
    |       ^^^^^^^^^^^^^^^^^^ help: remove the condition
    |
    = note: no expected values for `feature`
    = help: consider adding `random` as a feature in `Cargo.toml`
    = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
    = note: `#[warn(unexpected_cfgs)]` on by default

warning: unused import: `rustmath_core::Ring`
  --> rustmath-graphs/src/graph_path.rs:10:5
   |
10 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `vertex_map`
    --> rustmath-graphs/src/graph.rs:1585:9
     |
1585 |     let vertex_map: Vec<usize> = (0..n)
     |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vertex_map`
     |
     = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `alpha`
   --> rustmath-graphs/src/generators/distance_regular.rs:921:60
    |
921 | pub fn graph_with_classical_parameters(d: usize, b: usize, alpha: i32, beta: i32) -> Graph {
    |                                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`

warning: unused variable: `beta`
   --> rustmath-graphs/src/generators/distance_regular.rs:921:72
    |
921 | pub fn graph_with_classical_parameters(d: usize, b: usize, alpha: i32, beta: i32) -> Graph {
    |                                                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `r`
   --> rustmath-graphs/src/generators/families.rs:945:35
    |
945 | pub fn fuzzy_ball_graph(n: usize, r: usize) -> Graph {
    |                                   ^ help: if this is intentional, prefix it with an underscore: `_r`

warning: unused variable: `graph`
  --> rustmath-graphs/src/cographs.rs:64:19
   |
64 | pub fn find_pivot(graph: &Graph, vertices: &[usize]) -> Option<usize> {
   |                   ^^^^^ help: if this is intentional, prefix it with an underscore: `_graph`

warning: unused variable: `current`
  --> rustmath-graphs/src/cographs.rs:74:18
   |
74 | pub fn next_tree(current: &CoTree) -> Option<CoTree> {
   |                  ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_current`

warning: unused variable: `count`
   --> rustmath-graphs/src/convexity_properties.rs:241:13
    |
241 |         let count = 0;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_count`

warning: unused variable: `start`
   --> rustmath-graphs/src/planarity.rs:166:30
    |
166 |     fn new(graph: &'a Graph, start: usize, visited: &'a mut Vec<bool>) -> Self {
    |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_start`

warning: unused variable: `n`
   --> rustmath-graphs/src/automorphisms.rs:109:20
    |
109 |     pub fn trivial(n: usize) -> Self {
    |                    ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `old_num_colors`
   --> rustmath-graphs/src/automorphisms.rs:234:17
    |
234 |             let old_num_colors = self.num_colors;
    |                 ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_old_num_colors`

warning: field `start` is never read
   --> rustmath-graphs/src/backends/c_graph.rs:218:5
    |
212 | pub struct SearchIterator {
    |            -------------- field in this struct
...
218 |     start: usize,
    |     ^^^^^
    |
    = note: `SearchIterator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `graph` is never read
  --> rustmath-graphs/src/edge_connectivity.rs:21:5
   |
19 | pub struct GabowEdgeConnectivity {
   |            --------------------- field in this struct
20 |     /// The directed graph to analyze
21 |     graph: DiGraph,
   |     ^^^^^

warning: method `is_descendant` is never used
   --> rustmath-graphs/src/planarity.rs:243:8
    |
165 | impl<'a> DfsTree<'a> {
    | -------------------- method in this implementation
...
243 |     fn is_descendant(&self, v: usize, ancestor: usize) -> bool {
    |        ^^^^^^^^^^^^^

warning: associated function `trivial` is never used
   --> rustmath-graphs/src/automorphisms.rs:171:8
    |
169 | impl ColorPartition {
    | ------------------- associated function in this implementation
170 |     /// Create initial partition with all vertices having the same color
171 |     fn trivial(n: usize) -> Self {
    |        ^^^^^^^

warning: variable `N` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:228:13
    |
228 |         let N = self.conductor.to_f64().unwrap_or(1.0);
    |             ^ help: convert the identifier to snake case: `n`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `L_value` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:231:13
    |
231 |         let L_value = self.evaluate(s, 1000);
    |             ^^^^^^^ help: convert the identifier to snake case: `l_value`

warning: variable `N_to_s_half` should have a snake case name
   --> rustmath-ellipticcurves/src/lfunction.rs:233:13
    |
233 |         let N_to_s_half = N.powf(s.re / 2.0) * ComplexNum::new(
    |             ^^^^^^^^^^^ help: convert the identifier to snake case: `n_to_s_half`

warning: `rustmath-combinatorics` (lib) generated 98 warnings (run `cargo fix --lib -p rustmath-combinatorics` to apply 39 suggestions)
warning: `rustmath-graphs` (lib) generated 16 warnings
warning: `rustmath-ellipticcurves` (lib) generated 3 warnings
warning: unused import: `rustmath_rationals::Rational`
 --> rustmath-groups/src/matrix_group.rs:7:5
  |
7 | use rustmath_rationals::Rational;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/additive_abelian_group.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/additive_abelian_wrapper.rs:12:5
   |
12 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `AdditiveAbelianGroupElement`
  --> rustmath-groups/src/additive_abelian_wrapper.rs:13:59
   |
13 | use crate::additive_abelian_group::{AdditiveAbelianGroup, AdditiveAbelianGroupElement};
   |                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `MathError`
  --> rustmath-groups/src/affine_group.rs:17:27
   |
17 | use rustmath_core::{Ring, MathError};
   |                           ^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/artin.rs:36:5
   |
36 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ops::Mul`
  --> rustmath-groups/src/artin.rs:39:5
   |
39 | use std::ops::Mul;
   |     ^^^^^^^^^^^^^

warning: unused import: `ArtinGroupElement`
  --> rustmath-groups/src/braid.rs:51:32
   |
51 | use crate::artin::{ArtinGroup, ArtinGroupElement, FiniteTypeArtinGroup, FiniteTypeArtinGroupElement, CoxeterMatrix};
   |                                ^^^^^^^^^^^^^^^^^

warning: unused import: `crate::free_group::FreeGroupElement`
  --> rustmath-groups/src/braid.rs:52:5
   |
52 | use crate::free_group::FreeGroupElement;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/cactus_group.rs:30:5
   |
30 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::ops::Mul`
  --> rustmath-groups/src/cactus_group.rs:32:5
   |
32 | use std::ops::Mul;
   |     ^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-groups/src/cubic_braid.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-groups/src/finitely_presented.rs:30:24
   |
30 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `crate::group_traits::Group`
  --> rustmath-groups/src/misc_groups.rs:30:5
   |
30 | use crate::group_traits::Group;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `FiniteGroupTrait`
  --> rustmath-groups/src/semimonomial_transformation_group.rs:36:34
   |
36 | use crate::group_traits::{Group, FiniteGroupTrait};
   |                                  ^^^^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> rustmath-groups/src/libgap_mixin.rs:21:24
   |
21 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^

warning: unused import: `std::ops::Mul`
  --> rustmath-groups/src/nilpotent_lie_group.rs:33:5
   |
33 | use std::ops::Mul;
   |     ^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-groups/src/raag.rs:44:24
   |
44 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `Group`
  --> rustmath-groups/src/semimonomial_transformation_group.rs:36:27
   |
36 | use crate::group_traits::{Group, FiniteGroupTrait};
   |                           ^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-groups/src/libgap_group.rs:19:5
   |
19 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-groups/src/artin.rs:38:5
   |
38 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-groups/src/braid.rs:49:5
   |
49 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused variable: `element`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:287:32
    |
287 |     pub fn discrete_log(&self, element: &T) -> Result<Vec<i64>, String> {
    |                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p`
   --> rustmath-groups/src/additive_abelian_wrapper.rs:442:5
    |
442 |     p: usize,
    |     ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: variable does not need to be mutable
   --> rustmath-groups/src/free_group.rs:362:13
    |
362 |         let mut word: Vec<(isize, isize)> = self
    |             ----^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-groups/src/free_group.rs:490:13
    |
490 |         let mut result = f(self.word[0].0 as usize, self.word[0].1);
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable `pk` is assigned to, but never used
   --> rustmath-groups/src/generic.rs:290:17
    |
290 |         let mut pk = 1usize;
    |                 ^^
    |
    = note: consider using `_pk` instead

warning: unused variable: `target_order`
   --> rustmath-groups/src/generic.rs:446:9
    |
446 |     let target_order = lcm(order_a, order_b);
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_target_order`

warning: variable does not need to be mutable
   --> rustmath-groups/src/indexed_free_group.rs:226:13
    |
226 |         let mut inv_word: Vec<(I, i32)> = self
    |             ----^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: variable does not need to be mutable
   --> rustmath-groups/src/nilpotent_lie_group.rs:196:17
    |
196 |             let mut coords = vec![0.0; self.dim];
    |                 ----^^^^^^
    |                 |
    |                 help: remove this `mut`

warning: unused variable: `name`
   --> rustmath-groups/src/groups_catalog.rs:389:22
    |
389 |     pub fn Nilpotent(name: &str) -> NilpotentLieGroup {
    |                      ^^^^ help: if this is intentional, prefix it with an underscore: `_name`

warning: field `group` is never read
  --> rustmath-groups/src/finitely_presented.rs:74:5
   |
72 | pub struct RewritingSystem {
   |            --------------- field in this struct
73 |     /// The group this system applies to
74 |     group: FinitelyPresentedGroup,
   |     ^^^^^
   |
   = note: `RewritingSystem` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `is_validated` is never read
  --> rustmath-groups/src/libgap_morphism.rs:51:5
   |
36 | pub struct GroupMorphismLibgap<G, H>
   |            ------------------- field in this struct
...
51 |     is_validated: bool,
   |     ^^^^^^^^^^^^
   |
   = note: `GroupMorphismLibgap` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: function `Symmetric` should have a snake case name
  --> rustmath-groups/src/groups_catalog.rs:95:12
   |
95 |     pub fn Symmetric(n: usize) -> SymmetricGroup {
   |            ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `symmetric`
   |
   = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: function `Alternating` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:112:12
    |
112 |     pub fn Alternating(n: usize) -> AlternatingGroup {
    |            ^^^^^^^^^^^ help: convert the identifier to snake case: `alternating`

warning: function `Cyclic` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:129:12
    |
129 |     pub fn Cyclic(n: usize) -> PermutationGroup {
    |            ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `cyclic`

warning: function `KleinFour` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:143:12
    |
143 |     pub fn KleinFour() -> FinitelyPresentedGroup {
    |            ^^^^^^^^^ help: convert the identifier to snake case: `klein_four`

warning: function `Quaternion` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:156:12
    |
156 |     pub fn Quaternion() -> FinitelyPresentedGroup {
    |            ^^^^^^^^^^ help: convert the identifier to snake case: `quaternion`

warning: function `DiCyclic` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:191:12
    |
191 |     pub fn DiCyclic(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^^^ help: convert the identifier to snake case: `di_cyclic`

warning: function `Cyclic` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:216:12
    |
216 |     pub fn Cyclic(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `cyclic`

warning: function `Dihedral` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:233:12
    |
233 |     pub fn Dihedral(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^^^ help: convert the identifier to snake case: `dihedral`

warning: function `DiCyclic` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:250:12
    |
250 |     pub fn DiCyclic(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^^^ help: convert the identifier to snake case: `di_cyclic`

warning: function `Quaternion` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:263:12
    |
263 |     pub fn Quaternion() -> FinitelyPresentedGroup {
    |            ^^^^^^^^^^ help: convert the identifier to snake case: `quaternion`

warning: function `KleinFour` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:276:12
    |
276 |     pub fn KleinFour() -> FinitelyPresentedGroup {
    |            ^^^^^^^^^ help: convert the identifier to snake case: `klein_four`

warning: function `FGAbelian` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:293:12
    |
293 |     pub fn FGAbelian(invariants: Vec<usize>) -> FinitelyPresentedGroup {
    |            ^^^^^^^^^ help: convert the identifier to snake case: `fgabelian`

warning: function `Symmetric` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:310:12
    |
310 |     pub fn Symmetric(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `symmetric`

warning: function `Alternating` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:327:12
    |
327 |     pub fn Alternating(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^^^^^^ help: convert the identifier to snake case: `alternating`

warning: function `Cactus` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:344:12
    |
344 |     pub fn Cactus(n: usize) -> FinitelyPresentedGroup {
    |            ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `cactus`

warning: function `Nilpotent` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:389:12
    |
389 |     pub fn Nilpotent(name: &str) -> NilpotentLieGroup {
    |            ^^^^^^^^^ help: convert the identifier to snake case: `nilpotent`

warning: function `Braid` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:426:12
    |
426 |     pub fn Braid(n: usize) -> BraidGroup {
    |            ^^^^^ help: convert the identifier to snake case: `braid`

warning: function `Cactus` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:443:12
    |
443 |     pub fn Cactus(n: usize) -> CactusGroup {
    |            ^^^^^^ help: convert the identifier to snake case (notice the capitalization): `cactus`

warning: function `Free` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:471:12
    |
471 |     pub fn Free(n: usize) -> FreeGroup {
    |            ^^^^ help: convert the identifier to snake case (notice the capitalization): `free`

warning: function `AdditiveAbelian` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:527:12
    |
527 |     pub fn AdditiveAbelian(invariants: Vec<i32>) -> AdditiveAbelianGroup {
    |            ^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `additive_abelian`

warning: function `AdditiveCyclic` should have a snake case name
   --> rustmath-groups/src/groups_catalog.rs:545:12
    |
545 |     pub fn AdditiveCyclic(n: i32) -> AdditiveAbelianGroup {
    |            ^^^^^^^^^^^^^^ help: convert the identifier to snake case: `additive_cyclic`

warning: type `IdealMonoid_nc` should have an upper camel case name
  --> rustmath-rings/src/noncommutative_ideals.rs:67:10
   |
67 | pub type IdealMonoid_nc = IdealMonoidNc;
   |          ^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `IdealMonoidNc`
   |
   = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: type `Ideal_nc` should have an upper camel case name
   --> rustmath-rings/src/noncommutative_ideals.rs:196:10
    |
196 | pub type Ideal_nc = IdealNc;
    |          ^^^^^^^^ help: convert the identifier to upper camel case: `IdealNc`

warning: type `FunctionFieldPlace_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field/place_polymod.rs:61:10
   |
61 | pub type FunctionFieldPlace_polymod<F> = FunctionFieldPlacePolymod<F>;
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldPlacePolymod`

warning: type `FunctionFieldPlace_rational` should have an upper camel case name
  --> rustmath-rings/src/function_field/place_rational.rs:69:10
   |
69 | pub type FunctionFieldPlace_rational<F> = FunctionFieldPlaceRational<F>;
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldPlaceRational`

warning: type `FunctionFieldValuation_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/valuation.rs:131:10
    |
131 | pub type FunctionFieldValuation_base<F> = FunctionFieldValuationBase<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldValuationBase`

warning: type `ClassicalFunctionFieldValuation_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/valuation.rs:195:10
    |
195 | pub type ClassicalFunctionFieldValuation_base<F> = ClassicalFunctionFieldValuationBase<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `ClassicalFunctionFieldValuationBase`

warning: type `RationalFunctionFieldValuation_base` should have an upper camel case name
   --> rustmath-rings/src/function_field/valuation.rs:295:10
    |
295 | pub type RationalFunctionFieldValuation_base<F> = RationalFunctionFieldValuationBase<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RationalFunctionFieldValuationBase`

warning: type `FunctionField_polymod` should have an upper camel case name
  --> rustmath-rings/src/function_field/function_field_polymod.rs:94:10
   |
94 | pub type FunctionField_polymod<F> = FunctionFieldPolymod<F>;
   |          ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldPolymod`

warning: type `FunctionField_simple` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:177:10
    |
177 | pub type FunctionField_simple<F> = FunctionFieldSimple<F>;
    |          ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldSimple`

warning: type `FunctionField_char_zero` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:231:10
    |
231 | pub type FunctionField_char_zero<F> = FunctionFieldCharZero<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldCharZero`

warning: type `FunctionField_integral` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:267:10
    |
267 | pub type FunctionField_integral<F> = FunctionFieldIntegral<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIntegral`

warning: type `FunctionField_char_zero_integral` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:306:10
    |
306 | pub type FunctionField_char_zero_integral<F> = FunctionFieldCharZeroIntegral<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldCharZeroIntegral`

warning: type `FunctionField_global` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:344:10
    |
344 | pub type FunctionField_global<F> = FunctionFieldGlobal<F>;
    |          ^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldGlobal`

warning: type `FunctionField_global_integral` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_polymod.rs:401:10
    |
401 | pub type FunctionField_global_integral<F> = FunctionFieldGlobalIntegral<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldGlobalIntegral`

warning: type `RationalFunctionField_char_zero` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_rational.rs:172:10
    |
172 | pub type RationalFunctionField_char_zero<F> = RationalFunctionFieldCharZero<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RationalFunctionFieldCharZero`

warning: type `RationalFunctionField_global` should have an upper camel case name
   --> rustmath-rings/src/function_field/function_field_rational.rs:242:10
    |
242 | pub type RationalFunctionField_global<F> = RationalFunctionFieldGlobal<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RationalFunctionFieldGlobal`

warning: type `FunctionFieldIdeal_rational` should have an upper camel case name
  --> rustmath-rings/src/function_field/ideal_rational.rs:85:10
   |
85 | pub type FunctionFieldIdeal_rational<F> = FunctionFieldIdealRational<F>;
   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealRational`

warning: type `FunctionFieldIdealInfinite_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/ideal_rational.rs:263:10
    |
263 | pub type FunctionFieldIdealInfinite_rational<F> = FunctionFieldIdealInfiniteRational<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldIdealInfiniteRational`

warning: type `FunctionFieldMorphism_polymod` should have an upper camel case name
   --> rustmath-rings/src/function_field/maps.rs:146:10
    |
146 | pub type FunctionFieldMorphism_polymod<F> = FunctionFieldMorphismPolymod<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMorphismPolymod`

warning: type `FunctionFieldMorphism_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/maps.rs:191:10
    |
191 | pub type FunctionFieldMorphism_rational<F> = FunctionFieldMorphismRational<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMorphismRational`

warning: type `FunctionFieldOrder_basis` should have an upper camel case name
  --> rustmath-rings/src/function_field/order_basis.rs:97:10
   |
97 | pub type FunctionFieldOrder_basis<F> = FunctionFieldOrderBasis<F>;
   |          ^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldOrderBasis`

warning: type `FunctionFieldOrderInfinite_basis` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_basis.rs:248:10
    |
248 | pub type FunctionFieldOrderInfinite_basis<F> = FunctionFieldOrderInfiniteBasis<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldOrderInfiniteBasis`

warning: type `FunctionFieldMaximalOrder_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_rational.rs:103:10
    |
103 | pub type FunctionFieldMaximalOrder_rational<F> = FunctionFieldMaximalOrderRational<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderRational`

warning: type `FunctionFieldMaximalOrderInfinite_rational` should have an upper camel case name
   --> rustmath-rings/src/function_field/order_rational.rs:326:10
    |
326 | pub type FunctionFieldMaximalOrderInfinite_rational<F> = FunctionFieldMaximalOrderInfiniteRational<F>;
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `FunctionFieldMaximalOrderInfiniteRational`

warning: type `real_lazy_field` should have an upper camel case name
   --> rustmath-rings/src/real_lazy.rs:548:12
    |
548 | pub struct real_lazy_field {
    |            ^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `RealLazyField`

warning: type `complex_lazy_field` should have an upper camel case name
   --> rustmath-rings/src/real_lazy.rs:623:12
    |
623 | pub struct complex_lazy_field {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `ComplexLazyField`

warning: unused import: `Ring`
  --> rustmath-rings/src/abc.rs:24:21
   |
24 | use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain};
   |                     ^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/asymptotic.rs:44:5
   |
44 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/differential.rs:40:21
   |
40 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/divisor.rs:43:21
   |
43 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field.rs:12:21
   |
12 | use rustmath_core::{Ring, IntegralDomain};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field_element.rs:33:21
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field};
   |                     ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field_element.rs:33:43
   |
33 | use rustmath_core::{Ring, IntegralDomain, Field};
   |                                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:21
   |
37 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/fraction_field_fpt.rs:37:27
   |
37 | use rustmath_core::{Ring, Field};
   |                           ^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element.rs:31:21
   |
31 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element_polymod.rs:31:21
   |
31 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field_element_rational.rs:27:21
   |
27 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused import: `Hasher`
  --> rustmath-rings/src/growth_group.rs:50:23
   |
50 | use std::hash::{Hash, Hasher};
   |                       ^^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/ideal_polymod.rs:48:28
   |
48 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `GrowthGroup`
  --> rustmath-rings/src/growth_group_cartesian.rs:35:20
   |
35 |     GrowthElement, GrowthGroup, Variable, GrowthGroupFactor,
   |                    ^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/function_field/picard_group.rs:57:28
   |
57 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/padics/capped_relative.rs:44:40
   |
44 | use rustmath_core::{MathError, Result, Ring};
   |                                        ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/padics/factory.rs:71:40
   |
71 | use rustmath_core::{MathError, Result, Ring};
   |                                        ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/puiseux_series_ring_element.rs:34:28
   |
34 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/puiseux_series_ring.rs:40:28
   |
40 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Ring`
  --> rustmath-rings/src/tate_algebra.rs:37:28
   |
37 | use rustmath_core::{Field, Ring};
   |                            ^^^^

warning: unused import: `Field`
  --> rustmath-rings/src/residue_field.rs:24:27
   |
24 | use rustmath_core::{Ring, Field};
   |                           ^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-rings/src/semirings/non_negative_integer_semiring.rs:40:5
   |
40 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `place`
   --> rustmath-rings/src/differential.rs:122:29
    |
122 |     pub fn valuation(&self, place: &str) -> i64 {
    |                             ^^^^^ help: if this is intentional, prefix it with an underscore: `_place`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `function`
   --> rustmath-rings/src/divisor.rs:219:30
    |
219 |     pub fn principal_divisor(function: String) -> Self {
    |                              ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_function`

warning: unused variable: `x`
   --> rustmath-rings/src/fraction_field.rs:287:53
    |
287 | pub fn is_fraction_field_element<R: IntegralDomain>(x: &FractionFieldElement<R>) -> bool {
    |                                                     ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> rustmath-rings/src/fraction_field_element.rs:306:53
    |
306 | pub fn is_fraction_field_element<R: IntegralDomain>(x: &FractionFieldElement<R>) -> bool {
    |                                                     ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `x`
   --> rustmath-rings/src/function_field_element.rs:272:44
    |
272 | pub fn is_function_field_element<F: Field>(x: &FunctionFieldElement<F>) -> bool {
    |                                            ^ help: if this is intentional, prefix it with an underscore: `_x`

warning: unused variable: `num_val`
   --> rustmath-rings/src/function_field_element_rational.rs:153:13
    |
153 |         let num_val = self.eval_poly(&self.numerator, point);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_val`

warning: unused variable: `value`
   --> rustmath-rings/src/infinity.rs:331:32
    |
331 | pub fn is_infinite<T: 'static>(value: &T) -> bool {
    |                                ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`

warning: unused variable: `prev`
    --> rustmath-rings/src/padics/extension.rs:1047:17
     |
1047 |             let prev = automorphisms.last().unwrap();
     |                 ^^^^ help: if this is intentional, prefix it with an underscore: `_prev`

warning: unused variable: `ring2`
   --> rustmath-rings/src/ring_extension.rs:310:34
    |
310 | pub fn common_base<R>(ring1: &R, ring2: &R) -> Result<R, RingExtensionError>
    |                                  ^^^^^ help: if this is intentional, prefix it with an underscore: `_ring2`

warning: unused variable: `sqrt_abs`
   --> rustmath-rings/src/universal_cyclotomic_field.rs:278:13
    |
278 |         let sqrt_abs = ucf_sqrt_int(-n)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sqrt_abs`

warning: unused variable: `element`
   --> rustmath-rings/src/function_field/valuation.rs:247:25
    |
247 |     fn valuation(&self, element: &str) -> i64 {
    |                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: unused variable: `element`
   --> rustmath-rings/src/function_field/valuation.rs:361:25
    |
361 |     fn valuation(&self, element: &str) -> i64 {
    |                         ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: unused variable: `g`
   --> rustmath-rings/src/function_field/order_polymod.rs:336:13
    |
336 |         let g = self.genus();
    |             ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `d2`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:327:47
    |
327 |     pub fn add(&self, d1: &MumfordDivisor<F>, d2: &MumfordDivisor<F>) -> MumfordDivisor<F> {
    |                                               ^^ help: if this is intentional, prefix it with an underscore: `_d2`

warning: unused variable: `h`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:343:33
    |
343 |         let neg_v = if let Some(h) = self.curve.h() {
    |                                 ^ help: if this is intentional, prefix it with an underscore: `_h`

warning: unused variable: `d`
   --> rustmath-rings/src/function_field/jacobian_hyperelliptic.rs:385:28
    |
385 |     pub fn contains(&self, d: &MumfordDivisor<F>) -> bool {
    |                            ^ help: if this is intentional, prefix it with an underscore: `_d`

warning: unused variable: `a`
   --> rustmath-rings/src/invariants/reconstruction.rs:103:9
    |
103 |     let a = R::from(1);
    |         ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `b`
   --> rustmath-rings/src/invariants/reconstruction.rs:104:9
    |
104 |     let b = R::from(0);
    |         ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `element`
   --> rustmath-rings/src/power_series_poly.rs:279:23
    |
279 |     pub fn act(&self, element: &R, series: &PowerSeriesPoly<R>) -> PowerSeriesPoly<R> {
    |                       ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_element`

warning: unused variable: `other_exp`
   --> rustmath-rings/src/puiseux_series_ring_element.rs:221:24
    |
221 |         let (self_exp, other_exp) = self.to_common_ramification(&PuiseuxSeries::new(
    |                        ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_exp`

warning: methods `numerator_mut` and `denominator_mut` are never used
   --> rustmath-rings/src/fraction_field_element.rs:105:8
    |
 57 | impl<R: IntegralDomain> FractionFieldElement<R> {
    | ----------------------------------------------- methods in this implementation
...
105 |     fn numerator_mut(&mut self) -> &mut R {
    |        ^^^^^^^^^^^^^
...
110 |     fn denominator_mut(&mut self) -> &mut R {
    |        ^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `source` is never read
   --> rustmath-rings/src/fraction_field_fpt.rs:499:5
    |
498 | pub struct FpTToFpSection {
    |            -------------- field in this struct
499 |     source: FpT,
    |     ^^^^^^

warning: field `max_degree` is never read
   --> rustmath-rings/src/fraction_field_fpt.rs:545:5
    |
543 | pub struct FpTIterator {
    |            ----------- field in this struct
544 |     field: FpT,
545 |     max_degree: usize,
    |     ^^^^^^^^^^

warning: field `error` is never read
   --> rustmath-rings/src/growth_group.rs:132:5
    |
130 | pub struct PartialConversionElement<T> {
    |            ------------------------ field in this struct
131 |     value: Option<T>,
132 |     error: Option<String>,
    |     ^^^^^
    |
    = note: `PartialConversionElement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `map_fn` is never read
   --> rustmath-rings/src/morphism.rs:117:5
    |
111 | pub struct RingMap<R: Ring, S: Ring, F>
    |            ------- field in this struct
...
117 |     map_fn: F,
    |     ^^^^^^
    |
    = note: `RingMap` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `is_injective_cached` and `is_surjective_cached` are never read
   --> rustmath-rings/src/morphism.rs:151:5
    |
143 | pub struct RingHomomorphism<R, S>
    |            ---------------- fields in this struct
...
151 |     is_injective_cached: Option<bool>,
    |     ^^^^^^^^^^^^^^^^^^^
152 |     /// Cached surjectivity status
153 |     is_surjective_cached: Option<bool>,
    |     ^^^^^^^^^^^^^^^^^^^^
    |
    = note: `RingHomomorphism` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/morphism.rs:199:5
    |
194 | pub struct RingHomomorphismImGens<R, S>
    |            ---------------------- field in this struct
...
199 |     base: RingHomomorphism<R, S>,
    |     ^^^^
    |
    = note: `RingHomomorphismImGens` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/morphism.rs:273:5
    |
268 | pub struct RingHomomorphismFromBase<R, S>
    |            ------------------------ field in this struct
...
273 |     base: RingHomomorphism<R, S>,
    |     ^^^^
    |
    = note: `RingHomomorphismFromBase` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/morphism.rs:309:5
    |
304 | pub struct RingHomomorphismFromFractionField<R, S>
    |            --------------------------------- field in this struct
...
309 |     base: RingHomomorphism<R, S>,
    |     ^^^^
    |
    = note: `RingHomomorphismFromFractionField` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/morphism.rs:344:5
    |
339 | pub struct RingHomomorphismFromQuotient<R, S>
    |            ---------------------------- field in this struct
...
344 |     base: RingHomomorphism<R, S>,
    |     ^^^^
    |
    = note: `RingHomomorphismFromQuotient` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/morphism.rs:378:5
    |
374 | pub struct RingHomomorphismCover<R>
    |            --------------------- field in this struct
...
378 |     base: RingHomomorphism<R, R>,
    |     ^^^^
    |
    = note: `RingHomomorphismCover` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/morphism.rs:411:5
    |
407 | pub struct FrobeniusEndomorphism<R>
    |            --------------------- field in this struct
...
411 |     base: RingHomomorphism<R, R>,
    |     ^^^^
    |
    = note: `FrobeniusEndomorphism` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: methods `coefficients_mut` and `reduce` are never used
   --> rustmath-rings/src/padics/extension.rs:461:8
    |
393 | impl PadicExtensionElement {
    | -------------------------- methods in this implementation
...
461 |     fn coefficients_mut(&mut self) -> &mut Vec<PadicRational> {
    |        ^^^^^^^^^^^^^^^^
...
594 |     fn reduce(&mut self) {
    |        ^^^^^^

warning: field `modulus` is never read
   --> rustmath-rings/src/padics/factory.rs:350:5
    |
347 | pub struct PadicIntegerExtension {
    |            --------------------- field in this struct
...
350 |     modulus: Option<UnivariatePolynomial<Integer>>,
    |     ^^^^^^^
    |
    = note: `PadicIntegerExtension` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `quotient` is never read
   --> rustmath-rings/src/quotient_ring.rs:268:5
    |
266 | pub struct QuotientRingIdealGeneric<R: Ring> {
    |            ------------------------ field in this struct
267 |     /// The quotient ring this ideal belongs to
268 |     quotient: QuotientRingNc<R>,
    |     ^^^^^^^^
    |
    = note: `QuotientRingIdealGeneric` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/quotient_ring.rs:293:5
    |
292 | pub struct QuotientRingIdealPrincipal<R: Ring> {
    |            -------------------------- field in this struct
293 |     base: QuotientRingIdealGeneric<R>,
    |     ^^^^
    |
    = note: `QuotientRingIdealPrincipal` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/ring_extension.rs:154:5
    |
149 | pub struct RingExtensionWithBasis<K, L>
    |            ---------------------- field in this struct
...
154 |     base: RingExtensionGeneric<K, L>,
    |     ^^^^
    |
    = note: `RingExtensionWithBasis` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-rings/src/ring_extension.rs:257:5
    |
252 | pub struct RingExtensionFractionField<K, L>
    |            -------------------------- field in this struct
...
257 |     base: RingExtensionGeneric<K, L>,
    |     ^^^^
    |
    = note: `RingExtensionFractionField` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
  --> rustmath-rings/src/ring_extension_morphism.rs:28:5
   |
20 | pub struct RingExtensionHomomorphism<K, L, M, N>
   |            ------------------------- field in this struct
...
28 |     base: RingHomomorphism<L, N>,
   |     ^^^^
   |
   = note: `RingExtensionHomomorphism` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `finite` is never read
   --> rustmath-rings/src/augmented_valuation.rs:261:5
    |
260 | pub struct FinalFiniteAugmentedValuation<R> {
    |            ----------------------------- field in this struct
261 |     finite: FiniteAugmentedValuation<R>,
    |     ^^^^^^
    |
    = note: `FinalFiniteAugmentedValuation` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `integral` is never read
   --> rustmath-rings/src/function_field/function_field_polymod.rs:397:5
    |
393 | pub struct FunctionFieldGlobalIntegral<F: Field> {
    |            --------------------------- field in this struct
...
397 |     integral: FunctionFieldIntegral<F>,
    |     ^^^^^^^^
    |
    = note: `FunctionFieldGlobalIntegral` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `inner` is never read
   --> rustmath-rings/src/function_field/maps.rs:496:5
    |
494 | pub struct FractionFieldToFunctionField<F: Field> {
    |            ---------------------------- field in this struct
495 |     /// Vector space isomorphism
496 |     inner: FunctionFieldVectorSpaceIsomorphism<F>,
    |     ^^^^^
    |
    = note: `FractionFieldToFunctionField` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `inner` is never read
   --> rustmath-rings/src/function_field/maps.rs:512:5
    |
510 | pub struct FunctionFieldToFractionField<F: Field> {
    |            ---------------------------- field in this struct
511 |     /// Vector space isomorphism
512 |     inner: FunctionFieldVectorSpaceIsomorphism<F>,
    |     ^^^^^
    |
    = note: `FunctionFieldToFractionField` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `inner` is never read
   --> rustmath-rings/src/function_field/maps.rs:528:5
    |
526 | pub struct FunctionFieldRingMorphism<F: Field> {
    |            ------------------------- field in this struct
527 |     /// Base morphism
528 |     inner: FunctionFieldMorphism<F>,
    |     ^^^^^
    |
    = note: `FunctionFieldRingMorphism` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `field` and `constant_field` are never read
   --> rustmath-rings/src/function_field/maps.rs:549:5
    |
547 | pub struct FunctionFieldConversionToConstantBaseField<F: Field> {
    |            ------------------------------------------ fields in this struct
548 |     /// Function field
549 |     field: String,
    |     ^^^^^
550 |     /// Constant field
551 |     constant_field: String,
    |     ^^^^^^^^^^^^^^
    |
    = note: `FunctionFieldConversionToConstantBaseField` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `source` is never read
   --> rustmath-rings/src/function_field/jacobian_hess.rs:295:5
    |
293 | pub struct JacobianGroupEmbedding<F: Field> {
    |            ---------------------- field in this struct
294 |     /// Source curve
295 |     source: String,
    |     ^^^^^^
    |
    = note: `JacobianGroupEmbedding` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `forms` is never read
   --> rustmath-rings/src/invariants/invariant_theory.rs:439:5
    |
437 | pub struct TwoTernaryQuadratics<R: Ring> {
    |            -------------------- field in this struct
438 |     /// The underlying pair of forms
439 |     forms: TwoAlgebraicForms<R>,
    |     ^^^^^
    |
    = note: `TwoTernaryQuadratics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `forms` is never read
   --> rustmath-rings/src/invariants/invariant_theory.rs:457:5
    |
455 | pub struct TwoQuaternaryQuadratics<R: Ring> {
    |            ----------------------- field in this struct
456 |     /// The underlying pair of forms
457 |     forms: TwoAlgebraicForms<R>,
    |     ^^^^^
    |
    = note: `TwoQuaternaryQuadratics` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `complete` is never read
  --> rustmath-rings/src/lazy_series.rs:60:5
   |
56 | pub struct LazyModuleElement<R: Ring> {
   |            ----------------- field in this struct
...
60 |     complete: bool,
   |     ^^^^^^^^
   |
   = note: `LazyModuleElement` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `base_valuation` is never read
  --> rustmath-rings/src/valuation/gauss_valuation.rs:14:5
   |
13 | pub struct GaussValuation<R: Ring> {
   |            -------------- field in this struct
14 |     base_valuation: Box<dyn DiscretePseudoValuation<R>>,
   |     ^^^^^^^^^^^^^^
   |
   = note: `GaussValuation` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: trait `ToF64` is never used
   --> rustmath-rings/src/qqbar.rs:575:7
    |
575 | trait ToF64 {
    |       ^^^^^

warning: using `.clone()` on a double reference, which returns `&Ratio<BigInt>` instead of cloning the inner type
   --> rustmath-rings/src/asymptotic.rs:783:60
    |
783 |             let abs_coeff = if coeff.is_negative() { -coeff.clone() } else { (*coeff).clone() };
    |                                                            ^^^^^^^^
    |
    = note: `#[warn(suspicious_double_ref_op)]` on by default

warning: function `RealLazyField` should have a snake case name
   --> rustmath-rings/src/real_lazy.rs:688:8
    |
688 | pub fn RealLazyField() -> RealLazyField {
    |        ^^^^^^^^^^^^^ help: convert the identifier to snake case: `real_lazy_field`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: function `ComplexLazyField` should have a snake case name
   --> rustmath-rings/src/real_lazy.rs:693:8
    |
693 | pub fn ComplexLazyField() -> ComplexLazyField {
    |        ^^^^^^^^^^^^^^^^ help: convert the identifier to snake case: `complex_lazy_field`

warning: unused import: `std::collections::HashSet`
  --> rustmath-liealgebras/src/root_system.rs:12:5
   |
12 | use std::collections::HashSet;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_combinatorics::permutations::Permutation`
  --> rustmath-liealgebras/src/weyl_group.rs:10:5
   |
10 | use rustmath_combinatorics::permutations::Permutation;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/weight_lattice.rs:18:21
   |
18 | use std::ops::{Add, Mul, Neg};
   |                     ^^^

warning: unused import: `Affinity`
  --> rustmath-liealgebras/src/dynkin_diagram.rs:15:52
   |
15 | use crate::cartan_type::{CartanType, CartanLetter, Affinity};
   |                                                    ^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/lie_algebra.rs:32:5
   |
32 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-liealgebras/src/lie_algebra.rs:34:5
   |
34 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-liealgebras/src/lie_algebra_element.rs:31:5
   |
31 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/lie_algebra_element.rs:35:26
   |
35 | use std::ops::{Add, Sub, Mul, Neg};
   |                          ^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-liealgebras/src/lie_algebra_element.rs:36:5
   |
36 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/poincare_birkhoff_witt.rs:42:26
   |
42 | use std::ops::{Add, Sub, Mul, Neg};
   |                          ^^^

warning: unused imports: `Display` and `self`
  --> rustmath-liealgebras/src/representation.rs:39:16
   |
39 | use std::fmt::{self, Display, Debug};
   |                ^^^^  ^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-liealgebras/src/representation.rs:40:5
   |
40 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `Mul`
  --> rustmath-liealgebras/src/representation.rs:41:26
   |
41 | use std::ops::{Add, Sub, Mul, Neg};
   |                          ^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/abelian.rs:17:5
   |
17 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/heisenberg.rs:26:5
   |
26 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `LieBracket`
  --> rustmath-liealgebras/src/bch.rs:21:54
   |
21 | use crate::free_lie_algebra::{FreeLieAlgebraElement, LieBracket};
   |                                                      ^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-liealgebras/src/affine_lie_algebra.rs:45:5
   |
45 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-liealgebras/src/bgg_dual_module.rs:44:33
   |
44 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `std::marker::PhantomData`
  --> rustmath-liealgebras/src/bgg_dual_module.rs:46:5
   |
46 | use std::marker::PhantomData;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `BGGDualModule` and `SimpleModule`
  --> rustmath-liealgebras/src/bgg_resolution.rs:37:30
   |
37 | use crate::bgg_dual_module::{SimpleModule, BGGDualModule};
   |                              ^^^^^^^^^^^^  ^^^^^^^^^^^^^

warning: unused import: `HashMap`
  --> rustmath-liealgebras/src/verma_module.rs:19:24
   |
19 | use std::collections::{HashMap, BTreeMap};
   |                        ^^^^^^^

warning: unused imports: `Mul` and `Sub`
  --> rustmath-liealgebras/src/verma_module.rs:21:21
   |
21 | use std::ops::{Add, Mul, Neg, Sub};
   |                     ^^^       ^^^

warning: unused import: `PBWElement`
  --> rustmath-liealgebras/src/verma_module.rs:22:37
   |
22 | use crate::poincare_birkhoff_witt::{PBWElement, PBWMonomial, PoincareBirkhoffWittBasis};
   |                                     ^^^^^^^^^^

warning: unused import: `FinitelyGeneratedLieAlgebra`
  --> rustmath-liealgebras/src/verma_module.rs:23:42
   |
23 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `WeylGroup`
  --> rustmath-liealgebras/src/verma_module.rs:25:25
   |
25 | use crate::weyl_group::{WeylGroup, WeylGroupElement};
   |                         ^^^^^^^^^

warning: unused import: `BTreeSet`
  --> rustmath-liealgebras/src/center_uea.rs:16:43
   |
16 | use std::collections::{HashMap, BTreeMap, BTreeSet};
   |                                           ^^^^^^^^

warning: unused imports: `PBWMonomial` and `PoincareBirkhoffWittBasis`
  --> rustmath-liealgebras/src/center_uea.rs:19:49
   |
19 | use crate::poincare_birkhoff_witt::{PBWElement, PBWMonomial, PoincareBirkhoffWittBasis};
   |                                                 ^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `FinitelyGeneratedLieAlgebra`
  --> rustmath-liealgebras/src/center_uea.rs:20:42
   |
20 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Field`
  --> rustmath-liealgebras/src/symplectic_derivation.rs:20:27
   |
20 | use rustmath_core::{Ring, Field, MathError, Result};
   |                           ^^^^^

warning: unused import: `HashMap`
  --> rustmath-liealgebras/src/symplectic_derivation.rs:21:24
   |
21 | use std::collections::{HashMap, BTreeMap};
   |                        ^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-liealgebras/src/subalgebra.rs:14:24
   |
14 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-liealgebras/src/compact_real_form.rs:31:5
   |
31 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `NumericConversion`
  --> rustmath-liealgebras/src/chevalley_basis.rs:27:27
   |
27 | use rustmath_core::{Ring, NumericConversion};
   |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `LieAlgebraBase`
  --> rustmath-liealgebras/src/verma_module.rs:23:26
   |
23 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                          ^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-liealgebras/src/verma_module.rs:18:21
   |
18 | use rustmath_core::{Ring, Field, MathError, Result};
   |                     ^^^^

warning: unused import: `LieAlgebraBase`
  --> rustmath-liealgebras/src/center_uea.rs:20:26
   |
20 | use crate::lie_algebra::{LieAlgebraBase, FinitelyGeneratedLieAlgebra};
   |                          ^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-liealgebras/src/center_uea.rs:15:21
   |
15 | use rustmath_core::{Ring, Field, MathError, Result};
   |                     ^^^^

warning: unused variable: `size`
   --> rustmath-liealgebras/src/cartan_matrix.rs:293:13
    |
293 |         let size = n + 1;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_size`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `size`
   --> rustmath-liealgebras/src/cartan_matrix.rs:311:13
    |
311 |         let size = n + 1;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: unused variable: `size`
   --> rustmath-liealgebras/src/cartan_matrix.rs:329:13
    |
329 |         let size = n + 1;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_size`

warning: unused variable: `highest_weight`
   --> rustmath-liealgebras/src/weight_lattice.rs:364:34
    |
364 |     pub fn weyl_dimension(&self, highest_weight: &Weight) -> Integer {
    |                                  ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_highest_weight`

warning: unused variable: `processed`
   --> rustmath-liealgebras/src/dynkin_diagram.rs:107:17
    |
107 |         let mut processed: HashSet<(usize, usize)> = HashSet::new();
    |                 ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_processed`

warning: variable does not need to be mutable
   --> rustmath-liealgebras/src/dynkin_diagram.rs:107:13
    |
107 |         let mut processed: HashSet<(usize, usize)> = HashSet::new();
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `i`
   --> rustmath-liealgebras/src/affine_lie_algebra.rs:565:20
    |
565 |     fn affine_root(i: usize) -> Self
    |                    ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `i`
   --> rustmath-liealgebras/src/affine_lie_algebra.rs:578:22
    |
578 |     fn affine_coroot(i: usize) -> Self
    |                      ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `gen_index`
   --> rustmath-liealgebras/src/bgg_dual_module.rs:442:9
    |
442 |         gen_index: usize,
    |         ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_gen_index`

warning: unused variable: `degree`
   --> rustmath-liealgebras/src/bgg_resolution.rs:137:36
    |
137 |     pub fn module_at_degree(&self, degree: usize) -> Vec<R>
    |                                    ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `degree`
   --> rustmath-liealgebras/src/bgg_resolution.rs:149:31
    |
149 |     pub fn is_exact_at(&self, degree: usize) -> bool {
    |                               ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `cartan_type`
   --> rustmath-liealgebras/src/bgg_resolution.rs:255:5
    |
255 |     cartan_type: &CartanType,
    |     ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cartan_type`

warning: unused variable: `highest_weight`
   --> rustmath-liealgebras/src/bgg_resolution.rs:256:5
    |
256 |     highest_weight: &[R],
    |     ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_highest_weight`

warning: unused variable: `i`
   --> rustmath-liealgebras/src/bgg_resolution.rs:292:10
    |
292 |     for &i in weyl_element {
    |          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: variable does not need to be mutable
   --> rustmath-liealgebras/src/bgg_resolution.rs:285:9
    |
285 |     let mut shifted: Vec<R> = weight
    |         ----^^^^^^^
    |         |
    |         help: remove this `mut`

warning: unused variable: `pbw_element`
   --> rustmath-liealgebras/src/center_uea.rs:345:27
    |
345 |     pub fn retract(&self, pbw_element: &PBWElement<F>) -> Option<CenterElement<F>> {
    |                           ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pbw_element`

warning: unused variable: `pbw_element`
   --> rustmath-liealgebras/src/center_uea.rs:352:30
    |
352 |     pub fn is_central(&self, pbw_element: &PBWElement<F>) -> bool {
    |                              ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pbw_element`

warning: field `construction_method` is never read
   --> rustmath-liealgebras/src/lie_algebra.rs:215:5
    |
209 | pub struct InfinitelyGeneratedLieAlgebra<R: Ring + Clone, E: LieAlgebraElement<R>> {
    |            ----------------------------- field in this struct
...
215 |     construction_method: String,
    |     ^^^^^^^^^^^^^^^^^^^
    |
    = note: `InfinitelyGeneratedLieAlgebra` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `basis` is never read
   --> rustmath-liealgebras/src/lie_algebra.rs:292:5
    |
284 | pub struct LieAlgebraFromAssociative<R: Ring + Clone, A>
    |            ------------------------- field in this struct
...
292 |     basis: Option<Vec<A>>,
    |     ^^^^^
    |
    = note: `LieAlgebraFromAssociative` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-liealgebras/src/poincare_birkhoff_witt.rs:471:5
    |
469 | pub struct PoincareBirkhoffWittBasisSemisimple<R: Ring + Clone> {
    |            ----------------------------------- field in this struct
470 |     /// Base PBW structure
471 |     base: PoincareBirkhoffWittBasis<R>,
    |     ^^^^
    |
    = note: `PoincareBirkhoffWittBasisSemisimple` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: function `bernoulli_number` is never used
  --> rustmath-liealgebras/src/bch.rs:34:4
   |
34 | fn bernoulli_number(n: usize) -> Rational {
   |    ^^^^^^^^^^^^^^^^

warning: function `binomial_coefficient` is never used
  --> rustmath-liealgebras/src/bch.rs:70:4
   |
70 | fn binomial_coefficient(n: usize, k: usize) -> usize {
   |    ^^^^^^^^^^^^^^^^^^^^

warning: field `cache` is never read
   --> rustmath-liealgebras/src/bch.rs:126:5
    |
118 | pub struct BCHIterator<R: Ring + Clone> {
    |            ----------- field in this struct
...
126 |     cache: HashMap<usize, FreeLieAlgebraElement<R>>,
    |     ^^^^^

warning: field `basis_cache` is never read
   --> rustmath-liealgebras/src/bgg_dual_module.rs:147:5
    |
139 | pub struct SimpleModule<R: Ring> {
    |            ------------ field in this struct
...
147 |     basis_cache: HashMap<Vec<usize>, R>,
    |     ^^^^^^^^^^^
    |
    = note: `SimpleModule` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `root_system` and `pbw_basis` are never read
   --> rustmath-liealgebras/src/verma_module.rs:323:5
    |
317 | pub struct VermaModule<F: Field> {
    |            ----------- fields in this struct
...
323 |     root_system: Option<RootSystem>,
    |     ^^^^^^^^^^^
324 |     /// PBW basis for the universal enveloping algebra
325 |     pbw_basis: Option<PoincareBirkhoffWittBasis<F>>,
    |     ^^^^^^^^^

warning: field `weyl_element` is never read
   --> rustmath-liealgebras/src/verma_module.rs:461:5
    |
455 | pub struct VermaModuleHomomorphism<F: Field> {
    |            ----------------------- field in this struct
...
461 |     weyl_element: Option<WeylGroupElement>,
    |     ^^^^^^^^^^^^

warning: method `cartan_matrix_entry` is never used
   --> rustmath-liealgebras/src/chevalley_basis.rs:137:8
    |
 99 | impl<R: Ring + Clone + From<i64>> LieAlgebraChevalleyBasis<R> {
    | ------------------------------------------------------------- method in this implementation
...
137 |     fn cartan_matrix_entry(&self, i: usize, j: usize) -> Rational {
    |        ^^^^^^^^^^^^^^^^^^^

warning: unused `Result` that must be used
   --> rustmath-liealgebras/src/classical.rs:206:13
    |
206 |             mat.set(i, j, R::from(1));
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
    = note: `#[warn(unused_must_use)]` (part of `#[warn(unused)]`) on by default
help: use `let _ = ...` to ignore the resulting value
    |
206 |             let _ = mat.set(i, j, R::from(1));
    |             +++++++

warning: unused `Result` that must be used
   --> rustmath-liealgebras/src/classical.rs:302:13
    |
302 |             mat.set(i, i + 1, R::from(1));
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
302 |             let _ = mat.set(i, i + 1, R::from(1));
    |             +++++++

warning: unused `Result` that must be used
   --> rustmath-liealgebras/src/classical.rs:315:13
    |
315 |             mat.set(i + 1, i, R::from(1));
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
315 |             let _ = mat.set(i + 1, i, R::from(1));
    |             +++++++

warning: unused `Result` that must be used
   --> rustmath-liealgebras/src/classical.rs:328:13
    |
328 |             mat.set(i, i, R::from(1));
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
328 |             let _ = mat.set(i, i, R::from(1));
    |             +++++++

warning: unused `Result` that must be used
   --> rustmath-liealgebras/src/classical.rs:329:13
    |
329 |             mat.set(i + 1, i + 1, R::from(-1));
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: this `Result` may be an `Err` variant, which should be handled
help: use `let _ = ...` to ignore the resulting value
    |
329 |             let _ = mat.set(i + 1, i + 1, R::from(-1));
    |             +++++++

warning: unused import: `HashSet`
  --> rustmath-geometry/src/plane_curve_ops.rs:17:24
   |
17 | use std::collections::{HashSet, HashMap};
   |                        ^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `n`
   --> rustmath-geometry/src/hyperplane_arrangement/check_freeness.rs:219:9
    |
219 |     let n = hyperplanes.len();
    |         ^ help: if this is intentional, prefix it with an underscore: `_n`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `obj`
   --> rustmath-geometry/src/lattice_polytope.rs:539:28
    |
539 | pub fn is_lattice_polytope(obj: &LatticePolytopeClass) -> bool {
    |                            ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: associated function `empty` is never used
  --> rustmath-geometry/src/hyperplane_arrangement/arrangement.rs:88:8
   |
42 | impl<R: Ring> HyperplaneArrangementElement<R> {
   | --------------------------------------------- associated function in this implementation
...
88 |     fn empty(ambient_dim: usize) -> Self {
   |        ^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `outer`
   --> rustmath-symmetricfunctions/src/ribbon.rs:188:5
    |
188 |     outer: &Partition,
    |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_outer`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `inner`
   --> rustmath-symmetricfunctions/src/ribbon.rs:189:5
    |
189 |     inner: &Partition,
    |     ^^^^^ help: if this is intentional, prefix it with an underscore: `_inner`

warning: unused variable: `f`
   --> rustmath-symmetricfunctions/src/operations.rs:207:18
    |
207 | pub fn coproduct(f: &SymFun) -> Vec<(SymFun, SymFun)> {
    |                  ^ help: if this is intentional, prefix it with an underscore: `_f`

warning: unused variable: `max_degree`
  --> rustmath-symmetricfunctions/src/plethysm.rs:68:35
   |
68 | pub fn plethystic_exp(f: &SymFun, max_degree: usize) -> SymFun {
   |                                   ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_degree`

warning: unused variable: `f`
  --> rustmath-symmetricfunctions/src/plethysm.rs:90:25
   |
90 | pub fn internal_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
   |                         ^ help: if this is intentional, prefix it with an underscore: `_f`

warning: unused variable: `g`
  --> rustmath-symmetricfunctions/src/plethysm.rs:90:37
   |
90 | pub fn internal_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
   |                                     ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `f`
   --> rustmath-symmetricfunctions/src/plethysm.rs:101:26
    |
101 | pub fn kronecker_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
    |                          ^ help: if this is intentional, prefix it with an underscore: `_f`

warning: unused variable: `g`
   --> rustmath-symmetricfunctions/src/plethysm.rs:101:38
    |
101 | pub fn kronecker_product(f: &SymFun, g: &SymFun) -> Option<SymFun> {
    |                                      ^ help: if this is intentional, prefix it with an underscore: `_g`

warning: unused variable: `lambda`
   --> rustmath-symmetricfunctions/src/plethysm.rs:110:32
    |
110 | pub fn schur_complete_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lambda`

warning: unused variable: `m`
   --> rustmath-symmetricfunctions/src/plethysm.rs:110:52
    |
110 | pub fn schur_complete_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                                    ^ help: if this is intentional, prefix it with an underscore: `_m`

warning: unused variable: `lambda`
   --> rustmath-symmetricfunctions/src/plethysm.rs:119:34
    |
119 | pub fn schur_elementary_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_lambda`

warning: unused variable: `m`
   --> rustmath-symmetricfunctions/src/plethysm.rs:119:54
    |
119 | pub fn schur_elementary_plethysm(lambda: &Partition, m: usize) -> SymFun {
    |                                                      ^ help: if this is intentional, prefix it with an underscore: `_m`

warning: unused variable: `n`
   --> rustmath-symmetricfunctions/src/ncsf.rs:265:13
    |
265 |         let n = I.sum();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
   --> rustmath-symmetricfunctions/src/qsym.rs:338:9
    |
338 |     let n: usize = parts.iter().sum();
    |         ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `n`
  --> rustmath-symmetricfunctions/src/super_schur.rs:76:9
   |
76 |     let n = shape.sum();
   |         ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:175:20
    |
175 | pub fn concatenate(I: &Composition, J: &Composition) -> Composition {
    |                    ^ help: convert the identifier to snake case (notice the capitalization): `i`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:175:37
    |
175 | pub fn concatenate(I: &Composition, J: &Composition) -> Composition {
    |                                     ^ help: convert the identifier to snake case: `j`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:218:10
    |
218 |     for (I, coeff_I) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `coeff_I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:218:13
    |
218 |     for (I, coeff_I) in &f.coeffs {
    |             ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `coeff_i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:219:14
    |
219 |         for (J, coeff_J) in &g.coeffs {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `coeff_J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:219:17
    |
219 |         for (J, coeff_J) in &g.coeffs {
    |                 ^^^^^^^ help: convert the identifier to snake case: `coeff_j`

warning: variable `IJ` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:220:17
    |
220 |             let IJ = concatenate(I, J);
    |                 ^^ help: convert the identifier to snake case: `ij`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:241:10
    |
241 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:242:14
    |
242 |         for (J, K) in composition_splits(I) {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `K` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:242:17
    |
242 |         for (J, K) in composition_splits(I) {
    |                 ^ help: convert the identifier to snake case (notice the capitalization): `k`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:264:10
    |
264 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J_comp` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:273:13
    |
273 |         let J_comp = I.clone(); // Placeholder - needs proper implementation
    |             ^^^^^^ help: convert the identifier to snake case: `j_comp`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:288:10
    |
288 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J_comp` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:289:13
    |
289 |         let J_comp = I.clone(); // Placeholder - needs proper implementation
    |             ^^^^^^ help: convert the identifier to snake case: `j_comp`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:307:10
    |
307 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:324:10
    |
324 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:389:10
    |
389 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:401:16
    |
401 | pub fn refines(J: &Composition, I: &Composition) -> bool {
    |                ^ help: convert the identifier to snake case: `j`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:401:33
    |
401 | pub fn refines(J: &Composition, I: &Composition) -> bool {
    |                                 ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:402:9
    |
402 |     let I_parts = I.parts();
    |         ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_parts`

warning: variable `J_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/ncsf.rs:403:9
    |
403 |     let J_parts = J.parts();
    |         ^^^^^^^ help: convert the identifier to snake case: `j_parts`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:235:10
    |
235 |     for (I, coeff_I) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `coeff_I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:235:13
    |
235 |     for (I, coeff_I) in &f.coeffs {
    |             ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `coeff_i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:236:14
    |
236 |         for (J, coeff_J) in &g.coeffs {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `coeff_J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:236:17
    |
236 |         for (J, coeff_J) in &g.coeffs {
    |                 ^^^^^^^ help: convert the identifier to snake case: `coeff_j`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:254:18
    |
254 | fn quasi_shuffle(I: &Composition, J: &Composition) -> Vec<Composition> {
    |                  ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:254:35
    |
254 | fn quasi_shuffle(I: &Composition, J: &Composition) -> Vec<Composition> {
    |                                   ^ help: convert the identifier to snake case: `j`

warning: variable `I_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:255:9
    |
255 |     let I_parts = I.parts();
    |         ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_parts`

warning: variable `J_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:256:9
    |
256 |     let J_parts = J.parts();
    |         ^^^^^^^ help: convert the identifier to snake case: `j_parts`

warning: variable `I_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:269:9
    |
269 |         I_parts: &[usize],
    |         ^^^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_parts`

warning: variable `J_parts` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:270:9
    |
270 |         J_parts: &[usize],
    |         ^^^^^^^ help: convert the identifier to snake case: `j_parts`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:321:10
    |
321 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:323:14
    |
323 |         for (J, K) in splits {
    |              ^ help: convert the identifier to snake case: `j`

warning: variable `K` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:323:17
    |
323 |         for (J, K) in splits {
    |                 ^ help: convert the identifier to snake case (notice the capitalization): `k`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:388:10
    |
388 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:408:10
    |
408 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I_len` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:409:13
    |
409 |         let I_len = I.length();
    |             ^^^^^ help: convert the identifier to snake case (notice the capitalization): `i_len`

warning: variable `J` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:412:13
    |
412 |         for J in refinements(I) {
    |             ^ help: convert the identifier to snake case: `j`

warning: variable `J_len` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:413:17
    |
413 |             let J_len = J.length();
    |                 ^^^^^ help: convert the identifier to snake case: `j_len`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:426:10
    |
426 |     for (I, coeff) in &f.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: variable `I` should have a snake case name
   --> rustmath-symmetricfunctions/src/qsym.rs:467:10
    |
467 |     for (I, f_coeff) in &f_mono.coeffs {
    |          ^ help: convert the identifier to snake case (notice the capitalization): `i`

warning: unused variable: `rank`
   --> rustmath-crystals/src/character.rs:139:47
    |
139 | pub fn weyl_character(highest_weight: Weight, rank: usize) -> Character {
    |                                               ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `hw_weight`
   --> rustmath-crystals/src/character.rs:155:13
    |
155 |         let hw_weight = crystal.weight(&hw);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_hw_weight`

warning: unused variable: `diff`
  --> rustmath-crystals/src/littelmann.rs:73:13
   |
73 |         let diff = v2 - v1;
   |             ^^^^ help: if this is intentional, prefix it with an underscore: `_diff`

warning: unused variable: `min_val`
   --> rustmath-crystals/src/littelmann.rs:185:23
    |
185 |         let (min_idx, min_val) = path.i_string_min(i, &self.root_system);
    |                       ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_val`

warning: unused variable: `tab`
   --> rustmath-crystals/src/kr_crystal.rs:222:32
    |
222 |             KRElement::Tableau(tab) => {
    |                                ^^^ help: if this is intentional, prefix it with an underscore: `_tab`

warning: unused variable: `i`
   --> rustmath-crystals/src/kr_crystal.rs:220:42
    |
220 |     fn apply_ei(&self, elem: &KRElement, i: usize) -> Option<KRElement> {
    |                                          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `tab`
   --> rustmath-crystals/src/kr_crystal.rs:235:32
    |
235 |             KRElement::Tableau(tab) => {
    |                                ^^^ help: if this is intentional, prefix it with an underscore: `_tab`

warning: unused variable: `i`
   --> rustmath-crystals/src/kr_crystal.rs:233:42
    |
233 |     fn apply_fi(&self, elem: &KRElement, i: usize) -> Option<KRElement> {
    |                                          ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `crystal`
   --> rustmath-crystals/src/kr_crystal.rs:308:24
    |
308 | pub fn energy_function(crystal: &KRCrystal, elem: &KRElement) -> i64 {
    |                        ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_crystal`

warning: unused variable: `elem`
   --> rustmath-crystals/src/kr_crystal.rs:308:45
    |
308 | pub fn energy_function(crystal: &KRCrystal, elem: &KRElement) -> i64 {
    |                                             ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`

warning: unused variable: `k`
  --> rustmath-crystals/src/nakajima.rs:70:19
   |
70 |         for (&(i, k), &exp) in &self.exponents {
   |                   ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `other_part`
   --> rustmath-crystals/src/rigged_configurations.rs:218:18
    |
218 |             for &other_part in &other_partition.parts {
    |                  ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_other_part`

warning: unused variable: `i`
   --> rustmath-crystals/src/rigged_configurations.rs:364:38
    |
364 | fn compute_epsilon_i(rc: &RCElement, i: usize) -> i64 {
    |                                      ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `rc`
   --> rustmath-crystals/src/rigged_configurations.rs:408:12
    |
408 | fn phi_map(rc: &RCElement, tensor_shape: &[(usize, usize)]) -> TensorProductImage {
    |            ^^ help: if this is intentional, prefix it with an underscore: `_rc`

warning: unused variable: `tp`
   --> rustmath-crystals/src/rigged_configurations.rs:429:16
    |
429 | fn phi_inverse(tp: &TensorProductImage, rank: usize) -> RCElement {
    |                ^^ help: if this is intentional, prefix it with an underscore: `_tp`

warning: unused variable: `tensor_shape`
   --> rustmath-crystals/src/rigged_configurations.rs:437:52
    |
437 | fn generate_all_rigged_configurations(rank: usize, tensor_shape: &[(usize, usize)]) -> Vec<RCElement> {
    |                                                    ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tensor_shape`

warning: unused variable: `highest_weight`
   --> rustmath-crystals/src/rigged_configurations.rs:523:29
    |
523 |     pub fn new(rank: usize, highest_weight: Weight) -> Self {
    |                             ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_highest_weight`

warning: unused variable: `node`
   --> rustmath-crystals/src/rigged_configurations.rs:544:22
    |
544 | fn build_kleber_tree(node: &mut KleberNode, rank: usize) {
    |                      ^^^^ help: if this is intentional, prefix it with an underscore: `_node`

warning: unused variable: `rank`
   --> rustmath-crystals/src/rigged_configurations.rs:544:45
    |
544 | fn build_kleber_tree(node: &mut KleberNode, rank: usize) {
    |                                             ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`

warning: unused variable: `rc`
   --> rustmath-crystals/src/rigged_configurations.rs:713:23
    |
713 |     pub fn e_0(&self, rc: &RCElement) -> Option<RCElement> {
    |                       ^^ help: if this is intentional, prefix it with an underscore: `_rc`

warning: unused variable: `rc`
   --> rustmath-crystals/src/rigged_configurations.rs:719:23
    |
719 |     pub fn f_0(&self, rc: &RCElement) -> Option<RCElement> {
    |                       ^^ help: if this is intentional, prefix it with an underscore: `_rc`

warning: unused import: `rustmath_core::Ring`
 --> rustmath-coding/src/linear_code.rs:5:5
  |
5 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `field_char`
   --> rustmath-coding/src/linear_code.rs:207:60
    |
207 |     fn compute_parity_check_matrix(generator: &[Vec<u64>], field_char: u64) -> Vec<Vec<u64>> {
    |                                                            ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_field_char`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p`
   --> rustmath-coding/src/reed_solomon.rs:103:13
    |
103 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
   --> rustmath-coding/src/reed_solomon.rs:165:13
    |
165 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `k`
  --> rustmath-coding/src/bch.rs:63:38
   |
63 |     pub fn with_parameters(n: usize, k: usize, delta: usize) -> Result<Self, String> {
   |                                      ^ help: if this is intentional, prefix it with an underscore: `_k`

warning: unused variable: `p`
   --> rustmath-coding/src/syndrome.rs:197:13
    |
197 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
   --> rustmath-coding/src/syndrome.rs:205:13
    |
205 |         let p = self.field_char;
    |             ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: field `eval_points` is never read
  --> rustmath-coding/src/reed_solomon.rs:23:5
   |
13 | pub struct ReedSolomonCode {
   |            --------------- field in this struct
...
23 |     eval_points: Vec<u64>,
   |     ^^^^^^^^^^^
   |
   = note: `ReedSolomonCode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: fields `m` and `field_char` are never read
  --> rustmath-coding/src/bch.rs:19:5
   |
11 | pub struct BCHCode {
   |            ------- fields in this struct
...
19 |     m: usize,
   |     ^
...
23 |     field_char: u64,
   |     ^^^^^^^^^^
   |
   = note: `BCHCode` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `field_char` is never read
  --> rustmath-coding/src/syndrome.rs:12:5
   |
 8 | pub struct SyndromeTable {
   |            ------------- field in this struct
...
12 |     field_char: u64,
   |     ^^^^^^^^^^
   |
   = note: `SyndromeTable` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: unused imports: `ManifoldError`, `ManifoldPoint`, `Result`, and `TopologicalManifold`
 --> rustmath-manifolds/src/vector_bundle.rs:7:13
  |
7 | use crate::{TopologicalManifold, ManifoldPoint, ManifoldError, Result};
  |             ^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `ManifoldPoint`
 --> rustmath-manifolds/src/vector_bundle_fiber.rs:7:13
  |
7 | use crate::{ManifoldPoint, ManifoldError, Result};
  |             ^^^^^^^^^^^^^

warning: unused import: `crate::chart::Chart`
 --> rustmath-manifolds/src/transition.rs:6:5
  |
6 | use crate::chart::Chart;
  |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
 --> rustmath-manifolds/src/transition.rs:9:5
  |
9 | use rustmath_matrix::Matrix;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::sync::Arc`
  --> rustmath-manifolds/src/transition.rs:12:5
   |
12 | use std::sync::Arc;
   |     ^^^^^^^^^^^^^^

warning: unused import: `std::hash::Hash`
  --> rustmath-manifolds/src/traits.rs:14:5
   |
14 | use std::hash::Hash;
   |     ^^^^^^^^^^^^^^^

warning: unused import: `crate::scalar_field::ScalarFieldEnhanced as ScalarField`
  --> rustmath-manifolds/src/diff_form.rs:14:5
   |
14 | use crate::scalar_field::ScalarFieldEnhanced as ScalarField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::scalar_field::ScalarFieldEnhanced`
 --> rustmath-manifolds/src/riemannian.rs:7:5
  |
7 | use crate::scalar_field::ScalarFieldEnhanced;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::diff_form::DiffForm`
  --> rustmath-manifolds/src/lie_group.rs:10:5
   |
10 | use crate::diff_form::DiffForm;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `TangentSpace`
  --> rustmath-manifolds/src/lie_algebra.rs:10:43
   |
10 | use crate::tangent_space::{TangentVector, TangentSpace};
   |                                           ^^^^^^^^^^^^

warning: unused import: `crate::chart::Chart`
  --> rustmath-manifolds/src/lie_algebra.rs:12:5
   |
12 | use crate::chart::Chart;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-manifolds/src/lie_algebra.rs:13:5
   |
13 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-manifolds/src/lie_algebra.rs:14:5
   |
14 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_symbolic::Expr`
  --> rustmath-manifolds/src/lie_algebra.rs:15:5
   |
15 | use rustmath_symbolic::Expr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-manifolds/src/lie_algebra.rs:17:5
   |
17 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::diff_form::DiffForm`
  --> rustmath-manifolds/src/fiber_bundles.rs:16:5
   |
16 | use crate::diff_form::DiffForm;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::scalar_field::ScalarFieldEnhanced as ScalarField`
  --> rustmath-manifolds/src/integration.rs:14:5
   |
14 | use crate::scalar_field::ScalarFieldEnhanced as ScalarField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_reals::Real`
  --> rustmath-manifolds/src/integration.rs:18:5
   |
18 | use rustmath_reals::Real;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
  --> rustmath-manifolds/src/integration.rs:20:5
   |
20 | use std::f64::consts::PI;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unnecessary parentheses around block return value
   --> rustmath-manifolds/src/integration.rs:571:25
    |
571 |                         ((2.0 * std::f64::consts::PI / val).sqrt() * (val / std::f64::consts::E).powf(val))
    |                         ^                                                                                 ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
571 -                         ((2.0 * std::f64::consts::PI / val).sqrt() * (val / std::f64::consts::E).powf(val))
571 +                         (2.0 * std::f64::consts::PI / val).sqrt() * (val / std::f64::consts::E).powf(val)
    |

warning: unnecessary parentheses around block return value
   --> rustmath-manifolds/src/integration.rs:580:25
    |
580 |                         ((2.0 * std::f64::consts::PI / x).sqrt() * (x / std::f64::consts::E).powf(x))
    |                         ^                                                                           ^
    |
help: remove these parentheses
    |
580 -                         ((2.0 * std::f64::consts::PI / x).sqrt() * (x / std::f64::consts::E).powf(x))
580 +                         (2.0 * std::f64::consts::PI / x).sqrt() * (x / std::f64::consts::E).powf(x)
    |

warning: unused import: `crate::tensor_field::TensorField`
  --> rustmath-manifolds/src/topology.rs:15:5
   |
15 | use crate::tensor_field::TensorField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_symbolic::Expr`
  --> rustmath-manifolds/src/topology.rs:17:5
   |
17 | use rustmath_symbolic::Expr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-manifolds/src/topology.rs:19:5
   |
19 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Covector`
  --> rustmath-manifolds/src/maps.rs:16:43
   |
16 | use crate::tangent_space::{TangentVector, Covector};
   |                                           ^^^^^^^^

warning: unused import: `ManifoldError`
 --> rustmath-manifolds/src/symmetries.rs:9:21
  |
9 | use crate::errors::{ManifoldError, Result};
  |                     ^^^^^^^^^^^^^

warning: unused import: `crate::ComplexManifold`
  --> rustmath-manifolds/src/symmetries.rs:10:5
   |
10 | use crate::ComplexManifold;
   |     ^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::maps::Diffeomorphism`
  --> rustmath-manifolds/src/symmetries.rs:16:5
   |
16 | use crate::maps::Diffeomorphism;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-manifolds/src/symmetries.rs:20:5
   |
20 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::f64::consts::PI`
  --> rustmath-manifolds/src/catalog.rs:17:5
   |
17 | use std::f64::consts::PI;
   |     ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::manifold::TopologicalManifold`
  --> rustmath-manifolds/src/complex_manifold.rs:23:5
   |
23 | use crate::manifold::TopologicalManifold;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CoordinateFunction`
  --> rustmath-manifolds/src/complex_manifold.rs:24:27
   |
24 | use crate::chart::{Chart, CoordinateFunction};
   |                           ^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-manifolds/src/almost_complex.rs:32:5
   |
32 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-manifolds/src/almost_complex.rs:33:5
   |
33 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tensor_field::TensorField`
  --> rustmath-manifolds/src/kahler.rs:29:5
   |
29 | use crate::tensor_field::TensorField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-manifolds/src/finsler.rs:32:5
   |
32 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tangent_space::TangentVector`
  --> rustmath-manifolds/src/subriemannian.rs:32:5
   |
32 | use crate::tangent_space::TangentVector;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::tensor_field::TensorField`
  --> rustmath-manifolds/src/spin.rs:37:5
   |
37 | use crate::tensor_field::TensorField;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_symbolic::Expr`
  --> rustmath-manifolds/src/spin.rs:38:5
   |
38 | use rustmath_symbolic::Expr;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `ManifoldError`
  --> rustmath-manifolds/src/dirac.rs:36:21
   |
36 | use crate::errors::{ManifoldError, Result};
   |                     ^^^^^^^^^^^^^

warning: unused import: `RiemannianMetric`
  --> rustmath-manifolds/src/dirac.rs:38:25
   |
38 | use crate::riemannian::{RiemannianMetric, LeviCivitaConnection};
   |                         ^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::NumericConversion`
 --> rustmath-manifolds/src/transition.rs:8:5
  |
8 | use rustmath_core::NumericConversion;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_core::NumericConversion`
  --> rustmath-manifolds/src/integration.rs:16:5
   |
16 | use rustmath_core::NumericConversion;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
  --> rustmath-manifolds/src/modules.rs:22:46
   |
22 | use rustmath_core::{Parent, ParentWithBasis, Ring};
   |                                              ^^^^

warning: unused variable: `expr`
   --> rustmath-manifolds/src/scalar_field.rs:119:13
    |
119 |         let expr = self.expr(chart)?;
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_expr`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `components`
   --> rustmath-manifolds/src/tensor_field.rs:233:13
    |
233 |         let components = self.components(chart)?;
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_components`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/tangent_space.rs:254:36
    |
254 |     pub fn coordinate_basis(&self, chart: &Chart) -> Vec<TangentVector> {
    |                                    ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `comps`
   --> rustmath-manifolds/src/riemannian.rs:213:13
    |
213 |         let comps = self.components(chart)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_comps`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/lie_group.rs:124:13
    |
124 |         let chart = self.manifold.default_chart()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/lie_group.rs:175:13
    |
175 |         let chart = self.manifold.default_chart()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `p`
   --> rustmath-manifolds/src/fiber_bundles.rs:392:41
    |
392 |     pub fn horizontal_projection(&self, p: &ManifoldPoint, v: &TangentVector) -> Result<TangentVector> {
    |                                         ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `tolerance`
   --> rustmath-manifolds/src/fiber_bundles.rs:463:27
    |
463 |     pub fn is_flat(&self, tolerance: f64) -> Result<bool> {
    |                           ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
463 |     pub fn is_flat(&self, _tolerance: f64) -> Result<bool> {
    |                           +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
    |
463 -     pub fn is_flat(&self, tolerance: f64) -> Result<bool> {
463 +     pub fn is_flat(&self, tensor_field::TensorField::is_approximately_zero::EPSILON: f64) -> Result<bool> {
    |

warning: unused variable: `factorial`
   --> rustmath-manifolds/src/symplectic.rs:315:13
    |
315 |         let factorial = (1..=n).product::<usize>() as f64;
    |             ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
315 |         let _factorial = (1..=n).product::<usize>() as f64;
    |             +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
    |
315 -         let factorial = (1..=n).product::<usize>() as f64;
315 +         let tensor_field::TensorField::is_approximately_zero::EPSILON = (1..=n).product::<usize>() as f64;
    |

warning: unused variable: `dh`
   --> rustmath-manifolds/src/symplectic.rs:363:13
    |
363 |         let dh = hamiltonian.differential(chart)?;
    |             ^^ help: if this is intentional, prefix it with an underscore: `_dh`

warning: unused variable: `term1`
   --> rustmath-manifolds/src/symplectic.rs:461:13
    |
461 |         let term1 = self.bracket(f, &gh)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_term1`

warning: unused variable: `term2`
   --> rustmath-manifolds/src/symplectic.rs:462:13
    |
462 |         let term2 = self.bracket(g, &hf)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_term2`

warning: unused variable: `term3`
   --> rustmath-manifolds/src/symplectic.rs:463:13
    |
463 |         let term3 = self.bracket(h, &fg)?;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_term3`

warning: unused variable: `n`
   --> rustmath-manifolds/src/integration.rs:302:13
    |
302 |         let n = form.manifold().dimension();
    |             ^ help: if this is intentional, prefix it with an underscore: `_n`

warning: unused variable: `remaining_bounds`
   --> rustmath-manifolds/src/integration.rs:664:9
    |
664 |     let remaining_bounds = &bounds[1..];
    |         ^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_remaining_bounds`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/topology.rs:349:60
    |
349 |     pub fn from_curvature(&mut self, curvature: &DiffForm, chart: &Chart) -> Result<()> {
    |                                                            ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `metric`
   --> rustmath-manifolds/src/topology.rs:537:9
    |
537 |         metric: &RiemannianMetric,
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_metric`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/topology.rs:538:9
    |
538 |         chart: &Chart,
    |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `jacobian`
   --> rustmath-manifolds/src/maps.rs:146:13
    |
146 |         let jacobian = self.jacobian(source_chart, target_chart)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian`

warning: unused variable: `point_coords`
   --> rustmath-manifolds/src/maps.rs:144:9
    |
144 |         point_coords: &[f64],
    |         ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_point_coords`

warning: unused variable: `v_components`
   --> rustmath-manifolds/src/maps.rs:183:13
    |
183 |         let v_components = vector.components();
    |             ^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_v_components`

warning: unused variable: `row`
   --> rustmath-manifolds/src/maps.rs:187:13
    |
187 |         for row in jacobian.iter() {
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_row`

warning: unused variable: `jacobian`
   --> rustmath-manifolds/src/maps.rs:390:13
    |
390 |         let jacobian = map.jacobian(source_chart, target_chart)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian`

warning: unused variable: `n_source`
   --> rustmath-manifolds/src/maps.rs:399:13
    |
399 |         let n_source = self.map.source.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_source`

warning: unused variable: `n_target`
   --> rustmath-manifolds/src/maps.rs:400:13
    |
400 |         let n_target = self.map.target.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_target`

warning: unused variable: `jacobian`
   --> rustmath-manifolds/src/maps.rs:473:13
    |
473 |         let jacobian = map.jacobian(source_chart, target_chart)?;
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_jacobian`

warning: unused variable: `n_source`
   --> rustmath-manifolds/src/maps.rs:482:13
    |
482 |         let n_source = self.map.source.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_source`

warning: unused variable: `n_target`
   --> rustmath-manifolds/src/maps.rs:483:13
    |
483 |         let n_target = self.map.target.dimension();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_n_target`

warning: unused variable: `inv_self`
   --> rustmath-manifolds/src/maps.rs:747:19
    |
747 |             (Some(inv_self), Some(inv_other)) => {
    |                   ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inv_self`

warning: unused variable: `inv_other`
   --> rustmath-manifolds/src/maps.rs:747:35
    |
747 |             (Some(inv_self), Some(inv_other)) => {
    |                                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_inv_other`

warning: variable does not need to be mutable
   --> rustmath-manifolds/src/maps.rs:748:21
    |
748 |                 let mut inv = SmoothMap::new(
    |                     ----^^^
    |                     |
    |                     help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `tolerance`
  --> rustmath-manifolds/src/symmetries.rs:82:45
   |
82 |     pub fn verify(&mut self, chart: &Chart, tolerance: f64) -> Result<bool> {
   |                                             ^^^^^^^^^
   |
help: if this is intentional, prefix it with an underscore
   |
82 |     pub fn verify(&mut self, chart: &Chart, _tolerance: f64) -> Result<bool> {
   |                                             +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
   |
82 -     pub fn verify(&mut self, chart: &Chart, tolerance: f64) -> Result<bool> {
82 +     pub fn verify(&mut self, chart: &Chart, tensor_field::TensorField::is_approximately_zero::EPSILON: f64) -> Result<bool> {
   |

warning: unused variable: `tolerance`
   --> rustmath-manifolds/src/symmetries.rs:166:76
    |
166 |     pub fn commutes_with(&self, other: &KillingVectorField, chart: &Chart, tolerance: f64) -> Result<bool> {
    |                                                                            ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
166 |     pub fn commutes_with(&self, other: &KillingVectorField, chart: &Chart, _tolerance: f64) -> Result<bool> {
    |                                                                            +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
    |
166 -     pub fn commutes_with(&self, other: &KillingVectorField, chart: &Chart, tolerance: f64) -> Result<bool> {
166 +     pub fn commutes_with(&self, other: &KillingVectorField, chart: &Chart, tensor_field::TensorField::is_approximately_zero::EPSILON: f64) -> Result<bool> {
    |

warning: unused variable: `expected`
   --> rustmath-manifolds/src/symmetries.rs:282:21
    |
282 |                 let expected = lambda.clone() * g_comps[i][j].clone();
    |                     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_expected`

warning: unused variable: `actual`
   --> rustmath-manifolds/src/symmetries.rs:283:21
    |
283 |                 let actual = &lie_comps[idx];
    |                     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_actual`

warning: unused variable: `tolerance`
   --> rustmath-manifolds/src/symmetries.rs:233:45
    |
233 |     pub fn verify(&mut self, chart: &Chart, tolerance: f64) -> Result<bool> {
    |                                             ^^^^^^^^^
    |
help: if this is intentional, prefix it with an underscore
    |
233 |     pub fn verify(&mut self, chart: &Chart, _tolerance: f64) -> Result<bool> {
    |                                             +
help: you might have meant to pattern match on the similarly named constant `EPSILON`
    |
233 -     pub fn verify(&mut self, chart: &Chart, tolerance: f64) -> Result<bool> {
233 +     pub fn verify(&mut self, chart: &Chart, tensor_field::TensorField::is_approximately_zero::EPSILON: f64) -> Result<bool> {
    |

warning: unused variable: `factor`
   --> rustmath-manifolds/src/symmetries.rs:298:21
    |
298 |         if let Some(factor) = &self.conformal_factor {
    |                     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_factor`

warning: unused variable: `bracket`
   --> rustmath-manifolds/src/symmetries.rs:408:21
    |
408 |                 let bracket = self.killing_fields[i].lie_bracket(&self.killing_fields[j], chart)?;
    |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bracket`

warning: variable does not need to be mutable
   --> rustmath-manifolds/src/symmetries.rs:403:13
    |
403 |         let mut constants = vec![vec![vec![0.0; n]; n]; n];
    |             ----^^^^^^^^^
    |             |
    |             help: remove this `mut`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/catalog.rs:109:32
    |
109 |     pub fn is_spacelike(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                                ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `vector_components`
   --> rustmath-manifolds/src/catalog.rs:109:47
    |
109 |     pub fn is_spacelike(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                                               ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vector_components`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/catalog.rs:115:27
    |
115 |     pub fn is_null(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `vector_components`
   --> rustmath-manifolds/src/catalog.rs:115:42
    |
115 |     pub fn is_null(&self, chart: &Chart, vector_components: &[Expr]) -> Result<bool> {
    |                                          ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_vector_components`

warning: unused variable: `t`
   --> rustmath-manifolds/src/catalog.rs:181:13
    |
181 |         let t = chart.coordinate_symbol(0);
    |             ^ help: if this is intentional, prefix it with an underscore: `_t`

warning: unused variable: `phi`
   --> rustmath-manifolds/src/catalog.rs:184:13
    |
184 |         let phi = chart.coordinate_symbol(3);
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_phi`

warning: unused variable: `delta`
   --> rustmath-manifolds/src/catalog.rs:336:13
    |
336 |         let delta = r_expr.clone() * r_expr.clone()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_delta`

warning: unused variable: `sigma`
   --> rustmath-manifolds/src/catalog.rs:342:13
    |
342 |         let sigma = r_expr.clone() * r_expr.clone()
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_sigma`

warning: unused variable: `sin_squared`
   --> rustmath-manifolds/src/catalog.rs:347:13
    |
347 |         let sin_squared = sin_theta.clone() * sin_theta;
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_sin_squared`

warning: unused variable: `expr`
   --> rustmath-manifolds/src/complex_manifold.rs:332:25
    |
332 |             if let Some(expr) = self.chart_expressions.get(chart.name()) {
    |                         ^^^^ help: if this is intentional, prefix it with an underscore: `_expr`

warning: unused variable: `point`
   --> rustmath-manifolds/src/complex_manifold.rs:329:27
    |
329 |     pub fn eval_at(&self, point: &ManifoldPoint) -> Result<Complex> {
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_point`

warning: unused variable: `chart`
   --> rustmath-manifolds/src/complex_manifold.rs:349:30
    |
349 |     pub fn derivative(&self, chart: &ComplexChart) -> Option<HolomorphicFunction> {
    |                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_chart`

warning: unused variable: `metric`
   --> rustmath-manifolds/src/almost_complex.rs:248:45
    |
248 |     pub fn is_compatible_with_metric(&self, metric: &RiemannianMetric) -> bool {
    |                                             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_metric`

warning: unused variable: `metric`
   --> rustmath-manifolds/src/kahler.rs:113:9
    |
113 |         metric: &RiemannianMetric,
    |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_metric`

warning: unused variable: `point`
   --> rustmath-manifolds/src/finsler.rs:124:24
    |
124 |     pub fn eval(&self, point: &ManifoldPoint, tangent_vector: &TangentVector) -> Result<f64> {
    |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_point`

warning: unused variable: `tangent_vector`
   --> rustmath-manifolds/src/finsler.rs:124:47
    |
124 |     pub fn eval(&self, point: &ManifoldPoint, tangent_vector: &TangentVector) -> Result<f64> {
    |                                               ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_tangent_vector`

warning: unused variable: `bracket`
   --> rustmath-manifolds/src/subriemannian.rs:115:21
    |
115 |                 let bracket = self.frame[i].lie_bracket(&self.frame[j], chart)?;
    |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_bracket`

warning: unused variable: `p`
   --> rustmath-manifolds/src/subriemannian.rs:290:28
    |
290 |     pub fn distance(&self, p: &ManifoldPoint, q: &ManifoldPoint) -> Result<f64> {
    |                            ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `q`
   --> rustmath-manifolds/src/subriemannian.rs:290:47
    |
290 |     pub fn distance(&self, p: &ManifoldPoint, q: &ManifoldPoint) -> Result<f64> {
    |                                               ^ help: if this is intentional, prefix it with an underscore: `_q`

warning: unused variable: `spinor`
  --> rustmath-manifolds/src/dirac.rs:81:25
   |
81 |     pub fn apply(&self, spinor: &SpinorField) -> Result<SpinorField> {
   |                         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_spinor`

warning: field `inverse_jacobian` is never read
  --> rustmath-manifolds/src/transition.rs:41:5
   |
28 | pub struct TransitionFunction {
   |            ------------------ field in this struct
...
41 |     inverse_jacobian: Option<Vec<Vec<Expr>>>,
   |     ^^^^^^^^^^^^^^^^
   |
   = note: `TransitionFunction` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `name` is never read
  --> rustmath-manifolds/src/tensor_field.rs:78:5
   |
67 | pub struct TensorField {
   |            ----------- field in this struct
...
78 |     name: Option<String>,
   |     ^^^^
   |
   = note: `TensorField` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: field `manifold` is never read
   --> rustmath-manifolds/src/tangent_space.rs:290:5
    |
284 | pub struct Covector {
    |            -------- field in this struct
...
290 |     manifold: Arc<DifferentiableManifold>,
    |     ^^^^^^^^
    |
    = note: `Covector` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `cache` is never read
  --> rustmath-manifolds/src/modules.rs:56:5
   |
52 | pub struct DiffScalarFieldAlgebra {
   |            ---------------------- field in this struct
...
56 |     cache: HashMap<String, ScalarFieldEnhanced>,
   |     ^^^^^
   |
   = note: `DiffScalarFieldAlgebra` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `name` is never read
   --> rustmath-manifolds/src/riemannian.rs:259:5
    |
252 | pub struct AffineConnection {
    |            ---------------- field in this struct
...
259 |     name: Option<String>,
    |     ^^^^
    |
    = note: `AffineConnection` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `riemann` is never read
   --> rustmath-manifolds/src/riemannian.rs:459:5
    |
457 | pub struct RicciTensor {
    |            ----------- field in this struct
458 |     /// The Riemann tensor
459 |     riemann: Arc<RiemannTensor>,
    |     ^^^^^^^
    |
    = note: `RicciTensor` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `ricci` and `metric` are never read
   --> rustmath-manifolds/src/riemannian.rs:492:5
    |
490 | pub struct ScalarCurvature {
    |            --------------- fields in this struct
491 |     /// The Ricci tensor
492 |     ricci: Arc<RicciTensor>,
    |     ^^^^^
493 |     /// The metric
494 |     metric: Arc<RiemannianMetric>,
    |     ^^^^^^
    |
    = note: `ScalarCurvature` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `connection` is never read
   --> rustmath-manifolds/src/riemannian.rs:538:5
    |
534 | pub struct Geodesic {
    |            -------- field in this struct
...
538 |     connection: Arc<AffineConnection>,
    |     ^^^^^^^^^^
    |
    = note: `Geodesic` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `connection` is never read
   --> rustmath-manifolds/src/riemannian.rs:617:5
    |
615 | pub struct ParallelTransport {
    |            ----------------- field in this struct
616 |     /// The connection
617 |     connection: Arc<AffineConnection>,
    |     ^^^^^^^^^^

warning: fields `left_translation_cache` and `right_translation_cache` are never read
  --> rustmath-manifolds/src/lie_group.rs:48:5
   |
32 | pub struct LieGroup {
   |            -------- fields in this struct
...
48 |     left_translation_cache: Arc<std::sync::RwLock<HashMap<String, Box<dyn Fn(&ManifoldPoint) -> Result<ManifoldPoint> + ...
   |     ^^^^^^^^^^^^^^^^^^^^^^
...
51 |     right_translation_cache: Arc<std::sync::RwLock<HashMap<String, Box<dyn Fn(&ManifoldPoint) -> Result<ManifoldPoint> +...
   |     ^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `LieGroup` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `basis` is never read
  --> rustmath-manifolds/src/lie_algebra.rs:41:5
   |
32 | pub struct LieAlgebra {
   |            ---------- field in this struct
...
41 |     basis: Vec<TangentVector>,
   |     ^^^^^
   |
   = note: `LieAlgebra` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `name`, `domain_in_base`, `chart`, `trivialization_map`, and `inverse_map` are never read
  --> rustmath-manifolds/src/fiber_bundles.rs:56:5
   |
54 | pub struct Trivialization {
   |            -------------- fields in this struct
55 |     /// Name of the trivialization
56 |     name: String,
   |     ^^^^
...
59 |     domain_in_base: Vec<ManifoldPoint>,
   |     ^^^^^^^^^^^^^^
...
62 |     chart: Chart,
   |     ^^^^^
...
65 |     trivialization_map: Arc<dyn Fn(&ManifoldPoint) -> Result<(ManifoldPoint, ManifoldPoint)> + Send + Sync>,
   |     ^^^^^^^^^^^^^^^^^^
...
68 |     inverse_map: Arc<dyn Fn(&ManifoldPoint, &ManifoldPoint) -> Result<ManifoldPoint> + Send + Sync>,
   |     ^^^^^^^^^^^
   |
   = note: `Trivialization` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `symplectic_manifold` is never read
   --> rustmath-manifolds/src/symplectic.rs:339:5
    |
337 | pub struct HamiltonianVectorField {
    |            ---------------------- field in this struct
338 |     /// The symplectic manifold
339 |     symplectic_manifold: SymplecticManifold,
    |     ^^^^^^^^^^^^^^^^^^^
    |
    = note: `HamiltonianVectorField` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: function `adaptive_simpson` is never used
   --> rustmath-manifolds/src/integration.rs:721:4
    |
721 | fn adaptive_simpson(
    |    ^^^^^^^^^^^^^^^^

warning: function `adaptive_simpson_recursive` is never used
   --> rustmath-manifolds/src/integration.rs:732:4
    |
732 | fn adaptive_simpson_recursive(
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `gauss_legendre_1d` is never used
   --> rustmath-manifolds/src/integration.rs:787:4
    |
787 | fn gauss_legendre_1d(integrand: &Expr, chart: &Chart, a: f64, b: f64) -> Result<f64> {
    |    ^^^^^^^^^^^^^^^^^

warning: function `monte_carlo_integration` is never used
   --> rustmath-manifolds/src/integration.rs:822:4
    |
822 | fn monte_carlo_integration(
    |    ^^^^^^^^^^^^^^^^^^^^^^^

warning: field `manifold` is never read
   --> rustmath-manifolds/src/topology.rs:126:5
    |
124 | pub struct BettiNumber {
    |            ----------- field in this struct
125 |     /// The underlying manifold
126 |     manifold: Arc<DifferentiableManifold>,
    |     ^^^^^^^^
    |
    = note: `BettiNumber` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `manifold` is never read
   --> rustmath-manifolds/src/topology.rs:206:5
    |
204 | pub struct EulerCharacteristic {
    |            ------------------- field in this struct
205 |     /// The underlying manifold
206 |     manifold: Arc<DifferentiableManifold>,
    |     ^^^^^^^^
    |
    = note: `EulerCharacteristic` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `manifold` and `rank` are never read
   --> rustmath-manifolds/src/topology.rs:302:5
    |
300 | pub struct ChernClass {
    |            ---------- fields in this struct
301 |     /// The base manifold
302 |     manifold: Arc<DifferentiableManifold>,
    |     ^^^^^^^^
303 |     /// Rank of the vector bundle
304 |     rank: usize,
    |     ^^^^
    |
    = note: `ChernClass` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: fields `manifold` and `rank` are never read
   --> rustmath-manifolds/src/topology.rs:394:5
    |
392 | pub struct PontryaginClass {
    |            --------------- fields in this struct
393 |     /// The base manifold
394 |     manifold: Arc<DifferentiableManifold>,
    |     ^^^^^^^^
395 |     /// Rank of the vector bundle
396 |     rank: usize,
    |     ^^^^
    |
    = note: `PontryaginClass` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `manifold` is never read
   --> rustmath-manifolds/src/topology.rs:480:5
    |
478 | pub struct EulerClass {
    |            ---------- field in this struct
479 |     /// The base manifold
480 |     manifold: Arc<DifferentiableManifold>,
    |     ^^^^^^^^
    |
    = note: `EulerClass` has a derived impl for the trait `Clone`, but this is intentionally ignored during dead code analysis

warning: field `dimension` is never read
  --> rustmath-manifolds/src/spin.rs:92:5
   |
86 | pub struct SpinStructure {
   |            ------------- field in this struct
...
92 |     dimension: usize,
   |     ^^^^^^^^^
   |
   = note: `SpinStructure` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: fields `clifford` and `connection` are never read
  --> rustmath-manifolds/src/dirac.rs:53:5
   |
47 | pub struct DiracOperator {
   |            ------------- fields in this struct
...
53 |     clifford: CliffordMultiplication,
   |     ^^^^^^^^
54 |     /// The spinor connection
55 |     connection: SpinorConnection,
   |     ^^^^^^^^^^
   |
   = note: `DiracOperator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `levi_civita` is never read
   --> rustmath-manifolds/src/dirac.rs:141:5
    |
139 | pub struct SpinorConnection {
    |            ---------------- field in this struct
140 |     /// The underlying Levi-Civita connection
141 |     levi_civita: LeviCivitaConnection,
    |     ^^^^^^^^^^^
    |
    = note: `SpinorConnection` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base_dirac` is never read
   --> rustmath-manifolds/src/dirac.rs:206:5
    |
204 | pub struct TwistedDiracOperator {
    |            -------------------- field in this struct
205 |     /// The base Dirac operator
206 |     base_dirac: DiracOperator,
    |     ^^^^^^^^^^
    |
    = note: `TwistedDiracOperator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `dirac` is never read
   --> rustmath-manifolds/src/dirac.rs:264:5
    |
262 | pub struct DiracHeatKernel {
    |            --------------- field in this struct
263 |     /// The Dirac operator
264 |     dirac: Arc<DiracOperator>,
    |     ^^^^^

warning: unused variable: `precision`
  --> rustmath-algebraic/src/algebraic_number.rs:51:30
   |
51 |     pub fn to_complex(&self, precision: usize) -> Complex {
   |                              ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `precision`
   --> rustmath-algebraic/src/algebraic_real.rs:149:26
    |
149 |     pub fn to_f64(&self, precision: usize) -> f64 {
    |                          ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`

warning: unused variable: `min_poly`
  --> rustmath-algebraic/src/conjugates.rs:18:9
   |
18 |     let min_poly = minimal_polynomial(alpha);
   |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_poly`

warning: `rustmath-groups` (lib) generated 54 warnings (run `cargo fix --lib -p rustmath-groups` to apply 22 suggestions)
warning: `rustmath-rings` (lib) generated 103 warnings
warning: `rustmath-liealgebras` (lib) generated 69 warnings (run `cargo fix --lib -p rustmath-liealgebras` to apply 34 suggestions)
warning: `rustmath-geometry` (lib) generated 4 warnings (run `cargo fix --lib -p rustmath-geometry` to apply 1 suggestion)
warning: `rustmath-symmetricfunctions` (lib) generated 56 warnings
warning: `rustmath-crystals` (lib) generated 21 warnings
warning: `rustmath-coding` (lib) generated 10 warnings
warning: `rustmath-manifolds` (lib) generated 130 warnings (run `cargo fix --lib -p rustmath-manifolds` to apply 48 suggestions)
warning: `rustmath-algebraic` (lib) generated 3 warnings
   Compiling rustmath-category v0.1.0 (/home/john/RustMath/rustmath-category)
warning: unused import: `MathError`
  --> rustmath-schemes/src/generic/mod.rs:52:21
   |
52 | use rustmath_core::{MathError, Result, Ring};
   |                     ^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `DimensionTheory`
  --> rustmath-schemes/src/affine/mod.rs:59:59
   |
59 | use crate::generic::{Scheme, SchemeMorphism, SchemePoint, DimensionTheory, Separated};
   |                                                           ^^^^^^^^^^^^^^^

warning: unused import: `std::fmt`
  --> rustmath-schemes/src/affine/mod.rs:60:5
   |
60 | use std::fmt;
   |     ^^^^^^^^

warning: unused import: `ToPrimitive`
  --> rustmath-schemes/src/elliptic_curves/isogeny.rs:75:23
   |
75 | use num_traits::{One, ToPrimitive, Zero};
   |                       ^^^^^^^^^^^

warning: unused import: `num_bigint::BigInt`
  --> rustmath-schemes/src/elliptic_curves/heegner.rs:77:5
   |
77 | use num_bigint::BigInt;
   |     ^^^^^^^^^^^^^^^^^^

warning: unused import: `One`
  --> rustmath-schemes/src/elliptic_curves/heegner.rs:79:24
   |
79 | use num_traits::{Zero, One, Signed, ToPrimitive};
   |                        ^^^

warning: unused import: `ToPrimitive`
  --> rustmath-schemes/src/elliptic_curves/rational.rs:71:37
   |
71 | use num_traits::{One, Zero, Signed, ToPrimitive};
   |                                     ^^^^^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-schemes/src/elliptic_curves/rational.rs:76:5
   |
76 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `rustmath_rationals::Rational`
  --> rustmath-schemes/src/elliptic_curves/rational.rs:77:5
   |
77 | use rustmath_rationals::Rational;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
   --> rustmath-schemes/src/elliptic_curves/mod.rs:184:28
    |
184 | use rustmath_core::{Field, Ring};
    |                            ^^^^

warning: unused import: `crate::projective_space::ProjectiveSpace`
  --> rustmath-schemes/src/line_bundle.rs:17:5
   |
17 | use crate::projective_space::ProjectiveSpace;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `Zero`
  --> rustmath-schemes/src/segre.rs:27:18
   |
27 | use num_traits::{Zero, One};
   |                  ^^^^

warning: unused import: `Zero`
  --> rustmath-schemes/src/veronese.rs:27:18
   |
27 | use num_traits::{Zero, One};
   |                  ^^^^

warning: unused import: `Signed`
  --> rustmath-schemes/src/elliptic_curves/chabauty.rs:77:29
   |
77 | use num_traits::{Zero, One, Signed, ToPrimitive};
   |                             ^^^^^^

warning: unused import: `Signed`
  --> rustmath-schemes/src/elliptic_curves/heegner.rs:79:29
   |
79 | use num_traits::{Zero, One, Signed, ToPrimitive};
   |                             ^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-schemes/src/elliptic_curves/rational.rs:72:5
   |
72 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^

warning: unused variable: `n`
  --> rustmath-schemes/src/affine/mod.rs:96:25
   |
96 |     pub fn affine_space(n: usize, base_ring: R) -> Self {
   |                         ^ help: if this is intentional, prefix it with an underscore: `_n`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: function cannot return without recursing
  --> rustmath-schemes/src/projective/mod.rs:82:5
   |
82 |     fn base_ring(&self) -> &Self::BaseRing {
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing
83 |         self.base_ring()
   |         ---------------- recursive call site
   |
   = help: a `loop` may express intention better if this is on purpose
   = note: `#[warn(unconditional_recursion)]` on by default

warning: function cannot return without recursing
   --> rustmath-schemes/src/projective/mod.rs:120:5
    |
120 |     fn base_ring(&self) -> &Self::BaseRing {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing
121 |         self.base_ring()
    |         ---------------- recursive call site
    |
    = help: a `loop` may express intention better if this is on purpose

warning: unused variable: `curve`
   --> rustmath-schemes/src/elliptic_curves/isogeny.rs:519:27
    |
519 |     fn find_ell_isogenies(curve: &EllipticCurve, ell: usize) -> Vec<Isogeny> {
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_curve`

warning: unused variable: `ell`
   --> rustmath-schemes/src/elliptic_curves/isogeny.rs:519:50
    |
519 |     fn find_ell_isogenies(curve: &EllipticCurve, ell: usize) -> Vec<Isogeny> {
    |                                                  ^^^ help: if this is intentional, prefix it with an underscore: `_ell`

warning: unused variable: `disc_abs`
   --> rustmath-schemes/src/elliptic_curves/rational.rs:354:13
    |
354 |         let disc_abs = self.discriminant.abs();
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_disc_abs`

warning: unused variable: `v_p_disc`
   --> rustmath-schemes/src/elliptic_curves/rational.rs:400:13
    |
400 |         let v_p_disc = self.valuation(p, &self.discriminant);
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_v_p_disc`

warning: unused variable: `coleman`
   --> rustmath-schemes/src/elliptic_curves/chabauty.rs:344:13
    |
344 |         let coleman = ColemanIntegral::new(self.prime.clone(), self.precision);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_coleman`

warning: variable does not need to be mutable
   --> rustmath-schemes/src/elliptic_curves/chabauty.rs:341:13
    |
341 |         let mut points = vec![RationalPoint::infinity()];
    |             ----^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `dim`
   --> rustmath-schemes/src/line_bundle.rs:136:21
    |
136 |         if let Some(dim) = self.scheme.dimension() {
    |                     ^^^ help: if this is intentional, prefix it with an underscore: `_dim`

warning: unused variable: `denom`
   --> rustmath-schemes/src/proj.rs:165:13
    |
165 |         let denom = &homogeneous[self.index];
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_denom`

warning: field `curve` is never read
   --> rustmath-schemes/src/elliptic_curves/mod.rs:195:5
    |
194 | pub struct TorsionSubgroup<F: Field> {
    |            --------------- field in this struct
195 |     curve: EllipticCurve<F>,
    |     ^^^^^
    |
    = note: `TorsionSubgroup` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: fields `v` and `w` are never read
   --> rustmath-schemes/src/elliptic_curves/isogeny.rs:98:5
    |
 88 | pub struct Isogeny {
    |            ------- fields in this struct
...
 98 |     v: BigRational,
    |     ^
 99 |     /// Vlu's w coefficient
100 |     w: BigRational,
    |     ^
    |
    = note: `Isogeny` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `heights_cache` is never read
   --> rustmath-schemes/src/elliptic_curves/heegner.rs:518:5
    |
516 | pub struct HeightPairing {
    |            ------------- field in this struct
517 |     /// Cached heights of points
518 |     heights_cache: HashMap<String, CanonicalHeight>,
    |     ^^^^^^^^^^^^^
    |
    = note: `HeightPairing` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: fields `prime` and `precision` are never read
  --> rustmath-schemes/src/elliptic_curves/chabauty.rs:88:5
   |
86 | pub struct ColemanIntegral {
   |            --------------- fields in this struct
87 |     /// The prime p for p-adic analysis
88 |     prime: BigInt,
   |     ^^^^^
89 |     /// Precision for p-adic computations
90 |     precision: usize,
   |     ^^^^^^^^^

warning: methods `padic_log` and `frobenius_lift` are never used
   --> rustmath-schemes/src/elliptic_curves/chabauty.rs:141:8
    |
 93 | impl ColemanIntegral {
    | -------------------- methods in this implementation
...
141 |     fn padic_log(&self, _x: &BigRational) -> BigRational {
    |        ^^^^^^^^^
...
150 |     fn frobenius_lift(&self, _point: &RationalPoint) -> RationalPoint {
    |        ^^^^^^^^^^^^^^

warning: methods `find_two_torsion` and `is_rational_point` are never used
   --> rustmath-schemes/src/elliptic_curves/chabauty.rs:304:8
    |
173 | impl ChabautyColeman {
    | -------------------- methods in this implementation
...
304 |     fn find_two_torsion(&self) -> Vec<RationalPoint> {
    |        ^^^^^^^^^^^^^^^^
...
407 |     fn is_rational_point(&self, point: &RationalPoint) -> bool {
    |        ^^^^^^^^^^^^^^^^^

warning: associated function `poly_add` is never used
   --> rustmath-schemes/src/elliptic_curves/chabauty.rs:617:8
    |
480 | impl DivisionPolynomials {
    | ------------------------ associated function in this implementation
...
617 |     fn poly_add(p: &[BigRational], q: &[BigRational]) -> Vec<BigRational> {
    |        ^^^^^^^^

warning: methods `padic_height` and `padic_height_pairing` are never used
    --> rustmath-schemes/src/elliptic_curves/chabauty.rs:1097:8
     |
 904 | impl QuadraticChabauty {
     | ---------------------- methods in this implementation
...
1097 |     fn padic_height(&self, _point: &RationalPoint) -> BigRational {
     |        ^^^^^^^^^^^^
...
1105 |     fn padic_height_pairing(
     |        ^^^^^^^^^^^^^^^^^^^^

warning: field `morphism` is never read
   --> rustmath-schemes/src/projective_morphism.rs:265:5
    |
263 | pub struct BaseLocus<R: Ring> {
    |            --------- field in this struct
264 |     /// The morphism
265 |     morphism: ProjectiveMorphism<R>,
    |     ^^^^^^^^
    |
    = note: `BaseLocus` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis

warning: comparison is useless due to type limits
  --> rustmath-schemes/src/graded_ring.rs:64:41
   |
64 |         self.components.keys().all(|&d| d >= 0)
   |                                         ^^^^^^
   |
   = note: `#[warn(unused_comparisons)]` on by default

warning: unused variable: `face_idx`
   --> rustmath-plot3d/src/export.rs:209:10
    |
209 |     for (face_idx, face) in mesh.faces.iter().enumerate() {
    |          ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_face_idx`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `crate::lie_conformal_algebra::GeneratorIndex`
  --> rustmath-lieconformal/src/lie_conformal_algebra_element.rs:14:5
   |
14 | use crate::lie_conformal_algebra::GeneratorIndex;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `std::collections::HashMap`
  --> rustmath-lieconformal/src/graded_lie_conformal_algebra.rs:13:5
   |
13 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `GeneratorIndex`
  --> rustmath-lieconformal/src/graded_lie_conformal_algebra.rs:15:57
   |
15 | use crate::lie_conformal_algebra::{LieConformalAlgebra, GeneratorIndex};
   |                                                         ^^^^^^^^^^^^^^

warning: unused import: `crate::lie_conformal_algebra_element::LieConformalAlgebraElement`
  --> rustmath-lieconformal/src/graded_lie_conformal_algebra.rs:16:5
   |
16 | use crate::lie_conformal_algebra_element::LieConformalAlgebraElement;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `LambdaBracket`
  --> rustmath-lieconformal/src/lie_conformal_algebra_with_basis.rs:12:57
   |
12 | use crate::lie_conformal_algebra::{LieConformalAlgebra, LambdaBracket, GeneratorIndex};
   |                                                         ^^^^^^^^^^^^^

warning: unused variable: `degree`
   --> rustmath-lieconformal/src/graded_lie_conformal_algebra.rs:121:37
    |
121 |     fn homogeneous_component(&self, degree: Degree) -> Vec<Self::Element> {
    |                                     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `a`
   --> rustmath-lieconformal/src/virasoro_lie_conformal_algebra.rs:159:9
    |
159 |         a: &VirasoroLCAElement<R>,
    |         ^ help: if this is intentional, prefix it with an underscore: `_a`

warning: unused variable: `b`
   --> rustmath-lieconformal/src/virasoro_lie_conformal_algebra.rs:160:9
    |
160 |         b: &VirasoroLCAElement<R>,
    |         ^ help: if this is intentional, prefix it with an underscore: `_b`

warning: unused variable: `ngens`
   --> rustmath-lieconformal/src/affine_lie_conformal_algebra.rs:110:13
    |
110 |         let ngens = dim + 1;
    |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_ngens`

warning: unused variable: `ct`
   --> rustmath-lieconformal/src/affine_lie_conformal_algebra.rs:202:31
    |
202 |     fn compute_structure_data(ct: &CartanType, base_ring: &R) ->
    |                               ^^ help: if this is intentional, prefix it with an underscore: `_ct`

warning: unused variable: `base_ring`
   --> rustmath-lieconformal/src/affine_lie_conformal_algebra.rs:202:48
    |
202 |     fn compute_structure_data(ct: &CartanType, base_ring: &R) ->
    |                                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_base_ring`

warning: unused variable: `poly_a`
   --> rustmath-lieconformal/src/affine_lie_conformal_algebra.rs:350:23
    |
350 |         for (basis_a, poly_a) in a.terms() {
    |                       ^^^^^^ help: if this is intentional, prefix it with an underscore: `_poly_a`

warning: unused variable: `poly_b`
   --> rustmath-lieconformal/src/affine_lie_conformal_algebra.rs:351:27
    |
351 |             for (basis_b, poly_b) in b.terms() {
    |                           ^^^^^^ help: if this is intentional, prefix it with an underscore: `_poly_b`

warning: method `T` should have a snake case name
   --> rustmath-lieconformal/src/lie_conformal_algebra_element.rs:296:12
    |
296 |     pub fn T(&self, n: usize) -> Self
    |            ^ help: convert the identifier to snake case: `t`
    |
    = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: method `T` should have a snake case name
   --> rustmath-lieconformal/src/lie_conformal_algebra_element.rs:452:12
    |
452 |     pub fn T(&self, n: usize) -> Self
    |            ^ help: convert the identifier to snake case: `t`

warning: unused variable: `cell_res`
   --> rustmath-quantumgroups/src/fock_space.rs:274:37
    |
274 | ...   if let Some(cell_res) = lambda.cell_residue(comp_idx, row, col, &self.params.multicharge, self.params.n) {
    |                   ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_cell_res`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `min_power`
   --> rustmath-quantumgroups/src/q_bernoulli.rs:113:36
    |
113 |         let (q_int_num, q_int_den, min_power) = laurent_to_rational(&q_int_laurent);
    |                                    ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_min_power`

   Compiling rustmath-interfaces v0.1.0 (/home/john/RustMath/rustmath-interfaces)
warning: unused import: `rustmath_core::Ring`
 --> rustmath-topology/src/cell_complex.rs:8:5
  |
8 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_matrix::Matrix`
  --> rustmath-topology/src/cell_complex.rs:10:5
   |
10 | use rustmath_matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-topology/src/delta_complex.rs:12:33
   |
12 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-topology/src/filtered_simplicial_complex.rs:10:5
   |
10 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `HashMap` and `HashSet`
  --> rustmath-topology/src/filtered_simplicial_complex.rs:11:24
   |
11 | use std::collections::{HashMap, HashSet};
   |                        ^^^^^^^  ^^^^^^^

warning: unused import: `rustmath_integers::Integer`
  --> rustmath-topology/src/moment_angle_complex.rs:10:5
   |
10 | use rustmath_integers::Integer;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `crate::cell_complex::GenericCellComplex`
  --> rustmath-topology/src/simplicial_complex.rs:11:5
   |
11 | use crate::cell_complex::GenericCellComplex;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `HashSet`
  --> rustmath-topology/src/simplicial_set.rs:12:33
   |
12 | use std::collections::{HashMap, HashSet};
   |                                 ^^^^^^^

warning: unused import: `AbstractSimplex`
 --> rustmath-topology/src/simplicial_set_morphism.rs:7:44
  |
7 | use crate::simplicial_set::{SimplicialSet, AbstractSimplex};
  |                                            ^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-topology/src/reidemeister.rs:16:5
   |
16 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `CrossingType`
  --> rustmath-topology/src/knot_polynomials.rs:34:25
   |
34 | use crate::knot::{Knot, CrossingType};
   |                         ^^^^^^^^^^^^

warning: unused imports: `ReidemeisterMoveType` and `ReidemeisterMove`
  --> rustmath-topology/src/knot_invariants.rs:29:42
   |
29 | use crate::reidemeister::{simplify_knot, ReidemeisterMove, ReidemeisterMoveType};
   |                                          ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::collections::HashSet`
  --> rustmath-topology/src/knot_invariants.rs:30:5
   |
30 | use std::collections::HashSet;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `CrossingType` and `Crossing`
  --> rustmath-topology/src/link.rs:28:25
   |
28 | use crate::knot::{Knot, Crossing, CrossingType};
   |                         ^^^^^^^^  ^^^^^^^^^^^^

warning: unused import: `std::collections::HashMap`
  --> rustmath-topology/src/link.rs:29:5
   |
29 | use std::collections::HashMap;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `max_dim`
   --> rustmath-topology/src/cell_complex.rs:108:21
    |
108 |         if let Some(max_dim) = self.dimension {
    |                     ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_dim`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `obj`
  --> rustmath-topology/src/simplicial_complex_homset.rs:80:37
   |
80 | pub fn is_simplicial_complex_homset(obj: &SimplicialComplexHomset) -> bool {
   |                                     ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `obj`
   --> rustmath-topology/src/simplicial_complex_morphism.rs:173:39
    |
173 | pub fn is_simplicial_complex_morphism(obj: &SimplicialComplexMorphism) -> bool {
    |                                       ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `base_point`
  --> rustmath-topology/src/simplicial_set_constructions.rs:17:9
   |
17 |     let base_point = cone.add_simplex(AbstractSimplex::with_name(0, 0, "cone_point"));
   |         ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_base_point`

warning: unused variable: `north`
  --> rustmath-topology/src/simplicial_set_constructions.rs:33:9
   |
33 |     let north = suspension.add_simplex(AbstractSimplex::with_name(0, 0, "north"));
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_north`

warning: unused variable: `south`
  --> rustmath-topology/src/simplicial_set_constructions.rs:34:9
   |
34 |     let south = suspension.add_simplex(AbstractSimplex::with_name(0, 1, "south"));
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_south`

warning: variable does not need to be mutable
  --> rustmath-topology/src/simplicial_set_constructions.rs:47:9
   |
47 |     let mut product = SimplicialSet::with_name(&name);
   |         ----^^^^^^^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `base`
  --> rustmath-topology/src/simplicial_set_constructions.rs:65:9
   |
65 |     let base = wedge.add_simplex(AbstractSimplex::with_name(0, 0, "base"));
   |         ^^^^ help: if this is intentional, prefix it with an underscore: `_base`

warning: variable does not need to be mutable
  --> rustmath-topology/src/simplicial_set_constructions.rs:95:9
   |
95 |     let mut union = SimplicialSet::with_name(&name);
   |         ----^^^^^
   |         |
   |         help: remove this `mut`

warning: unused variable: `sigma`
  --> rustmath-topology/src/simplicial_set_examples.rs:88:9
   |
88 |     let sigma = ss.add_simplex(AbstractSimplex::with_name(2, 0, ""));
   |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_sigma`

warning: unused variable: `crossing_data`
  --> rustmath-topology/src/knot.rs:96:17
   |
96 |         for (i, crossing_data) in pd_code.iter().enumerate() {
   |                 ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_crossing_data`

warning: unused variable: `label`
   --> rustmath-topology/src/knot.rs:308:10
    |
308 |     for (label, positions) in crossing_positions.iter() {
    |          ^^^^^ help: if this is intentional, prefix it with an underscore: `_label`

warning: unused variable: `i`
   --> rustmath-topology/src/braid.rs:117:17
    |
117 |             let i = gen.index;
    |                 ^ help: if this is intentional, prefix it with an underscore: `_i`

warning: unused variable: `crossing`
   --> rustmath-topology/src/knot_polynomials.rs:220:9
    |
220 |     let crossing = pd_code[0];
    |         ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_crossing`

warning: unused variable: `a_smoothing`
   --> rustmath-topology/src/knot_polynomials.rs:238:65
    |
238 | fn apply_smoothing(pd_code: &[[usize; 4]], crossing_idx: usize, a_smoothing: bool) -> Vec<[usize; 4]> {
    |                                                                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_a_smoothing`

warning: unused variable: `num_comp`
  --> rustmath-topology/src/link.rs:71:13
   |
71 |         let num_comp = knot.num_components();
   |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_num_comp`

warning: unused variable: `crossing`
   --> rustmath-topology/src/link.rs:103:13
    |
103 |         for crossing in &self.pd_code {
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_crossing`

warning: field `base` is never read
   --> rustmath-topology/src/cubical_complex.rs:127:5
    |
125 | pub struct CubicalComplex {
    |            -------------- field in this struct
126 |     /// The underlying cell complex
127 |     base: GenericCellComplex,
    |     ^^^^
    |
    = note: `CubicalComplex` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `base` is never read
  --> rustmath-topology/src/delta_complex.rs:48:5
   |
46 | pub struct DeltaComplex {
   |            ------------ field in this struct
47 |     /// The underlying cell complex
48 |     base: GenericCellComplex,
   |     ^^^^
   |
   = note: `DeltaComplex` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: unused import: `rustmath_core::Ring`
 --> rustmath-quadraticforms/src/quadratic_form.rs:6:5
  |
6 | use rustmath_core::Ring;
  |     ^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/theta_series.rs:8:21
  |
8 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/theta_series.rs:8:27
  |
8 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/local_densities.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/local_densities.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/genus_theory.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/genus_theory.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-quadraticforms/src/advanced.rs:9:21
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                     ^^^^

warning: unused import: `NumericConversion`
 --> rustmath-quadraticforms/src/advanced.rs:9:27
  |
9 | use rustmath_core::{Ring, NumericConversion};
  |                           ^^^^^^^^^^^^^^^^^

warning: unused variable: `d`
  --> rustmath-quadraticforms/src/local_densities.rs:83:13
   |
83 |         let d = (-self.form.discriminant()).clone();
   |             ^ help: if this is intentional, prefix it with an underscore: `_d`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `p_power`
   --> rustmath-quadraticforms/src/local_densities.rs:173:13
    |
173 |         let p_power = p_int.pow(k);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_p_power`

warning: unused variable: `n3`
  --> rustmath-quadraticforms/src/advanced.rs:96:42
   |
96 |             if let [(n1, a1), (n2, a2), (n3, a3)] = window {
   |                                          ^^ help: if this is intentional, prefix it with an underscore: `_n3`

warning: method `p_adic_equivalent` is never used
   --> rustmath-quadraticforms/src/genus_theory.rs:189:8
    |
 18 | impl GenusTheory {
    | ---------------- method in this implementation
...
189 |     fn p_adic_equivalent(&self, form1: &QuadraticForm, form2: &QuadraticForm, p: u64) -> bool {
    |        ^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `list_plot_multiple` is never used
   --> rustmath-plot/src/plots/list_plot.rs:138:8
    |
138 | pub fn list_plot_multiple(
    |        ^^^^^^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `scatter_plot_y` is never used
  --> rustmath-plot/src/plots/scatter_plot.rs:77:8
   |
77 | pub fn scatter_plot_y(
   |        ^^^^^^^^^^^^^^

warning: function `scatter_plot_colored` is never used
   --> rustmath-plot/src/plots/scatter_plot.rs:116:8
    |
116 | pub fn scatter_plot_colored(
    |        ^^^^^^^^^^^^^^^^^^^^

warning: function `scatter_plot_sized` is never used
   --> rustmath-plot/src/plots/scatter_plot.rs:160:8
    |
160 | pub fn scatter_plot_sized(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `contour_plot_filled` is never used
   --> rustmath-plot/src/plots/contour_plot.rs:122:8
    |
122 | pub fn contour_plot_filled<F>(
    |        ^^^^^^^^^^^^^^^^^^^

warning: function `density_plot_custom` is never used
   --> rustmath-plot/src/plots/density_plot.rs:154:8
    |
154 | pub fn density_plot_custom<F, C>(
    |        ^^^^^^^^^^^^^^^^^^^

warning: function `histogram_custom_bins` is never used
   --> rustmath-plot/src/plots/histogram.rs:132:8
    |
132 | pub fn histogram_custom_bins(
    |        ^^^^^^^^^^^^^^^^^^^^^

warning: function `bar_chart_horizontal` is never used
  --> rustmath-plot/src/plots/bar_chart.rs:77:8
   |
77 | pub fn bar_chart_horizontal(
   |        ^^^^^^^^^^^^^^^^^^^^

warning: function `bar_chart_colored` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:122:8
    |
122 | pub fn bar_chart_colored(data: Vec<(f64, f64, Color)>, bar_width: Option<f64>) -> Graphics {
    |        ^^^^^^^^^^^^^^^^^

warning: function `bar_chart_grouped` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:166:8
    |
166 | pub fn bar_chart_grouped(
    |        ^^^^^^^^^^^^^^^^^

warning: function `bar_chart_stacked` is never used
   --> rustmath-plot/src/plots/bar_chart.rs:232:8
    |
232 | pub fn bar_chart_stacked(data: Vec<(f64, Vec<f64>, Vec<Color>)>, bar_width: Option<f64>) -> Graphics {
    |        ^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_range` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:119:8
    |
119 | pub fn matrix_plot_range(
    |        ^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_binary` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:173:8
    |
173 | pub fn matrix_plot_binary(
    |        ^^^^^^^^^^^^^^^^^^

warning: function `matrix_plot_spy` is never used
   --> rustmath-plot/src/plots/matrix_plot.rs:222:8
    |
222 | pub fn matrix_plot_spy(matrix: Vec<Vec<f64>>, threshold: Option<f64>, color: Color) -> Graphics {
    |        ^^^^^^^^^^^^^^^

warning: unused import: `Ring`
 --> rustmath-affineschemes/src/prime_ideal.rs:6:21
  |
6 | use rustmath_core::{Ring, CommutativeRing, MathError, Result};
  |                     ^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Ring`
 --> rustmath-affineschemes/src/spec.rs:7:38
  |
7 | use rustmath_core::{CommutativeRing, Ring};
  |                                      ^^^^

warning: unused import: `Ring`
 --> rustmath-affineschemes/src/structure_sheaf.rs:9:38
  |
9 | use rustmath_core::{CommutativeRing, Ring};
  |                                      ^^^^

warning: unused import: `Ring`
  --> rustmath-affineschemes/src/morphism.rs:13:38
   |
13 | use rustmath_core::{CommutativeRing, Ring};
   |                                      ^^^^

warning: fields `first` and `second` are never read
  --> rustmath-affineschemes/src/fiber_product.rs:38:5
   |
29 | pub struct FiberProduct<R, S, T>
   |            ------------ fields in this struct
...
38 |     first: AffineScheme<S>,
   |     ^^^^^
39 |     /// The second scheme Spec(T)
40 |     second: AffineScheme<T>,
   |     ^^^^^^
   |
   = note: `FiberProduct` has derived impls for the traits `Debug` and `Clone`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `source` is never read
   --> rustmath-affineschemes/src/varieties.rs:247:5
    |
241 | pub struct VarietyMorphism<K, A, B>
    |            --------------- field in this struct
...
247 |     source: AffineVariety<K, A>,
    |     ^^^^^^

warning: unused variable: `obj`
   --> rustmath-modular/src/abvar.rs:490:35
    |
490 | pub fn is_modular_abelian_variety(obj: &ModularAbelianVariety) -> bool {
    |                                   ^^^ help: if this is intentional, prefix it with an underscore: `_obj`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `space`
   --> rustmath-modular/src/abvar.rs:519:24
    |
519 | pub fn modsym_lattices(space: &ModularSymbolSpace) -> Vec<Vec<BigRational>> {
    |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_space`

warning: unused variable: `coeffs`
   --> rustmath-modular/src/abvar.rs:531:18
    |
531 | pub fn sqrt_poly(coeffs: &[BigRational]) -> Option<Vec<BigRational>> {
    |                  ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: unused variable: `h_subgroup`
   --> rustmath-modular/src/abvar.rs:935:27
    |
935 |     pub fn jh(level: u64, h_subgroup: Vec<u64>) -> ModularAbelianVariety {
    |                           ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_h_subgroup`

warning: unused variable: `obj`
   --> rustmath-modular/src/dirichlet.rs:213:31
    |
213 | pub fn is_dirichlet_character(obj: &DirichletCharacter) -> bool {
    |                               ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `obj`
   --> rustmath-modular/src/dirichlet.rs:219:27
    |
219 | pub fn is_dirichlet_group(obj: &DirichletGroup) -> bool {
    |                           ^^^ help: if this is intentional, prefix it with an underscore: `_obj`

warning: unused variable: `N`
   --> rustmath-modular/src/etaproducts.rs:323:5
    |
323 |     N: &BigInt,
    |     ^ help: if this is intentional, prefix it with an underscore: `_N`

warning: unused variable: `degree`
   --> rustmath-modular/src/etaproducts.rs:324:5
    |
324 |     degree: usize,
    |     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_degree`

warning: unused variable: `p`
 --> rustmath-modular/src/btquotients/btquotient.rs:6:16
  |
6 |     pub fn new(p: u64, level: u64) -> Self {
  |                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `level`
 --> rustmath-modular/src/btquotients/btquotient.rs:6:24
  |
6 |     pub fn new(p: u64, level: u64) -> Self {
  |                        ^^^^^ help: if this is intentional, prefix it with an underscore: `_level`

warning: unused variable: `weight`
 --> rustmath-modular/src/btquotients/pautomorphicform.rs:6:16
  |
6 |     pub fn new(weight: i32) -> Self {
  |                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_weight`

warning: unused variable: `coeffs`
 --> rustmath-modular/src/drinfeld_modform/element.rs:6:16
  |
6 |     pub fn new(coeffs: Vec<f64>) -> Self {
  |                ^^^^^^ help: if this is intentional, prefix it with an underscore: `_coeffs`

warning: unused variable: `rank`
 --> rustmath-modular/src/drinfeld_modform/ring.rs:6:16
  |
6 |     pub fn new(rank: usize) -> Self {
  |                ^^^^ help: if this is intentional, prefix it with an underscore: `_rank`

warning: unused variable: `level`
 --> rustmath-modular/src/quatalg/brandt.rs:6:16
  |
6 |     pub fn new(level: u64) -> Self {
  |                ^^^^^ help: if this is intentional, prefix it with an underscore: `_level`

warning: unused variable: `p`
 --> rustmath-modular/src/ssmod/ssmod.rs:6:16
  |
6 |     pub fn new(p: u64) -> Self {
  |                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `alpha`
  --> rustmath-modular/src/hypergeometric_motive.rs:29:26
   |
29 |     fn compute_conductor(alpha: &[f64], beta: &[f64]) -> u64 {
   |                          ^^^^^ help: if this is intentional, prefix it with an underscore: `_alpha`

warning: unused variable: `beta`
  --> rustmath-modular/src/hypergeometric_motive.rs:29:41
   |
29 |     fn compute_conductor(alpha: &[f64], beta: &[f64]) -> u64 {
   |                                         ^^^^ help: if this is intentional, prefix it with an underscore: `_beta`

warning: unused variable: `p`
  --> rustmath-modular/src/hypergeometric_motive.rs:35:32
   |
35 |     pub fn euler_factor(&self, p: u64) -> Vec<f64> {
   |                                ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `p`
  --> rustmath-modular/src/hypergeometric_motive.rs:41:38
   |
41 |     pub fn is_wildly_ramified(&self, p: u64) -> bool {
   |                                      ^ help: if this is intentional, prefix it with an underscore: `_p`

warning: unused variable: `precision`
  --> rustmath-modular/src/multiple_zeta.rs:30:35
   |
30 |     pub fn numerical_value(&self, precision: usize) -> f64 {
   |                                   ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_precision`

warning: field `matrix` is never read
  --> rustmath-modular/src/hecke.rs:20:5
   |
14 | pub struct HeckeOperator {
   |            ------------- field in this struct
...
20 |     matrix: Option<Vec<Vec<BigRational>>>,
   |     ^^^^^^
   |
   = note: `HeckeOperator` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: field `base` is never read
   --> rustmath-modular/src/abvar.rs:575:5
    |
573 | pub struct FiniteSubgroupLattice {
    |            --------------------- field in this struct
574 |     /// Base finite subgroup
575 |     base: FiniteSubgroup,
    |     ^^^^
    |
    = note: `FiniteSubgroupLattice` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-modular/src/abvar.rs:677:5
    |
675 | pub struct LseriesComplex {
    |            -------------- field in this struct
676 |     /// Base L-series
677 |     base: Lseries,
    |     ^^^^
    |
    = note: `LseriesComplex` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: field `base` is never read
   --> rustmath-modular/src/abvar.rs:699:5
    |
697 | pub struct LseriesPadic {
    |            ------------ field in this struct
698 |     /// Base L-series
699 |     base: Lseries,
    |     ^^^^
    |
    = note: `LseriesPadic` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis

warning: variable `N` should have a snake case name
  --> rustmath-modular/src/dims.rs:54:14
   |
54 | pub fn eisen(N: &BigInt, k: i64) -> BigInt {
   |              ^ help: convert the identifier to snake case: `n`
   |
   = note: `#[warn(non_snake_case)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: variable `N` should have a snake case name
  --> rustmath-modular/src/dims.rs:79:17
   |
79 | pub fn co_delta(N: &BigInt) -> BigInt {
   |                 ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:109:14
    |
109 | pub fn co_nu(N: &BigInt) -> BigInt {
    |              ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:141:23
    |
141 | pub fn cohen_oesterle(N: &BigInt, k: i64) -> BigInt {
    |                       ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:173:33
    |
173 | pub fn dimension_new_cusp_forms(N: &BigInt, k: i64) -> BigInt {
    |                                 ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:202:29
    |
202 | pub fn dimension_cusp_forms(N: &BigInt, k: i64) -> BigInt {
    |                             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:241:22
    |
241 | pub fn dimension_eis(N: &BigInt, k: i64) -> BigInt {
    |                      ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:253:32
    |
253 | pub fn dimension_modular_forms(N: &BigInt, k: i64) -> BigInt {
    |                                ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dims.rs:280:20
    |
280 | pub fn sturm_bound(N: &BigInt, k: i64) -> BigInt {
    |                    ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dirichlet.rs:208:30
    |
208 | pub fn dirichlet_group_class(N: BigInt) -> DirichletGroup {
    |                              ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dirichlet.rs:231:26
    |
231 | pub fn trivial_character(N: BigInt) -> DirichletCharacter {
    |                          ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/dirichlet.rs:265:28
    |
265 | pub fn principal_character(N: BigInt) -> DirichletCharacter {
    |                            ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:141:13
    |
141 |         let N = self.conductor as f64;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N_power` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:145:13
    |
145 |         let N_power = Complex64::new(
    |             ^^^^^^^ help: convert the identifier to snake case: `n_power`

warning: variable `L_value` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:161:13
    |
161 |         let L_value = self.evaluate_series(s, 1000);
    |             ^^^^^^^ help: convert the identifier to snake case: `l_value`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:203:13
    |
203 |         let N = self.conductor as f64;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `W` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:219:13
    |
219 |         let W = self.root_number();
    |             ^ help: convert the identifier to snake case (notice the capitalization): `w`

warning: variable `N_power` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:220:13
    |
220 |         let N_power = Complex64::from(N).powc(Complex64::from(0.5) - s);
    |             ^^^^^^^ help: convert the identifier to snake case: `n_power`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:310:13
    |
310 |         let N = self.conductor as f64;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `sqrt_N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:314:13
    |
314 |         let sqrt_N = N.sqrt();
    |             ^^^^^^ help: convert the identifier to snake case: `sqrt_n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:323:13
    |
323 |         let N = self.conductor;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/lfunction.rs:346:13
    |
346 |         let N = self.conductor;
    |             ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:169:24
    |
169 | pub fn eta_group_class(N: BigInt) -> EtaGroup {
    |                        ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:178:20
    |
178 | pub fn eta_product(N: BigInt, powers: HashMap<BigInt, i64>) -> EtaGroupElement {
    |                    ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:260:18
    |
260 | pub fn all_cusps(N: BigInt) -> Vec<(BigInt, BigInt)> {
    |                  ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:283:27
    |
283 | pub fn num_cusps_of_width(N: &BigInt, width: &BigInt) -> usize {
    |                           ^ help: convert the identifier to snake case: `n`

warning: variable `N` should have a snake case name
   --> rustmath-modular/src/etaproducts.rs:323:5
    |
323 |     N: &BigInt,
    |     ^ help: convert the identifier to snake case: `n`

warning: unused variable: `text`
   --> rustmath-crypto/src/classical.rs:212:21
    |
212 | pub fn hill_decrypt(text: &str, key_matrix: &Matrix<Integer>) -> Result<String> {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_text`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `key_matrix`
   --> rustmath-crypto/src/classical.rs:212:33
    |
212 | pub fn hill_decrypt(text: &str, key_matrix: &Matrix<Integer>) -> Result<String> {
    |                                 ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_key_matrix`

warning: unused variable: `j`
   --> rustmath-crypto/src/kdf.rs:213:17
    |
213 |             for j in 0..32 {
    |                 ^ help: if this is intentional, prefix it with an underscore: `_j`

warning: unused variable: `challenge`
   --> rustmath-crypto/src/eddsa.rs:351:13
    |
351 |         let challenge = SHA256::hash(&challenge_input);
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_challenge`

warning: unused variable: `s_point`
   --> rustmath-crypto/src/eddsa.rs:358:13
    |
358 |         let s_point = basepoint.scalar_mul(&signature.s);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_s_point`

warning: unused variable: `r_point`
   --> rustmath-crypto/src/eddsa.rs:359:13
    |
359 |         let r_point = basepoint.scalar_mul(&signature.r);
    |             ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_r_point`

warning: unused variable: `verify_hash`
   --> rustmath-crypto/src/eddsa.rs:367:13
    |
367 |         let verify_hash = SHA256::hash(&verify_input);
    |             ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_verify_hash`

warning: associated function `quarter_round` is never used
   --> rustmath-crypto/src/stream_cipher.rs:144:8
    |
 88 | impl ChaCha20 {
    | ------------- associated function in this implementation
...
144 |     fn quarter_round(a: &mut u32, b: &mut u32, c: &mut u32, d: &mut u32) {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: associated items `P`, `from_bytes`, and `mul_small` are never used
   --> rustmath-crypto/src/eddsa.rs:52:11
    |
 50 | impl FieldElement {
    | ----------------- associated items in this implementation
 51 |     /// Prime for Curve25519: 2^255 - 19
 52 |     const P: [u64; 5] = [
    |           ^
...
 69 |     fn from_bytes(bytes: &[u8; 32]) -> Self {
    |        ^^^^^^^^^^
...
122 |     fn mul_small(&self, scalar: u64) -> FieldElement {
    |        ^^^^^^^^^

warning: unused import: `rustmath_core::Ring`
  --> rustmath-calculus/src/riemann.rs:26:5
   |
26 | use rustmath_core::Ring;
   |     ^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_core::NumericConversion`
 --> rustmath-calculus/src/sum.rs:6:5
  |
6 | use rustmath_core::NumericConversion;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused variable: `dy`
   --> rustmath-calculus/src/riemann.rs:182:17
    |
182 |             let dy = if i == 0 {
    |                 ^^ help: if this is intentional, prefix it with an underscore: `_dy`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `m`
   --> rustmath-calculus/src/transforms/dwt.rs:371:9
    |
371 |     let m = filter.len();
    |         ^ help: if this is intentional, prefix it with an underscore: `_m`

warning: field `wavelet` is never read
  --> rustmath-calculus/src/transforms/dwt.rs:36:5
   |
34 | pub struct DiscreteWaveletTransform {
   |            ------------------------ field in this struct
35 |     /// Wavelet family
36 |     wavelet: WaveletFamily,
   |     ^^^^^^^
   |
   = note: `DiscreteWaveletTransform` has derived impls for the traits `Clone` and `Debug`, but these are intentionally ignored during dead code analysis
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: methods `fft_recursive` and `dft_fallback` are never used
   --> rustmath-calculus/src/transforms/fft.rs:67:8
    |
 32 | impl FastFourierTransformComplex {
    | -------------------------------- methods in this implementation
...
 67 |     fn fft_recursive(&self, input: &[Complex]) -> Vec<Complex> {
    |        ^^^^^^^^^^^^^
...
116 |     fn dft_fallback(&self, input: &[Complex]) -> Vec<Complex> {
    |        ^^^^^^^^^^^^

warning: `rustmath-schemes` (lib) generated 37 warnings (run `cargo fix --lib -p rustmath-schemes` to apply 14 suggestions)
warning: `rustmath-plot3d` (lib) generated 1 warning
warning: `rustmath-lieconformal` (lib) generated 15 warnings (run `cargo fix --lib -p rustmath-lieconformal` to apply 5 suggestions)
warning: `rustmath-quantumgroups` (lib) generated 2 warnings
warning: `rustmath-topology` (lib) generated 34 warnings (run `cargo fix --lib -p rustmath-topology` to apply 17 suggestions)
warning: `rustmath-quadraticforms` (lib) generated 13 warnings
warning: `rustmath-plot` (lib) generated 14 warnings
warning: `rustmath-affineschemes` (lib) generated 6 warnings
warning: `rustmath-modular` (lib) generated 51 warnings
warning: `rustmath-crypto` (lib) generated 9 warnings
warning: `rustmath-calculus` (lib) generated 6 warnings
   Compiling rustmath-curves v0.1.0 (/home/john/RustMath/rustmath-curves)
error[E0407]: method `super_categories` is not a member of trait `Category`
   --> rustmath-category/src/group_category.rs:241:5
    |
241 | /     fn super_categories(&self) -> Vec<Box<dyn Category>> {
242 | |         vec![Box::new(GroupCategory::new())]
243 | |     }
    | |_____^ not a member of trait `Category`

error[E0407]: method `super_categories` is not a member of trait `Category`
   --> rustmath-category/src/group_category.rs:285:5
    |
285 | /     fn super_categories(&self) -> Vec<Box<dyn Category>> {
286 | |         vec![Box::new(GroupCategory::new())]
287 | |     }
    | |_____^ not a member of trait `Category`

error[E0407]: method `super_categories` is not a member of trait `Category`
   --> rustmath-category/src/group_category.rs:330:5
    |
330 | /     fn super_categories(&self) -> Vec<Box<dyn Category>> {
331 | |         vec![Box::new(GroupCategory::new())]
332 | |     }
    | |_____^ not a member of trait `Category`

error[E0407]: method `super_categories` is not a member of trait `Category`
  --> rustmath-category/src/ring_category.rs:93:5
   |
93 | /     fn super_categories(&self) -> Vec<Box<dyn Category>> {
94 | |         vec![Box::new(RingCategory)]
95 | |     }
   | |_____^ not a member of trait `Category`

error[E0407]: method `super_categories` is not a member of trait `Category`
   --> rustmath-category/src/ring_category.rs:138:5
    |
138 | /     fn super_categories(&self) -> Vec<Box<dyn Category>> {
139 | |         vec![Box::new(CommutativeRingCategory)]
140 | |     }
    | |_____^ not a member of trait `Category`

warning: unused import: `Morphism`
  --> rustmath-category/src/coercion.rs:24:47
   |
24 | use crate::morphism::{FormalCoercionMorphism, Morphism};
   |                                               ^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `crate::functor::Functor`
 --> rustmath-category/src/natural_transformation.rs:6:5
  |
6 | use crate::functor::Functor;
  |     ^^^^^^^^^^^^^^^^^^^^^^^

warning: unused imports: `Associativity`, `Distributivity`, `Identity`, and `Unity`
 --> rustmath-category/src/ring_category.rs:9:21
  |
9 | use crate::axioms::{Associativity, Commutativity, Distributivity, Identity, Unity, AxiomSet};
  |                     ^^^^^^^^^^^^^                 ^^^^^^^^^^^^^^  ^^^^^^^^  ^^^^^

warning: unused imports: `CommutativeRing` and `Result`
  --> rustmath-category/src/ring_category.rs:11:27
   |
11 | use rustmath_core::{Ring, CommutativeRing, Parent, Result};
   |                           ^^^^^^^^^^^^^^^          ^^^^^^

warning: unused import: `rustmath_symbolic::expression::Expr`
 --> rustmath-curves/src/plane_curve.rs:9:5
  |
9 | use rustmath_symbolic::expression::Expr;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `rustmath_matrix::matrix::Matrix`
  --> rustmath-curves/src/singularities.rs:12:5
   |
12 | use rustmath_matrix::matrix::Matrix;
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `GapElement_Boolean` should have an upper camel case name
  --> rustmath-interfaces/src/gap_element.rs:89:12
   |
89 | pub struct GapElement_Boolean {
   |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementBoolean`
   |
   = note: `#[warn(non_camel_case_types)]` (part of `#[warn(nonstandard_style)]`) on by default

warning: type `GapElement_Integer` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:161:12
    |
161 | pub struct GapElement_Integer {
    |            ^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementInteger`

warning: type `GapElement_Rational` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:259:12
    |
259 | pub struct GapElement_Rational {
    |            ^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementRational`

warning: type `GapElement_Float` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:333:12
    |
333 | pub struct GapElement_Float {
    |            ^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementFloat`

warning: type `GapElement_String` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:382:12
    |
382 | pub struct GapElement_String {
    |            ^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementString`

warning: type `GapElement_List` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:455:12
    |
455 | pub struct GapElement_List {
    |            ^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementList`

warning: type `GapElement_Record` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:545:12
    |
545 | pub struct GapElement_Record {
    |            ^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementRecord`

warning: type `GapElement_RecordIterator` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:611:12
    |
611 | pub struct GapElement_RecordIterator {
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementRecordIterator`

warning: type `GapElement_Permutation` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:640:12
    |
640 | pub struct GapElement_Permutation {
    |            ^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementPermutation`

warning: type `GapElement_Function` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:725:12
    |
725 | pub struct GapElement_Function {
    |            ^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementFunction`

warning: unused import: `rustmath_polynomials::multivariate::MultiPoly`
   --> rustmath-curves/src/weierstrass.rs:296:9
    |
296 |     use rustmath_polynomials::multivariate::MultiPoly;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: type `GapElement_MethodProxy` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:769:12
    |
769 | pub struct GapElement_MethodProxy {
    |            ^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementMethodProxy`

warning: type `GapElement_FiniteField` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:799:12
    |
799 | pub struct GapElement_FiniteField {
    |            ^^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementFiniteField`

warning: type `GapElement_IntegerMod` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:864:12
    |
864 | pub struct GapElement_IntegerMod {
    |            ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementIntegerMod`

warning: type `GapElement_Cyclotomic` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:922:12
    |
922 | pub struct GapElement_Cyclotomic {
    |            ^^^^^^^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementCyclotomic`

warning: type `GapElement_Ring` should have an upper camel case name
   --> rustmath-interfaces/src/gap_element.rs:987:12
    |
987 | pub struct GapElement_Ring {
    |            ^^^^^^^^^^^^^^^ help: convert the identifier to upper camel case: `GapElementRing`

warning: unused import: `crate::gap_element::*`
  --> rustmath-interfaces/src/libgap.rs:32:5
   |
32 | use crate::gap_element::*;
   |     ^^^^^^^^^^^^^^^^^^^^^
   |
   = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `GapError`
  --> rustmath-interfaces/src/util.rs:28:18
   |
28 | use crate::gap::{GapError, GapInterface, Result};
   |                  ^^^^^^^^

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/hyperelliptic.rs:45:15
    |
 45 |         if !f.is_square_free() {
    |               ^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `UnivariatePolynomial::<R>::is_square_free`
   --> /home/john/RustMath/rustmath-polynomials/src/univariate.rs:389:12
    |
387 |     pub fn is_square_free(&self) -> bool
    |            -------------- required by a bound in this associated function
388 |     where
389 |         R: EuclideanDomain,
    |            ^^^^^^^^^^^^^^^ required by this bound in `UnivariatePolynomial::<R>::is_square_free`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 30 | impl<F: Field + Clone + PartialEq + rustmath_core::NumericConversion + rustmath_core::EuclideanDomain> HyperellipticCurve<F> {
    |                                                                      ++++++++++++++++++++++++++++++++

error[E0308]: mismatched types
  --> rustmath-curves/src/hyperelliptic.rs:61:9
   |
60 |     pub fn degree(&self) -> usize {
   |                             ----- expected `usize` because of return type
61 |         self.f.degree()
   |         ^^^^^^^^^^^^^^^ expected `usize`, found `Option<usize>`
   |
   = note: expected type `usize`
              found enum `Option<usize>`
help: consider using `Option::expect` to unwrap the `Option<usize>` value, panicking if the value is an `Option::None`
   |
61 |         self.f.degree().expect("REASON")
   |                        +++++++++++++++++

error[E0308]: mismatched types
  --> rustmath-curves/src/hyperelliptic.rs:88:9
   |
30 | impl<F: Field + Clone + PartialEq + rustmath_core::NumericConversion> HyperellipticCurve<F> {
   |      - expected this type parameter
...
87 |     pub fn discriminant(&self) -> F {
   |                                   - expected `F` because of return type
88 |         self.f.discriminant()
   |         ^^^^^^^^^^^^^^^^^^^^^ expected type parameter `F`, found `Option<F>`
   |
   = note: expected type parameter `F`
                        found enum `Option<F>`
help: consider using `Option::expect` to unwrap the `Option<F>` value, panicking if the value is an `Option::None`
   |
88 |         self.f.discriminant().expect("REASON")
   |                              +++++++++++++++++

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/hyperelliptic.rs:94:17
    |
 94 |         !self.f.is_square_free()
    |                 ^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `UnivariatePolynomial::<R>::is_square_free`
   --> /home/john/RustMath/rustmath-polynomials/src/univariate.rs:389:12
    |
387 |     pub fn is_square_free(&self) -> bool
    |            -------------- required by a bound in this associated function
388 |     where
389 |         R: EuclideanDomain,
    |            ^^^^^^^^^^^^^^^ required by this bound in `UnivariatePolynomial::<R>::is_square_free`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 30 | impl<F: Field + Clone + PartialEq + rustmath_core::NumericConversion + rustmath_core::EuclideanDomain> HyperellipticCurve<F> {
    |                                                                      ++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `dyn Axiom: Clone` is not satisfied
   --> rustmath-category/src/axioms.rs:299:5
    |
297 | #[derive(Debug, Clone)]
    |                 ----- in this derive macro expansion
298 | pub struct AxiomSet {
299 |     axioms: Vec<Box<dyn Axiom>>,
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `dyn Axiom`
    |
    = note: required for `Box<dyn Axiom>` to implement `Clone`
    = note: 1 redundant requirement hidden
    = note: required for `Vec<Box<dyn Axiom>>` to implement `Clone`

error[E0308]: mismatched types
  --> rustmath-curves/src/divisor.rs:37:25
   |
37 |         if u.degree() > 0 && !u.is_monic() {
   |            ----------   ^ expected `Option<usize>`, found integer
   |            |
   |            expected because this is `Option<usize>`
   |
   = note: expected enum `Option<usize>`
              found type `{integer}`
help: try wrapping the expression in `Some`
   |
37 |         if u.degree() > Some(0) && !u.is_monic() {
   |                         +++++ +

error[E0308]: mismatched types
  --> rustmath-curves/src/divisor.rs:61:28
   |
61 |         self.u.degree() == 0 && self.v.is_zero()
   |         ---------------    ^ expected `Option<usize>`, found integer
   |         |
   |         expected because this is `Option<usize>`
   |
   = note: expected enum `Option<usize>`
              found type `{integer}`
help: try wrapping the expression in `Some`
   |
61 |         self.u.degree() == Some(0) && self.v.is_zero()
   |                            +++++ +

error[E0308]: mismatched types
  --> rustmath-curves/src/divisor.rs:66:9
   |
65 |     pub fn degree(&self) -> usize {
   |                             ----- expected `usize` because of return type
66 |         self.u.degree()
   |         ^^^^^^^^^^^^^^^ expected `usize`, found `Option<usize>`
   |
   = note: expected type `usize`
              found enum `Option<usize>`
help: consider using `Option::expect` to unwrap the `Option<usize>` value, panicking if the value is an `Option::None`
   |
66 |         self.u.degree().expect("REASON")
   |                        +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-curves/src/divisor.rs:109:49
    |
 30 | impl<F: Field + Clone + PartialEq> MumfordDivisor<F> {
    |      - expected this type parameter
...
109 |         let slope = (y2.clone() - y1.clone()) * (x2.clone() - x1.clone()).inverse();
    |                     -------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected type parameter `F`, found `Result<F, MathError>`
    |                     |
    |                     expected because this is `F`
    |
    = note: expected type parameter `F`
                         found enum `Result<F, MathError>`
help: consider using `Result::expect` to unwrap the `Result<F, MathError>` value, panicking if the value is a `Result::Err`
    |
109 |         let slope = (y2.clone() - y1.clone()) * (x2.clone() - x1.clone()).inverse().expect("REASON");
    |                                                                                    +++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-curves/src/divisor.rs:134:13
    |
134 |         let (_, remainder) = diff.div_rem(&self.u);
    |             ^^^^^^^^^^^^^^   --------------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
    |             |
    |             expected `Result<(..., ...), ...>`, found `(_, _)`
    |
    = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
              found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
    |
134 |         let Ok((_, remainder)) = diff.div_rem(&self.u);
    |             +++              +

error[E0308]: mismatched types
   --> rustmath-curves/src/divisor.rs:177:30
    |
177 |         if self.u.degree() > 0 && !self.u.is_monic() {
    |            ---------------   ^ expected `Option<usize>`, found integer
    |            |
    |            expected because this is `Option<usize>`
    |
    = note: expected enum `Option<usize>`
               found type `{integer}`
help: try wrapping the expression in `Some`
    |
177 |         if self.u.degree() > Some(0) && !self.u.is_monic() {
    |                              +++++ +

error[E0308]: mismatched types
  --> rustmath-curves/src/cantor.rs:89:17
   |
89 |             let (q, r) = u1.div_rem(&d);
   |                 ^^^^^^   -------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
   |                 |
   |                 expected `Result<(..., ...), ...>`, found `(_, _)`
   |
   = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
             found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
   |
89 |             let Ok((q, r)) = u1.div_rem(&d);
   |                 +++      +

error[E0308]: mismatched types
  --> rustmath-curves/src/cantor.rs:98:17
   |
98 |             let (q, r) = u2.div_rem(&d);
   |                 ^^^^^^   -------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
   |                 |
   |                 expected `Result<(..., ...), ...>`, found `(_, _)`
   |
   = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
             found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
   |
98 |             let Ok((q, r)) = u2.div_rem(&d);
   |                 +++      +

error[E0308]: mismatched types
   --> rustmath-curves/src/cantor.rs:108:17
    |
108 |             let (q, r) = u_numerator.div_rem(&d_squared);
    |                 ^^^^^^   ------------------------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
    |                 |
    |                 expected `Result<(..., ...), ...>`, found `(_, _)`
    |
    = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
              found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
    |
108 |             let Ok((q, r)) = u_numerator.div_rem(&d_squared);
    |                 +++      +

error[E0308]: mismatched types
   --> rustmath-curves/src/cantor.rs:128:17
    |
128 |             let (_, rem) = v1.div_rem(&u);
    |                 ^^^^^^^^   -------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
    |                 |
    |                 expected `Result<(..., ...), ...>`, found `(_, _)`
    |
    = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
              found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
    |
128 |             let Ok((_, rem)) = v1.div_rem(&u);
    |                 +++        +

error[E0308]: mismatched types
   --> rustmath-curves/src/cantor.rs:173:13
    |
173 |         let (u_prime, remainder) = numerator.div_rem(u);
    |             ^^^^^^^^^^^^^^^^^^^^   -------------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
    |             |
    |             expected `Result<(..., ...), ...>`, found `(_, _)`
    |
    = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
              found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
    |
173 |         let Ok((u_prime, remainder)) = numerator.div_rem(u);
    |             +++                    +

error[E0308]: mismatched types
   --> rustmath-curves/src/cantor.rs:191:13
    |
191 |         let (_, v_prime) = neg_v.div_rem(&u_prime);
    |             ^^^^^^^^^^^^   ----------------------- this expression has type `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
    |             |
    |             expected `Result<(..., ...), ...>`, found `(_, _)`
    |
    = note: expected enum `Result<(UnivariatePolynomial<F>, UnivariatePolynomial<F>), MathError>`
              found tuple `(_, _)`
help: try wrapping the pattern in `Ok`
    |
191 |         let Ok((_, v_prime)) = neg_v.div_rem(&u_prime);
    |             +++            +

error[E0599]: the method `contains_point` exists for struct `HyperellipticCurve<F>`, but its trait bounds were not satisfied
  --> rustmath-curves/src/jacobian.rs:59:24
   |
59 |         if !self.curve.contains_point(&x, &y) {
   |                        ^^^^^^^^^^^^^^ method cannot be called on `HyperellipticCurve<F>` due to unsatisfied trait bounds
   |
  ::: rustmath-curves/src/hyperelliptic.rs:23:1
   |
23 | pub struct HyperellipticCurve<F: Field> {
   | --------------------------------------- method `contains_point` not found for this struct
   |
note: trait bound `F: NumericConversion` was not satisfied
  --> rustmath-curves/src/hyperelliptic.rs:30:37
   |
30 | impl<F: Field + Clone + PartialEq + rustmath_core::NumericConversion> HyperellipticCurve<F> {
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ---------------------
   |                                     |
   |                                     unsatisfied trait bound introduced here

error[E0599]: the method `contains_point` exists for struct `HyperellipticCurve<F>`, but its trait bounds were not satisfied
  --> rustmath-curves/src/jacobian.rs:83:24
   |
83 |         if !self.curve.contains_point(&x1, &y1) {
   |                        ^^^^^^^^^^^^^^ method cannot be called on `HyperellipticCurve<F>` due to unsatisfied trait bounds
   |
  ::: rustmath-curves/src/hyperelliptic.rs:23:1
   |
23 | pub struct HyperellipticCurve<F: Field> {
   | --------------------------------------- method `contains_point` not found for this struct
   |
note: trait bound `F: NumericConversion` was not satisfied
  --> rustmath-curves/src/hyperelliptic.rs:30:37
   |
30 | impl<F: Field + Clone + PartialEq + rustmath_core::NumericConversion> HyperellipticCurve<F> {
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ---------------------
   |                                     |
   |                                     unsatisfied trait bound introduced here

warning: variable does not need to be mutable
   --> rustmath-category/src/axioms.rs:374:13
    |
374 |         let mut set = Self::integral_domain();
    |             ----^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0599]: the method `contains_point` exists for struct `HyperellipticCurve<F>`, but its trait bounds were not satisfied
  --> rustmath-curves/src/jacobian.rs:86:24
   |
86 |         if !self.curve.contains_point(&x2, &y2) {
   |                        ^^^^^^^^^^^^^^ method cannot be called on `HyperellipticCurve<F>` due to unsatisfied trait bounds
   |
  ::: rustmath-curves/src/hyperelliptic.rs:23:1
   |
23 | pub struct HyperellipticCurve<F: Field> {
   | --------------------------------------- method `contains_point` not found for this struct
   |
note: trait bound `F: NumericConversion` was not satisfied
  --> rustmath-curves/src/hyperelliptic.rs:30:37
   |
30 | impl<F: Field + Clone + PartialEq + rustmath_core::NumericConversion> HyperellipticCurve<F> {
   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ---------------------
   |                                     |
   |                                     unsatisfied trait bound introduced here

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/jacobian.rs:91:23
    |
 91 |         let reduced = CantorAlgorithm::reduce(divisor, &self.curve.f, self.genus());
    |                       ^^^^^^^^^^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `CantorAlgorithm::reduce`
   --> rustmath-curves/src/cantor.rs:138:50
    |
138 |     pub fn reduce<F: Field + Clone + PartialEq + EuclideanDomain>(
    |                                                  ^^^^^^^^^^^^^^^ required by this bound in `CantorAlgorithm::reduce`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 38 | impl<F: Field + Clone + PartialEq + rustmath_core::EuclideanDomain> Jacobian<F> {
    |                                   ++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/jacobian.rs:103:23
    |
103 |         let reduced = CantorAlgorithm::reduce(divisor, &self.curve.f, self.genus());
    |                       ^^^^^^^^^^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `CantorAlgorithm::reduce`
   --> rustmath-curves/src/cantor.rs:138:50
    |
138 |     pub fn reduce<F: Field + Clone + PartialEq + EuclideanDomain>(
    |                                                  ^^^^^^^^^^^^^^^ required by this bound in `CantorAlgorithm::reduce`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 38 | impl<F: Field + Clone + PartialEq + rustmath_core::EuclideanDomain> Jacobian<F> {
    |                                   ++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/jacobian.rs:113:19
    |
113 |         let sum = CantorAlgorithm::add(&a.divisor, &b.divisor, &self.curve.f, self.genus());
    |                   ^^^^^^^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `CantorAlgorithm::add`
   --> rustmath-curves/src/cantor.rs:38:47
    |
 38 |     pub fn add<F: Field + Clone + PartialEq + EuclideanDomain>(
    |                                               ^^^^^^^^^^^^^^^ required by this bound in `CantorAlgorithm::add`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 38 | impl<F: Field + Clone + PartialEq + rustmath_core::EuclideanDomain> Jacobian<F> {
    |                                   ++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/jacobian.rs:131:22
    |
131 |         let result = CantorAlgorithm::scalar_multiply(
    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `CantorAlgorithm::scalar_multiply`
   --> rustmath-curves/src/cantor.rs:210:59
    |
210 |     pub fn scalar_multiply<F: Field + Clone + PartialEq + EuclideanDomain>(
    |                                                           ^^^^^^^^^^^^^^^ required by this bound in `CantorAlgorithm::scalar_multiply`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 38 | impl<F: Field + Clone + PartialEq + rustmath_core::EuclideanDomain> Jacobian<F> {
    |                                   ++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/jacobian.rs:148:9
    |
148 |         CantorAlgorithm::order(&element.divisor, &self.curve.f, self.genus(), max_iter)
    |         ^^^^^^^^^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `CantorAlgorithm::order`
   --> rustmath-curves/src/cantor.rs:251:49
    |
251 |     pub fn order<F: Field + Clone + PartialEq + EuclideanDomain>(
    |                                                 ^^^^^^^^^^^^^^^ required by this bound in `CantorAlgorithm::order`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
 38 | impl<F: Field + Clone + PartialEq + rustmath_core::EuclideanDomain> Jacobian<F> {
    |                                   ++++++++++++++++++++++++++++++++

error[E0277]: the trait bound `F: EuclideanDomain` is not satisfied
   --> rustmath-curves/src/jacobian.rs:215:23
    |
215 |         let doubled = CantorAlgorithm::double(
    |                       ^^^^^^^^^^^^^^^^^^^^^^^ the trait `EuclideanDomain` is not implemented for `F`
    |
note: required by a bound in `CantorAlgorithm::double`
   --> rustmath-curves/src/cantor.rs:199:50
    |
199 |     pub fn double<F: Field + Clone + PartialEq + EuclideanDomain>(
    |                                                  ^^^^^^^^^^^^^^^ required by this bound in `CantorAlgorithm::double`
help: consider further restricting type parameter `F` with trait `EuclideanDomain`
    |
172 | impl<F: Field + Clone + PartialEq + rustmath_core::EuclideanDomain> JacobianElement<F> {
    |                                   ++++++++++++++++++++++++++++++++

warning: unused import: `Ring`
  --> rustmath-curves/src/jacobian.rs:20:21
   |
20 | use rustmath_core::{Ring, Field};
   |                     ^^^^

warning: unused variable: `coercion`
   --> rustmath-category/src/coercion.rs:377:5
    |
377 |     coercion: &impl Coercion<Source = S, Target = T>,
    |     ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_coercion`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: variable does not need to be mutable
   --> rustmath-curves/src/singularities.rs:132:9
    |
132 |     let mut singularities = Vec::new();
    |         ----^^^^^^^^^^^^^
    |         |
    |         help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `point`
   --> rustmath-curves/src/singularities.rs:260:62
    |
260 | fn translate_to_origin<R: Ring + Clone>(poly: &MultiPoly<R>, point: &[R]) -> MultiPoly<R> {
    |                                                              ^^^^^ help: if this is intentional, prefix it with an underscore: `_point`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

error[E0308]: mismatched types
   --> rustmath-interfaces/src/test_long.rs:110:60
    |
110 |     println!("Average time per operation: {:?}", elapsed / iterations);
    |                                                            ^^^^^^^^^^ expected `u32`, found `usize`
    |
help: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit
    |
110 |     println!("Average time per operation: {:?}", elapsed / iterations.try_into().unwrap());
    |                                                                      ++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-interfaces/src/test_long.rs:159:60
    |
159 |     println!("Average time per operation: {:?}", elapsed / iterations);
    |                                                            ^^^^^^^^^^ expected `u32`, found `usize`
    |
help: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit
    |
159 |     println!("Average time per operation: {:?}", elapsed / iterations.try_into().unwrap());
    |                                                                      ++++++++++++++++++++

error[E0308]: mismatched types
   --> rustmath-interfaces/src/test_long.rs:207:60
    |
207 |     println!("Average time per operation: {:?}", elapsed / iterations);
    |                                                            ^^^^^^^^^^ expected `u32`, found `usize`
    |
help: you can convert a `usize` to a `u32` and panic if the converted value doesn't fit
    |
207 |     println!("Average time per operation: {:?}", elapsed / iterations.try_into().unwrap());
    |                                                                      ++++++++++++++++++++

warning: unused variable: `unit`
   --> rustmath-curves/src/parameterization.rs:161:13
    |
161 |         let unit = Self::unit_circle();
    |             ^^^^ help: if this is intentional, prefix it with an underscore: `_unit`

warning: unused variable: `two`
   --> rustmath-curves/src/weierstrass.rs:137:13
    |
137 |         let two = F::one() + F::one();
    |             ^^^ help: if this is intentional, prefix it with an underscore: `_two`

warning: unused variable: `upper_bound`
   --> rustmath-curves/src/riemann_roch.rs:263:17
    |
263 |             let upper_bound = d + 1;
    |                 ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_upper_bound`

warning: variable does not need to be mutable
   --> rustmath-curves/src/riemann_roch.rs:347:21
    |
347 |                 let mut func = FunctionFieldElement::monomial(i, primary_place);
    |                     ----^^^^
    |                     |
    |                     help: remove this `mut`

warning: variable does not need to be mutable
   --> rustmath-curves/src/riemann_roch.rs:385:29
    |
385 |                         let mut func = FunctionFieldElement::monomial(i, place);
    |                             ----^^^^
    |                             |
    |                             help: remove this `mut`

Some errors have detailed explanations: E0277, E0407.
For more information about an error, try `rustc --explain E0277`.
warning: `rustmath-category` (lib) generated 6 warnings
error: could not compile `rustmath-category` (lib) due to 6 previous errors; 6 warnings emitted
warning: build failed, waiting for other jobs to finish...
Some errors have detailed explanations: E0277, E0308, E0599.
warning: `rustmath-curves` (lib) generated 11 warnings
error: could not compile `rustmath-curves` (lib) due to 25 previous errors; 11 warnings emitted
warning: unused variable: `interface`
  --> rustmath-interfaces/src/libgap.rs:74:13
   |
74 |         let interface = self.interface.lock()
   |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_interface`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `n`
   --> rustmath-interfaces/src/libgap.rs:116:36
    |
116 |     pub fn FreeAbelianGroup(&self, n: usize) -> Result<String> {
    |                                    ^ help: if this is intentional, prefix it with an underscore: `_n`

For more information about this error, try `rustc --explain E0308`.
warning: `rustmath-interfaces` (lib) generated 19 warnings
error: could not compile `rustmath-interfaces` (lib) due to 3 previous errors; 19 warnings emitted
