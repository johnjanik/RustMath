//! Poincaré-Birkhoff-Witt Universal Enveloping Algebra
//!
//! The universal enveloping algebra U(g) of a Lie algebra g is the associative
//! algebra generated by g with multiplication defined by the commutator bracket.
//!
//! The Poincaré-Birkhoff-Witt (PBW) theorem states that U(g) has a canonical
//! basis consisting of ordered monomials: b₁^e₁ ⊗ b₂^e₂ ⊗ ⋯ ⊗ bₙ^eₙ where
//! {b₁, b₂, ..., bₙ} is an ordered basis of g.
//!
//! # Mathematical Background
//!
//! For a Lie algebra g with bracket [−,−], the universal enveloping algebra
//! U(g) is characterized by:
//!
//! 1. **Universality**: For any associative algebra A and Lie algebra map φ: g → A,
//!    there exists a unique algebra map Φ: U(g) → A extending φ
//!
//! 2. **PBW Basis**: Ordered monomials form a basis, providing a faithful
//!    representation of g inside U(g)
//!
//! 3. **Multiplication**: Products are computed using the commutation relation:
//!    xy = yx + [x,y] when x > y in the chosen basis ordering
//!
//! # Applications
//!
//! - Representation theory: Modules over U(g) ↔ representations of g
//! - Casimir elements: Central elements in U(g) for computing invariants
//! - Quantum groups: q-deformations of U(g)
//! - Symmetric algebras: gr(U(g)) ≅ Sym(g) (associated graded algebra)
//!
//! Corresponds to sage.algebras.lie_algebras.poincare_birkhoff_witt
//!
//! # References
//! - Dixmier, J. "Enveloping Algebras" (1977)
//! - Humphreys, J. "Introduction to Lie Algebras and Representation Theory" (1972)
//! - Chari, V. and Pressley, A. "A Guide to Quantum Groups" (1994)

use rustmath_core::Ring;
use std::collections::{HashMap, BTreeMap};
use std::fmt::{self, Display, Debug};
use std::hash::Hash;
use std::ops::{Add, Sub, Mul, Neg};
use std::cmp::Ordering;

// ============================================================================
// Monomial Type
// ============================================================================

/// A PBW monomial: ordered product of basis elements
///
/// Represented as a map from basis index to exponent.
/// The canonical ordering ensures unique representation.
///
/// # Examples
///
/// For basis {x, y, z} with x > y > z:
/// - x²yz³ is stored as {0: 2, 1: 1, 2: 3}
/// - yx is normalized to xy + [y,x]
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct PBWMonomial {
    /// Map from basis index to exponent (only non-zero exponents stored)
    exponents: BTreeMap<usize, usize>,
}

impl PBWMonomial {
    /// Create a new monomial
    pub fn new(exponents: BTreeMap<usize, usize>) -> Self {
        // Filter out zero exponents
        let filtered: BTreeMap<usize, usize> = exponents
            .into_iter()
            .filter(|(_, exp)| *exp > 0)
            .collect();

        PBWMonomial { exponents: filtered }
    }

    /// Create the unit monomial (1)
    pub fn one() -> Self {
        PBWMonomial {
            exponents: BTreeMap::new(),
        }
    }

    /// Create a single generator monomial
    pub fn generator(index: usize, power: usize) -> Self {
        if power == 0 {
            return Self::one();
        }

        let mut exponents = BTreeMap::new();
        exponents.insert(index, power);
        PBWMonomial { exponents }
    }

    /// Check if this is the unit monomial
    pub fn is_one(&self) -> bool {
        self.exponents.is_empty()
    }

    /// Get the exponents
    pub fn exponents(&self) -> &BTreeMap<usize, usize> {
        &self.exponents
    }

    /// Get the total degree (sum of exponents)
    pub fn degree(&self) -> usize {
        self.exponents.values().sum()
    }

    /// Multiply two monomials (assumes they're already in canonical order)
    pub fn mul_canonical(&self, other: &Self) -> Self {
        let mut result = self.exponents.clone();

        for (idx, exp) in &other.exponents {
            *result.entry(*idx).or_insert(0) += exp;
        }

        PBWMonomial::new(result)
    }
}

impl Display for PBWMonomial {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.is_one() {
            return write!(f, "1");
        }

        let terms: Vec<String> = self
            .exponents
            .iter()
            .map(|(idx, exp)| {
                if *exp == 1 {
                    format!("b_{}", idx)
                } else {
                    format!("b_{}^{}", idx, exp)
                }
            })
            .collect();

        write!(f, "{}", terms.join("⊗"))
    }
}

impl PartialOrd for PBWMonomial {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for PBWMonomial {
    fn cmp(&self, other: &Self) -> Ordering {
        // Reverse degree lexicographic order
        // First compare by degree (higher degree > lower degree)
        match other.degree().cmp(&self.degree()) {
            Ordering::Equal => {
                // Then lexicographically by exponents (reverse iteration)
                other.exponents.cmp(&self.exponents)
            }
            ord => ord,
        }
    }
}

// ============================================================================
// PBW Element
// ============================================================================

/// Element of a universal enveloping algebra in PBW basis
///
/// Represented as a linear combination of PBW monomials.
///
/// # Type Parameters
///
/// * `R` - The coefficient ring
#[derive(Clone, Debug)]
pub struct PBWElement<R: Ring + Clone> {
    /// Coefficients for each monomial
    monomials: HashMap<PBWMonomial, R>,
}

impl<R: Ring + Clone + PartialEq + From<i64>> PBWElement<R> {
    /// Create a new element
    pub fn new(monomials: HashMap<PBWMonomial, R>) -> Self {
        // Remove zero coefficients
        let filtered: HashMap<PBWMonomial, R> = monomials
            .into_iter()
            .filter(|(_, coeff)| coeff != &R::from(0))
            .collect();

        PBWElement { monomials: filtered }
    }

    /// Create the zero element
    pub fn zero() -> Self {
        PBWElement {
            monomials: HashMap::new(),
        }
    }

    /// Create the unit element (1)
    pub fn one() -> Self {
        let mut monomials = HashMap::new();
        monomials.insert(PBWMonomial::one(), R::from(1));
        PBWElement { monomials }
    }

    /// Create a single monomial element
    pub fn monomial(mon: PBWMonomial, coeff: R) -> Self {
        if coeff == R::from(0) {
            return Self::zero();
        }

        let mut monomials = HashMap::new();
        monomials.insert(mon, coeff);
        PBWElement { monomials }
    }

    /// Create an element from a single generator
    pub fn generator(index: usize, coeff: R) -> Self {
        Self::monomial(PBWMonomial::generator(index, 1), coeff)
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool {
        self.monomials.is_empty()
    }

    /// Check if this is one
    pub fn is_one(&self) -> bool {
        if self.monomials.len() != 1 {
            return false;
        }

        if let Some((mon, coeff)) = self.monomials.iter().next() {
            mon.is_one() && coeff == &R::from(1)
        } else {
            false
        }
    }

    /// Get the monomials
    pub fn monomials(&self) -> &HashMap<PBWMonomial, R> {
        &self.monomials
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Self {
        if scalar == &R::from(0) {
            return Self::zero();
        }

        let scaled: HashMap<PBWMonomial, R> = self
            .monomials
            .iter()
            .map(|(mon, coeff)| (mon.clone(), coeff.clone() * scalar.clone()))
            .collect();

        PBWElement::new(scaled)
    }
}

impl<R: Ring + Clone + PartialEq + From<i64>> Add for PBWElement<R> {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        let mut result = self.monomials.clone();

        for (mon, coeff) in other.monomials {
            let entry = result.entry(mon).or_insert_with(|| R::from(0));
            *entry = entry.clone() + coeff;
        }

        PBWElement::new(result)
    }
}

impl<R: Ring + Clone + PartialEq + From<i64>> Sub for PBWElement<R> {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        let mut result = self.monomials.clone();

        for (mon, coeff) in other.monomials {
            let entry = result.entry(mon).or_insert_with(|| R::from(0));
            *entry = entry.clone() - coeff;
        }

        PBWElement::new(result)
    }
}

impl<R: Ring + Clone + PartialEq + From<i64>> Neg for PBWElement<R> {
    type Output = Self;

    fn neg(self) -> Self {
        let negated: HashMap<PBWMonomial, R> = self
            .monomials
            .into_iter()
            .map(|(mon, coeff)| (mon, -coeff))
            .collect();

        PBWElement::new(negated)
    }
}

impl<R: Ring + Clone + Display + PartialEq + From<i64>> Display for PBWElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let terms: Vec<String> = self
            .monomials
            .iter()
            .map(|(mon, coeff)| {
                if mon.is_one() {
                    format!("{}", coeff)
                } else {
                    format!("{}*{}", coeff, mon)
                }
            })
            .collect();

        write!(f, "{}", terms.join(" + "))
    }
}

// ============================================================================
// PBW Basis (Universal Enveloping Algebra)
// ============================================================================

/// Universal enveloping algebra with Poincaré-Birkhoff-Witt basis
///
/// This represents U(g) for a Lie algebra g, with elements expressed
/// in the PBW basis.
///
/// # Type Parameters
///
/// * `R` - The coefficient ring
///
/// # Structure
///
/// The algebra is generated by basis elements of the Lie algebra.
/// Products are computed using the commutation relation:
/// - x * y = y * x + [x,y] when x > y in the basis ordering
///
/// This ensures all elements can be written uniquely as linear combinations
/// of ordered monomials.
#[derive(Clone, Debug)]
pub struct PoincareBirkhoffWittBasis<R: Ring + Clone> {
    /// Dimension of the Lie algebra (if finite)
    lie_algebra_dimension: Option<usize>,

    /// Names of basis elements
    basis_names: Vec<String>,

    /// Structure coefficients for Lie bracket: [b_i, b_j] = Σ c^k_ij * b_k
    /// Stored only for i < j due to antisymmetry
    structure_coefficients: HashMap<(usize, usize), HashMap<usize, R>>,
}

impl<R: Ring + Clone + PartialEq + From<i64>> PoincareBirkhoffWittBasis<R> {
    /// Create a new PBW basis from a Lie algebra
    ///
    /// # Arguments
    ///
    /// * `basis_names` - Names of the Lie algebra basis elements
    /// * `structure_coefficients` - Structure coefficients defining [b_i, b_j]
    pub fn new(
        basis_names: Vec<String>,
        structure_coefficients: HashMap<(usize, usize), HashMap<usize, R>>,
    ) -> Self {
        let dimension = Some(basis_names.len());

        PoincareBirkhoffWittBasis {
            lie_algebra_dimension: dimension,
            basis_names,
            structure_coefficients,
        }
    }

    /// Get the Lie algebra dimension
    pub fn lie_algebra_dimension(&self) -> Option<usize> {
        self.lie_algebra_dimension
    }

    /// Get the basis names
    pub fn basis_names(&self) -> &[String] {
        &self.basis_names
    }

    /// Compute [b_i, b_j] as a PBW element
    pub fn bracket(&self, i: usize, j: usize) -> PBWElement<R> {
        if i == j {
            return PBWElement::zero();
        }

        let (idx_i, idx_j, sign) = if i < j {
            (i, j, R::from(1))
        } else {
            (j, i, R::from(-1))
        };

        if let Some(coeffs) = self.structure_coefficients.get(&(idx_i, idx_j)) {
            let mut monomials = HashMap::new();

            for (k, coeff) in coeffs {
                let signed_coeff = coeff.clone() * sign.clone();
                let mon = PBWMonomial::generator(*k, 1);
                monomials.insert(mon, signed_coeff);
            }

            PBWElement::new(monomials)
        } else {
            PBWElement::zero()
        }
    }

    /// Compute product of two monomials in PBW basis
    ///
    /// Uses the commutation relation: x*y = y*x + [x,y] when x > y
    pub fn product_monomials(&self, m1: &PBWMonomial, m2: &PBWMonomial) -> PBWElement<R> {
        if m1.is_one() {
            return PBWElement::monomial(m2.clone(), R::from(1));
        }
        if m2.is_one() {
            return PBWElement::monomial(m1.clone(), R::from(1));
        }

        // For simplicity, multiply directly (full implementation would reorder)
        let product = m1.mul_canonical(m2);
        PBWElement::monomial(product, R::from(1))
    }
}

// ============================================================================
// Semisimple Specialization
// ============================================================================

/// Specialized PBW basis for semisimple Lie algebras
///
/// For semisimple Lie algebras with triangular decomposition g = n⁻ ⊕ h ⊕ n⁺,
/// this provides optimized implementations using the root space structure.
///
/// # Type Parameters
///
/// * `R` - The coefficient ring
#[derive(Clone, Debug)]
pub struct PoincareBirkhoffWittBasisSemisimple<R: Ring + Clone> {
    /// Base PBW structure
    base: PoincareBirkhoffWittBasis<R>,

    /// Rank of the Lie algebra
    rank: usize,

    /// Indices of Cartan subalgebra elements
    cartan_indices: Vec<usize>,

    /// Indices of positive root generators
    positive_root_indices: Vec<usize>,

    /// Indices of negative root generators
    negative_root_indices: Vec<usize>,
}

impl<R: Ring + Clone + PartialEq + From<i64>> PoincareBirkhoffWittBasisSemisimple<R> {
    /// Create a new semisimple PBW basis
    ///
    /// # Arguments
    ///
    /// * `base` - The underlying PBW basis
    /// * `rank` - The rank (dimension of Cartan subalgebra)
    /// * `cartan_indices` - Indices of h basis elements
    /// * `positive_root_indices` - Indices of n⁺ generators
    /// * `negative_root_indices` - Indices of n⁻ generators
    pub fn new(
        base: PoincareBirkhoffWittBasis<R>,
        rank: usize,
        cartan_indices: Vec<usize>,
        positive_root_indices: Vec<usize>,
        negative_root_indices: Vec<usize>,
    ) -> Self {
        PoincareBirkhoffWittBasisSemisimple {
            base,
            rank,
            cartan_indices,
            positive_root_indices,
            negative_root_indices,
        }
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.rank
    }

    /// Get a Cartan element
    pub fn cartan_element(&self, i: usize) -> Option<PBWElement<R>> {
        if i >= self.cartan_indices.len() {
            return None;
        }

        let idx = self.cartan_indices[i];
        Some(PBWElement::generator(idx, R::from(1)))
    }

    /// Get a positive root generator
    pub fn positive_root(&self, i: usize) -> Option<PBWElement<R>> {
        if i >= self.positive_root_indices.len() {
            return None;
        }

        let idx = self.positive_root_indices[i];
        Some(PBWElement::generator(idx, R::from(1)))
    }

    /// Get a negative root generator
    pub fn negative_root(&self, i: usize) -> Option<PBWElement<R>> {
        if i >= self.negative_root_indices.len() {
            return None;
        }

        let idx = self.negative_root_indices[i];
        Some(PBWElement::generator(idx, R::from(1)))
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_pbw_monomial_creation() {
        let mon = PBWMonomial::generator(0, 2);
        assert_eq!(mon.degree(), 2);
        assert!(!mon.is_one());

        let one = PBWMonomial::one();
        assert!(one.is_one());
        assert_eq!(one.degree(), 0);
    }

    #[test]
    fn test_pbw_monomial_multiplication() {
        let m1 = PBWMonomial::generator(0, 2);
        let m2 = PBWMonomial::generator(1, 3);

        let product = m1.mul_canonical(&m2);
        assert_eq!(product.degree(), 5);
        assert_eq!(product.exponents().get(&0), Some(&2));
        assert_eq!(product.exponents().get(&1), Some(&3));
    }

    #[test]
    fn test_pbw_monomial_ordering() {
        let m1 = PBWMonomial::generator(0, 1); // degree 1
        let m2 = PBWMonomial::generator(0, 2); // degree 2

        // Higher degree > lower degree
        assert!(m2 > m1);
    }

    #[test]
    fn test_pbw_element_creation() {
        let elem = PBWElement::<Integer>::generator(0, Integer::from(3));

        assert!(!elem.is_zero());
        assert!(!elem.is_one());
        assert_eq!(elem.monomials().len(), 1);
    }

    #[test]
    fn test_pbw_element_arithmetic() {
        let e1 = PBWElement::<Integer>::generator(0, Integer::from(2));
        let e2 = PBWElement::<Integer>::generator(1, Integer::from(3));

        let sum = e1.clone() + e2.clone();
        assert_eq!(sum.monomials().len(), 2);

        let diff = e1.clone() - e2.clone();
        assert_eq!(diff.monomials().len(), 2);

        let neg = -e1.clone();
        assert_eq!(neg.monomials().len(), 1);

        let zero = e1.clone() - e1.clone();
        assert!(zero.is_zero());
    }

    #[test]
    fn test_pbw_element_scalar_mul() {
        let elem = PBWElement::<Integer>::generator(0, Integer::from(2));
        let scaled = elem.scalar_mul(&Integer::from(3));

        assert_eq!(scaled.monomials().len(), 1);

        let zero_scaled = elem.scalar_mul(&Integer::from(0));
        assert!(zero_scaled.is_zero());
    }

    #[test]
    fn test_pbw_basis_creation() {
        let basis_names = vec!["e".to_string(), "f".to_string(), "h".to_string()];
        let coeffs = HashMap::new(); // Abelian for simplicity

        let pbw = PoincareBirkhoffWittBasis::<Integer>::new(basis_names, coeffs);

        assert_eq!(pbw.lie_algebra_dimension(), Some(3));
        assert_eq!(pbw.basis_names().len(), 3);
    }

    #[test]
    fn test_pbw_bracket_computation() {
        let mut coeffs = HashMap::new();

        // [e, f] = h (indices 0, 1 -> 2)
        let mut ef_bracket = HashMap::new();
        ef_bracket.insert(2, Integer::from(1));
        coeffs.insert((0, 1), ef_bracket);

        let basis_names = vec!["e".to_string(), "f".to_string(), "h".to_string()];
        let pbw = PoincareBirkhoffWittBasis::new(basis_names, coeffs);

        let bracket = pbw.bracket(0, 1);
        assert!(!bracket.is_zero());

        let zero_bracket = pbw.bracket(0, 0);
        assert!(zero_bracket.is_zero());
    }

    #[test]
    fn test_semisimple_pbw() {
        let basis_names = vec!["e".to_string(), "f".to_string(), "h".to_string()];
        let base = PoincareBirkhoffWittBasis::<Integer>::new(basis_names, HashMap::new());

        let semisimple = PoincareBirkhoffWittBasisSemisimple::new(
            base,
            1,
            vec![2],       // h is Cartan
            vec![0],       // e is positive root
            vec![1],       // f is negative root
        );

        assert_eq!(semisimple.rank(), 1);
        assert!(semisimple.cartan_element(0).is_some());
        assert!(semisimple.positive_root(0).is_some());
        assert!(semisimple.negative_root(0).is_some());
    }

    #[test]
    fn test_pbw_one_and_zero() {
        let one = PBWElement::<Integer>::one();
        assert!(one.is_one());
        assert!(!one.is_zero());

        let zero = PBWElement::<Integer>::zero();
        assert!(zero.is_zero());
        assert!(!zero.is_one());
    }
}
