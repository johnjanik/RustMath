//! Example Lie Algebras
//!
//! This module provides convenient factory functions for constructing
//! various types of Lie algebras with standard parameters.
//!
//! Corresponds to sage.algebras.lie_algebras.examples
//!
//! # Available Examples
//!
//! - Abelian Lie algebras (commutative)
//! - Classical Lie algebras (sl, sp, so, gl)
//! - Heisenberg algebras
//! - Free Lie algebras
//! - Nilpotent Lie algebras
//! - Virasoro algebras
//!
//! # Examples
//!
//! ```
//! use rustmath_liealgebras::examples;
//! use rustmath_rationals::Rational;
//!
//! // Create an abelian Lie algebra of dimension 3
//! let lie_alg = examples::abelian::<Rational>(3);
//!
//! // Create sl_2 (special linear Lie algebra)
//! let sl2 = examples::sl::<Rational>(2);
//! ```

use crate::abelian::AbelianLieAlgebra;
use crate::classical::{
    SpecialLinearLieAlgebra, SpecialOrthogonalLieAlgebra, SymplecticLieAlgebra,
};
use crate::heisenberg::HeisenbergAlgebra;
use crate::free_lie_algebra::{FreeLieAlgebra, FreeLieAlgebraBasis};
use crate::nilpotent::FreeNilpotentLieAlgebra;
use crate::virasoro::VirasoroAlgebra;
use rustmath_core::Ring;

/// Create an abelian (commutative) Lie algebra of given dimension
///
/// An abelian Lie algebra has [x, y] = 0 for all elements x and y.
///
/// # Arguments
///
/// * `dimension` - The dimension of the Lie algebra
///
/// # Returns
///
/// An abelian Lie algebra of the specified dimension
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::abelian;
/// use rustmath_rationals::Rational;
///
/// let lie_alg = abelian::<Rational>(3);
/// ```
pub fn abelian<R: Ring + Clone>(dimension: usize) -> AbelianLieAlgebra<R> {
    AbelianLieAlgebra::new(dimension)
}

/// Create the special linear Lie algebra sl_n
///
/// sl_n consists of n×n matrices with trace zero.
///
/// # Arguments
///
/// * `n` - The dimension (size of matrices)
///
/// # Returns
///
/// The special linear Lie algebra sl_n, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::sl;
/// use rustmath_rationals::Rational;
///
/// let sl2 = sl::<Rational>(2).unwrap();
/// let sl3 = sl::<Rational>(3).unwrap();
/// ```
pub fn sl<R: Ring + Clone>(n: usize) -> Result<SpecialLinearLieAlgebra<R>, String> {
    SpecialLinearLieAlgebra::new(n)
}

/// Create the special orthogonal Lie algebra so_n
///
/// so_n consists of n×n skew-symmetric matrices.
///
/// # Arguments
///
/// * `n` - The dimension
///
/// # Returns
///
/// The special orthogonal Lie algebra so_n, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::so;
/// use rustmath_rationals::Rational;
///
/// let so3 = so::<Rational>(3).unwrap();
/// ```
pub fn so<R: Ring + Clone>(n: usize) -> Result<SpecialOrthogonalLieAlgebra<R>, String> {
    SpecialOrthogonalLieAlgebra::new(n)
}

/// Create the symplectic Lie algebra sp_n
///
/// sp_n (also denoted sp_{2n}) consists of 2n×2n matrices preserving
/// the standard symplectic form.
///
/// # Arguments
///
/// * `n` - Half the dimension (creates sp_{2n})
///
/// # Returns
///
/// The symplectic Lie algebra sp_{2n}, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::sp;
/// use rustmath_rationals::Rational;
///
/// let sp2 = sp::<Rational>(1).unwrap();  // sp_2
/// let sp4 = sp::<Rational>(2).unwrap();  // sp_4
/// ```
pub fn sp<R: Ring + Clone>(n: usize) -> Result<SymplecticLieAlgebra<R>, String> {
    SymplecticLieAlgebra::new(n)
}

/// Create the Heisenberg Lie algebra H_{2n+1}
///
/// The Heisenberg algebra is the Lie algebra of the Heisenberg group,
/// with generators p_i, q_i, and central element z satisfying
/// [q_i, p_j] = δ_{ij} z.
///
/// # Arguments
///
/// * `n` - The number of p-q pairs (total dimension is 2n+1)
///
/// # Returns
///
/// The Heisenberg Lie algebra of dimension 2n+1
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::heisenberg;
/// use rustmath_rationals::Rational;
///
/// let h3 = heisenberg::<Rational>(1);  // dim 3: p, q, z
/// let h5 = heisenberg::<Rational>(2);  // dim 5: p₁, q₁, p₂, q₂, z
/// ```
pub fn heisenberg<R>(n: usize) -> HeisenbergAlgebra<R>
where
    R: Ring + Clone + From<i64>,
{
    HeisenbergAlgebra::new(n)
}

/// Create a free Lie algebra on n generators
///
/// A free Lie algebra is the free object in the category of Lie algebras,
/// generated by a set of symbols with no additional relations.
///
/// Uses the Lyndon basis by default.
///
/// # Arguments
///
/// * `num_generators` - Number of generators
///
/// # Returns
///
/// A free Lie algebra on the specified number of generators
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::free_lie_algebra;
/// use rustmath_rationals::Rational;
///
/// let free = free_lie_algebra::<Rational>(2);
/// ```
pub fn free_lie_algebra<R: Ring + Clone>(num_generators: usize) -> FreeLieAlgebra<R> {
    FreeLieAlgebra::new(num_generators, FreeLieAlgebraBasis::Lyndon)
}

/// Create a free nilpotent Lie algebra
///
/// A nilpotent Lie algebra where all iterated brackets of sufficient
/// depth vanish.
///
/// # Arguments
///
/// * `num_generators` - Number of generators
/// * `step` - Nilpotency class (L^{step+1} = 0)
///
/// # Returns
///
/// A free nilpotent Lie algebra
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::free_nilpotent;
/// use rustmath_rationals::Rational;
///
/// // Free nilpotent of step 2 on 2 generators
/// let nilp = free_nilpotent::<Rational>(2, 2);
/// ```
pub fn free_nilpotent<R>(num_generators: usize, step: usize) -> FreeNilpotentLieAlgebra<R>
where
    R: Ring + Clone + From<i64> + std::ops::Add<Output = R> + std::ops::Mul<Output = R> + std::ops::Neg<Output = R> + PartialEq,
{
    FreeNilpotentLieAlgebra::new(num_generators, step)
}

/// Create the Virasoro algebra
///
/// The Virasoro algebra is an infinite-dimensional Lie algebra that
/// appears in conformal field theory and string theory.
///
/// # Returns
///
/// The Virasoro algebra
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::virasoro;
/// use rustmath_rationals::Rational;
///
/// let vir = virasoro::<Rational>();
/// ```
pub fn virasoro<R: Ring + Clone>() -> VirasoroAlgebra<R> {
    VirasoroAlgebra::new()
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;
    use rustmath_integers::Integer;

    #[test]
    fn test_abelian_example() {
        let lie_alg = abelian::<Integer>(3);
        // Test that we can create the algebra
        assert_eq!(lie_alg.dimension(), 3);
    }

    #[test]
    fn test_classical_examples() {
        // Test that we can create classical Lie algebras
        let sl2 = sl::<Integer>(2).unwrap();
        assert_eq!(sl2.dimension(), 3);  // sl_2 has dimension 3

        let sl3 = sl::<Integer>(3).unwrap();
        assert_eq!(sl3.dimension(), 8);  // sl_3 has dimension 8

        let so3 = so::<Integer>(3).unwrap();
        assert_eq!(so3.dimension(), 3);  // so_3 has dimension 3

        let sp2 = sp::<Integer>(1).unwrap();
        assert_eq!(sp2.dimension(), 3);  // sp_2 has dimension 3
    }

    #[test]
    fn test_heisenberg_example() {
        // Test Heisenberg algebra creation
        let h = heisenberg::<Integer>(1);
        assert_eq!(h.dimension(), 3);  // dim = 2n + 1 = 3

        let h2 = heisenberg::<Integer>(2);
        assert_eq!(h2.dimension(), 5);  // dim = 2*2 + 1 = 5
    }

    #[test]
    fn test_free_lie_algebra_example() {
        // Test free Lie algebra creation
        let free = free_lie_algebra::<Integer>(2);
        assert_eq!(free.num_generators(), 2);
    }

    #[test]
    fn test_free_nilpotent_example() {
        // Test free nilpotent Lie algebra creation
        let nilp = free_nilpotent::<Integer>(2, 2);
        assert_eq!(nilp.num_generators(), 2);
        assert_eq!(nilp.step(), 2);
    }

    #[test]
    fn test_virasoro_example() {
        // Test Virasoro algebra creation
        let _vir = virasoro::<Integer>();
        // Just test that it can be created
        assert!(true);
    }

    #[test]
    fn test_all_factories_work() {
        // Comprehensive test that all factory functions work
        let _ab = abelian::<Integer>(2);
        let _sl = sl::<Integer>(2).unwrap();
        let _so = so::<Integer>(3).unwrap();
        let _sp = sp::<Integer>(1).unwrap();
        let _h = heisenberg::<Integer>(1);
        let _free = free_lie_algebra::<Integer>(2);
        let _nilp = free_nilpotent::<Integer>(2, 2);
        let _vir = virasoro::<Integer>();

        // If we got here, all factories work
        assert!(true);
    }
}
