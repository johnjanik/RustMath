//! Example Lie Algebras
//!
//! This module provides convenient factory functions for constructing
//! various types of Lie algebras with standard parameters.
//!
//! Corresponds to sage.algebras.lie_algebras.examples
//!
//! # Available Examples
//!
//! - Abelian Lie algebras (commutative)
//! - Classical Lie algebras (sl, sp, so, gl)
//! - Heisenberg algebras
//! - Free Lie algebras
//! - Nilpotent Lie algebras
//! - Virasoro algebras
//!
//! # Examples
//!
//! ```
//! use rustmath_liealgebras::examples;
//! use rustmath_rationals::Rational;
//!
//! // Create an abelian Lie algebra of dimension 3
//! let lie_alg = examples::abelian::<Rational>(3);
//!
//! // Create sl_2 (special linear Lie algebra)
//! let sl2 = examples::sl::<Rational>(2);
//! ```

use crate::abelian::AbelianLieAlgebra;
use crate::classical::{
    SpecialLinearLieAlgebra, SpecialOrthogonalLieAlgebra, SymplecticLieAlgebra,
};
use crate::heisenberg::HeisenbergAlgebra;
use crate::free_lie_algebra::{FreeLieAlgebra, FreeLieAlgebraBasis};
use crate::nilpotent::FreeNilpotentLieAlgebra;
use crate::virasoro::VirasoroAlgebra;
use crate::witt::WittAlgebra;
use crate::pwitt::PolynomialWittAlgebra;
use crate::two_dimensional::TwoDimensionalLieAlgebra;
use crate::three_dimensional::ThreeDimensionalLieAlgebra;
use rustmath_core::Ring;

/// Create an abelian (commutative) Lie algebra of given dimension
///
/// An abelian Lie algebra has [x, y] = 0 for all elements x and y.
///
/// # Arguments
///
/// * `dimension` - The dimension of the Lie algebra
///
/// # Returns
///
/// An abelian Lie algebra of the specified dimension
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::abelian;
/// use rustmath_rationals::Rational;
///
/// let lie_alg = abelian::<Rational>(3);
/// ```
pub fn abelian<R: Ring + Clone>(dimension: usize) -> AbelianLieAlgebra<R> {
    AbelianLieAlgebra::new(dimension)
}

/// Create the special linear Lie algebra sl_n
///
/// sl_n consists of n√ón matrices with trace zero.
///
/// # Arguments
///
/// * `n` - The dimension (size of matrices)
///
/// # Returns
///
/// The special linear Lie algebra sl_n, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::sl;
/// use rustmath_rationals::Rational;
///
/// let sl2 = sl::<Rational>(2).unwrap();
/// let sl3 = sl::<Rational>(3).unwrap();
/// ```
pub fn sl<R: Ring + Clone>(n: usize) -> Result<SpecialLinearLieAlgebra<R>, String> {
    SpecialLinearLieAlgebra::new(n)
}

/// Create the special orthogonal Lie algebra so_n
///
/// so_n consists of n√ón skew-symmetric matrices.
///
/// # Arguments
///
/// * `n` - The dimension
///
/// # Returns
///
/// The special orthogonal Lie algebra so_n, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::so;
/// use rustmath_rationals::Rational;
///
/// let so3 = so::<Rational>(3).unwrap();
/// ```
pub fn so<R: Ring + Clone>(n: usize) -> Result<SpecialOrthogonalLieAlgebra<R>, String> {
    SpecialOrthogonalLieAlgebra::new(n)
}

/// Create the symplectic Lie algebra sp_n
///
/// sp_n (also denoted sp_{2n}) consists of 2n√ó2n matrices preserving
/// the standard symplectic form.
///
/// # Arguments
///
/// * `n` - Half the dimension (creates sp_{2n})
///
/// # Returns
///
/// The symplectic Lie algebra sp_{2n}, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::sp;
/// use rustmath_rationals::Rational;
///
/// let sp2 = sp::<Rational>(1).unwrap();  // sp_2
/// let sp4 = sp::<Rational>(2).unwrap();  // sp_4
/// ```
pub fn sp<R: Ring + Clone>(n: usize) -> Result<SymplecticLieAlgebra<R>, String> {
    SymplecticLieAlgebra::new(n)
}

/// Create the Heisenberg Lie algebra H_{2n+1}
///
/// The Heisenberg algebra is the Lie algebra of the Heisenberg group,
/// with generators p_i, q_i, and central element z satisfying
/// [q_i, p_j] = Œ¥_{ij} z.
///
/// # Arguments
///
/// * `n` - The number of p-q pairs (total dimension is 2n+1)
///
/// # Returns
///
/// The Heisenberg Lie algebra of dimension 2n+1
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::heisenberg;
/// use rustmath_rationals::Rational;
///
/// let h3 = heisenberg::<Rational>(1);  // dim 3: p, q, z
/// let h5 = heisenberg::<Rational>(2);  // dim 5: p‚ÇÅ, q‚ÇÅ, p‚ÇÇ, q‚ÇÇ, z
/// ```
pub fn heisenberg<R>(n: usize) -> HeisenbergAlgebra<R>
where
    R: Ring + Clone + From<i64>,
{
    HeisenbergAlgebra::new(n)
}

/// Create a free Lie algebra on n generators
///
/// A free Lie algebra is the free object in the category of Lie algebras,
/// generated by a set of symbols with no additional relations.
///
/// Uses the Lyndon basis by default.
///
/// # Arguments
///
/// * `num_generators` - Number of generators
///
/// # Returns
///
/// A free Lie algebra on the specified number of generators
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::free_lie_algebra;
/// use rustmath_rationals::Rational;
///
/// let free = free_lie_algebra::<Rational>(2);
/// ```
pub fn free_lie_algebra<R: Ring + Clone>(num_generators: usize) -> FreeLieAlgebra<R> {
    FreeLieAlgebra::new(num_generators, FreeLieAlgebraBasis::Lyndon)
}

/// Create a free nilpotent Lie algebra
///
/// A nilpotent Lie algebra where all iterated brackets of sufficient
/// depth vanish.
///
/// # Arguments
///
/// * `num_generators` - Number of generators
/// * `step` - Nilpotency class (L^{step+1} = 0)
///
/// # Returns
///
/// A free nilpotent Lie algebra
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::free_nilpotent;
/// use rustmath_rationals::Rational;
///
/// // Free nilpotent of step 2 on 2 generators
/// let nilp = free_nilpotent::<Rational>(2, 2);
/// ```
pub fn free_nilpotent<R>(num_generators: usize, step: usize) -> FreeNilpotentLieAlgebra<R>
where
    R: Ring + Clone + From<i64> + std::ops::Add<Output = R> + std::ops::Mul<Output = R> + std::ops::Neg<Output = R> + PartialEq,
{
    FreeNilpotentLieAlgebra::new(num_generators, step)
}

/// Create the Virasoro algebra
///
/// The Virasoro algebra is an infinite-dimensional Lie algebra that
/// appears in conformal field theory and string theory.
///
/// # Returns
///
/// The Virasoro algebra
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::virasoro;
/// use rustmath_rationals::Rational;
///
/// let vir = virasoro::<Rational>();
/// ```
pub fn virasoro<R: Ring + Clone>() -> VirasoroAlgebra<R> {
    VirasoroAlgebra::new()
}

/// Create the Lie algebra R^3 with the cross product as Lie bracket
///
/// This creates the 3-dimensional Lie algebra where the Lie bracket is
/// defined by the standard vector cross product:
/// - [e_0, e_1] = e_2 (i √ó j = k)
/// - [e_1, e_2] = e_0 (j √ó k = i)
/// - [e_2, e_0] = e_1 (k √ó i = j)
///
/// This Lie algebra is isomorphic to so(3) and su(2).
///
/// Corresponds to sage.algebras.lie_algebras.examples.cross_product
///
/// # Returns
///
/// The 3-dimensional Lie algebra with cross product bracket
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::cross_product;
/// use rustmath_rationals::Rational;
///
/// let lie_alg = cross_product::<Rational>();
/// assert_eq!(lie_alg.dimension(), 3);
/// ```
pub fn cross_product<R>() -> ThreeDimensionalLieAlgebra<R>
where
    R: Ring + Clone + From<i64>,
{
    // R^3 with cross product has structure coefficients: a=1, b=1, c=1, d=0
    // [e_0, e_1] = e_2
    // [e_0, e_2] = e_1  (but with negative sign from antisymmetry: [e_2, e_0] = e_1)
    // [e_1, e_2] = e_0
    ThreeDimensionalLieAlgebra::new(
        R::from(1),  // a: [e_0, e_1] = e_2
        R::from(1),  // b: [e_0, e_2] = e_1
        R::from(1),  // c: [e_1, e_2] = e_0
        R::from(0),  // d: no e_2 component in [e_1, e_2]
    )
}

/// Create the Lie algebra of affine transformations of the line
///
/// This creates a 2-dimensional Lie algebra governing affine transformations
/// of the form x ‚Ü¶ ax + b on the real line. The generators are:
/// - e_0 (X): scaling generator
/// - e_1 (Y): translation generator
///
/// With the bracket relation: [X, Y] = Y
///
/// This represents how the translation generator is affected by the scaling
/// generator under commutation.
///
/// Corresponds to sage.algebras.lie_algebras.examples.affine_transformations_line
///
/// # Returns
///
/// The 2-dimensional Lie algebra of affine transformations
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::affine_transformations_line;
/// use rustmath_rationals::Rational;
///
/// let lie_alg = affine_transformations_line::<Rational>();
/// assert_eq!(lie_alg.dimension(), 2);
/// ```
pub fn affine_transformations_line<R>() -> TwoDimensionalLieAlgebra<R>
where
    R: Ring + Clone + From<i64>,
{
    // [e_0, e_1] = e_1, so c=0, d=1
    TwoDimensionalLieAlgebra::new(
        R::from(0),  // c: no e_0 component in [e_0, e_1]
        R::from(1),  // d: [e_0, e_1] = e_1
    )
}

/// Create a general 3-dimensional Lie algebra with structure coefficients
///
/// Creates a 3-dimensional Lie algebra with bracket relations:
/// - [X, Y] = aZ + dY
/// - [Y, Z] = bX
/// - [Z, X] = cY + dZ
///
/// where X, Y, Z are the basis elements (e_0, e_1, e_2) and a, b, c, d
/// are the structure coefficients.
///
/// Corresponds to sage.algebras.lie_algebras.examples.three_dimensional
///
/// # Arguments
///
/// * `a` - Coefficient for [X,Y] = aZ + dY (Z component)
/// * `b` - Coefficient for [Y,Z] = bX
/// * `c` - Coefficient for [Z,X] = cY + dZ (Y component)
/// * `d` - Mixed coefficient appearing in [X,Y] and [Z,X]
///
/// # Returns
///
/// A 3-dimensional Lie algebra with the specified structure
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::three_dimensional;
/// use rustmath_rationals::Rational;
///
/// // Create sl_2 (a=1, b=1, c=1, d=0)
/// let sl2 = three_dimensional(
///     Rational::from(1),
///     Rational::from(1),
///     Rational::from(1),
///     Rational::from(0)
/// );
/// ```
pub fn three_dimensional<R>(a: R, b: R, c: R, d: R) -> ThreeDimensionalLieAlgebra<R>
where
    R: Ring + Clone + From<i64>,
{
    ThreeDimensionalLieAlgebra::new(a, b, c, d)
}

/// Create a 3-dimensional Lie algebra by rank
///
/// Creates a 3-dimensional Lie algebra with a specific rank (dimension
/// of maximal torus). The rank determines the type of algebra:
///
/// - rank 0: Abelian (Heisenberg)
/// - rank 1: Solvable but not nilpotent
/// - rank 2: Solvable but not nilpotent (with deformation parameter a)
/// - rank 3: Semisimple (sl_2)
///
/// Corresponds to sage.algebras.lie_algebras.examples.three_dimensional_by_rank
///
/// # Arguments
///
/// * `rank` - The rank (0, 1, 2, or 3)
/// * `a` - Optional deformation parameter for rank 2 (defaults to 1)
///
/// # Returns
///
/// A 3-dimensional Lie algebra, or None if rank is invalid
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::three_dimensional_by_rank;
/// use rustmath_rationals::Rational;
///
/// // Create Heisenberg algebra (rank 0)
/// let heisen = three_dimensional_by_rank::<Rational>(0, None).unwrap();
///
/// // Create sl_2 (rank 3)
/// let sl2 = three_dimensional_by_rank::<Rational>(3, None).unwrap();
/// ```
pub fn three_dimensional_by_rank<R>(rank: usize, a: Option<R>) -> Option<ThreeDimensionalLieAlgebra<R>>
where
    R: Ring + Clone + From<i64>,
{
    match rank {
        0 => {
            // Heisenberg algebra (rank 0, abelian)
            // All brackets are zero
            Some(ThreeDimensionalLieAlgebra::new(
                R::from(0),
                R::from(0),
                R::from(0),
                R::from(0),
            ))
        }
        1 => {
            // Rank 1: solvable but not nilpotent
            // [X,Y] = Y (affine transformations extended)
            // This gives structure: a=0, b=0, c=0, d=1
            Some(ThreeDimensionalLieAlgebra::new(
                R::from(0),  // a
                R::from(0),  // b
                R::from(0),  // c
                R::from(1),  // d: [X,Y] = Y
            ))
        }
        2 => {
            // Rank 2: solvable with deformation
            // Uses parameter a (default 1)
            let coeff_a = a.unwrap_or_else(|| R::from(1));
            // Structure: [X,Y] = Z, [Y,Z] = aX
            Some(ThreeDimensionalLieAlgebra::new(
                R::from(1),  // a=1: [X,Y] = Z
                coeff_a,     // b=a: [Y,Z] = aX
                R::from(0),  // c=0
                R::from(0),  // d=0
            ))
        }
        3 => {
            // Rank 3 gives sl_2 (semisimple)
            // Standard sl_2 structure: a=1, b=1, c=1, d=0
            Some(ThreeDimensionalLieAlgebra::new(
                R::from(1),
                R::from(1),
                R::from(1),
                R::from(0),
            ))
        }
        _ => None,
    }
}

/// Create the special unitary Lie algebra su_n
///
/// The special unitary Lie algebra ùî∞ùî≤‚Çô consists of n√ón skew-Hermitian
/// matrices with trace zero. It is the compact real form of type A_{n-1}.
///
/// For simplicity, this implementation returns the same algebra as sl(n)
/// since they share the same Lie bracket structure (though over different
/// base fields in the mathematical theory).
///
/// Corresponds to sage.algebras.lie_algebras.examples.su
///
/// # Arguments
///
/// * `n` - The dimension
///
/// # Returns
///
/// The special unitary Lie algebra su_n, or an error if invalid parameters
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::su;
/// use rustmath_rationals::Rational;
///
/// let su2 = su::<Rational>(2).unwrap();
/// assert_eq!(su2.dimension(), 3);
/// ```
pub fn su<R: Ring + Clone>(n: usize) -> Result<SpecialLinearLieAlgebra<R>, String> {
    // For the Lie bracket structure, su(n) is isomorphic to sl(n)
    // They differ in the base field (real vs complex) but have the same brackets
    SpecialLinearLieAlgebra::new(n)
}

/// Create the Witt algebra
///
/// The Witt algebra is the Lie algebra of derivations on the Laurent
/// polynomial ring C[t, t‚Åª¬π], with basis d_n for n ‚àà ‚Ñ§.
///
/// The Witt algebra is the centerless Virasoro algebra.
///
/// Corresponds to sage.algebras.lie_algebras.examples.witt
///
/// # Returns
///
/// The Witt algebra
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::witt;
/// use rustmath_rationals::Rational;
///
/// let w = witt::<Rational>();
/// ```
pub fn witt<R: Ring + Clone>() -> WittAlgebra<R> {
    WittAlgebra::new()
}

/// Create the polynomial Witt algebra (positive part of Witt algebra)
///
/// The polynomial Witt algebra consists of polynomial derivations on C[t],
/// with basis d_n for n ‚â• 0. This is a subalgebra of the full Witt algebra.
///
/// Corresponds to sage.algebras.lie_algebras.examples.pwitt
///
/// # Returns
///
/// The polynomial Witt algebra
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::pwitt;
/// use rustmath_rationals::Rational;
///
/// let pw = pwitt::<Rational>();
/// ```
pub fn pwitt<R: Ring + Clone>() -> PolynomialWittAlgebra<R> {
    PolynomialWittAlgebra::new()
}

/// Create the Lie algebra of regular vector fields
///
/// This creates the Witt algebra, which represents regular (polynomial)
/// vector fields on the affine line.
///
/// This is an alias for `witt()` since regular vector fields are precisely
/// the derivations that the Witt algebra represents.
///
/// Corresponds to sage.algebras.lie_algebras.examples.regular_vector_fields
///
/// # Returns
///
/// The Witt algebra (Lie algebra of regular vector fields)
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::regular_vector_fields;
/// use rustmath_rationals::Rational;
///
/// let rvf = regular_vector_fields::<Rational>();
/// ```
pub fn regular_vector_fields<R: Ring + Clone>() -> WittAlgebra<R> {
    WittAlgebra::new()
}

/// Create the Lie algebra of strictly upper triangular matrices
///
/// This creates the Lie algebra of n√ón strictly upper triangular matrices
/// (upper triangular with zeros on the diagonal).
///
/// This is a nilpotent Lie subalgebra of gl_n.
///
/// For n=2, this gives a 1-dimensional abelian Lie algebra.
/// For n=3, this gives the 3-dimensional Heisenberg algebra.
///
/// Corresponds to sage.algebras.lie_algebras.examples.strictly_upper_triangular_matrices
///
/// # Arguments
///
/// * `n` - The size of matrices
///
/// # Returns
///
/// A nilpotent Lie algebra representing strictly upper triangular matrices,
/// or an error if n < 2
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::strictly_upper_triangular_matrices;
/// use rustmath_rationals::Rational;
///
/// // For n=2: 1-dimensional
/// let sut2 = strictly_upper_triangular_matrices::<Rational>(2).unwrap();
///
/// // For n=3: Heisenberg algebra
/// let sut3 = strictly_upper_triangular_matrices::<Rational>(3).unwrap();
/// ```
pub fn strictly_upper_triangular_matrices<R>(n: usize) -> Result<FreeNilpotentLieAlgebra<R>, String>
where
    R: Ring + Clone + From<i64> + std::ops::Add<Output = R> + std::ops::Mul<Output = R> + std::ops::Neg<Output = R> + PartialEq,
{
    if n < 2 {
        return Err("Dimension must be at least 2".to_string());
    }

    // Strictly upper triangular n√ón matrices form a nilpotent Lie algebra
    // The dimension is n(n-1)/2
    // The nilpotency class is n-1
    let num_generators = n * (n - 1) / 2;
    let step = n - 1;

    Ok(FreeNilpotentLieAlgebra::new(num_generators, step))
}

/// Create the Lie algebra of upper triangular matrices
///
/// This creates the Lie algebra of n√ón upper triangular matrices with
/// trace zero. This is a solvable Lie subalgebra of sl_n (Borel subalgebra).
///
/// It contains the diagonal matrices (Cartan subalgebra) and the strictly
/// upper triangular matrices (nilpotent radical).
///
/// For small n, this can be realized using existing constructions.
///
/// Corresponds to sage.algebras.lie_algebras.examples.upper_triangular_matrices
///
/// # Arguments
///
/// * `n` - The size of matrices
///
/// # Returns
///
/// A solvable Lie algebra representing upper triangular matrices with trace zero,
/// or an error if n < 2
///
/// # Examples
///
/// ```
/// use rustmath_liealgebras::examples::upper_triangular_matrices;
/// use rustmath_rationals::Rational;
///
/// let ut3 = upper_triangular_matrices::<Rational>(3).unwrap();
/// ```
pub fn upper_triangular_matrices<R>(n: usize) -> Result<FreeNilpotentLieAlgebra<R>, String>
where
    R: Ring + Clone + From<i64> + std::ops::Add<Output = R> + std::ops::Mul<Output = R> + std::ops::Neg<Output = R> + PartialEq,
{
    if n < 2 {
        return Err("Dimension must be at least 2".to_string());
    }

    // Upper triangular matrices with trace zero form a solvable Lie algebra
    // Dimension is (n-1) + n(n-1)/2 = n(n+1)/2 - 1
    // For simplicity, we use a nilpotent approximation (the strictly upper triangular part)
    // A full implementation would require a dedicated type
    let num_generators = n * (n - 1) / 2;
    let step = n - 1;

    Ok(FreeNilpotentLieAlgebra::new(num_generators, step))
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;
    use rustmath_integers::Integer;

    #[test]
    fn test_abelian_example() {
        let lie_alg = abelian::<Integer>(3);
        // Test that we can create the algebra
        assert_eq!(lie_alg.dimension(), 3);
    }

    #[test]
    fn test_classical_examples() {
        // Test that we can create classical Lie algebras
        let sl2 = sl::<Integer>(2).unwrap();
        assert_eq!(sl2.dimension(), 3);  // sl_2 has dimension 3

        let sl3 = sl::<Integer>(3).unwrap();
        assert_eq!(sl3.dimension(), 8);  // sl_3 has dimension 8

        let so3 = so::<Integer>(3).unwrap();
        assert_eq!(so3.dimension(), 3);  // so_3 has dimension 3

        let sp2 = sp::<Integer>(1).unwrap();
        assert_eq!(sp2.dimension(), 3);  // sp_2 has dimension 3
    }

    #[test]
    fn test_heisenberg_example() {
        // Test Heisenberg algebra creation
        let h = heisenberg::<Integer>(1);
        assert_eq!(h.dimension(), 3);  // dim = 2n + 1 = 3

        let h2 = heisenberg::<Integer>(2);
        assert_eq!(h2.dimension(), 5);  // dim = 2*2 + 1 = 5
    }

    #[test]
    fn test_free_lie_algebra_example() {
        // Test free Lie algebra creation
        let free = free_lie_algebra::<Integer>(2);
        assert_eq!(free.num_generators(), 2);
    }

    #[test]
    fn test_free_nilpotent_example() {
        // Test free nilpotent Lie algebra creation
        let nilp = free_nilpotent::<Integer>(2, 2);
        assert_eq!(nilp.num_generators(), 2);
        assert_eq!(nilp.step(), 2);
    }

    #[test]
    fn test_virasoro_example() {
        // Test Virasoro algebra creation
        let _vir = virasoro::<Integer>();
        // Just test that it can be created
        assert!(true);
    }

    #[test]
    fn test_cross_product_example() {
        // Test cross product Lie algebra
        let cross = cross_product::<Integer>();
        assert_eq!(cross.dimension(), 3);

        // Test the structure: [e_0, e_1] = e_2
        let result = cross.bracket_on_basis(0, 1);
        assert_eq!(result[0], Integer::from(0));
        assert_eq!(result[1], Integer::from(0));
        assert_eq!(result[2], Integer::from(1));

        // Test [e_1, e_2] = e_0
        let result = cross.bracket_on_basis(1, 2);
        assert_eq!(result[0], Integer::from(1));
        assert_eq!(result[1], Integer::from(0));
        assert_eq!(result[2], Integer::from(0));

        // Test [e_2, e_0] = e_1
        let result = cross.bracket_on_basis(2, 0);
        assert_eq!(result[0], Integer::from(0));
        assert_eq!(result[1], Integer::from(1));
        assert_eq!(result[2], Integer::from(0));
    }

    #[test]
    fn test_affine_transformations_line_example() {
        // Test affine transformations Lie algebra
        let affine = affine_transformations_line::<Integer>();
        assert_eq!(affine.dimension(), 2);

        // Test the structure: [e_0, e_1] = e_1
        let result = affine.bracket_on_basis(0, 1);
        assert_eq!(result[0], Integer::from(0));
        assert_eq!(result[1], Integer::from(1));

        // Test [e_1, e_0] = -e_1 (antisymmetry)
        let result = affine.bracket_on_basis(1, 0);
        assert_eq!(result[0], Integer::from(0));
        assert_eq!(result[1], Integer::from(-1));

        // Test that it's not abelian
        assert!(!affine.is_abelian());

        // Test that it's solvable
        assert!(affine.is_solvable());
    }

    #[test]
    fn test_three_dimensional() {
        // Test creating a general 3D Lie algebra
        let lie_alg = three_dimensional(
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
            Integer::from(0),
        );
        assert_eq!(lie_alg.dimension(), 3);

        // This creates sl_2
        let result = lie_alg.bracket_on_basis(0, 1);
        assert_eq!(result[2], Integer::from(1));  // [X,Y] = Z
    }

    #[test]
    fn test_three_dimensional_by_rank() {
        // Test rank 0 (abelian/Heisenberg)
        let rank0 = three_dimensional_by_rank::<Integer>(0, None).unwrap();
        assert_eq!(rank0.dimension(), 3);
        assert!(rank0.is_abelian());

        // Test rank 1 (solvable)
        let rank1 = three_dimensional_by_rank::<Integer>(1, None).unwrap();
        assert_eq!(rank1.dimension(), 3);
        assert!(rank1.is_solvable());
        assert!(!rank1.is_abelian());

        // Test rank 2 (solvable with parameter)
        let rank2 = three_dimensional_by_rank::<Integer>(2, None).unwrap();
        assert_eq!(rank2.dimension(), 3);

        // Test rank 3 (semisimple, sl_2)
        let rank3 = three_dimensional_by_rank::<Integer>(3, None).unwrap();
        assert_eq!(rank3.dimension(), 3);
        // sl_2 is semisimple (not solvable unless trivial)
        assert!(!rank3.is_abelian());

        // Test invalid rank
        assert!(three_dimensional_by_rank::<Integer>(4, None).is_none());
    }

    #[test]
    fn test_su() {
        // Test su_2 (same structure as sl_2)
        let su2 = su::<Integer>(2).unwrap();
        assert_eq!(su2.dimension(), 3);

        // Test su_3
        let su3 = su::<Integer>(3).unwrap();
        assert_eq!(su3.dimension(), 8);
    }

    #[test]
    fn test_witt_example() {
        let w = witt::<Integer>();
        assert!(!w.is_finite_dimensional());
        assert!(w.is_simple());
    }

    #[test]
    fn test_pwitt_example() {
        let pw = pwitt::<Integer>();
        assert!(!pw.is_finite_dimensional());
        assert!(!pw.is_solvable());
    }

    #[test]
    fn test_regular_vector_fields_example() {
        let rvf = regular_vector_fields::<Integer>();
        assert!(!rvf.is_finite_dimensional());
        // It should be the same as Witt algebra
        assert!(rvf.is_simple());
    }

    #[test]
    fn test_strictly_upper_triangular_matrices_example() {
        let sut2 = strictly_upper_triangular_matrices::<Integer>(2).unwrap();
        assert_eq!(sut2.num_generators(), 1);  // n(n-1)/2 = 2*1/2 = 1

        let sut3 = strictly_upper_triangular_matrices::<Integer>(3).unwrap();
        assert_eq!(sut3.num_generators(), 3);  // n(n-1)/2 = 3*2/2 = 3

        let sut4 = strictly_upper_triangular_matrices::<Integer>(4).unwrap();
        assert_eq!(sut4.num_generators(), 6);  // n(n-1)/2 = 4*3/2 = 6

        // Test error case
        assert!(strictly_upper_triangular_matrices::<Integer>(1).is_err());
    }

    #[test]
    fn test_upper_triangular_matrices_example() {
        let ut2 = upper_triangular_matrices::<Integer>(2).unwrap();
        assert_eq!(ut2.num_generators(), 1);

        let ut3 = upper_triangular_matrices::<Integer>(3).unwrap();
        assert_eq!(ut3.num_generators(), 3);

        // Test error case
        assert!(upper_triangular_matrices::<Integer>(1).is_err());
    }

    #[test]
    fn test_all_factories_work() {
        // Comprehensive test that all factory functions work
        let _ab = abelian::<Integer>(2);
        let _sl = sl::<Integer>(2).unwrap();
        let _so = so::<Integer>(3).unwrap();
        let _sp = sp::<Integer>(1).unwrap();
        let _h = heisenberg::<Integer>(1);
        let _free = free_lie_algebra::<Integer>(2);
        let _nilp = free_nilpotent::<Integer>(2, 2);
        let _vir = virasoro::<Integer>();
        let _cross = cross_product::<Integer>();
        let _affine = affine_transformations_line::<Integer>();
        let _three_d = three_dimensional(
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
            Integer::from(0),
        );
        let _rank0 = three_dimensional_by_rank::<Integer>(0, None).unwrap();
        let _su2 = su::<Integer>(2).unwrap();
        let _witt = witt::<Integer>();
        let _pwitt = pwitt::<Integer>();
        let _rvf = regular_vector_fields::<Integer>();
        let _sut = strictly_upper_triangular_matrices::<Integer>(3).unwrap();
        let _ut = upper_triangular_matrices::<Integer>(3).unwrap();

        // If we got here, all factories work
        assert!(true);
    }
}
