//! Lie Algebra Subalgebras and Ideals
//!
//! This module provides infrastructure for working with subalgebras and ideals
//! of finite-dimensional Lie algebras. A subalgebra is a subset closed under
//! the Lie bracket. An ideal is a subalgebra I such that [L, I] ⊆ I.
//!
//! Corresponds to sage.algebras.lie_algebras.subalgebra
//!
//! References:
//! - Humphreys, J. "Introduction to Lie Algebras and Representation Theory" (1972)
//! - Erdmann, K. and Wildon, M. "Introduction to Lie Algebras" (2006)

use rustmath_core::Ring;
use std::collections::{HashMap, HashSet};
use std::fmt::{self, Display};
use std::marker::PhantomData;

/// A subalgebra or ideal of a Lie algebra
///
/// Represents a Lie subalgebra S ⊆ L where S is closed under the Lie bracket.
/// If S is an ideal, then [L, S] ⊆ S for all elements in the ambient algebra.
///
/// # Type Parameters
///
/// * `R` - The coefficient ring
/// * `Element` - The type of elements in the ambient algebra
///
/// # Examples
///
/// ```
/// # use rustmath_liealgebras::{AbelianLieAlgebra, AbelianLieAlgebraElement};
/// # use rustmath_liealgebras::subalgebra::LieSubalgebra;
/// # use rustmath_integers::Integer;
///
/// let L: AbelianLieAlgebra<Integer> = AbelianLieAlgebra::new(3);
/// let generators = vec![
///     AbelianLieAlgebraElement::basis_element(0, 3),
///     AbelianLieAlgebraElement::basis_element(1, 3),
/// ];
///
/// let subalgebra = LieSubalgebra::new(3, generators, false);
/// assert_eq!(subalgebra.num_generators(), 2);
/// assert!(!subalgebra.is_ideal());
/// ```
pub struct LieSubalgebra<R: Ring, Element> {
    /// Dimension of the ambient algebra
    ambient_dim: usize,
    /// Generators of the subalgebra
    generators: Vec<Element>,
    /// Whether this is an ideal (not just a subalgebra)
    is_ideal: bool,
    /// Cached basis (computed via bracket closure)
    cached_basis: Option<Vec<Element>>,
    /// Marker for coefficient ring
    _phantom: PhantomData<R>,
}

impl<R, Element> LieSubalgebra<R, Element>
where
    R: Ring + Clone + From<i64>,
    Element: Clone,
{
    /// Create a new Lie subalgebra
    ///
    /// # Arguments
    ///
    /// * `ambient_dim` - Dimension of the ambient algebra
    /// * `generators` - Generating set for the subalgebra
    /// * `is_ideal` - Whether this is an ideal
    pub fn new(ambient_dim: usize, generators: Vec<Element>, is_ideal: bool) -> Self {
        LieSubalgebra {
            ambient_dim,
            generators,
            is_ideal,
            cached_basis: None,
            _phantom: PhantomData,
        }
    }

    /// Create an ideal (not just a subalgebra)
    pub fn new_ideal(ambient_dim: usize, generators: Vec<Element>) -> Self {
        Self::new(ambient_dim, generators, true)
    }

    /// Get the generators
    pub fn generators(&self) -> &[Element] {
        &self.generators
    }

    /// Get the number of generators
    pub fn num_generators(&self) -> usize {
        self.generators.len()
    }

    /// Check if this is an ideal
    pub fn is_ideal(&self) -> bool {
        self.is_ideal
    }

    /// Get the ambient dimension
    pub fn ambient_dimension(&self) -> usize {
        self.ambient_dim
    }

    /// Add a generator to the subalgebra
    pub fn add_generator(&mut self, gen: Element) {
        self.generators.push(gen);
        // Invalidate cached basis
        self.cached_basis = None;
    }

    /// Set whether this is an ideal
    pub fn set_is_ideal(&mut self, is_ideal: bool) {
        self.is_ideal = is_ideal;
    }
}

impl<R, Element> Clone for LieSubalgebra<R, Element>
where
    R: Ring + Clone,
    Element: Clone,
{
    fn clone(&self) -> Self {
        LieSubalgebra {
            ambient_dim: self.ambient_dim,
            generators: self.generators.clone(),
            is_ideal: self.is_ideal,
            cached_basis: self.cached_basis.clone(),
            _phantom: PhantomData,
        }
    }
}

impl<R, Element> Display for LieSubalgebra<R, Element>
where
    R: Ring + Clone + From<i64>,
    Element: Clone + Display,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_ideal {
            write!(f, "Lie algebra ideal in {}-dimensional algebra", self.ambient_dim)?;
        } else {
            write!(f, "Lie subalgebra of {}-dimensional algebra", self.ambient_dim)?;
        }
        write!(f, "\nGenerated by {} elements", self.num_generators())?;
        if self.num_generators() <= 5 {
            write!(f, ":")?;
            for (i, gen) in self.generators.iter().enumerate() {
                write!(f, "\n  [{}] {}", i, gen)?;
            }
        }
        Ok(())
    }
}

/// Trait for computing basis via bracket closure
pub trait BracketClosure<Element> {
    /// Compute a basis by repeatedly bracketing generators
    fn compute_basis(&self) -> Vec<Element>;
}

/// Trait for checking ideal property
pub trait CheckIdeal<Element> {
    /// Verify that [L, S] ⊆ S
    fn verify_is_ideal(&self, ambient_generators: &[Element]) -> bool;
}

/// Trait for reduction modulo subalgebra
pub trait Reduce<Element> {
    /// Reduce an ambient element modulo the subalgebra
    fn reduce(&self, element: &Element) -> Element;
}

/// Trait for lifting and retracting
pub trait LiftRetract<Element> {
    /// Lift a subalgebra element to the ambient algebra
    fn lift(&self, element: &Element) -> Element;

    /// Retract an ambient element to the subalgebra (if possible)
    fn retract(&self, element: &Element) -> Option<Element>;
}

/// Trait for subalgebra containment
pub trait Contains<Element> {
    /// Check if an element is in the subalgebra
    fn contains(&self, element: &Element) -> bool;
}

/// Trait for computing derived series
pub trait DerivedSeries<R: Ring, Element> {
    /// Compute the derived series [L, L], [[L, L], [L, L]], ...
    fn derived_series(&self, max_steps: usize) -> Vec<LieSubalgebra<R, Element>>;
}

/// Trait for computing lower central series
pub trait LowerCentralSeries<R: Ring, Element> {
    /// Compute the lower central series L, [L, L], [L, [L, L]], ...
    fn lower_central_series(&self, max_steps: usize) -> Vec<LieSubalgebra<R, Element>>;
}

/// The center of a Lie algebra
///
/// The center Z(L) = {z ∈ L : [z, x] = 0 for all x ∈ L}
pub struct Center<R: Ring, Element> {
    subalgebra: LieSubalgebra<R, Element>,
}

impl<R, Element> Center<R, Element>
where
    R: Ring + Clone + From<i64>,
    Element: Clone,
{
    /// Create the center from a list of central elements
    pub fn new(ambient_dim: usize, central_elements: Vec<Element>) -> Self {
        Center {
            subalgebra: LieSubalgebra::new(ambient_dim, central_elements, true),
        }
    }

    /// Get the underlying subalgebra structure
    pub fn as_subalgebra(&self) -> &LieSubalgebra<R, Element> {
        &self.subalgebra
    }

    /// Get the central elements (generators)
    pub fn central_elements(&self) -> &[Element] {
        self.subalgebra.generators()
    }

    /// Get the dimension of the ambient algebra
    pub fn ambient_dimension(&self) -> usize {
        self.subalgebra.ambient_dimension()
    }
}

/// Normalizer of a subalgebra
///
/// N_L(S) = {x ∈ L : [x, S] ⊆ S}
pub struct Normalizer<R: Ring, Element> {
    subalgebra: LieSubalgebra<R, Element>,
    /// The subalgebra being normalized
    normalized: LieSubalgebra<R, Element>,
}

impl<R, Element> Normalizer<R, Element>
where
    R: Ring + Clone + From<i64>,
    Element: Clone,
{
    /// Create the normalizer
    pub fn new(
        normalized: LieSubalgebra<R, Element>,
        normalizing_elements: Vec<Element>,
    ) -> Self {
        let ambient_dim = normalized.ambient_dimension();
        Normalizer {
            subalgebra: LieSubalgebra::new(ambient_dim, normalizing_elements, false),
            normalized,
        }
    }

    /// Get the underlying subalgebra
    pub fn as_subalgebra(&self) -> &LieSubalgebra<R, Element> {
        &self.subalgebra
    }

    /// Get the normalized subalgebra
    pub fn normalized_subalgebra(&self) -> &LieSubalgebra<R, Element> {
        &self.normalized
    }
}

/// Centralizer of a subset
///
/// C_L(X) = {y ∈ L : [y, x] = 0 for all x ∈ X}
pub struct Centralizer<R: Ring, Element> {
    subalgebra: LieSubalgebra<R, Element>,
    /// The subset being centralized
    centralized: Vec<Element>,
}

impl<R, Element> Centralizer<R, Element>
where
    R: Ring + Clone + From<i64>,
    Element: Clone,
{
    /// Create the centralizer
    pub fn new(ambient_dim: usize, centralized: Vec<Element>, centralizing: Vec<Element>) -> Self {
        Centralizer {
            subalgebra: LieSubalgebra::new(ambient_dim, centralizing, false),
            centralized,
        }
    }

    /// Get the underlying subalgebra
    pub fn as_subalgebra(&self) -> &LieSubalgebra<R, Element> {
        &self.subalgebra
    }

    /// Get the centralized elements
    pub fn centralized_elements(&self) -> &[Element] {
        &self.centralized
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::abelian::{AbelianLieAlgebra, AbelianLieAlgebraElement};
    use rustmath_integers::Integer;

    #[test]
    fn test_create_subalgebra() {
        let _L: AbelianLieAlgebra<Integer> = AbelianLieAlgebra::new(3);
        let generators = vec![
            AbelianLieAlgebraElement::<Integer>::basis_element(0, 3),
            AbelianLieAlgebraElement::<Integer>::basis_element(1, 3),
        ];

        let subalgebra: LieSubalgebra<Integer, _> =
            LieSubalgebra::new(3, generators, false);
        assert_eq!(subalgebra.ambient_dimension(), 3);
        assert_eq!(subalgebra.num_generators(), 2);
        assert!(!subalgebra.is_ideal());
    }

    #[test]
    fn test_create_ideal() {
        let _L: AbelianLieAlgebra<Integer> = AbelianLieAlgebra::new(4);
        let generators = vec![
            AbelianLieAlgebraElement::<Integer>::basis_element(2, 4),
            AbelianLieAlgebraElement::<Integer>::basis_element(3, 4),
        ];

        let ideal: LieSubalgebra<Integer, _> =
            LieSubalgebra::new_ideal(4, generators);
        assert_eq!(ideal.ambient_dimension(), 4);
        assert_eq!(ideal.num_generators(), 2);
        assert!(ideal.is_ideal());
    }

    #[test]
    fn test_add_generator() {
        let generators = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 3)];
        let mut subalgebra: LieSubalgebra<Integer, _> =
            LieSubalgebra::new(3, generators, false);

        assert_eq!(subalgebra.num_generators(), 1);

        subalgebra.add_generator(AbelianLieAlgebraElement::<Integer>::basis_element(1, 3));
        assert_eq!(subalgebra.num_generators(), 2);
    }

    #[test]
    fn test_set_is_ideal() {
        let generators = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 2)];
        let mut subalgebra: LieSubalgebra<Integer, _> =
            LieSubalgebra::new(2, generators, false);

        assert!(!subalgebra.is_ideal());
        subalgebra.set_is_ideal(true);
        assert!(subalgebra.is_ideal());
    }

    #[test]
    fn test_clone_subalgebra() {
        let generators = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 2)];
        let subalgebra: LieSubalgebra<Integer, _> =
            LieSubalgebra::new(2, generators, true);
        let cloned = subalgebra.clone();

        assert_eq!(cloned.ambient_dimension(), subalgebra.ambient_dimension());
        assert_eq!(cloned.num_generators(), subalgebra.num_generators());
        assert_eq!(cloned.is_ideal(), subalgebra.is_ideal());
    }

    #[test]
    fn test_center() {
        let central = vec![
            AbelianLieAlgebraElement::<Integer>::basis_element(0, 3),
            AbelianLieAlgebraElement::<Integer>::basis_element(1, 3),
        ];

        let center: Center<Integer, _> = Center::new(3, central);
        assert_eq!(center.ambient_dimension(), 3);
        assert_eq!(center.central_elements().len(), 2);
        assert!(center.as_subalgebra().is_ideal());
    }

    #[test]
    fn test_normalizer() {
        let normalized_gens = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 3)];
        let normalized: LieSubalgebra<Integer, _> =
            LieSubalgebra::new(3, normalized_gens, false);

        let normalizing = vec![
            AbelianLieAlgebraElement::<Integer>::basis_element(0, 3),
            AbelianLieAlgebraElement::<Integer>::basis_element(1, 3),
        ];

        let normalizer: Normalizer<Integer, _> =
            Normalizer::new(normalized, normalizing);
        assert_eq!(normalizer.as_subalgebra().num_generators(), 2);
    }

    #[test]
    fn test_centralizer() {
        let centralized = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 3)];
        let centralizing = vec![
            AbelianLieAlgebraElement::<Integer>::basis_element(1, 3),
            AbelianLieAlgebraElement::<Integer>::basis_element(2, 3),
        ];

        let centralizer: Centralizer<Integer, _> =
            Centralizer::new(3, centralized, centralizing);
        assert_eq!(centralizer.centralized_elements().len(), 1);
        assert_eq!(centralizer.as_subalgebra().num_generators(), 2);
    }

    #[test]
    fn test_display_subalgebra() {
        let generators = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 2)];
        let subalgebra: LieSubalgebra<Integer, _> =
            LieSubalgebra::new(2, generators, false);
        let display = format!("{}", subalgebra);
        assert!(display.contains("Lie subalgebra"));
        assert!(display.contains("2-dimensional"));
    }

    #[test]
    fn test_display_ideal() {
        let generators = vec![AbelianLieAlgebraElement::<Integer>::basis_element(0, 3)];
        let ideal: LieSubalgebra<Integer, _> =
            LieSubalgebra::new_ideal(3, generators);
        let display = format!("{}", ideal);
        assert!(display.contains("Lie algebra ideal"));
        assert!(display.contains("3-dimensional"));
    }
}
