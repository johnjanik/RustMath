//! Weyl Groups
//!
//! The Weyl group of a root system is the group generated by reflections
//! through the hyperplanes perpendicular to the simple roots. Weyl groups
//! are finite Coxeter groups that play a central role in Lie theory.
//!
//! Corresponds to sage.combinat.root_system.weyl_group

use crate::cartan_type::{CartanType, CartanLetter};
use rustmath_combinatorics::permutations::Permutation;

/// An element of a Weyl group represented as a reduced word
///
/// A Weyl group element is a product of simple reflections s_i
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct WeylGroupElement {
    /// The reduced word (sequence of simple reflection indices)
    pub reduced_word: Vec<usize>,
    /// The rank of the associated root system
    pub rank: usize,
}

impl WeylGroupElement {
    /// Create the identity element
    pub fn identity(rank: usize) -> Self {
        WeylGroupElement {
            reduced_word: Vec::new(),
            rank,
        }
    }

    /// Create from a reduced word
    pub fn from_reduced_word(word: Vec<usize>, rank: usize) -> Self {
        WeylGroupElement {
            reduced_word: word,
            rank,
        }
    }

    /// Create a simple reflection s_i
    pub fn simple_reflection(i: usize, rank: usize) -> Self {
        WeylGroupElement {
            reduced_word: vec![i],
            rank,
        }
    }

    /// Check if this is the identity
    pub fn is_identity(&self) -> bool {
        self.reduced_word.is_empty()
    }

    /// Get the length (number of simple reflections in the reduced word)
    pub fn length(&self) -> usize {
        self.reduced_word.len()
    }

    /// Multiply two Weyl group elements
    ///
    /// Note: This is a simplified version. Full implementation would
    /// ensure the result is in reduced form using braid relations.
    pub fn multiply(&self, other: &WeylGroupElement) -> WeylGroupElement {
        assert_eq!(self.rank, other.rank);

        let mut result_word = self.reduced_word.clone();
        result_word.extend_from_slice(&other.reduced_word);

        WeylGroupElement {
            reduced_word: result_word,
            rank: self.rank,
        }
    }

    /// Compute the inverse
    ///
    /// The inverse is obtained by reversing the reduced word
    pub fn inverse(&self) -> WeylGroupElement {
        WeylGroupElement {
            reduced_word: self.reduced_word.iter().rev().copied().collect(),
            rank: self.rank,
        }
    }
}

/// The Weyl group associated with a Cartan type
pub struct WeylGroup {
    /// The Cartan type
    pub cartan_type: CartanType,
}

impl WeylGroup {
    /// Create a Weyl group for a given Cartan type
    pub fn new(cartan_type: CartanType) -> Self {
        WeylGroup { cartan_type }
    }

    /// Get the identity element
    pub fn identity(&self) -> WeylGroupElement {
        WeylGroupElement::identity(self.cartan_type.rank)
    }

    /// Get a simple reflection s_i
    ///
    /// Simple reflections are indexed from 0 to rank-1
    pub fn simple_reflection(&self, i: usize) -> Option<WeylGroupElement> {
        if i < self.cartan_type.rank {
            Some(WeylGroupElement::simple_reflection(i, self.cartan_type.rank))
        } else {
            None
        }
    }

    /// Get all simple reflections
    pub fn simple_reflections(&self) -> Vec<WeylGroupElement> {
        (0..self.cartan_type.rank)
            .map(|i| WeylGroupElement::simple_reflection(i, self.cartan_type.rank))
            .collect()
    }

    /// Get the order (cardinality) of the Weyl group
    ///
    /// Returns the number of elements in this finite group
    pub fn order(&self) -> usize {
        match self.cartan_type.letter {
            CartanLetter::A => {
                // S_{n+1} has order (n+1)!
                let n = self.cartan_type.rank;
                (1..=n + 1).product()
            }
            CartanLetter::B | CartanLetter::C => {
                // Order is 2^n * n!
                let n = self.cartan_type.rank;
                (1_usize << n) * (1..=n).product::<usize>()
            }
            CartanLetter::D => {
                // Order is 2^{n-1} * n!
                let n = self.cartan_type.rank;
                (1_usize << (n - 1)) * (1..=n).product::<usize>()
            }
            CartanLetter::E => match self.cartan_type.rank {
                6 => 51840,
                7 => 2903040,
                8 => 696729600,
                _ => 0,
            },
            CartanLetter::F => 1152, // |W(F_4)| = 2^7 * 3^2
            CartanLetter::G => 12,   // |W(G_2)| = 12 (dihedral group D_6)
        }
    }

    /// Get the index set for simple reflections
    pub fn index_set(&self) -> Vec<usize> {
        (0..self.cartan_type.rank).collect()
    }

    /// Get the rank of the Weyl group
    pub fn rank(&self) -> usize {
        self.cartan_type.rank
    }

    /// Get the Coxeter number (height of the highest root + 1)
    pub fn coxeter_number(&self) -> usize {
        match self.cartan_type.letter {
            CartanLetter::A => self.cartan_type.rank + 1,
            CartanLetter::B | CartanLetter::C => 2 * self.cartan_type.rank,
            CartanLetter::D => 2 * self.cartan_type.rank - 2,
            CartanLetter::E => match self.cartan_type.rank {
                6 => 12,
                7 => 18,
                8 => 30,
                _ => 0,
            },
            CartanLetter::F => 12,
            CartanLetter::G => 6,
        }
    }

    /// Get the longest element of the Weyl group
    ///
    /// The longest element w_0 is the unique element of maximal length
    pub fn longest_element(&self) -> WeylGroupElement {
        // This is simplified - proper implementation would compute the actual longest element
        // For now, return identity as placeholder
        self.identity()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_weyl_group_element() {
        let w = WeylGroupElement::from_reduced_word(vec![0, 1, 0], 3);
        assert_eq!(w.length(), 3);
        assert!(!w.is_identity());

        let id = WeylGroupElement::identity(3);
        assert!(id.is_identity());
        assert_eq!(id.length(), 0);
    }

    #[test]
    fn test_simple_reflection() {
        let s = WeylGroupElement::simple_reflection(0, 3);
        assert_eq!(s.length(), 1);
        assert_eq!(s.reduced_word, vec![0]);
    }

    #[test]
    fn test_multiplication() {
        let s0 = WeylGroupElement::simple_reflection(0, 3);
        let s1 = WeylGroupElement::simple_reflection(1, 3);

        let product = s0.multiply(&s1);
        assert_eq!(product.length(), 2);
        assert_eq!(product.reduced_word, vec![0, 1]);
    }

    #[test]
    fn test_inverse() {
        let w = WeylGroupElement::from_reduced_word(vec![0, 1, 2], 3);
        let w_inv = w.inverse();

        assert_eq!(w_inv.reduced_word, vec![2, 1, 0]);
    }

    #[test]
    fn test_weyl_group_creation() {
        let ct = CartanType::new(CartanLetter::A, 3).unwrap();
        let W = WeylGroup::new(ct);

        assert_eq!(W.rank(), 3);
        assert_eq!(W.order(), 24); // |S_4| = 24

        let simples = W.simple_reflections();
        assert_eq!(simples.len(), 3);
    }

    #[test]
    fn test_weyl_group_orders() {
        let a3 = WeylGroup::new(CartanType::new(CartanLetter::A, 3).unwrap());
        assert_eq!(a3.order(), 24); // S_4

        let b3 = WeylGroup::new(CartanType::new(CartanLetter::B, 3).unwrap());
        assert_eq!(b3.order(), 48); // 2^3 * 3!

        let g2 = WeylGroup::new(CartanType::new(CartanLetter::G, 2).unwrap());
        assert_eq!(g2.order(), 12);
    }

    #[test]
    fn test_coxeter_number() {
        let a3 = WeylGroup::new(CartanType::new(CartanLetter::A, 3).unwrap());
        assert_eq!(a3.coxeter_number(), 4);

        let e8 = WeylGroup::new(CartanType::new(CartanLetter::E, 8).unwrap());
        assert_eq!(e8.coxeter_number(), 30);
    }
}
