//! Cyclic Sieving Phenomenon (CSP)
//!
//! The cyclic sieving phenomenon, introduced by Reiner, Stanton, and White (2004),
//! is a beautiful connection between combinatorics and algebra.
//!
//! A CSP triple (X, C, f(q)) consists of:
//! - X: a finite set
//! - C: a cyclic group acting on X
//! - f(q): a polynomial with non-negative integer coefficients
//!
//! The triple exhibits the cyclic sieving phenomenon if for any element c ∈ C
//! of order d, the number of fixed points of c equals f(ω) evaluated at a
//! primitive d-th root of unity ω.
//!
//! # Examples
//!
//! Classic example: Promotion on standard Young tableaux of shape λ
//! - X = standard tableaux of shape λ
//! - C = cyclic group generated by promotion
//! - f(q) = (q-analogue of |X|)
//!
//! # References
//!
//! Reiner, Stanton, White: "The cyclic sieving phenomenon", Journal of Combinatorial
//! Theory Series A 108 (2004), 17-50.

use rustmath_complex::Complex;
use rustmath_integers::Integer;
use rustmath_polynomials::{Polynomial, UnivariatePolynomial};
use std::collections::{HashMap, HashSet};
use std::f64::consts::PI;
use std::hash::Hash;

/// A cyclic action on a set, represented as a permutation-like function
pub trait CyclicAction<T> {
    /// Apply the cyclic action once
    fn apply(&self, element: &T) -> T;

    /// Apply the cyclic action k times
    fn apply_k_times(&self, element: &T, k: usize) -> T {
        let mut result = element.clone();
        for _ in 0..k {
            result = self.apply(&result);
        }
        result
    }

    /// Compute the order of the cyclic action
    /// (smallest positive integer n such that c^n = identity)
    fn order(&self, element: &T) -> usize
    where
        T: Eq,
    {
        let start = element.clone();
        let mut current = self.apply(element);
        let mut order = 1;

        while current != start && order < 1000000 {
            current = self.apply(&current);
            order += 1;
        }

        if order >= 1000000 {
            panic!("Cyclic action order exceeds maximum (1000000)");
        }

        order
    }
}

/// Function-based cyclic action
pub struct FunctionAction<T, F>
where
    F: Fn(&T) -> T,
{
    function: F,
    order: usize,
    _phantom: std::marker::PhantomData<T>,
}

impl<T, F> FunctionAction<T, F>
where
    F: Fn(&T) -> T,
{
    /// Create a new cyclic action from a function and its known order
    pub fn new(function: F, order: usize) -> Self {
        FunctionAction {
            function,
            order,
            _phantom: std::marker::PhantomData,
        }
    }
}

impl<T, F> CyclicAction<T> for FunctionAction<T, F>
where
    T: Clone,
    F: Fn(&T) -> T,
{
    fn apply(&self, element: &T) -> T {
        (self.function)(element)
    }

    fn order(&self, _element: &T) -> usize {
        self.order
    }
}

/// A CSP triple (X, C, f(q))
pub struct CyclicSievingTriple<T>
where
    T: Clone + Eq + Hash,
{
    /// The finite set X
    set: Vec<T>,
    /// The polynomial f(q) with integer coefficients
    polynomial: UnivariatePolynomial<Integer>,
    /// The order of the cyclic group
    order: usize,
}

impl<T> CyclicSievingTriple<T>
where
    T: Clone + Eq + Hash,
{
    /// Create a new CSP triple
    ///
    /// # Arguments
    ///
    /// * `set` - The finite set X
    /// * `polynomial` - The polynomial f(q) with non-negative integer coefficients
    /// * `order` - The order of the cyclic group
    pub fn new(set: Vec<T>, polynomial: UnivariatePolynomial<Integer>, order: usize) -> Self {
        // Verify polynomial has non-negative coefficients
        for coeff in polynomial.coefficients() {
            if coeff < &Integer::zero() {
                panic!("Polynomial must have non-negative coefficients");
            }
        }

        CyclicSievingTriple {
            set,
            polynomial,
            order,
        }
    }

    /// Get the size of the set
    pub fn set_size(&self) -> usize {
        self.set.len()
    }

    /// Get the polynomial
    pub fn polynomial(&self) -> &UnivariatePolynomial<Integer> {
        &self.polynomial
    }

    /// Get the order of the cyclic group
    pub fn order(&self) -> usize {
        self.order
    }

    /// Verify the cyclic sieving phenomenon
    ///
    /// Checks if for all k, the number of fixed points under c^k equals f(ω^k)
    /// where ω is a primitive n-th root of unity.
    ///
    /// Returns a vector of (k, fixed_points, f(ω^k)) for each k
    pub fn verify<A>(&self, action: &A) -> Vec<(usize, usize, Complex)>
    where
        A: CyclicAction<T>,
    {
        let n = self.order;
        let mut results = Vec::new();

        for k in 0..n {
            // Count fixed points under c^k
            let fixed_points = self.count_fixed_points(action, k);

            // Evaluate polynomial at ω^k where ω = e^(2πi/n)
            let omega_k = self.root_of_unity(k, n);
            let poly_value = self.eval_at_complex(&omega_k);

            results.push((k, fixed_points, poly_value));
        }

        results
    }

    /// Check if the CSP property holds
    ///
    /// Returns true if all fixed point counts match the polynomial evaluations
    /// (within numerical tolerance for the imaginary part)
    pub fn holds<A>(&self, action: &A) -> bool
    where
        A: CyclicAction<T>,
    {
        let results = self.verify(action);

        for (_k, fixed_points, poly_value) in results {
            // Check if polynomial value is essentially real
            if poly_value.imag().abs() > 1e-10 {
                return false;
            }

            // Check if real part matches fixed points
            let poly_real = poly_value.real().round() as usize;
            if poly_real != fixed_points {
                return false;
            }
        }

        true
    }

    /// Count fixed points under c^k
    fn count_fixed_points<A>(&self, action: &A, k: usize) -> usize
    where
        A: CyclicAction<T>,
    {
        self.set
            .iter()
            .filter(|element| {
                let transformed = action.apply_k_times(element, k);
                &transformed == *element
            })
            .count()
    }

    /// Compute a primitive n-th root of unity raised to the k-th power
    ///
    /// Returns e^(2πik/n)
    fn root_of_unity(&self, k: usize, n: usize) -> Complex {
        let angle = 2.0 * PI * (k as f64) / (n as f64);
        Complex::new(angle.cos(), angle.sin())
    }

    /// Evaluate the polynomial at a complex number
    fn eval_at_complex(&self, z: &Complex) -> Complex {
        // Use Horner's method
        let coeffs = self.polynomial.coefficients();

        if coeffs.is_empty() {
            return Complex::zero();
        }

        let mut result = Complex::from_real(coeffs.last().unwrap().to_f64());

        for coeff in coeffs.iter().rev().skip(1) {
            // result = result * z + coeff
            result = result * z.clone() + Complex::from_real(coeff.to_f64());
        }

        result
    }

    /// Compute the orbit polynomial X(q)
    ///
    /// The orbit polynomial is defined as:
    /// X(q) = sum over orbits O of q^|O|
    ///
    /// This is the polynomial that often exhibits the CSP.
    pub fn orbit_polynomial<A>(&self, action: &A) -> UnivariatePolynomial<Integer>
    where
        A: CyclicAction<T>,
    {
        let mut visited = HashSet::new();
        let mut orbit_sizes = HashMap::new();

        // Find all orbits
        for element in &self.set {
            if visited.contains(element) {
                continue;
            }

            // Compute orbit of this element
            let mut orbit = Vec::new();
            let mut current = element.clone();

            loop {
                if visited.contains(&current) {
                    break;
                }

                visited.insert(current.clone());
                orbit.push(current.clone());
                current = action.apply(&current);

                if &current == element {
                    break;
                }
            }

            // Record orbit size
            let size = orbit.len();
            *orbit_sizes.entry(size).or_insert(0) += 1;
        }

        // Build polynomial: sum of n_k * q^k where n_k is the number of orbits of size k
        let max_size = orbit_sizes.keys().max().copied().unwrap_or(0);
        let mut coeffs = vec![Integer::zero(); max_size + 1];

        for (size, count) in orbit_sizes {
            coeffs[size] = Integer::from(count as u32);
        }

        UnivariatePolynomial::new(coeffs)
    }

    /// Get detailed orbit structure
    ///
    /// Returns a map from orbit size to the list of orbits of that size
    pub fn orbit_structure<A>(&self, action: &A) -> HashMap<usize, Vec<Vec<T>>>
    where
        A: CyclicAction<T>,
    {
        let mut visited = HashSet::new();
        let mut orbits_by_size: HashMap<usize, Vec<Vec<T>>> = HashMap::new();

        for element in &self.set {
            if visited.contains(element) {
                continue;
            }

            // Compute orbit of this element
            let mut orbit = Vec::new();
            let mut current = element.clone();

            loop {
                if visited.contains(&current) {
                    break;
                }

                visited.insert(current.clone());
                orbit.push(current.clone());
                current = action.apply(&current);

                if &current == element {
                    break;
                }
            }

            let size = orbit.len();
            orbits_by_size.entry(size).or_insert_with(Vec::new).push(orbit);
        }

        orbits_by_size
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cyclic_action_rotation() {
        // Test cyclic rotation on [0, 1, 2, 3]
        let rotation = FunctionAction::new(|&x: &u32| (x + 1) % 4, 4);

        assert_eq!(rotation.apply(&0), 1);
        assert_eq!(rotation.apply(&1), 2);
        assert_eq!(rotation.apply(&2), 3);
        assert_eq!(rotation.apply(&3), 0);

        assert_eq!(rotation.apply_k_times(&0, 4), 0);
        assert_eq!(rotation.apply_k_times(&1, 4), 1);
        assert_eq!(rotation.order(&0), 4);
    }

    #[test]
    fn test_root_of_unity() {
        let set = vec![0u32, 1, 2, 3];
        let poly = UnivariatePolynomial::new(vec![
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
        ]);
        let triple = CyclicSievingTriple::new(set, poly, 4);

        // Test ω^0 = 1
        let omega_0 = triple.root_of_unity(0, 4);
        assert!((omega_0.real() - 1.0).abs() < 1e-10);
        assert!(omega_0.imag().abs() < 1e-10);

        // Test ω^2 = -1 for ω = e^(2πi/4)
        let omega_2 = triple.root_of_unity(2, 4);
        assert!((omega_2.real() - (-1.0)).abs() < 1e-10);
        assert!(omega_2.imag().abs() < 1e-10);

        // Test ω^1 = i for ω = e^(2πi/4)
        let omega_1 = triple.root_of_unity(1, 4);
        assert!(omega_1.real().abs() < 1e-10);
        assert!((omega_1.imag() - 1.0).abs() < 1e-10);
    }

    #[test]
    fn test_eval_at_complex() {
        // Test evaluating 1 + q + q^2 + q^3 at various points
        let poly = UnivariatePolynomial::new(vec![
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
        ]);
        let set = vec![0u32];
        let triple = CyclicSievingTriple::new(set, poly, 4);

        // At q = 1: 1 + 1 + 1 + 1 = 4
        let z = Complex::new(1.0, 0.0);
        let result = triple.eval_at_complex(&z);
        assert!((result.real() - 4.0).abs() < 1e-10);
        assert!(result.imag().abs() < 1e-10);

        // At q = -1: 1 - 1 + 1 - 1 = 0
        let z_neg = Complex::new(-1.0, 0.0);
        let result_neg = triple.eval_at_complex(&z_neg);
        assert!(result_neg.real().abs() < 1e-10);
        assert!(result_neg.imag().abs() < 1e-10);
    }

    #[test]
    fn test_orbit_polynomial_trivial_action() {
        // Trivial action: identity on {0, 1, 2, 3}
        let identity = FunctionAction::new(|&x: &u32| x, 1);
        let set = vec![0u32, 1, 2, 3];
        let poly = UnivariatePolynomial::new(vec![Integer::from(4)]);
        let triple = CyclicSievingTriple::new(set, poly, 1);

        // Orbit polynomial should be 4q^1 (4 orbits of size 1)
        let orbit_poly = triple.orbit_polynomial(&identity);
        assert_eq!(orbit_poly.coefficients(), &[Integer::zero(), Integer::from(4)]);
    }

    #[test]
    fn test_orbit_polynomial_full_rotation() {
        // Full cyclic rotation on {0, 1, 2, 3}
        let rotation = FunctionAction::new(|&x: &u32| (x + 1) % 4, 4);
        let set = vec![0u32, 1, 2, 3];
        let poly = UnivariatePolynomial::new(vec![
            Integer::from(0),
            Integer::from(0),
            Integer::from(0),
            Integer::from(0),
            Integer::from(1),
        ]);
        let triple = CyclicSievingTriple::new(set, poly, 4);

        // Orbit polynomial should be q^4 (1 orbit of size 4)
        let orbit_poly = triple.orbit_polynomial(&rotation);
        assert_eq!(
            orbit_poly.coefficients(),
            &[
                Integer::zero(),
                Integer::zero(),
                Integer::zero(),
                Integer::zero(),
                Integer::from(1)
            ]
        );
    }

    #[test]
    fn test_csp_simple_rotation() {
        // Simple CSP example: rotation on {0, 1, 2, 3}
        // with polynomial 1 + q + q^2 + q^3
        let rotation = FunctionAction::new(|&x: &u32| (x + 1) % 4, 4);
        let set = vec![0u32, 1, 2, 3];

        // The orbit polynomial is q^4
        // But let's test with (1+q)(1+q^2) = 1 + q + q^2 + q^3
        // which factors nicely
        let poly = UnivariatePolynomial::new(vec![
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
            Integer::from(1),
        ]);
        let triple = CyclicSievingTriple::new(set, poly, 4);

        let results = triple.verify(&rotation);

        // k=0: c^0 = id, all 4 elements fixed, f(1) = 4
        assert_eq!(results[0].0, 0);
        assert_eq!(results[0].1, 4);
        assert!((results[0].2.real() - 4.0).abs() < 1e-10);

        // k=1: c^1, no fixed points, f(i) = 1+i+i^2+i^3 = 1+i-1-i = 0
        assert_eq!(results[1].0, 1);
        assert_eq!(results[1].1, 0);
        assert!(results[1].2.real().abs() < 1e-10);
        assert!(results[1].2.imag().abs() < 1e-10);

        // k=2: c^2, elements 0,2 and 1,3 swap, no fixed points, f(-1) = 0
        assert_eq!(results[2].0, 2);
        assert_eq!(results[2].1, 0);
        assert!(results[2].2.real().abs() < 1e-10);

        // k=3: c^3, no fixed points, f(-i) = 1-i-1+i = 0
        assert_eq!(results[3].0, 3);
        assert_eq!(results[3].1, 0);
        assert!(results[3].2.real().abs() < 1e-10);
        assert!(results[3].2.imag().abs() < 1e-10);

        // Verify CSP holds
        assert!(triple.holds(&rotation));
    }

    #[test]
    fn test_csp_two_orbits() {
        // Action with two orbits: {0,1} and {2,3}
        let action = FunctionAction::new(
            |&x: &u32| match x {
                0 => 1,
                1 => 0,
                2 => 3,
                3 => 2,
                _ => x,
            },
            2,
        );

        let set = vec![0u32, 1, 2, 3];

        // Orbit polynomial is 2q^2
        // At q=1: 2*1 = 2 (but we have 4 fixed points at k=0 for id)
        // At q=-1: 2*1 = 2 (but k=1 gives us swaps)

        // Actually for the identity (k=0), all 4 are fixed
        // For c^1 (k=1), none are fixed
        // So polynomial should be 4 at q=1 and 0 at q=-1
        // That's 2 + 2q, wait no...
        // Actually the orbit polynomial 2q^2 means we have 2 orbits of size 2

        // For CSP, we need to check fixed points
        // k=0: id, all 4 fixed
        // k=1: swap, 0 fixed

        // The orbit polynomial evaluated:
        // At ω^0 = 1: 2*1^2 = 2 (not 4, so orbit poly is not the CSP poly here)

        // Let's use the correct CSP polynomial: 2(1+q) = 2 + 2q
        let poly = UnivariatePolynomial::new(vec![Integer::from(2), Integer::from(2)]);
        let triple = CyclicSievingTriple::new(set, poly, 2);

        let results = triple.verify(&action);

        // k=0: id, all 4 fixed, f(1) = 2 + 2 = 4 ✓
        assert_eq!(results[0].1, 4);
        assert!((results[0].2.real() - 4.0).abs() < 1e-10);

        // k=1: swap, 0 fixed, f(-1) = 2 - 2 = 0 ✓
        assert_eq!(results[1].1, 0);
        assert!(results[1].2.real().abs() < 1e-10);

        assert!(triple.holds(&action));
    }

    #[test]
    fn test_orbit_structure() {
        // Action with two orbits: {0,1} and {2,3}
        let action = FunctionAction::new(
            |&x: &u32| match x {
                0 => 1,
                1 => 0,
                2 => 3,
                3 => 2,
                _ => x,
            },
            2,
        );

        let set = vec![0u32, 1, 2, 3];
        let poly = UnivariatePolynomial::new(vec![Integer::from(2), Integer::from(2)]);
        let triple = CyclicSievingTriple::new(set, poly, 2);

        let orbits = triple.orbit_structure(&action);

        // Should have 2 orbits of size 2
        assert_eq!(orbits.len(), 1);
        assert!(orbits.contains_key(&2));
        assert_eq!(orbits[&2].len(), 2);
    }
}
