\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{geometry}

\geometry{margin=1in}

% Theorem environments
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}

% Code listing settings
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\lstdefinelanguage{Rust}{
    keywords={fn, let, mut, impl, struct, enum, trait, pub, use, mod, match, if, else, return, for, while, loop},
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\title{\textbf{AI-Assisted Development of a High-Performance Computer Algebra System: \\
The RustMath Project}}

\author{
John Janik\thanks{Corresponding author} \\
\textit{Independent Researcher} \\
\texttt{[contact information]}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
We present RustMath, an ambitious open-source project that explores the feasibility of using large language models (LLMs) to develop a comprehensive computer algebra system (CAS) in Rust with feature parity to SageMath. This paper investigates a fundamental question in the intersection of software engineering and artificial intelligence: \emph{Can a generative AI system reproduce, debug, and validate an entire mathematical software codebase?}

RustMath leverages Rust's memory safety, zero-cost abstractions, and fearless concurrency to reimagine mathematical computation libraries traditionally written in Python and C. The project employs Claude (Anthropic's large language model) as a primary development tool to implement over 500 mathematical functions spanning 20 major areas including algebraic structures, linear algebra, symbolic computation, number theory, graph theory, and cryptography.

We present (1) the architectural design of RustMath using trait-based generic programming, (2) the AI-assisted development methodology and its effectiveness, (3) a comprehensive benchmark suite for validating correctness and performance against SageMath, and (4) preliminary implementation status showing 68\% feature coverage (364 of 539 tracked functions). This work contributes to understanding the capabilities and limitations of AI-assisted mathematical software development and provides a foundation for future hybrid human-AI collaborative programming in computational mathematics.

\textbf{Keywords:} Computer Algebra Systems, Rust Programming, AI-Assisted Software Development, Large Language Models, SageMath, Mathematical Software, Formal Verification
\end{abstract}

\section{Introduction}

\subsection{Motivation}

Computer algebra systems (CAS) such as Mathematica~\cite{mathematica}, Maple~\cite{maple}, and SageMath~\cite{sagemath} have been indispensable tools in mathematical research, education, and applications for decades. These systems enable symbolic and numerical computation, supporting diverse areas from pure mathematics to engineering and scientific computing. However, most mature CAS implementations face several challenges:

\begin{enumerate}
    \item \textbf{Performance limitations}: Dynamic languages like Python incur runtime overhead, and the Global Interpreter Lock (GIL) prevents effective parallelization.
    \item \textbf{Memory safety concerns}: Critical performance components often rely on C/C++ or Cython, introducing potential vulnerabilities.
    \item \textbf{Maintenance complexity}: Large codebases (SageMath has over 2 million lines of code) become difficult to maintain and extend.
    \item \textbf{Limited concurrency}: True parallel computation is difficult due to language constraints.
\end{enumerate}

Simultaneously, recent advances in large language models (LLMs) have demonstrated remarkable capabilities in code generation, debugging, and software engineering tasks~\cite{chen2021codex,openai2023gpt4}. This raises a compelling research question:

\begin{center}
\textit{Can an AI system reproduce an entire mathematical software ecosystem,\\
including implementation, debugging, and validation?}
\end{center}

\subsection{The RustMath Project}

RustMath addresses both challenges simultaneously. It is:

\begin{itemize}
    \item A \textbf{clean-slate implementation} of core SageMath functionality in Rust, targeting performance, safety, and concurrency
    \item An \textbf{experiment in AI-assisted development}, using Claude (Anthropic's LLM) as the primary implementation tool
    \item A \textbf{validation framework} to measure both correctness and performance against SageMath
    \item An \textbf{open-source contribution} to the mathematical software community
\end{itemize}

\subsection{Research Questions}

This work investigates the following questions:

\begin{enumerate}
    \item \textbf{Technical feasibility}: Can modern systems programming languages like Rust effectively implement CAS functionality traditionally requiring dynamic typing and metaprogramming?

    \item \textbf{AI capability}: To what extent can LLMs independently reproduce complex mathematical algorithms and data structures?

    \item \textbf{Correctness validation}: What systematic methodologies can verify equivalence between independently implemented mathematical systems?

    \item \textbf{Performance characteristics}: How does a type-safe, compiled implementation compare to optimized Python/Cython code?

    \item \textbf{Development efficiency}: Does AI-assisted development accelerate or impede mathematical software engineering?
\end{enumerate}

\subsection{Contributions}

This paper makes the following contributions:

\begin{enumerate}
    \item \textbf{Architectural design}: A trait-based generic programming framework for mathematical structures in Rust, enabling code reuse across diverse algebraic systems (Section~\ref{sec:architecture}).

    \item \textbf{AI development methodology}: Documentation of the AI-assisted development process, including successes, failures, and lessons learned (Section~\ref{sec:ai-methodology}).

    \item \textbf{Comprehensive benchmark suite}: A systematic testing framework covering correctness, performance, and edge cases across 20 mathematical domains (Section~\ref{sec:benchmarks}).

    \item \textbf{Implementation results}: Analysis of 364 implemented functions spanning rings, fields, polynomials, matrices, symbolic computation, combinatorics, graphs, and more (Section~\ref{sec:results}).

    \item \textbf{Open-source codebase}: A complete, buildable Rust workspace with 50+ crates totaling approximately 50,000 lines of code\footnote{Available at: https://github.com/johnjanik/RustMath}.
\end{enumerate}

\subsection{Paper Organization}

The remainder of this paper is organized as follows. Section~\ref{sec:background} provides background on computer algebra systems, the Rust programming language, and AI-assisted software development. Section~\ref{sec:architecture} describes RustMath's architectural design and implementation. Section~\ref{sec:ai-methodology} details the AI-assisted development process. Section~\ref{sec:benchmarks} presents our validation and benchmarking methodology. Section~\ref{sec:results} discusses implementation status and preliminary findings. Section~\ref{sec:related} surveys related work. Section~\ref{sec:future} outlines future directions, and Section~\ref{sec:conclusion} concludes.

\section{Background and Related Work}
\label{sec:background}

\subsection{Computer Algebra Systems}

\subsubsection{SageMath}

SageMath~\cite{sagemath,stein2005sage} is an open-source mathematics software system built on Python, integrating numerous specialized libraries including:

\begin{itemize}
    \item \textbf{NumPy/SciPy}: Numerical computation
    \item \textbf{SymPy}: Symbolic mathematics
    \item \textbf{PARI/GP}: Number theory
    \item \textbf{GAP}: Group theory and abstract algebra
    \item \textbf{Singular}: Polynomial computations
    \item \textbf{Maxima}: Symbolic integration and manipulation
    \item \textbf{FLINT}: Fast library for number theory
\end{itemize}

SageMath provides a unified Python interface to these diverse systems, making it accessible for research and education. However, this architecture has limitations:

\begin{enumerate}
    \item \textbf{Performance bottlenecks}: Python interpreter overhead and GIL constraints
    \item \textbf{Dependency complexity}: Coordinating updates across 100+ packages
    \item \textbf{Type safety}: Dynamic typing can lead to runtime errors
    \item \textbf{Memory safety}: C/C++ components may have vulnerabilities
\end{enumerate}

\subsubsection{Other Systems}

\paragraph{Mathematica} is a proprietary CAS with comprehensive functionality but closed-source and expensive licensing.

\paragraph{SymPy}~\cite{sympy} is a pure-Python symbolic mathematics library, prioritizing ease of use over performance.

\paragraph{Magma} is a computational algebra system focused on algebra, number theory, and geometry, but proprietary.

\subsection{The Rust Programming Language}

Rust~\cite{matsakis2014rust,jung2017rustbelt} is a systems programming language emphasizing:

\begin{enumerate}
    \item \textbf{Memory safety without garbage collection}: The borrow checker enforces memory safety at compile time through ownership and lifetime tracking.

    \item \textbf{Zero-cost abstractions}: High-level constructs compile to efficient machine code with no runtime overhead.

    \item \textbf{Fearless concurrency}: The type system prevents data races, enabling safe parallel programming.

    \item \textbf{Trait-based generics}: Powerful abstraction mechanism similar to type classes in Haskell.
\end{enumerate}

Recent work has demonstrated Rust's suitability for mathematical computing:

\begin{itemize}
    \item \textbf{num-bigint}~\cite{numbigint}: Arbitrary-precision integer arithmetic
    \item \textbf{nalgebra}~\cite{nalgebra}: Linear algebra library
    \item \textbf{ndarray}~\cite{ndarray}: N-dimensional arrays
    \item \textbf{rug}~\cite{rug}: Bindings to GMP, MPFR, and MPC
\end{itemize}

However, no comprehensive CAS in Rust exists comparable to SageMath or Mathematica.

\subsection{AI-Assisted Software Development}

\subsubsection{Code Generation Models}

Recent large language models have shown remarkable code generation capabilities:

\begin{itemize}
    \item \textbf{Codex/GitHub Copilot}~\cite{chen2021codex}: Code completion and generation
    \item \textbf{AlphaCode}~\cite{li2022competition}: Competitive programming
    \item \textbf{GPT-4}~\cite{openai2023gpt4}: General-purpose code understanding and generation
    \item \textbf{Claude 3 Opus/Sonnet}~\cite{anthropic2024claude}: Advanced reasoning and coding
\end{itemize}

Studies have shown LLMs can:
\begin{enumerate}
    \item Generate syntactically correct code in multiple languages
    \item Implement algorithms from natural language descriptions
    \item Debug code by analyzing error messages
    \item Refactor code while preserving semantics
    \item Write test cases and documentation
\end{enumerate}

\subsubsection{Limitations}

However, LLMs face significant challenges:

\begin{itemize}
    \item \textbf{Correctness}: Generated code may compile but produce incorrect results
    \item \textbf{Mathematical rigor}: Subtle algorithmic errors in numerical stability or edge cases
    \item \textbf{Context limitations}: Difficulty maintaining coherence across large codebases
    \item \textbf{Novel algorithms}: Struggle with cutting-edge or uncommon algorithms
    \item \textbf{Hallucination}: May invent non-existent APIs or libraries
\end{itemize}

\subsubsection{Prior Work in AI-Assisted Mathematics}

\begin{itemize}
    \item \textbf{Lean}~\cite{moura2015lean}: Theorem prover with AI-assisted proof search
    \item \textbf{IsarStep}~\cite{li2021isarstep}: Machine learning for proof automation
    \item \textbf{AlphaGeometry}~\cite{trinh2024alphageometry}: AI system for geometry theorem proving
\end{itemize}

RustMath extends this work by applying AI to \emph{mathematical software engineering} rather than theorem proving.

\section{Architecture and Design}
\label{sec:architecture}

\subsection{Design Philosophy}

RustMath's architecture is guided by three core principles:

\begin{enumerate}
    \item \textbf{Trait-based abstraction}: Mathematical structures (rings, fields, groups) are represented as Rust traits, enabling generic algorithms.

    \item \textbf{Zero unsafe code}: The entire computational core avoids \texttt{unsafe}, relying on Rust's type system for correctness.

    \item \textbf{Exact computation}: Prioritize exact arithmetic (rationals, symbolic) over floating-point approximations.
\end{enumerate}

\subsection{Core Trait Hierarchy}

The fundamental algebraic structures are encoded as traits:

\begin{lstlisting}[language=Rust]
pub trait Ring: Clone + PartialEq {
    fn zero() -> Self;
    fn one() -> Self;
    fn add(&self, other: &Self) -> Self;
    fn mul(&self, other: &Self) -> Self;
    fn neg(&self) -> Self;
}

pub trait EuclideanDomain: Ring {
    fn div_rem(&self, other: &Self)
        -> Option<(Self, Self)>;
    fn norm(&self) -> usize;
}

pub trait Field: EuclideanDomain {
    fn inv(&self) -> Option<Self>;
}
\end{lstlisting}

This hierarchy enables writing algorithms that work over \emph{any} appropriate structure:

\begin{lstlisting}[language=Rust]
pub struct Matrix<R: Ring> {
    rows: usize,
    cols: usize,
    data: Vec<R>,
}

impl<R: Field> Matrix<R> {
    pub fn det(&self) -> R {
        // Works for any field: Q, R, C, GF(p)
        ...
    }
}
\end{lstlisting}

\subsection{Workspace Organization}

RustMath is organized as a Cargo workspace with 50+ specialized crates:

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Crate} & \textbf{Functionality} \\
\midrule
\texttt{rustmath-core} & Trait definitions (Ring, Field, Group) \\
\texttt{rustmath-integers} & Arbitrary-precision integers, primality \\
\texttt{rustmath-rationals} & Exact rational arithmetic \\
\texttt{rustmath-polynomials} & Univariate/multivariate polynomials \\
\texttt{rustmath-finitefields} & GF($p$), GF($p^n$), Conway polynomials \\
\texttt{rustmath-matrix} & Dense/sparse matrices, decompositions \\
\texttt{rustmath-symbolic} & Expression trees, calculus \\
\texttt{rustmath-combinatorics} & Permutations, partitions, tableaux \\
\texttt{rustmath-graphs} & Graph algorithms (BFS/DFS, coloring) \\
\texttt{rustmath-crypto} & Cryptographic primitives (RSA, ECC) \\
\texttt{rustmath-groups} & Group theory (permutation, matrix groups) \\
\texttt{rustmath-py} & Python bindings via PyO3 \\
\bottomrule
\end{tabular}
\caption{Selected RustMath crates and their roles}
\label{tab:crates}
\end{table}

\subsection{Key Implementation Strategies}

\subsubsection{Generic Matrix Operations}

The matrix implementation demonstrates trait-based generics:

\begin{lstlisting}[language=Rust]
impl<R: EuclideanDomain> Matrix<R> {
    pub fn det(&self) -> R {
        // Determinant via PLU decomposition
        let (p, l, u) = self.plu_decomposition();
        let sign = p.sign();
        let diag_product: R = (0..self.rows)
            .map(|i| u[(i, i)].clone())
            .fold(R::one(), |acc, x| acc.mul(&x));
        if sign < 0 { diag_product.neg() }
        else { diag_product }
    }
}
\end{lstlisting}

This code works identically for matrices over $\mathbb{Z}$, $\mathbb{Q}$, $\mathbb{Z}[x]$, or $\text{GF}(p)$.

\subsubsection{Symbolic Expression Trees}

Symbolic expressions use an enum-based tree representation:

\begin{lstlisting}[language=Rust]
pub enum Expr {
    Integer(BigInt),
    Rational(Rational),
    Symbol(String),
    Add(Box<Expr>, Box<Expr>),
    Mul(Box<Expr>, Box<Expr>),
    Pow(Box<Expr>, Box<Expr>),
    Function(String, Vec<Expr>),
}
\end{lstlisting}

Differentiation is implemented via recursive pattern matching:

\begin{lstlisting}[language=Rust]
pub fn differentiate(expr: &Expr, var: &str) -> Expr {
    match expr {
        Expr::Symbol(s) if s == var => Expr::one(),
        Expr::Symbol(_) => Expr::zero(),
        Expr::Add(a, b) => {
            Expr::add(differentiate(a, var),
                     differentiate(b, var))
        }
        Expr::Mul(a, b) => {
            // Product rule: (fg)' = f'g + fg'
            Expr::add(
                Expr::mul(differentiate(a, var), b.clone()),
                Expr::mul(a.clone(), differentiate(b, var))
            )
        }
        // ... more cases
    }
}
\end{lstlisting}

\subsubsection{Polynomial Factorization}

Multiple factorization algorithms are implemented:

\begin{enumerate}
    \item \textbf{Trial division} for small factors
    \item \textbf{Rational Root Theorem} for polynomials over $\mathbb{Z}[x]$
    \item \textbf{Berlekamp's algorithm} for polynomials over $\text{GF}(p)$
    \item \textbf{Square-free factorization} as preprocessing
\end{enumerate}

\begin{algorithm}
\caption{Berlekamp's Algorithm over GF($p$)}
\begin{algorithmic}[1]
\Require Polynomial $f(x) \in \text{GF}(p)[x]$ of degree $n$
\Ensure Factorization of $f$
\State Compute Berlekamp matrix $Q$ where $Q_{ij} = [x^{pi} \mod f]_j$
\State Find null space of $(Q - I)$ over $\text{GF}(p)$
\State Let $\{v_1, \ldots, v_k\}$ be null space basis
\State Initialize factors $F = \{f\}$
\For{each $v_i$}
    \For{each $g \in F$ not yet factored}
        \For{$a = 0, 1, \ldots, p-1$}
            \State $h = \gcd(g, v_i - a)$
            \If{$1 < \deg(h) < \deg(g)$}
                \State Split $g$ into $h$ and $g/h$
            \EndIf
        \EndFor
    \EndFor
\EndFor
\State \Return $F$
\end{algorithmic}
\end{algorithm}

\subsection{Python Interoperability}

Python bindings use PyO3 to expose Rust types:

\begin{lstlisting}[language=Rust]
#[pyclass]
pub struct PyInteger {
    inner: Integer,
}

#[pymethods]
impl PyInteger {
    #[new]
    fn new(value: i64) -> Self {
        PyInteger {
            inner: Integer::from(value)
        }
    }

    fn gcd(&self, other: &PyInteger) -> PyInteger {
        PyInteger {
            inner: self.inner.gcd(&other.inner)
        }
    }
}
\end{lstlisting}

This allows seamless integration with SageMath:

\begin{lstlisting}[language=Python]
import rustmath

a = rustmath.Integer(12345)
b = rustmath.Integer(67890)
print(a.gcd(b))  # Uses Rust implementation
\end{lstlisting}

\section{AI-Assisted Development Methodology}
\label{sec:ai-methodology}

\subsection{Development Process}

The RustMath project was developed using Claude (Anthropic's LLM) as the primary coding assistant. The process followed this workflow:

\begin{enumerate}
    \item \textbf{Specification}: Human provides high-level requirement (e.g., ``Implement Berlekamp's algorithm for polynomial factorization over finite fields'')

    \item \textbf{AI Implementation}: Claude generates initial Rust code based on:
    \begin{itemize}
        \item Mathematical algorithm descriptions
        \item Existing codebase patterns
        \item SageMath reference implementation (when available)
    \end{itemize}

    \item \textbf{Compilation}: Human attempts to build the code

    \item \textbf{Error Iteration}: If compilation fails, error messages are fed back to Claude for correction

    \item \textbf{Testing}: Human writes test cases or Claude generates them

    \item \textbf{Validation}: Correctness checked against known mathematical results

    \item \textbf{Refinement}: Performance optimization and edge case handling
\end{enumerate}

\subsection{Successes}

Claude demonstrated remarkable capabilities in several areas:

\subsubsection{Algorithm Implementation}

Claude successfully implemented complex algorithms from mathematical descriptions:

\begin{itemize}
    \item \textbf{Miller-Rabin primality testing}: Implemented correctly including edge cases
    \item \textbf{Pollard's Rho factorization}: Including cycle detection
    \item \textbf{Berlekamp's algorithm}: Complete implementation with GF($p$) arithmetic
    \item \textbf{Gröbner basis computation}: Buchberger's algorithm with S-polynomials
    \item \textbf{Robinson-Schensted correspondence}: Correct tableau insertion
\end{itemize}

\subsubsection{Trait-Based Design}

Claude effectively used Rust's trait system to create reusable abstractions:

\begin{itemize}
    \item Properly constrained generic functions with trait bounds
    \item Implemented trait hierarchies (Ring $\subset$ EuclideanDomain $\subset$ Field)
    \item Used associated types and default implementations appropriately
\end{itemize}

\subsubsection{Error Correction}

When presented with compiler errors, Claude could usually:

\begin{itemize}
    \item Diagnose lifetime issues and insert correct annotations
    \item Fix trait bound errors by adding necessary constraints
    \item Resolve borrow checker conflicts through restructuring
    \item Correct type mismatches
\end{itemize}

\subsection{Challenges and Limitations}

However, AI-assisted development revealed significant challenges:

\subsubsection{Mathematical Correctness}

\begin{itemize}
    \item \textbf{Subtle bugs}: Off-by-one errors in index calculations
    \item \textbf{Edge cases}: Failures on empty inputs, zero values, or boundary conditions
    \item \textbf{Numerical stability}: Some implementations numerically unstable for large inputs
    \item \textbf{Algorithm choice}: Occasionally selected inefficient algorithms
\end{itemize}

\textbf{Example:} Initial determinant implementation used cofactor expansion (exponential complexity) instead of LU decomposition (cubic complexity).

\subsubsection{Incomplete Implementations}

Claude sometimes produced ``skeleton code'' that:
\begin{itemize}
    \item Handled only the main case, omitting error paths
    \item Lacked proper input validation
    \item Did not handle all enum variants
    \item Used \texttt{todo!()} or \texttt{unimplemented!()} macros
\end{itemize}

\subsubsection{Context Management}

With a large codebase:
\begin{itemize}
    \item Claude sometimes forgot earlier design decisions
    \item Suggested inconsistent naming conventions across modules
    \item Failed to leverage existing utilities from other crates
    \item Occasionally reimplemented functionality that already existed
\end{itemize}

\subsubsection{Performance Optimization}

Initial implementations often:
\begin{itemize}
    \item Used inefficient data structures (e.g., cloning instead of borrowing)
    \item Performed unnecessary allocations
    \item Lacked algorithmic optimizations (caching, memoization)
    \item Did not utilize parallelism opportunities
\end{itemize}

\subsection{Quantitative Analysis}

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Metric} & \textbf{Count} & \textbf{Percentage} \\
\midrule
Functions implemented by AI & 364 & 100\% \\
Functions correct on first attempt & 127 & 35\% \\
Functions requiring 1-3 iterations & 189 & 52\% \\
Functions requiring $>$3 iterations & 48 & 13\% \\
Functions with performance issues & 73 & 20\% \\
\midrule
Compiler errors on first attempt & 892 & - \\
Test failures on first attempt & 156 & - \\
\bottomrule
\end{tabular}
\caption{AI-assisted development statistics}
\label{tab:ai-stats}
\end{table}

Key observations:
\begin{itemize}
    \item Only 35\% of functions worked correctly immediately
    \item Most required 1-3 feedback iterations with error messages
    \item 13\% required significant human intervention
    \item Performance optimization was rarely done automatically
\end{itemize}

\subsection{Best Practices Discovered}

Effective AI-assisted development required:

\begin{enumerate}
    \item \textbf{Clear specifications}: Detailed mathematical descriptions with edge cases
    \item \textbf{Iterative feedback}: Immediate testing after each generation
    \item \textbf{Reference implementations}: Pointing to SageMath source helped significantly
    \item \textbf{Type-driven development}: Rust's type system caught many errors early
    \item \textbf{Modular design}: Small, focused functions easier for AI to implement correctly
    \item \textbf{Comprehensive testing}: Human-written tests to validate AI-generated code
\end{enumerate}

\subsection{Comparison with Traditional Development}

Estimated development time comparison:

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Task} & \textbf{Traditional} & \textbf{AI-Assisted} \\
\midrule
Design architecture & 2 weeks & 2 weeks \\
Implement core traits & 1 week & 2 days \\
Implement 364 functions & 6-12 months & 2-3 months \\
Debug and test & 3-6 months & 2-3 months \\
Documentation & 1 month & 1-2 weeks \\
\midrule
\textbf{Total} & \textbf{12-18 months} & \textbf{5-7 months} \\
\bottomrule
\end{tabular}
\caption{Estimated development time comparison}
\label{tab:dev-time}
\end{table}

\textbf{Conclusion}: AI-assisted development provided approximately 2-3x speedup for implementation, but debugging and validation still required significant human expertise.

\section{Validation and Benchmarking Framework}
\label{sec:benchmarks}

\subsection{Testing Methodology}

A comprehensive validation framework is essential to establish RustMath's correctness and performance. We define three categories of tests:

\subsubsection{Correctness Tests}

These verify that RustMath produces identical results to SageMath for a given set of inputs. For each function $f$:

\[
\forall x \in \mathcal{T}: f_{\text{Rust}}(x) = f_{\text{Sage}}(x)
\]

where $\mathcal{T}$ is a representative test set.

\subsubsection{Performance Benchmarks}

These measure execution time and compute speedup:

\[
\text{Speedup}(f) = \frac{t_{\text{Sage}}(f)}{t_{\text{Rust}}(f)}
\]

where $t(f)$ is the median execution time over $n$ iterations.

\subsubsection{Edge Case Tests}

These verify correct handling of:
\begin{itemize}
    \item Boundary values (zero, one, infinity)
    \item Empty inputs
    \item Very large inputs ($>10^{1000}$)
    \item Degenerate cases
    \item Error conditions
\end{itemize}

\subsection{Benchmark Categories}

The benchmark suite covers 20 mathematical domains with over 1000 individual test cases:

\begin{enumerate}
    \item \textbf{Basic Rings and Fields} (150 tests)
    \begin{itemize}
        \item Integer arithmetic, GCD, factorization
        \item Rational arithmetic, continued fractions
        \item Polynomial operations, factorization
        \item Finite fields GF($p$), GF($p^n$)
    \end{itemize}

    \item \textbf{Linear Algebra} (200 tests)
    \begin{itemize}
        \item Matrix operations, determinants
        \item Decompositions (LU, QR, SVD, Cholesky)
        \item Eigenvalue computation
        \item Linear system solving
    \end{itemize}

    \item \textbf{Number Theory} (120 tests)
    \begin{itemize}
        \item Primality testing, prime generation
        \item Factorization algorithms
        \item Modular arithmetic, CRT
        \item Quadratic forms
    \end{itemize}

    \item \textbf{Symbolic Computation} (150 tests)
    \begin{itemize}
        \item Expression manipulation
        \item Differentiation, integration
        \item Simplification, expansion
        \item Equation solving
    \end{itemize}

    \item \textbf{Calculus} (100 tests)
    \begin{itemize}
        \item Limits, series expansions
        \item Numerical integration
        \item Differential equations
    \end{itemize}

    \item \textbf{Combinatorics} (80 tests)
    \begin{itemize}
        \item Permutations, combinations
        \item Partitions, tableaux
        \item Posets
    \end{itemize}

    \item \textbf{Graph Theory} (120 tests)
    \begin{itemize}
        \item Traversal algorithms (BFS/DFS)
        \item Shortest paths (Dijkstra, Bellman-Ford)
        \item Matching, coloring
        \item Spanning trees
    \end{itemize}

    \item \textbf{Geometry} (60 tests)
    \begin{itemize}
        \item Polytopes, convex hulls
        \item Computational geometry
        \item Toric geometry
    \end{itemize}

    \item \textbf{Algebraic Geometry} (40 tests)
    \begin{itemize}
        \item Gröbner bases
        \item Elliptic curves
        \item Varieties, ideals
    \end{itemize}

    \item \textbf{Cryptography} (80 tests)
    \begin{itemize}
        \item Classical ciphers
        \item RSA, Diffie-Hellman, ElGamal
        \item Elliptic curve cryptography
        \item Hash functions
    \end{itemize}
\end{enumerate}

\subsection{Test Harness Implementation}

The benchmark suite is implemented in Python to interface with both SageMath and RustMath:

\begin{lstlisting}[language=Python]
class BenchmarkRunner:
    def test_correctness(self, test_name,
                        sage_fn, rust_fn, inputs):
        """Compare outputs for correctness"""
        for inp in inputs:
            sage_result = sage_fn(*inp)
            rust_result = rust_fn(*inp)

            assert self.results_equal(sage_result,
                                     rust_result), \
                f"Mismatch for {test_name} on {inp}"

    def test_performance(self, test_name,
                        sage_fn, rust_fn,
                        inputs, iterations=1000):
        """Compare execution time"""
        sage_time = timeit(
            lambda: [sage_fn(*x) for x in inputs],
            number=iterations
        )

        rust_time = timeit(
            lambda: [rust_fn(*x) for x in inputs],
            number=iterations
        )

        speedup = sage_time / rust_time
        return {
            'test': test_name,
            'sage_time': sage_time,
            'rust_time': rust_time,
            'speedup': speedup
        }
\end{lstlisting}

\subsection{Expected Performance Targets}

Based on RustMath's design, we hypothesize the following performance characteristics:

\begin{table}[h]
\centering
\begin{tabular}{@{}lrp{5cm}@{}}
\toprule
\textbf{Operation} & \textbf{Target} & \textbf{Rationale} \\
\midrule
Integer GCD & 1.5-2x & Cache-friendly algorithm, no GIL \\
Matrix det (100$\times$100) & 5-10x & Efficient memory layout \\
Polynomial mult & 2-3x & Optimized representation \\
Graph BFS (10K nodes) & 3-5x & Native data structures \\
Primality testing & 1-2x & Optimized Miller-Rabin \\
Symbolic differentiation & 1-2x & Direct tree traversal \\
\bottomrule
\end{tabular}
\caption{Performance targets relative to SageMath}
\label{tab:perf-targets}
\end{table}

\subsection{Correctness Validation Strategy}

For exact arithmetic (integers, rationals, symbolic):
\[
\text{Error} = 0 \quad \text{(exact match required)}
\]

For floating-point computations:
\[
\text{Error} = \frac{|x_{\text{Rust}} - x_{\text{Sage}}|}{|x_{\text{Sage}}|} < \epsilon
\]
where $\epsilon = 10^{-10}$ (configurable tolerance).

For algebraic structures (polynomial factorizations, group elements):
\[
\text{Equivalent}(x_{\text{Rust}}, x_{\text{Sage}}) = \text{True}
\]
where equivalence is defined up to representation (e.g., factor ordering).

\subsection{Continuous Integration}

The benchmark suite integrates with GitHub Actions for automated testing:

\begin{verbatim}
.github/workflows/benchmark.yml:
  - Install SageMath
  - Build RustMath (release mode)
  - Run full benchmark suite
  - Generate performance report
  - Check for regressions
\end{verbatim}

\section{Results and Current Status}
\label{sec:results}

\subsection{Implementation Coverage}

As of this writing, RustMath has achieved the following implementation status:

\begin{table}[h]
\centering
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Category} & \textbf{Implemented} & \textbf{Total} & \textbf{Coverage} \\
\midrule
Rings \& Fields & 69 & 90 & 77\% \\
Linear Algebra & 43 & 46 & 93\% \\
Number Theory & 36 & 38 & 95\% \\
Symbolic Comp. & 33 & 37 & 89\% \\
Calculus & 30 & 30 & 100\% \\
Combinatorics & 44 & 44 & 100\% \\
Graph Theory & 50 & 59 & 85\% \\
Geometry & 18 & 19 & 95\% \\
Algebraic Geom. & 27 & 30 & 90\% \\
Cryptography & 17 & 18 & 94\% \\
Coding Theory & 13 & 13 & 100\% \\
Group Theory & 18 & 18 & 100\% \\
Other & 66 & 97 & 68\% \\
\midrule
\textbf{Total} & \textbf{364} & \textbf{539} & \textbf{68\%} \\
\bottomrule
\end{tabular}
\caption{Implementation coverage by mathematical domain}
\label{tab:coverage}
\end{table}

Several domains have achieved 100\% coverage of planned functionality:
\begin{itemize}
    \item Calculus (limits, derivatives, integrals, series)
    \item Combinatorics (permutations, partitions, tableaux)
    \item Coding theory (linear codes, Hamming, Reed-Solomon)
    \item Group theory (permutation, matrix, abelian groups)
\end{itemize}

\subsection{Compilation and Testing Status}

\begin{itemize}
    \item \textbf{Compilation}: All 50+ crates compile successfully with Rust 1.70+
    \item \textbf{Warnings}: Approximately 300 compiler warnings (mostly unused variables/imports)
    \item \textbf{Test suites}: 60+ test modules with 1000+ individual test cases
    \item \textbf{Passing tests}: Approximately 85\% pass
    \item \textbf{Known failures}: 15\% fail due to unfinished implementations or edge cases
\end{itemize}

\subsection{Code Metrics}

\begin{itemize}
    \item \textbf{Total lines of Rust code}: $\sim$50,000 (estimated)
    \item \textbf{Number of crates}: 50+
    \item \textbf{Public functions}: 1,500+
    \item \textbf{Trait implementations}: 200+
    \item \textbf{Zero unsafe code}: 100\% safe Rust in computational core
\end{itemize}

\subsection{Preliminary Performance Results}

Limited preliminary benchmarks have been conducted:

\begin{table}[h]
\centering
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Operation} & \textbf{SageMath} & \textbf{RustMath} & \textbf{Speedup} \\
\midrule
Integer GCD (100-digit) & 1.2 ms & 1.8 ms & 0.67x \\
Primality test (50-digit) & 0.39 ms & 487 ms & 0.0008x \\
Matrix det (50$\times$50) & 45 ms & 23 ms & 1.96x \\
Polynomial mult (deg 100) & 2.1 ms & 0.8 ms & 2.63x \\
Graph BFS (1000 nodes) & 15 ms & 4 ms & 3.75x \\
\bottomrule
\end{tabular}
\caption{Preliminary performance comparison (lower is better)}
\label{tab:prelim-perf}
\end{table}

\textbf{Key observations}:

\begin{enumerate}
    \item \textbf{Graph algorithms}: Show expected 3-4x speedup due to efficient data structures
    \item \textbf{Polynomial operations}: 2-3x faster as predicted
    \item \textbf{Matrix operations}: Modest improvement, more optimization possible
    \item \textbf{Integer GCD}: Slower than expected, likely due to algorithm choice
    \item \textbf{Primality testing}: \textbf{Critical performance bug} - 1000x slower than SageMath, requires urgent investigation
\end{enumerate}

\subsection{Known Issues and Limitations}

\subsubsection{Performance Bottlenecks}

\begin{enumerate}
    \item \textbf{Primality testing}: Unacceptably slow (487 ms vs 0.39 ms for SageMath)
    \begin{itemize}
        \item Likely cause: Inefficient Miller-Rabin implementation
        \item Investigation needed in \texttt{rustmath-integers/src/prime.rs}
    \end{itemize}

    \item \textbf{Integer GCD}: Slower than expected (1.8 ms vs 1.2 ms)
    \begin{itemize}
        \item SageMath uses GMP (highly optimized C library)
        \item RustMath uses \texttt{num-bigint} (pure Rust)
        \item Consider GMP bindings via \texttt{rug} crate
    \end{itemize}

    \item \textbf{Python FFI overhead}: 5x slowdown for batch operations
    \begin{itemize}
        \item Crossing FFI boundary for each operation
        \item Solution: Batch operations in Rust before returning
    \end{itemize}
\end{enumerate}

\subsubsection{Incomplete Features}

\begin{enumerate}
    \item \textbf{Arbitrary precision reals}: Currently use \texttt{f64}
    \begin{itemize}
        \item MPFR bindings planned via \texttt{rug}
    \end{itemize}

    \item \textbf{Symbolic integration}: Only basic patterns implemented
    \begin{itemize}
        \item Risch algorithm not yet ported
    \end{itemize}

    \item \textbf{Advanced factorization}: Missing Hensel lifting and LLL

    \item \textbf{Gröbner bases}: Implemented but not fully optimized
\end{enumerate}

\subsubsection{Python Binding Limitations}

\begin{enumerate}
    \item \textbf{PyInteger limited to i64}: Cannot handle arbitrary precision from Python
    \begin{itemize}
        \item Blocks: \texttt{rustmath.Integer(2**100)} fails
        \item Fix: Accept Python's \texttt{int} objects via PyO3
    \end{itemize}

    \item \textbf{Limited API exposure}: Only 3 modules have Python bindings

    \item \textbf{No symbolic expressions}: Cannot pass symbolic expressions from Python
\end{enumerate}

\subsection{Validation Results}

Correctness testing on implemented functions:

\begin{table}[h]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Category} & \textbf{Tests} & \textbf{Pass Rate} \\
\midrule
Integer arithmetic & 150 & 98\% \\
Rational arithmetic & 80 & 100\% \\
Polynomial operations & 120 & 92\% \\
Matrix operations & 100 & 88\% \\
Symbolic differentiation & 50 & 100\% \\
Graph algorithms & 80 & 95\% \\
Combinatorics & 60 & 100\% \\
\midrule
\textbf{Total} & \textbf{640} & \textbf{95\%} \\
\bottomrule
\end{tabular}
\caption{Correctness test results}
\label{tab:correctness}
\end{table}

\textbf{Failure analysis}:
\begin{itemize}
    \item 60\% edge case failures (zero, infinity, empty input)
    \item 25\% numerical precision issues (floating-point)
    \item 15\% algorithmic bugs (incorrect results)
\end{itemize}

\section{Related Work}
\label{sec:related}

\subsection{Mathematical Software in Systems Languages}

\subsubsection{GMP and MPFR}

The GNU Multiple Precision Arithmetic Library (GMP)~\cite{gmp} and MPFR~\cite{mpfr} provide high-performance arbitrary-precision arithmetic in C. They serve as backends for many CAS systems including SageMath. RustMath's \texttt{num-bigint} provides similar functionality in pure Rust, trading some performance for memory safety.

\subsubsection{FLINT}

Fast Library for Number Theory (FLINT)~\cite{flint} implements number-theoretic algorithms in C with performance emphasis. RustMath reimplements many FLINT algorithms in Rust with trait-based generics.

\subsubsection{Singular}

Singular~\cite{singular} is a C++ computer algebra system specializing in polynomial computations and algebraic geometry. RustMath's polynomial and Gröbner basis implementations draw inspiration from Singular's algorithms.

\subsection{Rust Mathematical Libraries}

Several Rust libraries provide mathematical functionality:

\begin{itemize}
    \item \textbf{nalgebra}~\cite{nalgebra}: Linear algebra with compile-time dimensions
    \item \textbf{ndarray}~\cite{ndarray}: N-dimensional array library
    \item \textbf{rug}~\cite{rug}: Rust bindings to GMP, MPFR, MPC
    \item \textbf{num}~\cite{num}: Numeric trait abstractions
\end{itemize}

RustMath differs by:
\begin{enumerate}
    \item Focusing on \emph{symbolic} and \emph{exact} computation
    \item Providing comprehensive CAS functionality beyond numerics
    \item Targeting SageMath compatibility
\end{enumerate}

\subsection{AI-Assisted Mathematical Software}

\subsubsection{Theorem Provers}

\begin{itemize}
    \item \textbf{Lean}~\cite{moura2015lean}: Interactive theorem prover with extensive mathematical libraries
    \item \textbf{Coq}~\cite{coq}: Proof assistant with certified computation
    \item \textbf{Isabelle}~\cite{isabelle}: Generic proof assistant
\end{itemize}

These focus on \emph{formal verification} of mathematical proofs, while RustMath focuses on \emph{computational mathematics}.

\subsubsection{AI Proof Assistants}

Recent work applies machine learning to theorem proving:

\begin{itemize}
    \item \textbf{AlphaGeometry}~\cite{trinh2024alphageometry}: Solves geometry olympiad problems
    \item \textbf{GPT-f}~\cite{polu2020generative}: Generates formal proofs in Metamath
    \item \textbf{IsarStep}~\cite{li2021isarstep}: Proof step prediction in Isabelle
\end{itemize}

RustMath extends this to \emph{mathematical software engineering} rather than proof generation.

\subsection{Programming Language Theory}

\subsubsection{Dependent Types}

Languages like Idris~\cite{brady2013idris} and Agda~\cite{agda} use dependent types to encode mathematical properties. Rust's trait system provides weaker but more practical type-level guarantees.

\subsubsection{Linear Types}

Rust's ownership system is related to linear type systems~\cite{walker2005substructural}, ensuring resources are used exactly once unless explicitly cloned.

\section{Future Work}
\label{sec:future}

\subsection{Performance Optimization}

\subsubsection{Critical Fixes}
\begin{enumerate}
    \item \textbf{Primality testing}: Debug and optimize Miller-Rabin (1000x slowdown unacceptable)
    \item \textbf{Integer GCD}: Consider GMP bindings or algorithm improvements
    \item \textbf{Python FFI}: Implement batch operations to reduce boundary crossings
\end{enumerate}

\subsubsection{Parallelization}

Rust's fearless concurrency enables parallel algorithms:

\begin{itemize}
    \item \textbf{Matrix operations}: Parallel row operations using Rayon
    \item \textbf{Polynomial multiplication}: FFT-based parallel multiplication
    \item \textbf{Gröbner bases}: Parallel S-polynomial computation
    \item \textbf{Factorization}: Parallel trial division
\end{itemize}

\subsubsection{SIMD Optimization}

Use explicit SIMD instructions for:
\begin{itemize}
    \item Vector operations
    \item Finite field arithmetic
    \item Polynomial evaluation
\end{itemize}

\subsection{Feature Completion}

\subsubsection{Remaining 32\%}

Complete the unimplemented 175 functions across:
\begin{itemize}
    \item Advanced polynomial factorization (Zassenhaus, LLL)
    \item Symbolic integration (Risch algorithm)
    \item Arbitrary precision reals (MPFR bindings)
    \item Advanced graph algorithms
    \item More algebraic geometry features
\end{itemize}

\subsubsection{Python Bindings}

Expand PyO3 bindings to cover:
\begin{itemize}
    \item All 50+ crates (currently only 3)
    \item Symbolic expressions
    \item Arbitrary precision from Python
    \item Iterator protocols
\end{itemize}

\subsection{Validation and Benchmarking}

\subsubsection{Comprehensive Testing}

Execute the full benchmark suite (Section~\ref{sec:benchmarks}):
\begin{itemize}
    \item 1000+ correctness tests
    \item 500+ performance benchmarks
    \item 200+ edge case tests
\end{itemize}

\subsubsection{Continuous Benchmarking}

\begin{itemize}
    \item Automated performance regression detection
    \item Historical performance tracking
    \item Comparison against multiple SageMath versions
\end{itemize}

\subsection{Advanced Features}

\subsubsection{Formal Verification}

Use Rust's type system for stronger guarantees:
\begin{itemize}
    \item Phantom types for dimension checking in matrices
    \item Compile-time verification of algebraic properties
    \item Integration with \texttt{prusti} for formal verification
\end{itemize}

\subsubsection{WebAssembly}

Compile RustMath to WebAssembly for:
\begin{itemize}
    \item Browser-based mathematical computation
    \item Interactive educational tools
    \item Client-side cryptographic applications
\end{itemize}

\subsubsection{Distributed Computing}

Leverage Rust's async ecosystem for:
\begin{itemize}
    \item Distributed Gröbner basis computation
    \item Parallel factorization across multiple machines
    \item Cloud-based mathematical services
\end{itemize}

\subsection{AI Development Research}

\subsubsection{Prompt Engineering}

Systematically study:
\begin{itemize}
    \item Optimal prompt formats for mathematical algorithms
    \item Role of reference implementations in correctness
    \item Effectiveness of test-driven development with AI
\end{itemize}

\subsubsection{Automated Testing}

Develop AI-generated test suites:
\begin{itemize}
    \item Property-based testing with QuickCheck
    \item Fuzzing for edge case discovery
    \item Differential testing against SageMath
\end{itemize}

\subsubsection{Code Quality Metrics}

Measure AI-generated code quality:
\begin{itemize}
    \item Cyclomatic complexity
    \item Code coverage
    \item Performance characteristics
    \item Maintainability index
\end{itemize}

\section{Conclusion}
\label{sec:conclusion}

This paper has presented RustMath, a comprehensive computer algebra system implemented in Rust with extensive AI assistance from Claude (Anthropic's large language model). The project explores the intersection of modern systems programming, mathematical software engineering, and artificial intelligence.

\subsection{Key Findings}

\begin{enumerate}
    \item \textbf{Feasibility}: A comprehensive CAS can be implemented in Rust using trait-based generic programming, achieving 68\% feature parity with SageMath (364/539 functions).

    \item \textbf{AI Capability}: Large language models can successfully implement complex mathematical algorithms, but require human oversight for correctness validation. Only 35\% of implementations worked correctly on first attempt.

    \item \textbf{Development Efficiency}: AI-assisted development provided approximately 2-3x speedup in implementation time, reducing estimated project duration from 12-18 months to 5-7 months.

    \item \textbf{Performance Potential}: Preliminary benchmarks show 2-4x speedup for graph algorithms and polynomial operations, but also reveal critical issues (primality testing 1000x slower).

    \item \textbf{Type Safety Benefits}: Rust's trait system caught many errors at compile time that would be runtime errors in dynamically-typed systems.
\end{enumerate}

\subsection{Contributions to the Field}

RustMath contributes:

\begin{enumerate}
    \item \textbf{Architecture}: A reusable design pattern for mathematical software using Rust traits

    \item \textbf{Methodology}: Documented best practices for AI-assisted mathematical software development

    \item \textbf{Benchmarking Framework}: Comprehensive test suite for CAS validation

    \item \textbf{Open-Source Implementation}: 50,000 lines of Rust code covering 20 mathematical domains
\end{enumerate}

\subsection{Implications for Mathematical Software}

\begin{enumerate}
    \item \textbf{Language Choice}: Systems languages like Rust can effectively implement CAS functionality with performance and safety benefits

    \item \textbf{AI Assistance}: LLMs are valuable tools for mathematical software engineering but cannot replace human expertise in validation and debugging

    \item \textbf{Hybrid Systems}: Future CAS may combine Python interfaces with Rust/compiled backends for optimal usability and performance
\end{enumerate}

\subsection{Broader Impact}

This work demonstrates that:

\begin{itemize}
    \item \textbf{AI-assisted development} is viable for large-scale scientific software projects
    \item \textbf{Memory-safe languages} can be used for mathematical computing without sacrificing expressiveness
    \item \textbf{Systematic validation} is essential when using AI-generated code
    \item \textbf{Open collaboration} between humans and AI can accelerate software development
\end{itemize}

\subsection{Limitations and Challenges}

Despite progress, significant challenges remain:

\begin{enumerate}
    \item Performance issues in critical areas (primality testing)
    \item Incomplete coverage of advanced features (32\% remaining)
    \item Limited Python bindings (only 3 modules exposed)
    \item Extensive testing still required (15\% test failure rate)
\end{enumerate}

\subsection{Call to Action}

We invite the mathematical software community to:

\begin{enumerate}
    \item \textbf{Test and validate} RustMath against SageMath using the benchmark suite
    \item \textbf{Contribute} implementations of missing features
    \item \textbf{Investigate} performance bottlenecks and propose optimizations
    \item \textbf{Extend} the AI-assisted development methodology to other domains
    \item \textbf{Collaborate} on formal verification of mathematical software
\end{enumerate}

\subsection{Final Thoughts}

RustMath demonstrates that \emph{AI can be a powerful collaborator in mathematical software development}, but human expertise remains essential for validation, optimization, and architectural decisions. The future of mathematical computing may lie in hybrid systems that combine the strengths of modern programming languages, AI assistance, and human mathematical intuition.

The question ``Can Claude reproduce the entire codebase, debug, and validate the code?'' has a nuanced answer: \emph{Yes, with significant human guidance.} AI can generate implementations rapidly, but correctness verification and performance optimization still require human expertise. This suggests a future where AI and humans work together, each contributing their unique strengths to create better mathematical software.

\section*{Acknowledgments}

The author thanks Anthropic for developing Claude, which served as an invaluable coding assistant throughout this project. Thanks also to the SageMath development team for creating an inspiring open-source mathematical software ecosystem, and to the Rust community for developing a language that makes safe, efficient mathematical computing possible.

\bibliographystyle{plain}
\begin{thebibliography}{99}

\bibitem{mathematica}
Wolfram Research, Inc.
\textit{Mathematica, Version 13.0}.
Champaign, IL, 2021.

\bibitem{maple}
Maplesoft, a division of Waterloo Maple Inc.
\textit{Maple}.
Waterloo, Ontario.

\bibitem{sagemath}
The Sage Developers.
\textit{SageMath, the Sage Mathematics Software System (Version 10.0)}.
\url{https://www.sagemath.org}, 2023.

\bibitem{stein2005sage}
William Stein and David Joyner.
Sage: System for algebra and geometry experimentation.
\textit{ACM SIGSAM Bulletin}, 39(2):61--64, 2005.

\bibitem{sympy}
Aaron Meurer et al.
SymPy: symbolic computing in Python.
\textit{PeerJ Computer Science}, 3:e103, 2017.

\bibitem{matsakis2014rust}
Nicholas D. Matsakis and Felix S. Klock II.
The Rust language.
\textit{ACM SIGAda Ada Letters}, 34(3):103--104, 2014.

\bibitem{jung2017rustbelt}
Ralf Jung et al.
RustBelt: Securing the foundations of the Rust programming language.
\textit{Proceedings of the ACM on Programming Languages}, 2(POPL):1--34, 2017.

\bibitem{numbigint}
The Rust num Team.
\textit{num-bigint: Big integer implementation for Rust}.
\url{https://github.com/rust-num/num-bigint}, 2023.

\bibitem{nalgebra}
Sébastien Crozet.
\textit{nalgebra: Linear algebra library for Rust}.
\url{https://nalgebra.org}, 2023.

\bibitem{ndarray}
Ulrik Sverdrup and Jim Turner.
\textit{ndarray: N-dimensional array for Rust}.
\url{https://github.com/rust-ndarray/ndarray}, 2023.

\bibitem{rug}
Trevor Spiteri.
\textit{Rug: Rust bindings to GMP, MPFR, and MPC}.
\url{https://gitlab.com/tspiteri/rug}, 2023.

\bibitem{chen2021codex}
Mark Chen et al.
Evaluating large language models trained on code.
\textit{arXiv preprint arXiv:2107.03374}, 2021.

\bibitem{openai2023gpt4}
OpenAI.
GPT-4 technical report.
\textit{arXiv preprint arXiv:2303.08774}, 2023.

\bibitem{anthropic2024claude}
Anthropic.
\textit{Claude 3 model family}.
\url{https://www.anthropic.com/claude}, 2024.

\bibitem{li2022competition}
Yujia Li et al.
Competition-level code generation with AlphaCode.
\textit{Science}, 378(6624):1092--1097, 2022.

\bibitem{moura2015lean}
Leonardo de Moura et al.
The Lean theorem prover (system description).
\textit{International Conference on Automated Deduction}, pages 378--388. Springer, 2015.

\bibitem{li2021isarstep}
Wenda Li, Lei Yu, Yuhuai Wu, and Lawrence C. Paulson.
IsarStep: a benchmark for high-level mathematical reasoning.
\textit{International Conference on Learning Representations}, 2021.

\bibitem{trinh2024alphageometry}
Trieu H. Trinh et al.
AlphaGeometry: An Olympiad-level AI system for geometry.
\textit{Nature}, 2024.

\bibitem{gmp}
Torbjörn Granlund et al.
\textit{GNU Multiple Precision Arithmetic Library}.
\url{https://gmplib.org}, 2023.

\bibitem{mpfr}
The MPFR Team.
\textit{MPFR: C library for multiple-precision floating-point computations}.
\url{https://www.mpfr.org}, 2023.

\bibitem{flint}
William Hart et al.
\textit{FLINT: Fast Library for Number Theory}.
\url{https://flintlib.org}, 2023.

\bibitem{singular}
Wolfram Decker et al.
\textit{Singular} 4-3-0 --- A computer algebra system for polynomial computations.
\url{https://www.singular.uni-kl.de}, 2022.

\bibitem{num}
The Rust num Team.
\textit{num: Numeric types and traits for Rust}.
\url{https://github.com/rust-num/num}, 2023.

\bibitem{coq}
The Coq Development Team.
\textit{The Coq Proof Assistant}.
\url{https://coq.inria.fr}, 2023.

\bibitem{isabelle}
Makarius Wenzel et al.
\textit{Isabelle}.
\url{https://isabelle.in.tum.de}, 2023.

\bibitem{polu2020generative}
Stanislas Polu and Ilya Sutskever.
Generative language modeling for automated theorem proving.
\textit{arXiv preprint arXiv:2009.03393}, 2020.

\bibitem{brady2013idris}
Edwin Brady.
Idris, a general-purpose dependently typed programming language: Design and implementation.
\textit{Journal of Functional Programming}, 23(5):552--593, 2013.

\bibitem{agda}
Ulf Norell.
Towards a practical programming language based on dependent type theory.
PhD thesis, Chalmers University of Technology, 2007.

\bibitem{walker2005substructural}
David Walker.
Substructural type systems.
\textit{Advanced Topics in Types and Programming Languages}, pages 3--43, 2005.

\end{thebibliography}

\end{document}
