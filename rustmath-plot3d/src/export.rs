//! Export 3D graphics to various file formats
//!
//! This module provides functionality to export 3D graphics to common file formats
//! like OBJ and STL for use in other 3D modeling and rendering software.

use crate::base::{Graphics3d, IndexFaceSet, Vector3D};
use crate::Result;
use std::fs::File;
use std::io::Write;
use std::path::Path;

/// Export a 3D mesh to Wavefront OBJ format
///
/// The OBJ format is a simple text-based format that stores 3D geometry including
/// vertices, normals, texture coordinates, and faces.
///
/// # Arguments
/// * `mesh` - The mesh to export
/// * `path` - Path to the output file
///
/// # Example
/// ```no_run
/// use rustmath_plot3d::export::export_obj;
/// use rustmath_plot3d::base::IndexFaceSet;
/// use rustmath_plot3d::base::Point3D;
///
/// let vertices = vec![
///     Point3D::new(0.0, 0.0, 0.0),
///     Point3D::new(1.0, 0.0, 0.0),
///     Point3D::new(0.0, 1.0, 0.0),
/// ];
/// let faces = vec![[0, 1, 2]];
/// let mesh = IndexFaceSet::new(vertices, faces);
/// export_obj(&mesh, "output.obj").unwrap();
/// ```
pub fn export_obj<P: AsRef<Path>>(mesh: &IndexFaceSet, path: P) -> Result<()> {
    let mut file = File::create(path)?;

    // Write header
    writeln!(file, "# Wavefront OBJ file")?;
    writeln!(file, "# Generated by RustMath")?;
    writeln!(file)?;

    // Write vertices
    writeln!(file, "# {} vertices", mesh.vertices.len())?;
    for v in &mesh.vertices {
        writeln!(file, "v {} {} {}", v.x, v.y, v.z)?;
    }
    writeln!(file)?;

    // Write vertex normals if available
    if let Some(normals) = &mesh.normals {
        writeln!(file, "# {} vertex normals", normals.len())?;
        for n in normals {
            writeln!(file, "vn {} {} {}", n.x, n.y, n.z)?;
        }
        writeln!(file)?;
    }

    // Write faces
    writeln!(file, "# {} faces", mesh.faces.len())?;
    if mesh.normals.is_some() {
        // Write faces with normal indices
        for face in &mesh.faces {
            // OBJ uses 1-based indexing
            writeln!(
                file,
                "f {}//{} {}//{} {}//{}",
                face[0] + 1, face[0] + 1,
                face[1] + 1, face[1] + 1,
                face[2] + 1, face[2] + 1
            )?;
        }
    } else {
        // Write faces without normals
        for face in &mesh.faces {
            writeln!(
                file,
                "f {} {} {}",
                face[0] + 1,
                face[1] + 1,
                face[2] + 1
            )?;
        }
    }

    Ok(())
}

/// Export a Graphics3d object to OBJ format
///
/// This will combine all meshes in the Graphics3d object into a single OBJ file.
///
/// # Arguments
/// * `graphics` - The Graphics3d object to export
/// * `path` - Path to the output file
pub fn export_graphics_obj<P: AsRef<Path>>(graphics: &Graphics3d, path: P) -> Result<()> {
    let mut file = File::create(path)?;

    // Write header
    writeln!(file, "# Wavefront OBJ file")?;
    writeln!(file, "# Generated by RustMath")?;
    writeln!(file)?;

    let mut vertex_offset = 0;
    let mut normal_offset = 0;

    for (obj_idx, primitive) in graphics.objects.iter().enumerate() {
        writeln!(file, "# Object {}", obj_idx)?;
        writeln!(file, "o object_{}", obj_idx)?;
        writeln!(file)?;

        let mesh = primitive.to_mesh()?;

        // Write vertices
        writeln!(file, "# {} vertices", mesh.vertices.len())?;
        for v in &mesh.vertices {
            writeln!(file, "v {} {} {}", v.x, v.y, v.z)?;
        }
        writeln!(file)?;

        // Write vertex normals if available
        if let Some(normals) = &mesh.normals {
            writeln!(file, "# {} vertex normals", normals.len())?;
            for n in normals {
                writeln!(file, "vn {} {} {}", n.x, n.y, n.z)?;
            }
            writeln!(file)?;
        }

        // Write faces
        writeln!(file, "# {} faces", mesh.faces.len())?;
        if mesh.normals.is_some() {
            for face in &mesh.faces {
                writeln!(
                    file,
                    "f {}//{} {}//{} {}//{}",
                    face[0] + 1 + vertex_offset, face[0] + 1 + normal_offset,
                    face[1] + 1 + vertex_offset, face[1] + 1 + normal_offset,
                    face[2] + 1 + vertex_offset, face[2] + 1 + normal_offset
                )?;
            }
            normal_offset += mesh.normals.as_ref().unwrap().len();
        } else {
            for face in &mesh.faces {
                writeln!(
                    file,
                    "f {} {} {}",
                    face[0] + 1 + vertex_offset,
                    face[1] + 1 + vertex_offset,
                    face[2] + 1 + vertex_offset
                )?;
            }
        }

        vertex_offset += mesh.vertices.len();
        writeln!(file)?;
    }

    Ok(())
}

/// Export a 3D mesh to binary STL format
///
/// STL (STereoLithography) is a format widely used for 3D printing and CAD.
/// This implementation uses the binary format, which is more compact than ASCII STL.
///
/// # Arguments
/// * `mesh` - The mesh to export
/// * `path` - Path to the output file
///
/// # Example
/// ```no_run
/// use rustmath_plot3d::export::export_stl;
/// use rustmath_plot3d::base::IndexFaceSet;
/// use rustmath_plot3d::base::Point3D;
///
/// let vertices = vec![
///     Point3D::new(0.0, 0.0, 0.0),
///     Point3D::new(1.0, 0.0, 0.0),
///     Point3D::new(0.0, 1.0, 0.0),
/// ];
/// let faces = vec![[0, 1, 2]];
/// let mesh = IndexFaceSet::new(vertices, faces);
/// export_stl(&mesh, "output.stl").unwrap();
/// ```
pub fn export_stl<P: AsRef<Path>>(mesh: &IndexFaceSet, path: P) -> Result<()> {
    let mut file = File::create(path)?;

    // STL binary format:
    // - 80 byte header
    // - 4 byte unsigned int (number of triangles)
    // - For each triangle:
    //   - 12 bytes for normal (3 floats)
    //   - 12 bytes for vertex 1 (3 floats)
    //   - 12 bytes for vertex 2 (3 floats)
    //   - 12 bytes for vertex 3 (3 floats)
    //   - 2 bytes for attribute byte count (usually 0)

    // Write 80-byte header
    let header = b"Binary STL file generated by RustMath                                          ";
    file.write_all(&header[..80])?;

    // Write number of triangles (4 bytes, little-endian)
    let num_triangles = mesh.faces.len() as u32;
    file.write_all(&num_triangles.to_le_bytes())?;

    // Write each triangle
    for (face_idx, face) in mesh.faces.iter().enumerate() {
        // Get vertices
        let v0 = &mesh.vertices[face[0]];
        let v1 = &mesh.vertices[face[1]];
        let v2 = &mesh.vertices[face[2]];

        // Compute face normal from cross product
        let edge1 = Vector3D::new(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
        let edge2 = Vector3D::new(v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);
        let normal = edge1.cross(&edge2).normalize();

        // Write normal (3 floats)
        file.write_all(&(normal.x as f32).to_le_bytes())?;
        file.write_all(&(normal.y as f32).to_le_bytes())?;
        file.write_all(&(normal.z as f32).to_le_bytes())?;

        // Write vertex 1
        file.write_all(&(v0.x as f32).to_le_bytes())?;
        file.write_all(&(v0.y as f32).to_le_bytes())?;
        file.write_all(&(v0.z as f32).to_le_bytes())?;

        // Write vertex 2
        file.write_all(&(v1.x as f32).to_le_bytes())?;
        file.write_all(&(v1.y as f32).to_le_bytes())?;
        file.write_all(&(v1.z as f32).to_le_bytes())?;

        // Write vertex 3
        file.write_all(&(v2.x as f32).to_le_bytes())?;
        file.write_all(&(v2.y as f32).to_le_bytes())?;
        file.write_all(&(v2.z as f32).to_le_bytes())?;

        // Write attribute byte count (2 bytes, usually 0)
        file.write_all(&[0u8, 0u8])?;
    }

    Ok(())
}

/// Export a Graphics3d object to STL format
///
/// This will combine all meshes in the Graphics3d object into a single STL file.
///
/// # Arguments
/// * `graphics` - The Graphics3d object to export
/// * `path` - Path to the output file
pub fn export_graphics_stl<P: AsRef<Path>>(graphics: &Graphics3d, path: P) -> Result<()> {
    let mut file = File::create(path)?;

    // Count total number of faces
    let total_faces: usize = graphics.objects.iter().map(|m| m.to_mesh().map(|mesh| mesh.faces.len()).unwrap_or(0)).sum();

    // Write 80-byte header
    let header = b"Binary STL file generated by RustMath                                          ";
    file.write_all(&header[..80])?;

    // Write number of triangles
    file.write_all(&(total_faces as u32).to_le_bytes())?;

    // Write each mesh
    for primitive in &graphics.objects {
        let mesh = primitive.to_mesh()?;
        for (_face_idx, face) in mesh.faces.iter().enumerate() {
            let v0 = &mesh.vertices[face[0]];
            let v1 = &mesh.vertices[face[1]];
            let v2 = &mesh.vertices[face[2]];

            // Calculate face normal
            let edge1 = Vector3D::new(v1.x - v0.x, v1.y - v0.y, v1.z - v0.z);
            let edge2 = Vector3D::new(v2.x - v0.x, v2.y - v0.y, v2.z - v0.z);
            let normal = edge1.cross(&edge2).normalize();

            // Write normal
            file.write_all(&(normal.x as f32).to_le_bytes())?;
            file.write_all(&(normal.y as f32).to_le_bytes())?;
            file.write_all(&(normal.z as f32).to_le_bytes())?;

            // Write vertices
            file.write_all(&(v0.x as f32).to_le_bytes())?;
            file.write_all(&(v0.y as f32).to_le_bytes())?;
            file.write_all(&(v0.z as f32).to_le_bytes())?;

            file.write_all(&(v1.x as f32).to_le_bytes())?;
            file.write_all(&(v1.y as f32).to_le_bytes())?;
            file.write_all(&(v1.z as f32).to_le_bytes())?;

            file.write_all(&(v2.x as f32).to_le_bytes())?;
            file.write_all(&(v2.y as f32).to_le_bytes())?;
            file.write_all(&(v2.z as f32).to_le_bytes())?;

            // Attribute byte count
            file.write_all(&[0u8, 0u8])?;
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::base::Point3D;

    #[test]
    fn test_export_obj_simple() {
        let vertices = vec![
            Point3D::new(0.0, 0.0, 0.0),
            Point3D::new(1.0, 0.0, 0.0),
            Point3D::new(0.0, 1.0, 0.0),
        ];
        let faces = vec![[0, 1, 2]];
        let mesh = IndexFaceSet::new(vertices, faces);

        let temp_path = "/tmp/test_export.obj";
        let result = export_obj(&mesh, temp_path);
        assert!(result.is_ok());

        // Check that file was created
        assert!(std::path::Path::new(temp_path).exists());
    }

    #[test]
    fn test_export_stl_simple() {
        let vertices = vec![
            Point3D::new(0.0, 0.0, 0.0),
            Point3D::new(1.0, 0.0, 0.0),
            Point3D::new(0.0, 1.0, 0.0),
        ];
        let faces = vec![[0, 1, 2]];
        let mesh = IndexFaceSet::new(vertices, faces);

        let temp_path = "/tmp/test_export.stl";
        let result = export_stl(&mesh, temp_path);
        assert!(result.is_ok());

        // Check that file was created and has correct size
        // Header (80) + count (4) + 1 triangle (50) = 134 bytes
        assert!(std::path::Path::new(temp_path).exists());
        let metadata = std::fs::metadata(temp_path).unwrap();
        assert_eq!(metadata.len(), 134);
    }

    #[test]
    fn test_export_graphics_obj() {
        let vertices = vec![
            Point3D::new(0.0, 0.0, 0.0),
            Point3D::new(1.0, 0.0, 0.0),
            Point3D::new(0.0, 1.0, 0.0),
        ];
        let faces = vec![[0, 1, 2]];
        let mesh = IndexFaceSet::new(vertices, faces);

        let mut graphics = Graphics3d::new();
        graphics.add_mesh(mesh);

        let temp_path = "/tmp/test_graphics.obj";
        let result = export_graphics_obj(&graphics, temp_path);
        assert!(result.is_ok());
    }

    #[test]
    fn test_export_graphics_stl() {
        let vertices = vec![
            Point3D::new(0.0, 0.0, 0.0),
            Point3D::new(1.0, 0.0, 0.0),
            Point3D::new(0.0, 1.0, 0.0),
        ];
        let faces = vec![[0, 1, 2]];
        let mesh = IndexFaceSet::new(vertices, faces);

        let mut graphics = Graphics3d::new();
        graphics.add_mesh(mesh);

        let temp_path = "/tmp/test_graphics.stl";
        let result = export_graphics_stl(&graphics, temp_path);
        assert!(result.is_ok());
    }
}
