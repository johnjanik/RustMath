//! LibGAP Mixin - Additional group properties and methods
//!
//! This module provides a mixin trait that adds extensive group-theoretic
//! functionality to groups. In SageMath, this provides access to GAP methods.
//! Here we provide pure Rust implementations.
//!
//! # Overview
//!
//! The `GroupMixinLibGAP` trait provides methods for:
//! - Testing group properties (abelian, nilpotent, solvable, simple, perfect)
//! - Computing conjugacy classes and character tables
//! - Finding subgroups, centralizers, normalizers
//! - Analyzing group structure
//!
//! # Example
//!
//! ```
//! use rustmath_groups::libgap_mixin::GroupMixinLibGAP;
//! ```

use std::collections::{HashMap, HashSet};
use crate::group_traits::{Group, GroupElement, FiniteGroupTrait};

/// Mixin trait providing LibGAP-style group methods
///
/// This trait extends basic group functionality with advanced
/// group-theoretic operations and property tests.
pub trait GroupMixinLibGAP: Group + FiniteGroupTrait {
    /// Test if the group is abelian (commutative)
    ///
    /// A group G is abelian if gh = hg for all g, h in G.
    fn is_abelian_libgap(&self) -> bool {
        let elements = self.elements();
        if elements.len() > 100 {
            // For large groups, just check generators
            return self.is_abelian();
        }

        for g in &elements {
            for h in &elements {
                if g.op(h) != h.op(g) {
                    return false;
                }
            }
        }
        true
    }

    /// Test if the group is cyclic
    ///
    /// A group is cyclic if it can be generated by a single element.
    fn is_cyclic(&self) -> bool {
        let elements = self.elements();
        let order = elements.len();

        for g in &elements {
            let mut generated = HashSet::new();
            let mut current = Self::Element::identity();

            for _ in 0..order {
                generated.insert(current.clone());
                current = current.op(g);
            }

            if generated.len() == order {
                return true;
            }
        }
        false
    }

    /// Test if the group is nilpotent
    ///
    /// A group is nilpotent if its lower central series reaches the trivial group.
    fn is_nilpotent(&self) -> bool {
        if self.is_abelian() {
            return true; // Abelian groups are nilpotent
        }

        let elements = self.elements();
        if elements.len() > 1000 {
            // For large groups, use heuristic
            return false;
        }

        // Compute lower central series
        let mut current_series = elements.clone();
        let id = Self::Element::identity();

        for _ in 0..elements.len() {
            let mut next_series = HashSet::new();

            // Compute commutators [G, current_series]
            for g in &elements {
                for h in &current_series {
                    next_series.insert(g.commutator(h));
                }
            }

            if next_series.len() == 1 && next_series.contains(&id) {
                return true; // Reached trivial group
            }

            if next_series.len() == current_series.len() {
                return false; // Series stabilized but not at identity
            }

            current_series = next_series.into_iter().collect();
        }

        false
    }

    /// Test if the group is solvable
    ///
    /// A group is solvable if its derived series reaches the trivial group.
    fn is_solvable(&self) -> bool {
        if self.is_abelian() {
            return true; // Abelian groups are solvable
        }

        let elements = self.elements();
        if elements.len() > 1000 {
            // For large groups, use heuristic
            return false;
        }

        // Compute derived series
        let mut current_series = elements.clone();
        let id = Self::Element::identity();

        for _ in 0..elements.len() {
            let mut next_series = HashSet::new();

            // Compute commutator subgroup [current, current]
            for g in &current_series {
                for h in &current_series {
                    next_series.insert(g.commutator(h));
                }
            }

            if next_series.len() == 1 && next_series.contains(&id) {
                return true; // Reached trivial group
            }

            if next_series.len() == current_series.len() {
                return false; // Series stabilized
            }

            current_series = next_series.into_iter().collect();
        }

        false
    }

    /// Test if the group is simple
    ///
    /// A group is simple if it has no nontrivial normal subgroups.
    fn is_simple(&self) -> bool {
        let order = self.finite_order();
        if order <= 2 {
            return order == 2; // Only Z/2Z is simple among groups of order ≤ 2
        }

        // Check for nontrivial normal subgroups
        // A subgroup is normal if it's closed under conjugation
        let elements = self.elements();

        // Try all possible subgroup sizes (divisors of group order)
        for size in 2..order {
            if order % size != 0 {
                continue;
            }

            // Check if any subset of this size forms a normal subgroup
            // For small groups, this is feasible; for large groups, we'd need better algorithms
            if size <= 20 && elements.len() <= 100 {
                if self.has_normal_subgroup_of_size(size) {
                    return false;
                }
            }
        }

        true
    }

    /// Test if the group is perfect
    ///
    /// A group is perfect if it equals its commutator subgroup.
    fn is_perfect(&self) -> bool {
        let elements = self.elements();
        let mut commutators = HashSet::new();

        // Compute all commutators
        for g in &elements {
            for h in &elements {
                commutators.insert(g.commutator(h));
            }
        }

        commutators.len() == elements.len()
    }

    /// Test if the group is supersolvable
    ///
    /// A group is supersolvable if it has a normal series with cyclic factors.
    fn is_supersolvable(&self) -> bool {
        // All abelian groups are supersolvable
        if self.is_abelian() {
            return true;
        }

        // For now, return false for non-abelian groups
        // A complete implementation would require computing composition series
        false
    }

    /// Test if the group is polycyclic
    ///
    /// A group is polycyclic if it has a subnormal series with cyclic factors.
    fn is_polycyclic(&self) -> bool {
        // All finite nilpotent groups are polycyclic
        if self.is_nilpotent() {
            return true;
        }

        false
    }

    /// Test if the group is a p-group
    ///
    /// A group is a p-group if its order is a power of a prime p.
    fn is_p_group(&self, p: usize) -> bool {
        let mut order = self.finite_order();

        if order == 1 {
            return true;
        }

        while order > 1 {
            if order % p != 0 {
                return false;
            }
            order /= p;
        }

        true
    }

    /// Get the cardinality (order) of the group
    fn cardinality(&self) -> usize {
        self.finite_order()
    }

    /// Get all elements as a list (alias for elements)
    fn list(&self) -> Vec<Self::Element> {
        self.elements()
    }

    /// Generate a random element from the group
    fn random_element_libgap(&self) -> Self::Element {
        let elements = self.elements();
        if elements.is_empty() {
            return Self::Element::identity();
        }

        use std::collections::hash_map::RandomState;
        use std::hash::{BuildHasher, Hash, Hasher};

        let s = RandomState::new();
        let mut hasher = s.build_hasher();
        std::time::SystemTime::now().hash(&mut hasher);
        let idx = (hasher.finish() as usize) % elements.len();

        elements[idx].clone()
    }

    /// Compute the exponent of the group
    ///
    /// The exponent is the LCM of all element orders.
    fn exponent_libgap(&self) -> usize {
        let elements = self.elements();
        let mut exp = 1;

        for elem in &elements {
            if let Some(ord) = elem.order() {
                exp = lcm(exp, ord);
            }
        }

        exp
    }

    /// Helper method to check for normal subgroups of a given size
    fn has_normal_subgroup_of_size(&self, _size: usize) -> bool {
        // Placeholder implementation
        // A full implementation would enumerate subgroups and test normality
        false
    }

    /// Compute the derived subgroup (commutator subgroup)
    ///
    /// The derived subgroup is generated by all commutators [g, h] = ghg⁻¹h⁻¹
    fn derived_subgroup(&self) -> Vec<Self::Element> {
        let elements = self.elements();
        let mut commutators = HashSet::new();
        let mut result = vec![Self::Element::identity()];

        // Generate all commutators
        for g in &elements {
            for h in &elements {
                let comm = g.commutator(h);
                if !commutators.contains(&comm) {
                    commutators.insert(comm.clone());
                    result.push(comm);
                }
            }
        }

        result
    }

    /// Compute the commutator subgroup (alias for derived_subgroup)
    fn commutator_subgroup(&self) -> Vec<Self::Element> {
        self.derived_subgroup()
    }

    /// Get the trivial character (all values = 1)
    fn trivial_character(&self) -> Vec<f64> {
        let n = self.conjugacy_classes().len();
        vec![1.0; n]
    }
}

/// Compute the least common multiple of two numbers
fn lcm(a: usize, b: usize) -> usize {
    if a == 0 || b == 0 {
        return 0;
    }
    (a * b) / gcd(a, b)
}

/// Compute the greatest common divisor of two numbers
fn gcd(mut a: usize, mut b: usize) -> usize {
    while b != 0 {
        let temp = b;
        b = a % b;
        a = temp;
    }
    a
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fmt;
    use std::cmp::Ordering;

    // Test element type - integers mod n
    #[derive(Clone, Debug, PartialEq, Eq, Hash)]
    struct ZModN {
        value: i64,
        modulus: i64,
    }

    impl ZModN {
        fn new(value: i64, modulus: i64) -> Self {
            ZModN {
                value: value.rem_euclid(modulus),
                modulus,
            }
        }
    }

    impl fmt::Display for ZModN {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.value)
        }
    }

    impl GroupElement for ZModN {
        fn identity() -> Self {
            ZModN::new(0, 1)
        }

        fn inverse(&self) -> Self {
            ZModN::new(-self.value, self.modulus)
        }

        fn op(&self, other: &Self) -> Self {
            ZModN::new(self.value + other.value, self.modulus)
        }
    }

    // Test group implementation
    #[derive(Clone, Debug)]
    struct CyclicGroup {
        order: usize,
    }

    impl fmt::Display for CyclicGroup {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "Z/{}", self.order)
        }
    }

    impl Group for CyclicGroup {
        type Element = ZModN;

        fn identity(&self) -> Self::Element {
            ZModN::new(0, self.order as i64)
        }

        fn is_abelian(&self) -> bool {
            true
        }

        fn is_finite(&self) -> bool {
            true
        }

        fn order(&self) -> Option<usize> {
            Some(self.order)
        }

        fn contains(&self, element: &Self::Element) -> bool {
            element.modulus == self.order as i64
        }
    }

    impl FiniteGroupTrait for CyclicGroup {
        fn elements(&self) -> Vec<Self::Element> {
            (0..self.order)
                .map(|i| ZModN::new(i as i64, self.order as i64))
                .collect()
        }

        fn finite_order(&self) -> usize {
            self.order
        }
    }

    impl GroupMixinLibGAP for CyclicGroup {}

    #[test]
    fn test_is_abelian() {
        let g = CyclicGroup { order: 5 };
        assert!(g.is_abelian_libgap());
    }

    #[test]
    fn test_is_cyclic() {
        let g = CyclicGroup { order: 7 };
        assert!(g.is_cyclic());
    }

    #[test]
    fn test_is_nilpotent() {
        let g = CyclicGroup { order: 6 };
        assert!(g.is_nilpotent());
    }

    #[test]
    fn test_is_solvable() {
        let g = CyclicGroup { order: 4 };
        assert!(g.is_solvable());
    }

    #[test]
    fn test_is_simple() {
        let g2 = CyclicGroup { order: 2 };
        assert!(g2.is_simple());

        let g4 = CyclicGroup { order: 4 };
        assert!(!g4.is_simple()); // Has subgroup of order 2
    }

    #[test]
    fn test_is_perfect() {
        let g = CyclicGroup { order: 5 };
        // Abelian groups are not perfect (unless trivial)
        assert!(!g.is_perfect());
    }

    #[test]
    fn test_is_supersolvable() {
        let g = CyclicGroup { order: 8 };
        assert!(g.is_supersolvable());
    }

    #[test]
    fn test_is_polycyclic() {
        let g = CyclicGroup { order: 9 };
        assert!(g.is_polycyclic());
    }

    #[test]
    fn test_is_p_group() {
        let g8 = CyclicGroup { order: 8 };
        assert!(g8.is_p_group(2));
        assert!(!g8.is_p_group(3));

        let g9 = CyclicGroup { order: 9 };
        assert!(g9.is_p_group(3));
        assert!(!g9.is_p_group(2));

        let g6 = CyclicGroup { order: 6 };
        assert!(!g6.is_p_group(2));
        assert!(!g6.is_p_group(3));
    }

    #[test]
    fn test_cardinality() {
        let g = CyclicGroup { order: 12 };
        assert_eq!(g.cardinality(), 12);
    }

    #[test]
    fn test_list() {
        let g = CyclicGroup { order: 4 };
        let elements = g.list();
        assert_eq!(elements.len(), 4);
    }

    #[test]
    fn test_random_element() {
        let g = CyclicGroup { order: 10 };
        let elem = g.random_element_libgap();
        assert!(g.contains(&elem));
    }

    #[test]
    fn test_exponent() {
        let g = CyclicGroup { order: 6 };
        let exp = g.exponent_libgap();
        assert_eq!(exp, 6);
    }

    #[test]
    fn test_derived_subgroup() {
        let g = CyclicGroup { order: 5 };
        let derived = g.derived_subgroup();
        // For abelian groups, derived subgroup is trivial
        assert_eq!(derived.len(), 1);
        assert!(derived[0].is_identity());
    }

    #[test]
    fn test_commutator_subgroup() {
        let g = CyclicGroup { order: 7 };
        let comm = g.commutator_subgroup();
        assert_eq!(comm.len(), 1);
    }

    #[test]
    fn test_trivial_character() {
        let g = CyclicGroup { order: 3 };
        let chi = g.trivial_character();
        // Z/3Z has 3 conjugacy classes (all singletons)
        assert_eq!(chi.len(), 3);
        assert!(chi.iter().all(|&x| x == 1.0));
    }

    #[test]
    fn test_gcd() {
        assert_eq!(gcd(12, 8), 4);
        assert_eq!(gcd(7, 5), 1);
        assert_eq!(gcd(100, 50), 50);
    }

    #[test]
    fn test_lcm() {
        assert_eq!(lcm(12, 8), 24);
        assert_eq!(lcm(7, 5), 35);
        assert_eq!(lcm(4, 6), 12);
    }
}
