//! Cactus Groups
//!
//! This module implements the n-fruit cactus group J_n, which is generated by
//! elements s_{pq} indexed by pairs 1 ≤ p < q ≤ n satisfying specific relations.
//!
//! The cactus group has important connections to symmetric groups, Coxeter groups,
//! and has applications in algebraic topology and representation theory.
//!
//! # Mathematical Structure
//!
//! The cactus group J_n has generators s_{pq} for 1 ≤ p < q ≤ n with relations:
//! 1. Each generator has order 2: s_{pq}² = 1
//! 2. Generators with disjoint intervals commute
//! 3. Nested interval relation: when [k,l] ⊆ [p,q],
//!    s_{pq}s_{kl} = s_{p+q-l,p+q-k}s_{pq}
//!
//! # Examples
//!
//! ```
//! use rustmath_groups::cactus_group::CactusGroup;
//!
//! // Create the cactus group on 3 fruits
//! let j3 = CactusGroup::new(3);
//! assert_eq!(j3.num_fruits(), 3);
//!
//! // Get a generator
//! let s12 = j3.gen(1, 2).unwrap();
//! ```

use std::collections::HashMap;
use std::fmt;
use std::ops::Mul;

use rustmath_combinatorics::Permutation;
use crate::group_traits::Group;
use crate::kernel_subgroup::KernelSubgroup;

/// A pair representing an interval [p, q]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Interval {
    pub p: usize,
    pub q: usize,
}

impl Interval {
    /// Create a new interval
    pub fn new(p: usize, q: usize) -> Self {
        assert!(p < q, "Interval requires p < q");
        Self { p, q }
    }

    /// Check if this interval is disjoint from another
    pub fn is_disjoint(&self, other: &Interval) -> bool {
        self.q < other.p || other.q < self.p
    }

    /// Check if this interval contains another
    pub fn contains(&self, other: &Interval) -> bool {
        self.p <= other.p && other.q <= self.q
    }

    /// Reflect an interval with respect to a base interval [p, q]
    /// Returns the interval [p+q-l, p+q-k] for interval [k, l]
    pub fn reflect(&self, base: &Interval) -> Interval {
        Interval {
            p: base.p + base.q - self.q,
            q: base.p + base.q - self.p,
        }
    }
}

impl fmt::Display for Interval {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "[{},{}]", self.p, self.q)
    }
}

/// The n-fruit cactus group J_n
///
/// The cactus group on n fruits is generated by elements s_{pq} for 1 ≤ p < q ≤ n.
#[derive(Debug, Clone)]
pub struct CactusGroup {
    /// Number of fruits
    n: usize,
    /// Cache of generators
    generators: Vec<Interval>,
}

impl CactusGroup {
    /// Create a new cactus group on n fruits
    ///
    /// # Arguments
    ///
    /// * `n` - Number of fruits (must be ≥ 1)
    pub fn new(n: usize) -> Self {
        assert!(n >= 1, "Need at least 1 fruit");

        // Generate all intervals [p, q] with 1 ≤ p < q ≤ n
        let mut generators = Vec::new();
        for p in 1..=n {
            for q in (p + 1)..=n {
                generators.push(Interval::new(p, q));
            }
        }

        Self { n, generators }
    }

    /// Returns the number of fruits
    pub fn num_fruits(&self) -> usize {
        self.n
    }

    /// Returns the number of generators
    pub fn num_generators(&self) -> usize {
        self.generators.len()
    }

    /// Returns all generators
    pub fn all_generators(&self) -> &[Interval] {
        &self.generators
    }

    /// Get the generator s_{pq}
    ///
    /// # Arguments
    ///
    /// * `p` - First index (1 ≤ p < q ≤ n)
    /// * `q` - Second index (1 ≤ p < q ≤ n)
    pub fn gen(&self, p: usize, q: usize) -> Option<CactusGroupElement> {
        if p >= q || p < 1 || q > self.n {
            return None;
        }

        let interval = Interval::new(p, q);
        Some(CactusGroupElement {
            parent: self.clone(),
            word: vec![interval],
        })
    }

    /// Returns the identity element
    pub fn identity(&self) -> CactusGroupElement {
        CactusGroupElement {
            parent: self.clone(),
            word: Vec::new(),
        }
    }

    /// Check if two intervals satisfy the commuting relation
    fn do_commute(&self, int1: &Interval, int2: &Interval) -> bool {
        int1.is_disjoint(int2)
    }

    /// Check if two intervals satisfy the nested relation
    fn is_nested(&self, outer: &Interval, inner: &Interval) -> bool {
        outer.contains(inner) && outer != inner
    }
}

impl fmt::Display for CactusGroup {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Cactus group J_{}", self.n)
    }
}

impl Group for CactusGroup {
    type Element = CactusGroupElement;

    fn identity(&self) -> Self::Element {
        CactusGroupElement {
            parent: self.clone(),
            word: Vec::new(),
        }
    }

    fn is_finite(&self) -> bool {
        // Cactus groups are finite
        true
    }

    fn order(&self) -> Option<usize> {
        // Cactus group J_n has order (2n-1)!!
        let mut result = 1;
        let mut k = 1;
        while k < 2 * self.n {
            result *= k;
            k += 2;
        }
        Some(result)
    }

    fn contains(&self, element: &Self::Element) -> bool {
        // Check if element belongs to this cactus group
        self.n == element.parent.n
    }
}

/// An element of a cactus group
///
/// Elements are represented as words in the generators s_{pq}.
#[derive(Debug, Clone)]
pub struct CactusGroupElement {
    parent: CactusGroup,
    word: Vec<Interval>,
}

impl CactusGroupElement {
    /// Create a new element from a word
    pub fn new(parent: CactusGroup, word: Vec<Interval>) -> Self {
        Self { parent, word }.normalize()
    }

    /// Returns a reference to the parent group
    pub fn parent(&self) -> &CactusGroup {
        &self.parent
    }

    /// Returns a reference to the word representation
    pub fn word(&self) -> &[Interval] {
        &self.word
    }

    /// Check if this is the identity element
    pub fn is_identity(&self) -> bool {
        self.word.is_empty()
    }

    /// Returns the length of the word
    pub fn length(&self) -> usize {
        self.word.len()
    }

    /// Multiply with another element
    pub fn multiply(&self, other: &Self) -> Self {
        let mut new_word = self.word.clone();
        new_word.extend(other.word.iter().cloned());
        Self {
            parent: self.parent.clone(),
            word: new_word,
        }
        .normalize()
    }

    /// Compute the inverse
    ///
    /// Since all generators have order 2, the inverse is just the reversed word.
    pub fn inverse(&self) -> Self {
        Self {
            parent: self.parent.clone(),
            word: self.word.iter().rev().cloned().collect(),
        }
    }

    /// Raise to a power
    pub fn pow(&self, n: i32) -> Self {
        if n == 0 {
            return self.parent.identity();
        }

        // Since all generators have order 2, we only need to handle even/odd powers
        if n % 2 == 0 {
            self.parent.identity()
        } else if n > 0 {
            self.clone()
        } else {
            self.inverse()
        }
    }

    /// Normalize the word using cactus group relations
    fn normalize(mut self) -> Self {
        // Apply relations to simplify the word
        loop {
            let mut changed = false;

            // 1. Cancel consecutive identical generators (s_{pq}^2 = 1)
            let mut i = 0;
            while i + 1 < self.word.len() {
                if self.word[i] == self.word[i + 1] {
                    self.word.remove(i);
                    self.word.remove(i);
                    changed = true;
                    if i > 0 {
                        i -= 1;
                    }
                } else {
                    i += 1;
                }
            }

            // 2. Commute disjoint generators (bubble sort style)
            for i in 0..(self.word.len().saturating_sub(1)) {
                if self.parent.do_commute(&self.word[i], &self.word[i + 1])
                    && self.word[i] > self.word[i + 1]
                {
                    self.word.swap(i, i + 1);
                    changed = true;
                }
            }

            // 3. Apply nested relation
            // s_{pq}s_{kl} = s_{p+q-l,p+q-k}s_{pq} when [k,l] ⊆ [p,q]
            for i in 0..(self.word.len().saturating_sub(1)) {
                if self.parent.is_nested(&self.word[i], &self.word[i + 1]) {
                    let reflected = self.word[i + 1].reflect(&self.word[i]);
                    self.word[i + 1] = reflected;
                    changed = true;
                }
            }

            if !changed {
                break;
            }
        }

        self
    }
}

impl fmt::Display for CactusGroupElement {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.word.is_empty() {
            return write!(f, "1");
        }

        for (i, interval) in self.word.iter().enumerate() {
            if i > 0 {
                write!(f, "*")?;
            }
            write!(f, "s[{},{}]", interval.p, interval.q)?;
        }
        Ok(())
    }
}

impl PartialEq for CactusGroupElement {
    fn eq(&self, other: &Self) -> bool {
        self.word == other.word
    }
}

impl Eq for CactusGroupElement {}

use std::hash::{Hash, Hasher};

impl Hash for CactusGroupElement {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // Hash only the word, as elements are compared within the same group context
        self.word.hash(state);
    }
}

use crate::group_traits::GroupElement;

impl std::ops::Mul for CactusGroupElement {
    type Output = Self;

    fn mul(self, other: Self) -> Self {
        self.op(&other)
    }
}

impl GroupElement for CactusGroupElement {
    fn identity() -> Self {
        // Create a minimal default group (1 fruit)
        // Note: Users should prefer calling group.identity() for the specific group
        let group = CactusGroup::new(1);
        CactusGroupElement {
            parent: group,
            word: Vec::new(),
        }
    }

    fn inverse(&self) -> Self {
        Self::inverse(self)
    }

    fn op(&self, other: &Self) -> Self {
        self.multiply(other)
    }
}

/// The pure cactus group PJ_n
///
/// The pure cactus group is the kernel of the natural homomorphism from J_n to S_n.
pub type PureCactusGroup = KernelSubgroup<CactusGroup, Permutation, fn(&CactusGroup) -> Permutation>;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_interval_creation() {
        let int = Interval::new(1, 3);
        assert_eq!(int.p, 1);
        assert_eq!(int.q, 3);
    }

    #[test]
    #[should_panic(expected = "Interval requires p < q")]
    fn test_invalid_interval() {
        Interval::new(3, 2);
    }

    #[test]
    fn test_interval_disjoint() {
        let int1 = Interval::new(1, 2);
        let int2 = Interval::new(3, 4);
        assert!(int1.is_disjoint(&int2));

        let int3 = Interval::new(1, 3);
        assert!(!int1.is_disjoint(&int3));
    }

    #[test]
    fn test_interval_contains() {
        let outer = Interval::new(1, 5);
        let inner = Interval::new(2, 4);
        assert!(outer.contains(&inner));
        assert!(!inner.contains(&outer));
    }

    #[test]
    fn test_interval_reflect() {
        let base = Interval::new(1, 5);
        let inner = Interval::new(2, 3);
        let reflected = inner.reflect(&base);
        assert_eq!(reflected.p, 3);
        assert_eq!(reflected.q, 4);
    }

    #[test]
    fn test_cactus_group_creation() {
        let j3 = CactusGroup::new(3);
        assert_eq!(j3.num_fruits(), 3);
        // For n=3, we have intervals [1,2], [1,3], [2,3]
        assert_eq!(j3.num_generators(), 3);
    }

    #[test]
    fn test_cactus_group_generators() {
        let j4 = CactusGroup::new(4);
        // For n=4, we have 6 intervals: [1,2], [1,3], [1,4], [2,3], [2,4], [3,4]
        assert_eq!(j4.num_generators(), 6);
    }

    #[test]
    fn test_cactus_element_creation() {
        let j3 = CactusGroup::new(3);
        let s12 = j3.gen(1, 2).unwrap();
        assert!(!s12.is_identity());
        assert_eq!(s12.length(), 1);
    }

    #[test]
    fn test_invalid_generator() {
        let j3 = CactusGroup::new(3);
        assert!(j3.gen(2, 2).is_none()); // p must be < q
        assert!(j3.gen(0, 2).is_none()); // p must be >= 1
        assert!(j3.gen(2, 5).is_none()); // q must be <= n
    }

    #[test]
    fn test_identity() {
        let j3 = CactusGroup::new(3);
        let id = j3.identity();
        assert!(id.is_identity());
        assert_eq!(id.length(), 0);
    }

    #[test]
    fn test_involution() {
        // All generators have order 2
        let j3 = CactusGroup::new(3);
        let s12 = j3.gen(1, 2).unwrap();
        let s12_squared = s12.multiply(&s12);
        assert!(s12_squared.is_identity());
    }

    #[test]
    fn test_inverse() {
        let j3 = CactusGroup::new(3);
        let s12 = j3.gen(1, 2).unwrap();
        let inv = s12.inverse();

        // Since generators have order 2, inverse equals itself
        assert_eq!(s12, inv);

        let prod = s12.multiply(&inv);
        assert!(prod.is_identity());
    }

    #[test]
    fn test_multiplication() {
        let j3 = CactusGroup::new(3);
        let s12 = j3.gen(1, 2).unwrap();
        let s23 = j3.gen(2, 3).unwrap();

        let prod = s12.multiply(&s23);
        // Product should not be identity (they don't commute or cancel)
        assert!(!prod.is_identity());
    }

    #[test]
    fn test_commuting_generators() {
        let j4 = CactusGroup::new(4);
        let s12 = j4.gen(1, 2).unwrap();
        let s34 = j4.gen(3, 4).unwrap();

        // These have disjoint intervals and should commute
        let ab = s12.multiply(&s34);
        let ba = s34.multiply(&s12);
        assert_eq!(ab, ba);
    }

    #[test]
    fn test_power() {
        let j3 = CactusGroup::new(3);
        let s12 = j3.gen(1, 2).unwrap();

        // s^0 = 1
        let s0 = s12.pow(0);
        assert!(s0.is_identity());

        // s^2 = 1 (order 2)
        let s2 = s12.pow(2);
        assert!(s2.is_identity());

        // s^1 = s
        let s1 = s12.pow(1);
        assert_eq!(s1, s12);

        // s^3 = s (since s^2 = 1)
        let s3 = s12.pow(3);
        assert_eq!(s3, s12);
    }

    #[test]
    fn test_display() {
        let j3 = CactusGroup::new(3);
        let display = format!("{}", j3);
        assert!(display.contains("Cactus group"));
        assert!(display.contains("3"));
    }

    #[test]
    fn test_element_display() {
        let j3 = CactusGroup::new(3);
        let s12 = j3.gen(1, 2).unwrap();
        let display = format!("{}", s12);
        assert!(display.contains("s"));
        assert!(display.contains("1"));
        assert!(display.contains("2"));
    }

    #[test]
    fn test_nested_relation() {
        let j5 = CactusGroup::new(5);
        let s15 = j5.gen(1, 5).unwrap();
        let s23 = j5.gen(2, 3).unwrap();

        // [2,3] is nested in [1,5]
        // Should apply nested relation during normalization
        let prod = s15.multiply(&s23);
        // The result should be normalized
        assert!(prod.length() <= 2);
    }

    #[test]
    #[should_panic(expected = "Need at least 1 fruit")]
    fn test_invalid_cactus_group() {
        CactusGroup::new(0);
    }
}
