//! Yang-Baxter Graphs
//!
//! This module provides construction of Yang-Baxter graphs from quantum groups.
//!
//! A Yang-Baxter graph is a labelled directed graph constructed by repeatedly
//! applying swap operators to a root vertex. The graph is generated by bubble-sorting
//! operations and has applications in quantum group theory and the Yang-Baxter equation.

use crate::digraph::DiGraph;
use std::collections::{HashMap, HashSet, VecDeque};
use std::fmt;
use std::hash::{Hash, Hasher};

/// Operator that swaps elements at positions i and i+1
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SwapOperator {
    position: usize,
}

impl SwapOperator {
    /// Create a new swap operator at the given position
    ///
    /// # Arguments
    ///
    /// * `position` - The position i where elements at i and i+1 will be swapped
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_graphs::generators::yang_baxter::SwapOperator;
    ///
    /// let op = SwapOperator::new(2);
    /// let result = op.apply(&vec![1, 2, 3, 4, 5]);
    /// assert_eq!(result, vec![1, 2, 4, 3, 5]);
    /// ```
    pub fn new(position: usize) -> Self {
        SwapOperator { position }
    }

    /// Get the position of this swap operator
    pub fn position(&self) -> usize {
        self.position
    }

    /// Apply the swap operation to a vector
    ///
    /// Swaps elements at positions `i` and `i+1` where `i` is the operator's position.
    ///
    /// # Arguments
    ///
    /// * `vec` - The vector to apply the swap to
    ///
    /// # Returns
    ///
    /// A new vector with the elements swapped
    pub fn apply<T: Clone>(&self, vec: &[T]) -> Vec<T> {
        if self.position + 1 >= vec.len() {
            return vec.to_vec();
        }

        let mut result = vec.to_vec();
        result.swap(self.position, self.position + 1);
        result
    }
}

impl Hash for SwapOperator {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.position.hash(state);
    }
}

impl fmt::Display for SwapOperator {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.position)
    }
}

/// Operator that swaps elements at positions i and i+1 only if element at i < element at i+1
///
/// This implements the "bubble-sort" constraint used in Yang-Baxter graphs.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SwapIncreasingOperator {
    position: usize,
}

impl SwapIncreasingOperator {
    /// Create a new swap-if-increasing operator at the given position
    ///
    /// # Arguments
    ///
    /// * `position` - The position i where elements will be conditionally swapped
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_graphs::generators::yang_baxter::SwapIncreasingOperator;
    ///
    /// let op = SwapIncreasingOperator::new(1);
    /// // Swaps because 2 < 3
    /// assert_eq!(op.apply(&vec![1, 2, 3, 4]), vec![1, 3, 2, 4]);
    /// // Doesn't swap because 3 > 2
    /// assert_eq!(op.apply(&vec![1, 3, 2, 4]), vec![1, 3, 2, 4]);
    /// ```
    pub fn new(position: usize) -> Self {
        SwapIncreasingOperator { position }
    }

    /// Get the position of this swap operator
    pub fn position(&self) -> usize {
        self.position
    }

    /// Apply the conditional swap operation to a vector
    ///
    /// Swaps elements at positions `i` and `i+1` only if `vec[i] < vec[i+1]`.
    ///
    /// # Arguments
    ///
    /// * `vec` - The vector to apply the swap to
    ///
    /// # Returns
    ///
    /// A new vector with the elements conditionally swapped
    pub fn apply<T: Clone + Ord>(&self, vec: &[T]) -> Vec<T> {
        if self.position + 1 >= vec.len() {
            return vec.to_vec();
        }

        if vec[self.position] < vec[self.position + 1] {
            let mut result = vec.to_vec();
            result.swap(self.position, self.position + 1);
            result
        } else {
            vec.to_vec()
        }
    }
}

impl Hash for SwapIncreasingOperator {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.position.hash(state);
    }
}

impl fmt::Display for SwapIncreasingOperator {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "swap-if-inc-{}", self.position)
    }
}

/// Construct a Yang-Baxter graph from a root vertex and swap-increasing operators
///
/// The Yang-Baxter graph is constructed by starting from a root vertex and
/// repeatedly applying swap-increasing operators to generate new vertices.
/// An edge is added from vertex u to vertex v labeled with operator i if
/// v is obtained by applying operator i to u.
///
/// # Arguments
///
/// * `root` - The starting vertex (root of the graph)
/// * `operators` - List of swap-increasing operators to apply
///
/// # Returns
///
/// A directed graph representing the Yang-Baxter graph
///
/// # Examples
///
/// ```
/// use rustmath_graphs::generators::yang_baxter::{yang_baxter_graph_generic, SwapIncreasingOperator};
///
/// let root = vec![0, 2, 1, 0];
/// let ops = vec![
///     SwapIncreasingOperator::new(0),
///     SwapIncreasingOperator::new(1),
///     SwapIncreasingOperator::new(2),
/// ];
///
/// let graph = yang_baxter_graph_generic(&root, &ops);
/// // The graph will contain all vertices reachable from root by bubble-sorting
/// ```
pub fn yang_baxter_graph_generic<T>(
    root: &[T],
    operators: &[SwapIncreasingOperator],
) -> DiGraph
where
    T: Clone + Ord + Hash + fmt::Debug,
{
    // First, collect all vertices and edges using BFS
    let mut vertex_to_id: HashMap<Vec<T>, usize> = HashMap::new();
    let mut edges: Vec<(usize, usize)> = Vec::new();
    let mut queue: VecDeque<Vec<T>> = VecDeque::new();

    // Add root vertex
    let root_vec = root.to_vec();
    vertex_to_id.insert(root_vec.clone(), 0);
    queue.push_back(root_vec);

    // BFS to generate all reachable vertices
    while let Some(u) = queue.pop_front() {
        let u_id = *vertex_to_id.get(&u).unwrap();

        for op in operators {
            let v = op.apply(&u);

            // Only add edge if v is different from u
            if v != u {
                let v_id = if let Some(&id) = vertex_to_id.get(&v) {
                    id
                } else {
                    let new_id = vertex_to_id.len();
                    vertex_to_id.insert(v.clone(), new_id);
                    queue.push_back(v.clone());
                    new_id
                };

                // Record edge from u to v
                edges.push((u_id, v_id));
            }
        }
    }

    // Now create the digraph with the correct number of vertices
    let num_vertices = vertex_to_id.len();
    let mut digraph = DiGraph::new(num_vertices);

    // Add all edges
    for (u, v) in edges {
        digraph.add_edge(u, v).ok();
    }

    digraph
}

/// Construct a Yang-Baxter graph from a partition
///
/// The Yang-Baxter graph defined by a partition `[p_1, ..., p_k]` is the
/// labelled directed graph with vertex set obtained by bubble-sorting
/// `(p_k-1, p_k-2, ..., 0, ..., p_1-1, p_1-2, ..., 0)`. There is an arrow
/// from u to v labelled by i if v is obtained by swapping the i-th and
/// (i+1)-th elements of u (when they are in increasing order).
///
/// # Arguments
///
/// * `partition` - A partition represented as a vector of positive integers
///
/// # Returns
///
/// A directed graph representing the Yang-Baxter graph of the partition
///
/// # Examples
///
/// ```
/// use rustmath_graphs::generators::yang_baxter::yang_baxter_graph_partition;
///
/// // Yang-Baxter graph for partition [3, 1]
/// let graph = yang_baxter_graph_partition(&[3, 1]);
/// assert_eq!(graph.num_vertices(), 3);
/// ```
pub fn yang_baxter_graph_partition(partition: &[usize]) -> DiGraph {
    if partition.is_empty() {
        return DiGraph::new(0);
    }

    // Sort partition in descending order
    let mut beta = partition.to_vec();
    beta.sort_by(|a, b| b.cmp(a));

    // Create root vertex by concatenating ascending sequences then reversing
    // For [3, 1], beta = [3, 1]
    // Concatenate: (0, 1, 2) + (0,) = (0, 1, 2, 0)
    // Reverse: (0, 2, 1, 0)
    let mut root = Vec::new();
    for &part in &beta {
        for j in 0..part {
            root.push(j);
        }
    }
    root.reverse();

    // Create swap-increasing operators
    let sum: usize = partition.iter().sum();
    let operators: Vec<SwapIncreasingOperator> = (0..sum.saturating_sub(1))
        .map(SwapIncreasingOperator::new)
        .collect();

    yang_baxter_graph_generic(&root, &operators)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_swap_operator() {
        let op = SwapOperator::new(1);
        assert_eq!(op.position(), 1);

        let vec = vec![1, 2, 3, 4];
        let result = op.apply(&vec);
        assert_eq!(result, vec![1, 3, 2, 4]);

        // Swap at position 0
        let op0 = SwapOperator::new(0);
        assert_eq!(op0.apply(&vec![1, 2, 3]), vec![2, 1, 3]);
    }

    #[test]
    fn test_swap_operator_edge_cases() {
        let op = SwapOperator::new(10);
        let vec = vec![1, 2, 3];
        let result = op.apply(&vec);
        assert_eq!(result, vec); // Out of bounds, returns unchanged
    }

    #[test]
    fn test_swap_increasing_operator() {
        let op = SwapIncreasingOperator::new(1);
        assert_eq!(op.position(), 1);

        // Should swap because 2 < 3
        let vec1 = vec![1, 2, 3, 4];
        let result1 = op.apply(&vec1);
        assert_eq!(result1, vec![1, 3, 2, 4]);

        // Should not swap because 3 > 2
        let vec2 = vec![1, 3, 2, 4];
        let result2 = op.apply(&vec2);
        assert_eq!(result2, vec![1, 3, 2, 4]);
    }

    #[test]
    fn test_swap_increasing_edge_cases() {
        let op = SwapIncreasingOperator::new(10);
        let vec = vec![1, 2, 3];
        let result = op.apply(&vec);
        assert_eq!(result, vec); // Out of bounds, returns unchanged
    }

    #[test]
    fn test_yang_baxter_graph_partition_3_1() {
        // Example from SageMath documentation
        // Partition [3, 1] should produce 3 vertices
        let graph = yang_baxter_graph_partition(&[3, 1]);
        assert_eq!(graph.num_vertices(), 3);
        assert_eq!(graph.num_edges(), 2);
    }

    #[test]
    fn test_yang_baxter_graph_partition_3_2() {
        // Partition [3, 2]
        let graph = yang_baxter_graph_partition(&[3, 2]);
        assert_eq!(graph.num_vertices(), 5);
    }

    #[test]
    fn test_yang_baxter_graph_partition_empty() {
        let graph = yang_baxter_graph_partition(&[]);
        assert_eq!(graph.num_vertices(), 0);
    }

    #[test]
    fn test_yang_baxter_graph_partition_single() {
        // Single part partition [n] should produce 1 vertex (already sorted)
        let graph = yang_baxter_graph_partition(&[3]);
        assert_eq!(graph.num_vertices(), 1);
    }

    #[test]
    fn test_yang_baxter_graph_generic() {
        let root = vec![0, 2, 1, 0];
        let ops = vec![
            SwapIncreasingOperator::new(0),
            SwapIncreasingOperator::new(1),
            SwapIncreasingOperator::new(2),
        ];

        let graph = yang_baxter_graph_generic(&root, &ops);
        assert_eq!(graph.num_vertices(), 3);
    }

    #[test]
    fn test_yang_baxter_graph_permutahedron() {
        // Using increasing sequence [1, 2, 3, 4] should generate
        // a permutahedron-like structure
        let root = vec![1, 2, 3, 4];
        let ops = vec![
            SwapIncreasingOperator::new(0),
            SwapIncreasingOperator::new(1),
            SwapIncreasingOperator::new(2),
        ];

        let graph = yang_baxter_graph_generic(&root, &ops);
        // Should generate all permutations reachable by adjacent swaps
        assert!(graph.num_vertices() > 1);
    }

    #[test]
    fn test_operators_display() {
        let swap_op = SwapOperator::new(3);
        assert_eq!(format!("{}", swap_op), "3");

        let swap_inc_op = SwapIncreasingOperator::new(2);
        assert_eq!(format!("{}", swap_inc_op), "swap-if-inc-2");
    }

    #[test]
    fn test_operators_equality() {
        let op1 = SwapOperator::new(2);
        let op2 = SwapOperator::new(2);
        let op3 = SwapOperator::new(3);

        assert_eq!(op1, op2);
        assert_ne!(op1, op3);

        let inc1 = SwapIncreasingOperator::new(1);
        let inc2 = SwapIncreasingOperator::new(1);
        let inc3 = SwapIncreasingOperator::new(2);

        assert_eq!(inc1, inc2);
        assert_ne!(inc1, inc3);
    }
}
