//! Cayley graphs
//!
//! A Cayley graph Cay(G, S) of a group G with generating set S is a graph
//! where vertices are group elements and edges connect g to gs for each s in S.
//!
//! Cayley graphs are always vertex-transitive and provide a geometric
//! representation of abstract groups.

use crate::graph::Graph;
use std::collections::{HashMap, HashSet, VecDeque};

/// Represents an element in a finitely presented group
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GroupElement {
    /// Identity element
    Identity,
    /// Generator with index
    Generator(usize),
    /// Inverse of generator
    Inverse(usize),
    /// Product of elements (stored in normal form)
    Product(Vec<i32>),  // Positive for generator, negative for inverse
}

impl GroupElement {
    /// Create identity element
    pub fn identity() -> Self {
        GroupElement::Identity
    }

    /// Create generator
    pub fn generator(i: usize) -> Self {
        GroupElement::Generator(i)
    }

    /// Multiply two group elements
    pub fn multiply(&self, other: &GroupElement) -> GroupElement {
        let mut word = self.to_word();
        word.extend(other.to_word());
        GroupElement::from_word(word)
    }

    /// Compute inverse
    pub fn inverse(&self) -> GroupElement {
        let word: Vec<i32> = self.to_word().iter().rev().map(|&x| -x).collect();
        GroupElement::from_word(word)
    }

    /// Convert to word representation
    fn to_word(&self) -> Vec<i32> {
        match self {
            GroupElement::Identity => vec![],
            GroupElement::Generator(i) => vec![(*i as i32) + 1],
            GroupElement::Inverse(i) => vec![-((*i as i32) + 1)],
            GroupElement::Product(w) => w.clone(),
        }
    }

    /// Create from word
    fn from_word(mut word: Vec<i32>) -> GroupElement {
        // Simplify word by removing consecutive inverses
        let mut i = 0;
        while i + 1 < word.len() {
            if word[i] == -word[i + 1] {
                word.remove(i);
                word.remove(i);
                if i > 0 {
                    i -= 1;
                }
            } else {
                i += 1;
            }
        }

        if word.is_empty() {
            GroupElement::Identity
        } else if word.len() == 1 {
            let g = word[0];
            if g > 0 {
                GroupElement::Generator((g - 1) as usize)
            } else {
                GroupElement::Inverse((-g - 1) as usize)
            }
        } else {
            GroupElement::Product(word)
        }
    }
}

/// A finitely generated group
#[derive(Debug, Clone)]
pub struct Group {
    /// Number of generators
    pub num_generators: usize,
    /// Relations (each relation is a word that equals identity)
    pub relations: Vec<Vec<i32>>,
}

impl Group {
    /// Create a free group on n generators
    pub fn free(n: usize) -> Self {
        Group {
            num_generators: n,
            relations: vec![],
        }
    }

    /// Create cyclic group Z/nZ
    pub fn cyclic(n: usize) -> Self {
        Group {
            num_generators: 1,
            relations: vec![vec![1; n]],  // g^n = e
        }
    }

    /// Create dihedral group D_n
    pub fn dihedral(n: usize) -> Self {
        Group {
            num_generators: 2,
            relations: vec![
                vec![1; n],           // r^n = e
                vec![2, 2],           // s^2 = e
                vec![2, 1, 2, -1],    // srs = r^-1
            ],
        }
    }

    /// Create symmetric group S_n (for small n)
    pub fn symmetric(n: usize) -> Self {
        if n <= 2 {
            return Group::cyclic(2);
        }

        // S_n generated by transpositions
        // For S_3: generators are (1 2) and (2 3)
        // Relations: (1 2)^2 = e, (2 3)^2 = e, ((1 2)(2 3))^3 = e
        Group {
            num_generators: n - 1,
            relations: vec![
                vec![1, 1],           // First generator squared
                vec![2, 2],           // Second generator squared
            ],
        }
    }

    /// Enumerate group elements up to a given word length
    pub fn enumerate_elements(&self, max_length: usize) -> Vec<GroupElement> {
        let mut elements = HashSet::new();
        elements.insert(GroupElement::Identity);

        let mut queue = VecDeque::new();
        queue.push_back(GroupElement::Identity);

        while let Some(elem) = queue.pop_front() {
            let word_len = match &elem {
                GroupElement::Identity => 0,
                GroupElement::Generator(_) | GroupElement::Inverse(_) => 1,
                GroupElement::Product(w) => w.len(),
            };

            if word_len >= max_length {
                continue;
            }

            // Multiply by each generator
            for i in 0..self.num_generators {
                let gen = GroupElement::generator(i);
                let new_elem = elem.multiply(&gen);

                if elements.insert(new_elem.clone()) {
                    queue.push_back(new_elem);
                }

                // Also try inverse
                let inv = GroupElement::Inverse(i);
                let new_elem_inv = elem.multiply(&inv);

                if elements.insert(new_elem_inv.clone()) {
                    queue.push_back(new_elem_inv);
                }
            }
        }

        elements.into_iter().collect()
    }
}

/// Cayley graph construction
pub struct CayleyGraph;

impl CayleyGraph {
    /// Build Cayley graph for a cyclic group Z/nZ
    pub fn cyclic(n: usize) -> Graph {
        let mut g = Graph::new(n);

        for i in 0..n {
            // Connect i to (i+1) mod n
            g.add_edge(i, (i + 1) % n).ok();
        }

        g
    }

    /// Build Cayley graph for dihedral group D_n
    pub fn dihedral(n: usize) -> Graph {
        // D_n has 2n elements
        // Vertices: 0..n-1 are rotations, n..2n-1 are reflections
        let mut g = Graph::new(2 * n);

        // Rotation edges (generator r)
        for i in 0..n {
            g.add_edge(i, (i + 1) % n).ok();
            g.add_edge(n + i, n + ((i + 1) % n)).ok();
        }

        // Reflection edges (generator s)
        for i in 0..n {
            g.add_edge(i, n + i).ok();
        }

        g
    }

    /// Build Cayley graph for free group on n generators (truncated to depth d)
    pub fn free_group(n: usize, depth: usize) -> Graph {
        let group = Group::free(n);
        let elements = group.enumerate_elements(depth);

        let num_vertices = elements.len();
        let mut g = Graph::new(num_vertices);

        // Create mapping from elements to indices
        let elem_to_idx: HashMap<GroupElement, usize> = elements
            .iter()
            .enumerate()
            .map(|(i, e)| (e.clone(), i))
            .collect();

        // Add edges
        for (i, elem) in elements.iter().enumerate() {
            for gen_idx in 0..n {
                let gen = GroupElement::generator(gen_idx);
                let product = elem.multiply(&gen);

                if let Some(&j) = elem_to_idx.get(&product) {
                    g.add_edge(i, j).ok();
                }

                // Also add edge for inverse
                let inv = GroupElement::Inverse(gen_idx);
                let product_inv = elem.multiply(&inv);

                if let Some(&j) = elem_to_idx.get(&product_inv) {
                    g.add_edge(i, j).ok();
                }
            }
        }

        g
    }

    /// Build Cayley graph from group and generating set
    pub fn from_group(group: &Group, max_elements: usize) -> Graph {
        let elements = group.enumerate_elements(5);
        let num_vertices = elements.len().min(max_elements);

        let mut g = Graph::new(num_vertices);

        let elem_to_idx: HashMap<GroupElement, usize> = elements
            .iter()
            .take(num_vertices)
            .enumerate()
            .map(|(i, e)| (e.clone(), i))
            .collect();

        for (i, elem) in elements.iter().take(num_vertices).enumerate() {
            for gen_idx in 0..group.num_generators {
                let gen = GroupElement::generator(gen_idx);
                let product = elem.multiply(&gen);

                if let Some(&j) = elem_to_idx.get(&product) {
                    g.add_edge(i, j).ok();
                }
            }
        }

        g
    }

    /// Build Cayley graph of permutation group
    pub fn permutation_group(n: usize, generators: Vec<Vec<usize>>) -> Graph {
        // Generate all permutations reachable from identity using generators
        let mut perms = HashSet::new();
        let identity: Vec<usize> = (0..n).collect();
        perms.insert(identity.clone());

        let mut queue = VecDeque::new();
        queue.push_back(identity);

        while let Some(perm) = queue.pop_front() {
            for gen in &generators {
                let new_perm = compose_permutations(&perm, gen);

                if perms.insert(new_perm.clone()) {
                    queue.push_back(new_perm);
                }
            }
        }

        // Build graph
        let perms_vec: Vec<Vec<usize>> = perms.into_iter().collect();
        let num_vertices = perms_vec.len();
        let mut g = Graph::new(num_vertices);

        let perm_to_idx: HashMap<Vec<usize>, usize> = perms_vec
            .iter()
            .enumerate()
            .map(|(i, p)| (p.clone(), i))
            .collect();

        for (i, perm) in perms_vec.iter().enumerate() {
            for gen in &generators {
                let product = compose_permutations(perm, gen);

                if let Some(&j) = perm_to_idx.get(&product) {
                    g.add_edge(i, j).ok();
                }
            }
        }

        g
    }

    /// Build hypercube graph Q_n (Cayley graph of Z_2^n)
    pub fn hypercube(n: usize) -> Graph {
        let num_vertices = 1 << n;  // 2^n vertices
        let mut g = Graph::new(num_vertices);

        for v in 0..num_vertices {
            for bit in 0..n {
                // Flip bit to get neighbor
                let neighbor = v ^ (1 << bit);
                if v < neighbor {
                    g.add_edge(v, neighbor).ok();
                }
            }
        }

        g
    }

    /// Build Petersen graph (Cayley graph of S5)
    /// Actually, Petersen is not a Cayley graph, but we provide a construction
    pub fn petersen() -> Graph {
        let mut g = Graph::new(10);

        // Outer pentagon
        for i in 0..5 {
            g.add_edge(i, (i + 1) % 5).ok();
        }

        // Inner pentagram
        for i in 0..5 {
            g.add_edge(5 + i, 5 + ((i + 2) % 5)).ok();
        }

        // Spokes
        for i in 0..5 {
            g.add_edge(i, 5 + i).ok();
        }

        g
    }
}

fn compose_permutations(p1: &[usize], p2: &[usize]) -> Vec<usize> {
    p1.iter().map(|&i| p2[i]).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_group_element_identity() {
        let e = GroupElement::identity();
        let g = GroupElement::generator(0);

        let product = e.multiply(&g);
        assert_eq!(product, g);
    }

    #[test]
    fn test_group_element_inverse() {
        let g = GroupElement::generator(0);
        let g_inv = g.inverse();

        let product = g.multiply(&g_inv);
        assert_eq!(product, GroupElement::Identity);
    }

    #[test]
    fn test_cyclic_group() {
        let g = Group::cyclic(4);
        assert_eq!(g.num_generators, 1);
        assert_eq!(g.relations.len(), 1);
    }

    #[test]
    fn test_dihedral_group() {
        let g = Group::dihedral(3);
        assert_eq!(g.num_generators, 2);
        // D3 has 3 relations
        assert_eq!(g.relations.len(), 3);
    }

    #[test]
    fn test_free_group() {
        let g = Group::free(2);
        assert_eq!(g.num_generators, 2);
        assert_eq!(g.relations.len(), 0);
    }

    #[test]
    fn test_enumerate_cyclic() {
        let g = Group::cyclic(3);
        let elems = g.enumerate_elements(3);
        // Should have 3 elements: e, g, g^2
        assert!(elems.len() >= 3);
    }

    #[test]
    fn test_cayley_cyclic() {
        let g = CayleyGraph::cyclic(5);
        assert_eq!(g.num_vertices(), 5);
        assert_eq!(g.num_edges(), 5); // Cycle
    }

    #[test]
    fn test_cayley_dihedral() {
        let g = CayleyGraph::dihedral(4);
        assert_eq!(g.num_vertices(), 8); // D4 has 8 elements
    }

    #[test]
    fn test_cayley_hypercube() {
        let g = CayleyGraph::hypercube(3);
        assert_eq!(g.num_vertices(), 8); // Q3 has 8 vertices
        assert_eq!(g.num_edges(), 12);   // Q3 has 12 edges
    }

    #[test]
    fn test_cayley_free_group() {
        let g = CayleyGraph::free_group(2, 2);
        assert!(g.num_vertices() > 0);
        // Free group on 2 generators grows exponentially
    }

    #[test]
    fn test_compose_permutations() {
        let p1 = vec![1, 0, 2];  // Swaps 0 and 1
        let p2 = vec![0, 2, 1];  // Swaps 1 and 2

        let result = compose_permutations(&p1, &p2);
        // p1 maps: 0->1, 1->0, 2->2
        // Applying p2 to the result: 0->1->2, 1->0->0, 2->2->1
        assert_eq!(result, vec![2, 0, 1]);
    }

    #[test]
    fn test_cayley_petersen() {
        let g = CayleyGraph::petersen();
        assert_eq!(g.num_vertices(), 10);
        assert_eq!(g.num_edges(), 15);

        // Petersen is 3-regular
        for v in 0..10 {
            assert_eq!(g.degree(v).unwrap(), 3);
        }
    }

    #[test]
    fn test_group_element_product() {
        let g1 = GroupElement::generator(0);
        let g2 = GroupElement::generator(1);

        let product = g1.multiply(&g2);
        match product {
            GroupElement::Product(w) => assert_eq!(w, vec![1, 2]),
            _ => panic!("Expected product"),
        }
    }

    #[test]
    fn test_cayley_from_group() {
        let group = Group::cyclic(4);
        let g = CayleyGraph::from_group(&group, 10);
        assert!(g.num_vertices() >= 4);
    }
}
