//! Ideals in function fields
//!
//! This module provides ideal structures for function fields, corresponding to
//! SageMath's `sage.rings.function_field.ideal`.
//!
//! # Mathematical Background
//!
//! In a function field K, ideals of the ring of integers (or a order) are
//! important for:
//! - Factorization of elements
//! - Class group computation
//! - Divisor theory
//! - Riemann-Roch theorem applications
//!
//! # Types of Ideals
//!
//! - **Finite ideals**: Generated by elements of bounded degree
//! - **Infinite ideals**: Related to places at infinity
//! - **Prime ideals**: Correspond to places of the function field
//! - **Fractional ideals**: Can have negative valuations
//!
//! # Key Types
//!
//! - `FunctionFieldIdeal`: Generic ideal in a function field
//! - `FunctionFieldIdealInfinite`: Ideal at infinity
//! - `IdealMonoid`: Monoid structure on ideals
//!
//! # Examples
//!
//! ```ignore
//! use rustmath_rings::function_field::ideal::*;
//!
//! // Create an ideal
//! let ideal = FunctionFieldIdeal::new("(x)".to_string());
//!
//! // Check if prime
//! if ideal.is_prime() {
//!     println!("Prime ideal of norm {}", ideal.norm());
//! }
//! ```

use rustmath_core::{Ring, Field};
use std::marker::PhantomData;
use std::fmt;
use std::collections::HashSet;

/// Generic ideal in a function field
///
/// Represents an ideal in the ring of integers of a function field.
/// This corresponds to SageMath's `FunctionFieldIdeal` class.
///
/// # Type Parameters
///
/// - `F`: The field type
///
/// # Mathematical Details
///
/// An ideal I in a function field has:
/// - Norm: N(I) = |O/I| where O is the ring of integers
//! - Valuation: v_P(I) for each place P
/// - Factorization: I = ∏ P^{v_P(I)}
#[derive(Clone, Debug)]
pub struct FunctionFieldIdeal<F: Field> {
    /// Generators of the ideal
    generators: Vec<String>,
    /// Norm of the ideal (if computed)
    norm: Option<usize>,
    /// Whether this is a prime ideal
    is_prime: bool,
    /// Field marker
    field_marker: PhantomData<F>,
}

impl<F: Field> FunctionFieldIdeal<F> {
    /// Create a new function field ideal
    ///
    /// # Arguments
    ///
    /// * `generator` - String representation of a generator
    ///
    /// # Returns
    ///
    /// A new FunctionFieldIdeal instance
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let ideal = FunctionFieldIdeal::new("(x)".to_string());
    /// ```
    pub fn new(generator: String) -> Self {
        FunctionFieldIdeal {
            generators: vec![generator],
            norm: None,
            is_prime: false,
            field_marker: PhantomData,
        }
    }

    /// Create from multiple generators
    ///
    /// # Arguments
    ///
    /// * `generators` - Vector of generator strings
    ///
    /// # Returns
    ///
    /// A new FunctionFieldIdeal
    pub fn from_generators(generators: Vec<String>) -> Self {
        FunctionFieldIdeal {
            generators,
            norm: None,
            is_prime: false,
            field_marker: PhantomData,
        }
    }

    /// Create a prime ideal
    ///
    /// # Arguments
    ///
    /// * `generator` - Generator of the prime ideal
    ///
    /// # Returns
    ///
    /// A prime ideal
    pub fn prime(generator: String) -> Self {
        FunctionFieldIdeal {
            generators: vec![generator],
            norm: None,
            is_prime: true,
            field_marker: PhantomData,
        }
    }

    /// Get the generators
    ///
    /// # Returns
    ///
    /// Reference to the generators
    pub fn generators(&self) -> &[String] {
        &self.generators
    }

    /// Check if this is a prime ideal
    ///
    /// # Returns
    ///
    /// True if the ideal is prime
    pub fn is_prime(&self) -> bool {
        self.is_prime
    }

    /// Mark as prime
    pub fn set_prime(&mut self, prime: bool) {
        self.is_prime = prime;
    }

    /// Get the norm
    ///
    /// # Returns
    ///
    /// The norm if computed
    pub fn norm(&self) -> Option<usize> {
        self.norm
    }

    /// Set the norm
    ///
    /// # Arguments
    ///
    /// * `n` - The norm value
    pub fn set_norm(&mut self, n: usize) {
        self.norm = Some(n);
    }

    /// Check if this is the unit ideal
    ///
    /// # Returns
    ///
    /// True if this is the unit ideal (1)
    pub fn is_unit(&self) -> bool {
        self.generators.len() == 1 && (self.generators[0] == "1" || self.generators[0] == "(1)")
    }

    /// Check if this is the zero ideal
    ///
    /// # Returns
    ///
    /// True if this is the zero ideal (0)
    pub fn is_zero(&self) -> bool {
        self.generators.len() == 1 && (self.generators[0] == "0" || self.generators[0] == "(0)")
    }

    /// Add a generator
    ///
    /// # Arguments
    ///
    /// * `gen` - New generator to add
    pub fn add_generator(&mut self, gen: String) {
        self.generators.push(gen);
    }
}

impl<F: Field> fmt::Display for FunctionFieldIdeal<F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if self.is_prime {
            write!(f, "Prime ideal ")?;
        } else {
            write!(f, "Ideal ")?;
        }
        write!(f, "(")?;
        for (i, gen) in self.generators.iter().enumerate() {
            if i > 0 {
                write!(f, ", ")?;
            }
            write!(f, "{}", gen)?;
        }
        write!(f, ")")
    }
}

/// Ideal at infinity in a function field
///
/// Represents an ideal corresponding to a place at infinity.
/// This corresponds to SageMath's `FunctionFieldIdealInfinite` class.
///
/// # Type Parameters
///
/// - `F`: The field type
///
/// # Mathematical Details
///
/// Infinite places are poles of the function field. For k(x), the place
/// at infinity corresponds to the valuation v_∞(f) = -deg(f).
#[derive(Clone, Debug)]
pub struct FunctionFieldIdealInfinite<F: Field> {
    /// Name of the place at infinity
    name: String,
    /// Degree of the place
    degree: usize,
    /// Field marker
    field_marker: PhantomData<F>,
}

impl<F: Field> FunctionFieldIdealInfinite<F> {
    /// Create a new infinite ideal
    ///
    /// # Arguments
    ///
    /// * `name` - Name of the place
    ///
    /// # Returns
    ///
    /// A new FunctionFieldIdealInfinite instance
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let inf_ideal = FunctionFieldIdealInfinite::new("∞".to_string());
    /// ```
    pub fn new(name: String) -> Self {
        FunctionFieldIdealInfinite {
            name,
            degree: 1,
            field_marker: PhantomData,
        }
    }

    /// Create with specified degree
    ///
    /// # Arguments
    ///
    /// * `name` - Name of the place
    /// * `degree` - Degree of the place
    ///
    /// # Returns
    ///
    /// A new infinite ideal with specified degree
    pub fn with_degree(name: String, degree: usize) -> Self {
        FunctionFieldIdealInfinite {
            name,
            degree,
            field_marker: PhantomData,
        }
    }

    /// Get the name
    ///
    /// # Returns
    ///
    /// Name of the place
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get the degree
    ///
    /// # Returns
    ///
    /// Degree of the place
    pub fn degree(&self) -> usize {
        self.degree
    }

    /// Check if this is the standard place at infinity
    ///
    /// # Returns
    ///
    /// True if this is the standard infinity place
    pub fn is_standard_infinity(&self) -> bool {
        self.name == "∞" || self.name == "inf"
    }
}

impl<F: Field> fmt::Display for FunctionFieldIdealInfinite<F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Ideal at {} (degree {})", self.name, self.degree)
    }
}

/// Monoid of ideals in a function field
///
/// Represents the multiplicative monoid structure on ideals.
/// This corresponds to SageMath's `IdealMonoid` class.
///
/// # Type Parameters
///
/// - `F`: The field type
///
/// # Mathematical Details
///
/// The ideal monoid has:
/// - Multiplication: (I)(J) = IJ
/// - Unit element: (1)
/// - Divisibility: I | J if J ⊆ I
#[derive(Clone, Debug)]
pub struct IdealMonoid<F: Field> {
    /// Function field name
    function_field: String,
    /// Known prime ideals
    prime_ideals: HashSet<String>,
    /// Field marker
    field_marker: PhantomData<F>,
}

impl<F: Field> IdealMonoid<F> {
    /// Create a new ideal monoid
    ///
    /// # Arguments
    ///
    /// * `function_field` - Name of the function field
    ///
    /// # Returns
    ///
    /// A new IdealMonoid instance
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let monoid = IdealMonoid::new("Q(x)".to_string());
    /// ```
    pub fn new(function_field: String) -> Self {
        IdealMonoid {
            function_field,
            prime_ideals: HashSet::new(),
            field_marker: PhantomData,
        }
    }

    /// Get the function field
    ///
    /// # Returns
    ///
    /// Name of the function field
    pub fn function_field(&self) -> &str {
        &self.function_field
    }

    /// Add a prime ideal
    ///
    /// # Arguments
    ///
    /// * `prime` - String representation of the prime
    pub fn add_prime(&mut self, prime: String) {
        self.prime_ideals.insert(prime);
    }

    /// Get the number of known primes
    ///
    /// # Returns
    ///
    /// Number of prime ideals
    pub fn num_primes(&self) -> usize {
        self.prime_ideals.len()
    }

    /// Check if a prime is known
    ///
    /// # Arguments
    ///
    /// * `prime` - String representation of the prime
    ///
    /// # Returns
    ///
    /// True if the prime is in the monoid
    pub fn has_prime(&self, prime: &str) -> bool {
        self.prime_ideals.contains(prime)
    }

    /// Get the unit ideal
    ///
    /// # Returns
    ///
    /// The unit ideal (1)
    pub fn unit_ideal(&self) -> FunctionFieldIdeal<F> {
        FunctionFieldIdeal::new("1".to_string())
    }
}

impl<F: Field> fmt::Display for IdealMonoid<F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Ideal monoid of {} ({} primes)",
            self.function_field,
            self.prime_ideals.len()
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;

    #[test]
    fn test_ideal_creation() {
        let ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::new("(x)".to_string());

        assert_eq!(ideal.generators().len(), 1);
        assert_eq!(ideal.generators()[0], "(x)");
        assert!(!ideal.is_prime());
    }

    #[test]
    fn test_prime_ideal() {
        let ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::prime("(x)".to_string());

        assert!(ideal.is_prime());
        assert_eq!(ideal.generators()[0], "(x)");
    }

    #[test]
    fn test_multiple_generators() {
        let ideal: FunctionFieldIdeal<Rational> =
            FunctionFieldIdeal::from_generators(vec!["x".to_string(), "y".to_string()]);

        assert_eq!(ideal.generators().len(), 2);
    }

    #[test]
    fn test_unit_ideal() {
        let ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::new("1".to_string());

        assert!(ideal.is_unit());
        assert!(!ideal.is_zero());
    }

    #[test]
    fn test_zero_ideal() {
        let ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::new("0".to_string());

        assert!(ideal.is_zero());
        assert!(!ideal.is_unit());
    }

    #[test]
    fn test_set_norm() {
        let mut ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::new("(x)".to_string());

        assert_eq!(ideal.norm(), None);
        ideal.set_norm(5);
        assert_eq!(ideal.norm(), Some(5));
    }

    #[test]
    fn test_add_generator() {
        let mut ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::new("x".to_string());

        ideal.add_generator("y".to_string());
        assert_eq!(ideal.generators().len(), 2);
    }

    #[test]
    fn test_infinite_ideal() {
        let inf: FunctionFieldIdealInfinite<Rational> =
            FunctionFieldIdealInfinite::new("∞".to_string());

        assert_eq!(inf.name(), "∞");
        assert_eq!(inf.degree(), 1);
        assert!(inf.is_standard_infinity());
    }

    #[test]
    fn test_infinite_ideal_with_degree() {
        let inf: FunctionFieldIdealInfinite<Rational> =
            FunctionFieldIdealInfinite::with_degree("P_∞".to_string(), 2);

        assert_eq!(inf.degree(), 2);
        assert!(!inf.is_standard_infinity());
    }

    #[test]
    fn test_ideal_monoid() {
        let mut monoid: IdealMonoid<Rational> = IdealMonoid::new("Q(x)".to_string());

        assert_eq!(monoid.function_field(), "Q(x)");
        assert_eq!(monoid.num_primes(), 0);

        monoid.add_prime("(x)".to_string());
        assert_eq!(monoid.num_primes(), 1);
        assert!(monoid.has_prime("(x)"));
    }

    #[test]
    fn test_unit_ideal_from_monoid() {
        let monoid: IdealMonoid<Rational> = IdealMonoid::new("Q(x)".to_string());
        let unit = monoid.unit_ideal();

        assert!(unit.is_unit());
    }

    #[test]
    fn test_ideal_display() {
        let ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::new("(x)".to_string());

        let display = format!("{}", ideal);
        assert!(display.contains("Ideal"));
        assert!(display.contains("(x)"));
    }

    #[test]
    fn test_prime_ideal_display() {
        let ideal: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::prime("(x)".to_string());

        let display = format!("{}", ideal);
        assert!(display.contains("Prime ideal"));
    }

    #[test]
    fn test_infinite_display() {
        let inf: FunctionFieldIdealInfinite<Rational> =
            FunctionFieldIdealInfinite::new("∞".to_string());

        let display = format!("{}", inf);
        assert!(display.contains("Ideal at"));
        assert!(display.contains("∞"));
    }

    #[test]
    fn test_monoid_display() {
        let monoid: IdealMonoid<Rational> = IdealMonoid::new("Q(x)".to_string());

        let display = format!("{}", monoid);
        assert!(display.contains("Ideal monoid"));
        assert!(display.contains("Q(x)"));
    }

    #[test]
    fn test_ideal_clone() {
        let ideal1: FunctionFieldIdeal<Rational> = FunctionFieldIdeal::prime("(x)".to_string());
        let ideal2 = ideal1.clone();

        assert_eq!(ideal1.is_prime(), ideal2.is_prime());
        assert_eq!(ideal1.generators(), ideal2.generators());
    }
}
