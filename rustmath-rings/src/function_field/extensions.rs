//! Function field extensions
//!
//! This module provides extension structures for function fields, corresponding to
//! SageMath's `sage.rings.function_field.extensions`.
//!
//! # Mathematical Background
//!
//! A function field extension L/K is an extension where L is a finite algebraic
//! extension of the function field K. There are two main types:
//!
//! - **Separable extensions**: Most common, where the minimal polynomial has distinct roots
//! - **Constant field extensions**: Where only the constant field is extended
//!
//! # Key Properties
//!
//! For a function field extension L/K:
//! - [L:K] is the degree of the extension
//! - The genus g_L relates to g_K via the Riemann-Hurwitz formula
//! - Places of K can ramify, split, or remain inert in L
//!
//! # Key Types
//!
//! - `FunctionFieldExtension`: Generic extension structure
//! - `ConstantFieldExtension`: Extensions of the constant field only
//!
//! # Examples
//!
//! ```ignore
//! use rustmath_rings::function_field::extensions::*;
//!
//! // Create a function field extension
//! let extension = FunctionFieldExtension::new("Q(x)".to_string(), "Q(x,y)".to_string(), 2);
//!
//! // Create a constant field extension
//! let const_ext = ConstantFieldExtension::new("Fq".to_string(), "Fq2".to_string());
//! ```

use rustmath_core::Field;
use std::marker::PhantomData;
use std::fmt;

/// Generic function field extension
///
/// Represents an extension L/K of function fields.
/// This corresponds to SageMath's `FunctionFieldExtension` class.
///
/// # Type Parameters
///
/// - `F`: The field type for the constant field
///
/// # Mathematical Details
///
/// The extension degree [L:K] determines how places split:
/// - Unramified: e_P = 1 (ramification index)
/// - Split completely: f_P = 1 (residue degree)
/// - Inert: f_P = [L:K]
#[derive(Clone, Debug)]
pub struct FunctionFieldExtension<F: Field> {
    /// Base function field K
    base_field: String,
    /// Extension field L
    extension_field: String,
    /// Degree of extension [L:K]
    degree: usize,
    /// Defining polynomial for the extension
    defining_polynomial: Option<String>,
    /// Field marker
    field_marker: PhantomData<F>,
}

impl<F: Field> FunctionFieldExtension<F> {
    /// Create a new function field extension
    ///
    /// # Arguments
    ///
    /// * `base_field` - The base field K
    /// * `extension_field` - The extension field L
    /// * `degree` - The degree [L:K]
    ///
    /// # Returns
    ///
    /// A new FunctionFieldExtension instance
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let ext = FunctionFieldExtension::new("Q(x)".to_string(), "Q(x,y)".to_string(), 2);
    /// assert_eq!(ext.degree(), 2);
    /// ```
    pub fn new(base_field: String, extension_field: String, degree: usize) -> Self {
        assert!(degree > 0, "Extension degree must be positive");
        FunctionFieldExtension {
            base_field,
            extension_field,
            degree,
            defining_polynomial: None,
            field_marker: PhantomData,
        }
    }

    /// Create with a defining polynomial
    ///
    /// # Arguments
    ///
    /// * `base_field` - The base field
    /// * `extension_field` - The extension field
    /// * `degree` - The degree
    /// * `poly` - Defining polynomial
    ///
    /// # Returns
    ///
    /// A new FunctionFieldExtension with defining polynomial
    pub fn with_polynomial(
        base_field: String,
        extension_field: String,
        degree: usize,
        poly: String,
    ) -> Self {
        FunctionFieldExtension {
            base_field,
            extension_field,
            degree,
            defining_polynomial: Some(poly),
            field_marker: PhantomData,
        }
    }

    /// Get the degree of the extension
    ///
    /// # Returns
    ///
    /// The degree [L:K]
    pub fn degree(&self) -> usize {
        self.degree
    }

    /// Get the base field
    ///
    /// # Returns
    ///
    /// Name of the base field
    pub fn base_field(&self) -> &str {
        &self.base_field
    }

    /// Get the extension field
    ///
    /// # Returns
    ///
    /// Name of the extension field
    pub fn extension_field(&self) -> &str {
        &self.extension_field
    }

    /// Get the defining polynomial
    ///
    /// # Returns
    ///
    /// The defining polynomial if set
    pub fn defining_polynomial(&self) -> Option<&String> {
        self.defining_polynomial.as_ref()
    }

    /// Check if the extension is trivial
    ///
    /// # Returns
    ///
    /// True if degree is 1 (trivial extension)
    pub fn is_trivial(&self) -> bool {
        self.degree == 1
    }

    /// Check if the extension is simple
    ///
    /// # Returns
    ///
    /// True if generated by a single element
    pub fn is_simple(&self) -> bool {
        self.defining_polynomial.is_some()
    }

    /// Compute relative genus using Riemann-Hurwitz
    ///
    /// # Arguments
    ///
    /// * `base_genus` - Genus of the base field
    ///
    /// # Returns
    ///
    /// Estimated genus of the extension field
    pub fn relative_genus(&self, base_genus: usize) -> usize {
        // Simplified Riemann-Hurwitz: 2g_L - 2 >= n(2g_K - 2)
        // For unramified extension: g_L = 1 + n(g_K - 1)
        if base_genus == 0 {
            0
        } else {
            1 + self.degree * (base_genus.saturating_sub(1))
        }
    }
}

impl<F: Field> fmt::Display for FunctionFieldExtension<F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "FunctionFieldExtension({}/{}, degree={})",
            self.extension_field, self.base_field, self.degree
        )
    }
}

/// Constant field extension
///
/// Represents an extension where only the constant field is extended.
/// This corresponds to SageMath's `ConstantFieldExtension` class.
///
/// # Type Parameters
///
/// - `F`: The constant field type
///
/// # Mathematical Details
///
/// For K = k(x) and L = l(x) where l/k is a field extension:
/// - The genus remains unchanged
/// - Places may split according to Galois theory
/// - This is always unramified
#[derive(Clone, Debug)]
pub struct ConstantFieldExtension<F: Field> {
    /// Base constant field k
    base_constant_field: String,
    /// Extended constant field l
    extension_constant_field: String,
    /// Degree [l:k]
    degree: usize,
    /// Field marker
    field_marker: PhantomData<F>,
}

impl<F: Field> ConstantFieldExtension<F> {
    /// Create a new constant field extension
    ///
    /// # Arguments
    ///
    /// * `base_constant` - Base constant field k
    /// * `extension_constant` - Extension constant field l
    ///
    /// # Returns
    ///
    /// A new ConstantFieldExtension instance
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let ext = ConstantFieldExtension::new("Fq".to_string(), "Fq2".to_string());
    /// ```
    pub fn new(base_constant: String, extension_constant: String) -> Self {
        // Infer degree from field names (simplified)
        let degree = infer_degree(&base_constant, &extension_constant);
        ConstantFieldExtension {
            base_constant_field: base_constant,
            extension_constant_field: extension_constant,
            degree,
            field_marker: PhantomData,
        }
    }

    /// Create with explicit degree
    ///
    /// # Arguments
    ///
    /// * `base_constant` - Base constant field
    /// * `extension_constant` - Extension constant field
    /// * `degree` - Extension degree
    ///
    /// # Returns
    ///
    /// A new ConstantFieldExtension with specified degree
    pub fn with_degree(base_constant: String, extension_constant: String, degree: usize) -> Self {
        ConstantFieldExtension {
            base_constant_field: base_constant,
            extension_constant_field: extension_constant,
            degree,
            field_marker: PhantomData,
        }
    }

    /// Get the degree
    ///
    /// # Returns
    ///
    /// Degree of the constant field extension
    pub fn degree(&self) -> usize {
        self.degree
    }

    /// Get the base constant field
    ///
    /// # Returns
    ///
    /// Name of the base constant field
    pub fn base_constant_field(&self) -> &str {
        &self.base_constant_field
    }

    /// Get the extension constant field
    ///
    /// # Returns
    ///
    /// Name of the extension constant field
    pub fn extension_constant_field(&self) -> &str {
        &self.extension_constant_field
    }

    /// Check if genus is preserved
    ///
    /// # Returns
    ///
    /// True (constant field extensions always preserve genus)
    pub fn preserves_genus(&self) -> bool {
        true
    }

    /// Check if unramified
    ///
    /// # Returns
    ///
    /// True (constant field extensions are always unramified)
    pub fn is_unramified(&self) -> bool {
        true
    }
}

impl<F: Field> fmt::Display for ConstantFieldExtension<F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ConstantFieldExtension({}/{}, degree={})",
            self.extension_constant_field, self.base_constant_field, self.degree
        )
    }
}

/// Infer degree from field names
fn infer_degree(base: &str, extension: &str) -> usize {
    // Simple heuristic: extract numbers from field names
    let base_num = extract_field_degree(base);
    let ext_num = extract_field_degree(extension);

    if ext_num > base_num && ext_num % base_num == 0 {
        (ext_num as f64).log(base_num as f64) as usize
    } else {
        1
    }
}

/// Extract field degree from name
fn extract_field_degree(name: &str) -> usize {
    // Parse "Fq", "Fq2", "F4", etc.
    if name.starts_with('F') || name.starts_with('f') {
        name[1..].chars()
            .filter(|c| c.is_numeric())
            .collect::<String>()
            .parse()
            .unwrap_or(2)
    } else {
        2
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;

    #[test]
    fn test_extension_creation() {
        let ext: FunctionFieldExtension<Rational> =
            FunctionFieldExtension::new("Q(x)".to_string(), "Q(x,y)".to_string(), 2);

        assert_eq!(ext.degree(), 2);
        assert_eq!(ext.base_field(), "Q(x)");
        assert_eq!(ext.extension_field(), "Q(x,y)");
        assert!(!ext.is_trivial());
    }

    #[test]
    fn test_trivial_extension() {
        let ext: FunctionFieldExtension<Rational> =
            FunctionFieldExtension::new("K".to_string(), "K".to_string(), 1);

        assert!(ext.is_trivial());
        assert_eq!(ext.degree(), 1);
    }

    #[test]
    fn test_extension_with_polynomial() {
        let ext: FunctionFieldExtension<Rational> = FunctionFieldExtension::with_polynomial(
            "Q(x)".to_string(),
            "Q(x,y)".to_string(),
            2,
            "y^2 - x".to_string(),
        );

        assert!(ext.is_simple());
        assert_eq!(ext.defining_polynomial(), Some(&"y^2 - x".to_string()));
    }

    #[test]
    fn test_relative_genus() {
        let ext: FunctionFieldExtension<Rational> =
            FunctionFieldExtension::new("K".to_string(), "L".to_string(), 2);

        assert_eq!(ext.relative_genus(0), 0);
        assert_eq!(ext.relative_genus(1), 1);
        assert_eq!(ext.relative_genus(2), 3); // 1 + 2*(2-1) = 3
    }

    #[test]
    fn test_constant_field_extension() {
        let ext: ConstantFieldExtension<Rational> =
            ConstantFieldExtension::new("Fq".to_string(), "Fq2".to_string());

        assert!(ext.preserves_genus());
        assert!(ext.is_unramified());
    }

    #[test]
    fn test_constant_extension_with_degree() {
        let ext: ConstantFieldExtension<Rational> =
            ConstantFieldExtension::with_degree("F2".to_string(), "F4".to_string(), 2);

        assert_eq!(ext.degree(), 2);
        assert_eq!(ext.base_constant_field(), "F2");
        assert_eq!(ext.extension_constant_field(), "F4");
    }

    #[test]
    fn test_infer_degree() {
        assert_eq!(infer_degree("F2", "F4"), 2);
        assert_eq!(infer_degree("F2", "F8"), 3);
        assert_eq!(infer_degree("F3", "F9"), 2);
    }

    #[test]
    fn test_extract_field_degree() {
        assert_eq!(extract_field_degree("F2"), 2);
        assert_eq!(extract_field_degree("F4"), 4);
        assert_eq!(extract_field_degree("F16"), 16);
        assert_eq!(extract_field_degree("Fq"), 2); // default
    }

    #[test]
    fn test_extension_display() {
        let ext: FunctionFieldExtension<Rational> =
            FunctionFieldExtension::new("K".to_string(), "L".to_string(), 3);

        let display = format!("{}", ext);
        assert!(display.contains("FunctionFieldExtension"));
        assert!(display.contains("degree=3"));
    }

    #[test]
    fn test_constant_extension_display() {
        let ext: ConstantFieldExtension<Rational> =
            ConstantFieldExtension::new("Fq".to_string(), "Fq2".to_string());

        let display = format!("{}", ext);
        assert!(display.contains("ConstantFieldExtension"));
    }

    #[test]
    fn test_extension_clone() {
        let ext1: FunctionFieldExtension<Rational> =
            FunctionFieldExtension::new("K".to_string(), "L".to_string(), 2);
        let ext2 = ext1.clone();

        assert_eq!(ext1.degree(), ext2.degree());
        assert_eq!(ext1.base_field(), ext2.base_field());
    }

    #[test]
    #[should_panic(expected = "Extension degree must be positive")]
    fn test_invalid_degree() {
        let _ext: FunctionFieldExtension<Rational> =
            FunctionFieldExtension::new("K".to_string(), "L".to_string(), 0);
    }
}
