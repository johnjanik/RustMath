//! Ideals in Rational Function Fields Module
//!
//! This module implements ideals in rational function fields k(x),
//! corresponding to SageMath's `sage.rings.function_field.ideal_rational` module.
//!
//! # Mathematical Overview
//!
//! In a rational function field k(x) = Frac(k[x]), ideals in the ring of
//! integers k[x] are particularly simple and well-understood.
//!
//! ## Principal Ideal Domain
//!
//! k[x] is a principal ideal domain (PID), meaning every ideal is generated
//! by a single element. For the function field k(x):
//!
//! - **Finite places**: Correspond to irreducible polynomials p(x) ∈ k[x]
//! - **Infinite place**: The unique place at infinity
//! - **Principal ideals**: All ideals are of the form (f(x)) for f ∈ k[x]
//!
//! ## Fractional Ideals
//!
//! Fractional ideals of k[x] are of the form:
//!
//! I = (f(x)/g(x)) · k[x]
//!
//! where f, g ∈ k[x]. The divisor group is isomorphic to the free abelian
//! group on irreducible polynomials plus the infinite place.
//!
//! # Implementation
//!
//! This module provides:
//!
//! - `FunctionFieldIdeal_rational`: Ideals in k[x]
//! - `FunctionFieldIdealInfinite_rational`: Ideal at infinity
//!
//! # Examples
//!
//! ```
//! use rustmath_rings::function_field::ideal_rational::FunctionFieldIdeal_rational;
//! use rustmath_rationals::Rational;
//!
//! let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x^2 + 1".to_string());
//! assert!(ideal.is_principal());
//! ```
//!
//! # References
//!
//! - SageMath: `sage.rings.function_field.ideal_rational`
//! - Rosen, M. (2002). "Number Theory in Function Fields"

use rustmath_core::Field;
use std::marker::PhantomData;

/// Ideal in a rational function field k(x)
///
/// Represents an ideal in k[x] or a fractional ideal in k(x).
///
/// # Type Parameters
///
/// * `F` - The constant field type
///
/// # Examples
///
/// ```
/// use rustmath_rings::function_field::ideal_rational::FunctionFieldIdeal_rational;
/// use rustmath_rationals::Rational;
///
/// let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
/// assert!(ideal.is_principal());
/// assert!(!ideal.is_zero());
/// ```
#[derive(Debug, Clone)]
pub struct FunctionFieldIdealRational<F: Field> {
    /// Generator polynomial (as string for simplicity)
    generator: String,
    /// Name of the ideal
    name: String,
    /// Whether this is a prime ideal
    is_prime_ideal: bool,
    /// Phantom data for field type
    _phantom: PhantomData<F>,
}

/// Type alias for snake_case compatibility
pub type FunctionFieldIdeal_rational<F> = FunctionFieldIdealRational<F>;

impl<F: Field> FunctionFieldIdeal_rational<F> {
    /// Create a new ideal
    pub fn new(name: String) -> Self {
        Self {
            generator: String::new(),
            name,
            is_prime_ideal: false,
            _phantom: PhantomData,
        }
    }

    /// Create a principal ideal generated by a polynomial
    pub fn principal(generator: String) -> Self {
        let name = format!("({})", generator);
        Self {
            name: name.clone(),
            generator: generator.clone(),
            is_prime_ideal: is_irreducible(&generator),
            _phantom: PhantomData,
        }
    }

    /// Create a prime ideal (irreducible polynomial)
    pub fn prime(irreducible: String) -> Self {
        Self {
            name: format!("({})", irreducible),
            generator: irreducible,
            is_prime_ideal: true,
            _phantom: PhantomData,
        }
    }

    /// Check if this is a principal ideal (always true for k[x])
    pub fn is_principal(&self) -> bool {
        true // k[x] is a PID
    }

    /// Check if this is a prime ideal
    pub fn is_prime(&self) -> bool {
        self.is_prime_ideal
    }

    /// Check if this is the unit ideal
    pub fn is_unit(&self) -> bool {
        self.generator == "1"
    }

    /// Check if this is the zero ideal
    pub fn is_zero(&self) -> bool {
        self.generator == "0" || self.generator.is_empty()
    }

    /// Get the generator
    pub fn generator(&self) -> &str {
        &self.generator
    }

    /// Get the name
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Get the degree of the generator
    pub fn degree(&self) -> usize {
        polynomial_degree(&self.generator)
    }

    /// Compute the norm (degree) of this ideal
    pub fn norm(&self) -> usize {
        if self.is_zero() {
            0
        } else {
            self.degree()
        }
    }

    /// Multiply two ideals
    ///
    /// In k[x], (f) * (g) = (f·g)
    pub fn multiply(&self, other: &Self) -> Self {
        let new_gen = if self.is_zero() || other.is_zero() {
            "0".to_string()
        } else if self.generator == "1" {
            other.generator.clone()
        } else if other.generator == "1" {
            self.generator.clone()
        } else {
            format!("({})({})", self.generator, other.generator)
        };

        Self::principal(new_gen)
    }

    /// Add two ideals
    ///
    /// In k[x], (f) + (g) = (gcd(f, g))
    pub fn add(&self, other: &Self) -> Self {
        if self.is_zero() {
            other.clone()
        } else if other.is_zero() {
            self.clone()
        } else {
            let gcd_gen = gcd_polynomial(&self.generator, &other.generator);
            Self::principal(gcd_gen)
        }
    }

    /// Compute intersection
    ///
    /// In k[x], (f) ∩ (g) = (lcm(f, g))
    pub fn intersect(&self, other: &Self) -> Self {
        if self.is_zero() || other.is_zero() {
            Self::principal("0".to_string())
        } else {
            let lcm_gen = lcm_polynomial(&self.generator, &other.generator);
            Self::principal(lcm_gen)
        }
    }

    /// Check if this ideal divides another
    ///
    /// (f) | (g) iff g ∈ (f) iff f | g
    pub fn divides(&self, other: &Self) -> bool {
        if self.is_zero() {
            other.is_zero()
        } else if self.is_unit() {
            true
        } else {
            // Would check if generator divides other's generator
            false
        }
    }

    /// Invert the ideal (for fractional ideals)
    pub fn invert(&self) -> Self {
        if self.is_zero() {
            panic!("Cannot invert zero ideal");
        }

        // Inverse of (f) is (1/f)
        let inv_gen = format!("1/({})", self.generator);
        Self {
            generator: inv_gen.clone(),
            name: format!("({})", inv_gen),
            is_prime_ideal: self.is_prime_ideal,
            _phantom: PhantomData,
        }
    }

    /// Check if well-defined
    pub fn is_well_defined(&self) -> bool {
        !self.name.is_empty()
    }
}

/// Ideal at infinity in a rational function field
///
/// Represents the unique infinite place in k(x).
///
/// # Examples
///
/// ```
/// use rustmath_rings::function_field::ideal_rational::FunctionFieldIdealInfinite_rational;
/// use rustmath_rationals::Rational;
///
/// let ideal_inf = FunctionFieldIdealInfinite_rational::<Rational>::new();
/// assert!(ideal_inf.is_infinite());
/// assert_eq!(ideal_inf.degree(), 1);
/// ```
#[derive(Debug, Clone)]
pub struct FunctionFieldIdealInfiniteRational<F: Field> {
    /// Phantom data for field type
    _phantom: PhantomData<F>,
}

/// Type alias for snake_case compatibility
pub type FunctionFieldIdealInfinite_rational<F> = FunctionFieldIdealInfiniteRational<F>;

impl<F: Field> FunctionFieldIdealInfinite_rational<F> {
    /// Create the infinite ideal
    pub fn new() -> Self {
        Self {
            _phantom: PhantomData,
        }
    }

    /// Check if infinite (always true)
    pub fn is_infinite(&self) -> bool {
        true
    }

    /// Get the degree (always 1 for k(x))
    pub fn degree(&self) -> usize {
        1
    }

    /// Get the valuation of a rational function at infinity
    ///
    /// For f/g, v_∞(f/g) = deg(g) - deg(f)
    pub fn valuation(&self, numerator: &str, denominator: &str) -> i32 {
        let deg_num = polynomial_degree(numerator) as i32;
        let deg_den = polynomial_degree(denominator) as i32;

        deg_den - deg_num
    }

    /// Get the name
    pub fn name(&self) -> String {
        "∞".to_string()
    }

    /// Check if a function has a pole at infinity
    pub fn has_pole(&self, numerator: &str, denominator: &str) -> bool {
        self.valuation(numerator, denominator) < 0
    }

    /// Check if a function has a zero at infinity
    pub fn has_zero(&self, numerator: &str, denominator: &str) -> bool {
        self.valuation(numerator, denominator) > 0
    }
}

impl<F: Field> Default for FunctionFieldIdealInfinite_rational<F> {
    fn default() -> Self {
        Self::new()
    }
}

/// Helper: Get polynomial degree
fn polynomial_degree(poly: &str) -> usize {
    if poly == "0" || poly.is_empty() {
        return 0;
    }

    // Simplified degree calculation
    if poly.contains("x^") {
        if let Some(pos) = poly.rfind("x^") {
            let after = &poly[pos + 2..];
            if let Some(end) = after.find(|c: char| !c.is_ascii_digit()) {
                if let Ok(deg) = after[..end].parse() {
                    return deg;
                }
            } else if let Ok(deg) = after.parse() {
                return deg;
            }
        }
    }

    if poly.contains('x') && !poly.contains("x^") {
        1
    } else {
        0
    }
}

/// Helper: Check if polynomial is irreducible (simplified)
fn is_irreducible(poly: &str) -> bool {
    if poly.is_empty() || poly == "0" {
        return false;
    }

    let deg = polynomial_degree(poly);

    // Degree 0 or 1 polynomials are irreducible if non-zero
    deg <= 1 && poly != "0"
}

/// Helper: Compute GCD of two polynomials (simplified)
fn gcd_polynomial(p1: &str, p2: &str) -> String {
    if p1 == "0" {
        p2.to_string()
    } else if p2 == "0" {
        p1.to_string()
    } else {
        // Simplified: would use Euclidean algorithm
        "gcd".to_string()
    }
}

/// Helper: Compute LCM of two polynomials (simplified)
fn lcm_polynomial(p1: &str, p2: &str) -> String {
    if p1 == "0" || p2 == "0" {
        "0".to_string()
    } else {
        // lcm(f,g) = f*g/gcd(f,g)
        format!("lcm({}, {})", p1, p2)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;

    #[test]
    fn test_function_field_ideal_rational() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::new("test".to_string());

        assert!(ideal.is_well_defined());
        assert!(ideal.is_principal());
        assert!(!ideal.is_prime());
    }

    #[test]
    fn test_principal_ideal() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x^2 + 1".to_string());

        assert!(ideal.is_principal());
        assert_eq!(ideal.generator(), "x^2 + 1");
        assert_eq!(ideal.degree(), 2);
    }

    #[test]
    fn test_prime_ideal() {
        let prime = FunctionFieldIdeal_rational::<Rational>::prime("x - 1".to_string());

        assert!(prime.is_prime());
        assert!(prime.is_principal());
        assert_eq!(prime.generator(), "x - 1");
    }

    #[test]
    fn test_unit_ideal() {
        let unit = FunctionFieldIdeal_rational::<Rational>::principal("1".to_string());

        assert!(unit.is_unit());
        assert!(!unit.is_zero());
        assert_eq!(unit.norm(), 0);
    }

    #[test]
    fn test_zero_ideal() {
        let zero = FunctionFieldIdeal_rational::<Rational>::principal("0".to_string());

        assert!(zero.is_zero());
        assert!(!zero.is_unit());
        assert_eq!(zero.norm(), 0);
    }

    #[test]
    fn test_ideal_degree() {
        let i1 = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        assert_eq!(i1.degree(), 1);

        let i2 = FunctionFieldIdeal_rational::<Rational>::principal("x^3".to_string());
        assert_eq!(i2.degree(), 3);

        let i3 = FunctionFieldIdeal_rational::<Rational>::principal("5".to_string());
        assert_eq!(i3.degree(), 0);
    }

    #[test]
    fn test_ideal_norm() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x^2".to_string());
        assert_eq!(ideal.norm(), 2);
    }

    #[test]
    fn test_ideal_multiplication() {
        let i1 = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let i2 = FunctionFieldIdeal_rational::<Rational>::principal("x+1".to_string());

        let product = i1.multiply(&i2);

        assert!(product.generator().contains("x"));
        assert!(product.generator().contains("x+1"));
    }

    #[test]
    fn test_multiply_by_unit() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let unit = FunctionFieldIdeal_rational::<Rational>::principal("1".to_string());

        let product = ideal.multiply(&unit);

        assert_eq!(product.generator(), "x");
    }

    #[test]
    fn test_multiply_by_zero() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let zero = FunctionFieldIdeal_rational::<Rational>::principal("0".to_string());

        let product = ideal.multiply(&zero);

        assert!(product.is_zero());
    }

    #[test]
    fn test_ideal_addition() {
        let i1 = FunctionFieldIdeal_rational::<Rational>::principal("x^2".to_string());
        let i2 = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());

        let sum = i1.add(&i2);

        // (x^2) + (x) = (gcd(x^2, x)) = (x) in a PID
        assert!(!sum.is_zero());
    }

    #[test]
    fn test_add_zero() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let zero = FunctionFieldIdeal_rational::<Rational>::principal("0".to_string());

        let sum = ideal.add(&zero);

        assert_eq!(sum.generator(), ideal.generator());
    }

    #[test]
    fn test_ideal_intersection() {
        let i1 = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let i2 = FunctionFieldIdeal_rational::<Rational>::principal("x+1".to_string());

        let inter = i1.intersect(&i2);

        // Intersection should be well-defined
        assert!(!inter.is_zero());
    }

    #[test]
    fn test_intersect_zero() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let zero = FunctionFieldIdeal_rational::<Rational>::principal("0".to_string());

        let inter = ideal.intersect(&zero);

        assert!(inter.is_zero());
    }

    #[test]
    fn test_ideal_inversion() {
        let ideal = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let inv = ideal.invert();

        assert!(inv.generator().contains("1/"));
        assert!(inv.generator().contains("x"));
    }

    #[test]
    #[should_panic]
    fn test_invert_zero_panics() {
        let zero = FunctionFieldIdeal_rational::<Rational>::principal("0".to_string());
        zero.invert(); // Should panic
    }

    #[test]
    fn test_function_field_ideal_infinite() {
        let ideal_inf = FunctionFieldIdealInfinite_rational::<Rational>::new();

        assert!(ideal_inf.is_infinite());
        assert_eq!(ideal_inf.degree(), 1);
        assert_eq!(ideal_inf.name(), "∞");
    }

    #[test]
    fn test_valuation_at_infinity() {
        let ideal_inf = FunctionFieldIdealInfinite_rational::<Rational>::new();

        // v_∞(x) = 0 - 1 = -1 (pole at infinity)
        assert_eq!(ideal_inf.valuation("x", "1"), -1);

        // v_∞(1/x) = 0 - (-1) = 1 (zero at infinity)
        assert_eq!(ideal_inf.valuation("1", "x"), 1);

        // v_∞(x^2/x^3) = 3 - 2 = 1
        assert_eq!(ideal_inf.valuation("x^2", "x^3"), 1);
    }

    #[test]
    fn test_has_pole_at_infinity() {
        let ideal_inf = FunctionFieldIdealInfinite_rational::<Rational>::new();

        // x has a pole at infinity
        assert!(ideal_inf.has_pole("x", "1"));

        // 1/x has a zero at infinity
        assert!(!ideal_inf.has_pole("1", "x"));
    }

    #[test]
    fn test_has_zero_at_infinity() {
        let ideal_inf = FunctionFieldIdealInfinite_rational::<Rational>::new();

        // 1/x has a zero at infinity
        assert!(ideal_inf.has_zero("1", "x"));

        // x has a pole at infinity
        assert!(!ideal_inf.has_zero("x", "1"));
    }

    #[test]
    fn test_polynomial_degree_helper() {
        assert_eq!(polynomial_degree("x^5"), 5);
        assert_eq!(polynomial_degree("x"), 1);
        assert_eq!(polynomial_degree("7"), 0);
        assert_eq!(polynomial_degree("0"), 0);
    }

    #[test]
    fn test_is_irreducible_helper() {
        assert!(is_irreducible("x"));
        assert!(is_irreducible("x - 1"));
        assert!(!is_irreducible("0"));
        assert!(!is_irreducible(""));
    }

    #[test]
    fn test_gcd_polynomial_helper() {
        let gcd = gcd_polynomial("x", "x^2");
        assert!(!gcd.is_empty());

        assert_eq!(gcd_polynomial("0", "x"), "x");
        assert_eq!(gcd_polynomial("x", "0"), "x");
    }

    #[test]
    fn test_lcm_polynomial_helper() {
        let lcm = lcm_polynomial("x", "x^2");
        assert!(!lcm.is_empty());

        assert_eq!(lcm_polynomial("0", "x"), "0");
        assert_eq!(lcm_polynomial("x", "0"), "0");
    }

    #[test]
    fn test_ideal_operations_chain() {
        let i1 = FunctionFieldIdeal_rational::<Rational>::principal("x".to_string());
        let i2 = FunctionFieldIdeal_rational::<Rational>::principal("x+1".to_string());
        let i3 = FunctionFieldIdeal_rational::<Rational>::principal("x-1".to_string());

        let prod = i1.multiply(&i2);
        let sum = prod.add(&i3);

        assert!(!sum.is_zero());
        assert!(sum.is_principal());
    }
}
