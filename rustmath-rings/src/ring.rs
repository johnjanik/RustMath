//! # Ring Module
//!
//! This module provides the abstract base classes and trait definitions for ring structures,
//! mirroring SageMath's `sage.rings.ring` module.
//!
//! ## Overview
//!
//! A ring is a fundamental algebraic structure with two binary operations (addition and
//! multiplication) satisfying specific axioms. This module defines the hierarchy of ring
//! types from most general to most specific.
//!
//! ## Class Hierarchy
//!
//! ```text
//! Ring (base trait)
//! â”œâ”€â”€ CommutativeRing (commutative multiplication)
//! â”‚   â”œâ”€â”€ IntegralDomain (no zero divisors)
//! â”‚   â”œâ”€â”€ NoetherianRing (ascending chain condition)
//! â”‚   â”œâ”€â”€ DedekindDomain (fractional ideals invertible)
//! â”‚   â”œâ”€â”€ PrincipalIdealDomain (all ideals principal)
//! â”‚   â”œâ”€â”€ Field (all nonzero elements invertible)
//! â”‚   â””â”€â”€ CommutativeAlgebra (algebra over base ring)
//! â””â”€â”€ Algebra (non-commutative algebra over base ring)
//! ```
//!
//! ## Examples
//!
//! ```rust
//! use rustmath_rings::ring::{Ring, CommutativeRing, Field, is_ring};
//! ```
//!
//! ## Mathematical Properties
//!
//! | Type | Commutative | No Zero Divisors | All Invertible | Ideals |
//! |------|-------------|------------------|----------------|--------|
//! | Ring | No | No | No | General |
//! | CommutativeRing | Yes | No | No | General |
//! | IntegralDomain | Yes | Yes | No | General |
//! | Field | Yes | Yes | Yes (nonzero) | {0}, R |
//! | PrincipalIdealDomain | Yes | Yes | No | Principal |
//! | DedekindDomain | Yes | Yes | No | Invertible |

// Re-export core traits
pub use rustmath_core::{Ring, CommutativeRing, Field, IntegralDomain, EuclideanDomain};

use std::fmt;
use std::marker::PhantomData;
use thiserror::Error;

/// Errors related to ring operations
#[derive(Debug, Clone, Error, PartialEq)]
pub enum RingError {
    #[error("Not a commutative ring")]
    NotCommutative,

    #[error("Base ring is not commutative")]
    BaseNotCommutative,

    #[error("Element not invertible")]
    NotInvertible,

    #[error("Zero divisor found")]
    ZeroDivisor,
}

/// Trait for Noetherian rings
///
/// A ring R is Noetherian if it satisfies the ascending chain condition (ACC)
/// on ideals: every ascending chain of ideals eventually stabilizes.
///
/// **Equivalent Conditions:**
/// - Every ideal is finitely generated
/// - Every non-empty set of ideals has a maximal element
pub trait NoetherianRing: CommutativeRing {
    /// Checks if this ring is Noetherian
    fn is_noetherian(&self) -> bool {
        true // Implementors must override if not always Noetherian
    }
}

/// Trait for Dedekind domains
///
/// A Dedekind domain is an integral domain where every nonzero proper ideal
/// factors uniquely into prime ideals.
///
/// **Equivalent Conditions:**
/// - Noetherian + integrally closed + dimension 1
/// - Every fractional ideal is invertible
///
/// **Examples:** â„¤, â„¤[âˆšd] (for d squarefree), ð’ª_K (ring of integers in number field)
pub trait DedekindDomain: IntegralDomain + NoetherianRing {
    /// Checks if this is a Dedekind domain
    fn is_dedekind_domain(&self) -> bool {
        true
    }

    /// Checks if this ring is integrally closed
    fn is_integrally_closed(&self) -> bool {
        true
    }

    /// Returns the Krull dimension (1 for Dedekind domains)
    fn krull_dimension(&self) -> usize {
        1
    }
}

/// Trait for Principal Ideal Domains (PIDs)
///
/// A PID is an integral domain where every ideal is principal (generated by
/// a single element).
///
/// **Key Properties:**
/// - Every PID is a unique factorization domain (UFD)
/// - Every PID is a Dedekind domain
/// - GCD and LCM exist for any pair of elements
///
/// **Examples:** â„¤, K[x] (polynomials over field K), â„¤[i] (Gaussian integers)
pub trait PrincipalIdealDomain: DedekindDomain {
    /// Checks if this is a PID
    fn is_principal_ideal_domain(&self) -> bool {
        true
    }

    /// Checks if this is a unique factorization domain
    fn is_ufd(&self) -> bool {
        true // PIDs are UFDs
    }
}

/// Trait for algebras over a base ring
///
/// An algebra A over a ring R is a ring A together with a ring homomorphism
/// R â†’ A (the structure map) such that the image of R is in the center of A.
pub trait Algebra<R: Ring>: Ring {
    /// Returns the base ring
    fn base_ring(&self) -> &R;

    /// Returns the structure map (embedding of base ring)
    fn structure_map(&self) -> Box<dyn Fn(&R) -> Self + 'static> where Self: 'static;

    /// Checks if this is an algebra over the given base ring
    fn is_algebra_over(&self, base: &R) -> bool;
}

/// Trait for commutative algebras
///
/// A commutative algebra is an algebra where the ring multiplication is commutative.
pub trait CommutativeAlgebra<R: CommutativeRing>: Algebra<R> + CommutativeRing {
    /// Checks if this algebra is commutative
    fn is_commutative_algebra(&self) -> bool {
        true
    }
}

/// A generic ring wrapper for demonstration
///
/// This provides a concrete implementation of the Ring trait for testing
/// and examples.
#[derive(Debug, Clone)]
pub struct GenericRing<T> {
    name: String,
    characteristic: u64,
    _phantom: PhantomData<T>,
}

impl<T> GenericRing<T> {
    /// Creates a new generic ring
    pub fn new(name: String, characteristic: u64) -> Self {
        GenericRing {
            name,
            characteristic,
            _phantom: PhantomData,
        }
    }

    /// Returns the ring's name
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Returns the characteristic
    pub fn characteristic(&self) -> u64 {
        self.characteristic
    }
}

impl<T> fmt::Display for GenericRing<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}

/// Checks if a value implements the Ring trait
///
/// This is the Rust equivalent of SageMath's `is_Ring()` function.
/// Note: In Rust, this is typically done via trait bounds at compile time.
pub fn is_ring<T: 'static>() -> bool {
    // Type-level checking in Rust
    std::any::TypeId::of::<T>() == std::any::TypeId::of::<i32>()
        || std::any::TypeId::of::<T>() == std::any::TypeId::of::<i64>()
        || std::any::TypeId::of::<T>() == std::any::TypeId::of::<f64>()
}

/// Extension methods for rings
pub trait RingExt: Ring {
    /// Returns the zero element
    fn zero(&self) -> Self where Self: Sized;

    /// Returns the unity element (1)
    fn one(&self) -> Self where Self: Sized;

    /// Returns the order (cardinality) of the ring
    fn order(&self) -> Option<usize> {
        None // Infinite by default
    }

    /// Checks if the ring is finite
    fn is_finite(&self) -> bool {
        self.order().is_some()
    }

    /// Checks if the ring is infinite
    fn is_infinite(&self) -> bool {
        !self.is_finite()
    }
}

/// Extension methods for commutative rings
pub trait CommutativeRingExt: CommutativeRing {
    // TODO: Fix - Field trait is not dyn compatible
    // /// Constructs the fraction field
    // ///
    // /// For an integral domain R, this returns its field of fractions Frac(R).
    // fn fraction_field(&self) -> Result<Box<dyn Field>, RingError> {
    //     Err::<Box<dyn std::any::Any>, _>(RingError::NotCommutative)
    // }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generic_ring_creation() {
        let ring: GenericRing<i32> = GenericRing::new("Z".to_string(), 0);
        assert_eq!(ring.name(), "Z");
        assert_eq!(ring.characteristic(), 0);
    }

    #[test]
    fn test_generic_ring_display() {
        let ring: GenericRing<i64> = GenericRing::new("Integer Ring".to_string(), 0);
        assert_eq!(format!("{}", ring), "Integer Ring");
    }

    #[test]
    fn test_is_ring() {
        assert!(is_ring::<i32>());
        assert!(is_ring::<i64>());
        assert!(is_ring::<f64>());
    }

    // Note: Additional tests for trait implementations would go here
    // but require concrete types that implement the traits
}
