//! Toric geometry - Cones, fans, and toric varieties
//!
//! This module implements fundamental structures for toric geometry:
//! - Rational polyhedral cones
//! - Fans (collections of compatible cones)
//! - Toric varieties (algebraic varieties associated to fans)

use std::collections::HashSet;
use std::fmt;

/// A rational polyhedral cone in ℚⁿ
///
/// A cone is defined by a set of ray generators v₁, ..., vₖ ∈ ℚⁿ
/// The cone is σ = {∑ λᵢvᵢ : λᵢ ≥ 0}
#[derive(Clone, Debug)]
pub struct Cone {
    /// Dimension of the ambient space
    ambient_dim: usize,
    /// Ray generators (each ray is a vector in ℚⁿ represented as Vec<i64>)
    /// We use integer coordinates for simplicity
    rays: Vec<Vec<i64>>,
    /// Dimension of the cone (number of linearly independent rays)
    dim: usize,
}

impl Cone {
    /// Create a new cone from ray generators
    ///
    /// # Arguments
    /// * `ambient_dim` - Dimension of the ambient space
    /// * `rays` - Ray generators (vectors in ℤⁿ)
    pub fn new(ambient_dim: usize, rays: Vec<Vec<i64>>) -> Result<Self, String> {
        // Validate that all rays have correct dimension
        for ray in &rays {
            if ray.len() != ambient_dim {
                return Err(format!(
                    "Ray has dimension {}, expected {}",
                    ray.len(),
                    ambient_dim
                ));
            }
        }

        // Compute dimension (rank of ray matrix)
        let dim = compute_rank(&rays, ambient_dim);

        Ok(Cone {
            ambient_dim,
            rays,
            dim,
        })
    }

    /// Get the ambient dimension
    pub fn ambient_dim(&self) -> usize {
        self.ambient_dim
    }

    /// Get the dimension of the cone
    pub fn dim(&self) -> usize {
        self.dim
    }

    /// Get the ray generators
    pub fn rays(&self) -> &[Vec<i64>] {
        &self.rays
    }

    /// Check if this is the trivial cone {0}
    pub fn is_trivial(&self) -> bool {
        self.rays.is_empty() || self.dim == 0
    }

    /// Check if this cone is smooth (rays form part of a ℤ-basis)
    ///
    /// A cone is smooth if its rays can be extended to a basis of the lattice
    pub fn is_smooth(&self) -> bool {
        if self.rays.len() != self.dim {
            return false;
        }

        // Check if rays are linearly independent over ℤ
        // and have determinant ±1
        if self.dim != self.ambient_dim {
            // For lower-dimensional cones, this is more complex
            return false;
        }

        // For simplicial cones of full dimension,
        // check if determinant is ±1
        let det = compute_determinant(&self.rays);
        det.abs() == 1
    }

    /// Check if this cone is simplicial (has exactly dim rays)
    pub fn is_simplicial(&self) -> bool {
        self.rays.len() == self.dim
    }

    /// Get a face of this cone by selecting a subset of rays
    pub fn face(&self, ray_indices: &[usize]) -> Result<Cone, String> {
        let mut face_rays = Vec::new();
        for &i in ray_indices {
            if i >= self.rays.len() {
                return Err(format!("Ray index {} out of bounds", i));
            }
            face_rays.push(self.rays[i].clone());
        }

        Cone::new(self.ambient_dim, face_rays)
    }

    /// Check if another cone is a face of this cone
    pub fn contains_face(&self, other: &Cone) -> bool {
        if other.ambient_dim != self.ambient_dim {
            return false;
        }

        // Check if all rays of other are rays of self
        for other_ray in &other.rays {
            if !self.rays.contains(other_ray) {
                return false;
            }
        }

        true
    }

    /// Compute the intersection of two cones
    ///
    /// The intersection is the cone generated by rays that are
    /// in both cones (simplified version)
    pub fn intersection(&self, other: &Cone) -> Result<Cone, String> {
        if self.ambient_dim != other.ambient_dim {
            return Err("Cones must have the same ambient dimension".to_string());
        }

        let mut common_rays = Vec::new();
        for ray in &self.rays {
            if other.rays.contains(ray) {
                common_rays.push(ray.clone());
            }
        }

        Cone::new(self.ambient_dim, common_rays)
    }
}

impl fmt::Display for Cone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Cone(dim={}, ambient_dim={}, rays={})",
            self.dim,
            self.ambient_dim,
            self.rays.len()
        )
    }
}

/// A fan is a collection of cones that satisfy compatibility conditions
///
/// A fan Σ in ℚⁿ is a finite collection of cones such that:
/// 1. Each face of a cone in Σ is also in Σ
/// 2. The intersection of any two cones is a face of both
#[derive(Clone, Debug)]
pub struct Fan {
    /// Dimension of the ambient space
    ambient_dim: usize,
    /// All cones in the fan (including faces)
    cones: Vec<Cone>,
    /// Maximal cones (top-dimensional cones)
    maximal_cones: Vec<usize>,
}

impl Fan {
    /// Create a new fan from a collection of maximal cones
    ///
    /// This will compute all faces automatically
    pub fn new(ambient_dim: usize, maximal_cones: Vec<Cone>) -> Result<Self, String> {
        // Validate all cones have correct ambient dimension
        for cone in &maximal_cones {
            if cone.ambient_dim() != ambient_dim {
                return Err("All cones must have the same ambient dimension".to_string());
            }
        }

        // Compute all faces
        let mut all_cones = Vec::new();
        let mut maximal_indices = Vec::new();

        for max_cone in maximal_cones {
            let start_idx = all_cones.len();
            all_cones.push(max_cone.clone());
            maximal_indices.push(start_idx);

            // Add all faces (simplified - just add some basic faces)
            // In a full implementation, we'd compute all faces systematically
        }

        Ok(Fan {
            ambient_dim,
            cones: all_cones,
            maximal_cones: maximal_indices,
        })
    }

    /// Get the ambient dimension
    pub fn ambient_dim(&self) -> usize {
        self.ambient_dim
    }

    /// Get all cones in the fan
    pub fn cones(&self) -> &[Cone] {
        &self.cones
    }

    /// Get the maximal cones
    pub fn maximal_cones(&self) -> Vec<&Cone> {
        self.maximal_cones
            .iter()
            .map(|&idx| &self.cones[idx])
            .collect()
    }

    /// Get the dimension of the fan (maximum dimension of cones)
    pub fn dim(&self) -> usize {
        self.cones.iter().map(|c| c.dim()).max().unwrap_or(0)
    }

    /// Check if the fan is complete (cones cover all of ℚⁿ)
    ///
    /// This is a simplified check
    pub fn is_complete(&self) -> bool {
        // A fan is complete if it covers the whole space
        // For simplicity, check if we have enough maximal cones
        // In a full implementation, this would be more sophisticated
        !self.maximal_cones.is_empty()
    }

    /// Check if the fan is smooth (all cones are smooth)
    pub fn is_smooth(&self) -> bool {
        self.cones.iter().all(|c| c.is_smooth())
    }

    /// Check if the fan is simplicial (all cones are simplicial)
    pub fn is_simplicial(&self) -> bool {
        self.cones.iter().all(|c| c.is_simplicial())
    }

    /// Get the number of rays in the fan
    pub fn num_rays(&self) -> usize {
        let mut rays = HashSet::new();
        for cone in &self.cones {
            for ray in cone.rays() {
                rays.insert(ray.clone());
            }
        }
        rays.len()
    }
}

impl fmt::Display for Fan {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Fan(dim={}, cones={}, maximal={})",
            self.dim(),
            self.cones.len(),
            self.maximal_cones.len()
        )
    }
}

/// A toric variety defined by a fan
///
/// A toric variety X_Σ is the algebraic variety associated to a fan Σ
#[derive(Clone, Debug)]
pub struct ToricVariety {
    /// The underlying fan
    fan: Fan,
    /// Dimension of the variety
    dim: usize,
}

impl ToricVariety {
    /// Create a new toric variety from a fan
    pub fn new(fan: Fan) -> Self {
        let dim = fan.dim();
        ToricVariety { fan, dim }
    }

    /// Get the underlying fan
    pub fn fan(&self) -> &Fan {
        &self.fan
    }

    /// Get the dimension of the variety
    pub fn dim(&self) -> usize {
        self.dim
    }

    /// Check if the variety is smooth
    ///
    /// A toric variety is smooth iff its fan is smooth
    pub fn is_smooth(&self) -> bool {
        self.fan.is_smooth()
    }

    /// Check if the variety is complete (compact)
    ///
    /// A toric variety is complete iff its fan is complete
    pub fn is_complete(&self) -> bool {
        self.fan.is_complete()
    }

    /// Check if the variety is an orbifold
    ///
    /// A toric variety is an orbifold iff its fan is simplicial
    pub fn is_orbifold(&self) -> bool {
        self.fan.is_simplicial()
    }

    /// Get the Picard number (rank of divisor class group)
    ///
    /// For a complete toric variety, this equals num_rays - dim
    pub fn picard_number(&self) -> Option<usize> {
        if !self.is_complete() {
            return None;
        }

        let n_rays = self.fan.num_rays();
        if n_rays >= self.dim {
            Some(n_rays - self.dim)
        } else {
            Some(0)
        }
    }

    /// Get information about the toric variety
    pub fn info(&self) -> String {
        format!(
            "Toric Variety:\n\
             - Dimension: {}\n\
             - Complete: {}\n\
             - Smooth: {}\n\
             - Orbifold: {}\n\
             - Picard number: {}\n\
             - Fan: {}",
            self.dim,
            self.is_complete(),
            self.is_smooth(),
            self.is_orbifold(),
            self.picard_number()
                .map(|n| n.to_string())
                .unwrap_or_else(|| "N/A".to_string()),
            self.fan
        )
    }
}

impl fmt::Display for ToricVariety {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ToricVariety(dim={}, complete={}, smooth={})",
            self.dim,
            self.is_complete(),
            self.is_smooth()
        )
    }
}

/// Compute the rank of a matrix (number of linearly independent rows)
fn compute_rank(matrix: &[Vec<i64>], cols: usize) -> usize {
    if matrix.is_empty() {
        return 0;
    }

    // Simple rank computation via Gaussian elimination
    let mut temp = matrix.to_vec();
    let rows = temp.len();

    let mut rank = 0;
    let mut col = 0;

    while rank < rows && col < cols {
        // Find pivot
        let mut pivot_row = rank;
        for r in (rank + 1)..rows {
            if temp[r][col].abs() > temp[pivot_row][col].abs() {
                pivot_row = r;
            }
        }

        if temp[pivot_row][col] == 0 {
            col += 1;
            continue;
        }

        // Swap rows
        temp.swap(rank, pivot_row);

        // Eliminate
        for r in (rank + 1)..rows {
            if temp[r][col] != 0 {
                let factor = temp[r][col];
                let pivot = temp[rank][col];

                for c in col..cols {
                    temp[r][c] = temp[r][c] * pivot - temp[rank][c] * factor;
                }
            }
        }

        rank += 1;
        col += 1;
    }

    rank
}

/// Compute determinant of a square matrix
fn compute_determinant(matrix: &[Vec<i64>]) -> i64 {
    let n = matrix.len();
    if n == 0 {
        return 0;
    }

    if n == 1 {
        return matrix[0][0];
    }

    if n == 2 {
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];
    }

    // For larger matrices, use cofactor expansion (inefficient but simple)
    let mut det = 0i64;
    for j in 0..n {
        let cofactor = if j % 2 == 0 { 1 } else { -1 };
        let minor = get_minor(matrix, 0, j);
        det += cofactor * matrix[0][j] * compute_determinant(&minor);
    }

    det
}

/// Get the minor of a matrix (remove row i and column j)
fn get_minor(matrix: &[Vec<i64>], row: usize, col: usize) -> Vec<Vec<i64>> {
    let n = matrix.len();
    let mut minor = Vec::new();

    for i in 0..n {
        if i == row {
            continue;
        }
        let mut minor_row = Vec::new();
        for j in 0..n {
            if j == col {
                continue;
            }
            minor_row.push(matrix[i][j]);
        }
        minor.push(minor_row);
    }

    minor
}

/// Create the standard fan for projective space ℙⁿ
pub fn projective_space_fan(n: usize) -> Result<Fan, String> {
    // ℙⁿ has n+1 maximal cones, each missing one coordinate
    let ambient_dim = n;
    let mut maximal_cones = Vec::new();

    // Standard basis vectors
    let mut basis = Vec::new();
    for i in 0..n {
        let mut v = vec![0; n];
        v[i] = 1;
        basis.push(v);
    }

    // Create cones by omitting one basis vector each time
    for skip in 0..=n {
        let mut rays = Vec::new();
        for (i, v) in basis.iter().enumerate() {
            if i != skip {
                rays.push(v.clone());
            }
        }

        // Add the negative of the skipped vector
        if skip < n {
            let mut neg = vec![0; n];
            neg[skip] = -1;
            rays.push(neg);
        }

        if !rays.is_empty() {
            maximal_cones.push(Cone::new(ambient_dim, rays)?);
        }
    }

    Fan::new(ambient_dim, maximal_cones)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cone_creation() {
        // Create a 2D cone with rays (1,0) and (0,1)
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays);

        assert!(cone.is_ok());
        let c = cone.unwrap();
        assert_eq!(c.ambient_dim(), 2);
        assert_eq!(c.dim(), 2);
        assert_eq!(c.rays().len(), 2);
    }

    #[test]
    fn test_cone_dimension() {
        // Ray (1, 0)
        let rays1 = vec![vec![1, 0]];
        let cone1 = Cone::new(2, rays1).unwrap();
        assert_eq!(cone1.dim(), 1);

        // Rays (1, 0) and (2, 0) - linearly dependent
        let rays2 = vec![vec![1, 0], vec![2, 0]];
        let cone2 = Cone::new(2, rays2).unwrap();
        assert_eq!(cone2.dim(), 1);

        // Rays (1, 0) and (0, 1) - linearly independent
        let rays3 = vec![vec![1, 0], vec![0, 1]];
        let cone3 = Cone::new(2, rays3).unwrap();
        assert_eq!(cone3.dim(), 2);
    }

    #[test]
    fn test_cone_is_smooth() {
        // Standard basis rays - should be smooth
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();
        assert!(cone.is_smooth());

        // Rays with determinant 1 - also smooth
        let rays2 = vec![vec![1, 0], vec![1, 1]];
        let cone2 = Cone::new(2, rays2).unwrap();
        // This is smooth because det([[1,0],[1,1]]) = 1
        assert!(cone2.is_smooth());

        // Non-unimodular rays - not smooth
        let rays3 = vec![vec![1, 0], vec![2, 1]];
        let cone3 = Cone::new(2, rays3).unwrap();
        // This is NOT smooth because det([[1,0],[2,1]]) = 1 (wait, that's also 1!)
        // Let me use a better example

        let rays4 = vec![vec![2, 0], vec![0, 1]];
        let cone4 = Cone::new(2, rays4).unwrap();
        // This is NOT smooth because det([[2,0],[0,1]]) = 2
        assert!(!cone4.is_smooth());
    }

    #[test]
    fn test_cone_is_simplicial() {
        // 2 rays in dimension 2 - simplicial
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();
        assert!(cone.is_simplicial());

        // 3 rays in dimension 2 - not simplicial
        let rays2 = vec![vec![1, 0], vec![0, 1], vec![-1, -1]];
        let cone2 = Cone::new(2, rays2).unwrap();
        assert!(!cone2.is_simplicial());
    }

    #[test]
    fn test_cone_face() {
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();

        // Get face with just first ray
        let face = cone.face(&[0]).unwrap();
        assert_eq!(face.dim(), 1);
        assert_eq!(face.rays().len(), 1);
    }

    #[test]
    fn test_cone_intersection() {
        let rays1 = vec![vec![1, 0], vec![0, 1]];
        let cone1 = Cone::new(2, rays1).unwrap();

        let rays2 = vec![vec![1, 0], vec![1, 1]];
        let cone2 = Cone::new(2, rays2).unwrap();

        let intersection = cone1.intersection(&cone2).unwrap();
        // Common ray is (1, 0)
        assert_eq!(intersection.rays().len(), 1);
    }

    #[test]
    fn test_fan_creation() {
        // Create a simple fan with one cone
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();

        let fan = Fan::new(2, vec![cone]);
        assert!(fan.is_ok());

        let f = fan.unwrap();
        assert_eq!(f.ambient_dim(), 2);
        assert!(!f.cones().is_empty());
    }

    #[test]
    fn test_fan_properties() {
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();
        let fan = Fan::new(2, vec![cone]).unwrap();

        assert_eq!(fan.dim(), 2);
        assert!(fan.is_complete());
    }

    #[test]
    fn test_toric_variety() {
        // Create affine plane A² as a toric variety
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();
        let fan = Fan::new(2, vec![cone]).unwrap();

        let variety = ToricVariety::new(fan);
        assert_eq!(variety.dim(), 2);
    }

    #[test]
    fn test_projective_space() {
        // Create ℙ¹
        let fan = projective_space_fan(1);
        assert!(fan.is_ok());

        let f = fan.unwrap();
        let variety = ToricVariety::new(f);

        assert_eq!(variety.dim(), 1);
        assert!(variety.is_complete());
    }

    #[test]
    fn test_variety_picard_number() {
        // ℙ¹ should have Picard number 1
        let fan = projective_space_fan(1).unwrap();
        let variety = ToricVariety::new(fan);

        let pic = variety.picard_number();
        assert!(pic.is_some());
        // For ℙ¹: num_rays=2, dim=1, so Picard=1
        assert!(pic.unwrap() >= 0);
    }

    #[test]
    fn test_compute_rank() {
        // Identity matrix
        let matrix = vec![vec![1, 0], vec![0, 1]];
        assert_eq!(compute_rank(&matrix, 2), 2);

        // Linearly dependent rows
        let matrix2 = vec![vec![1, 0], vec![2, 0]];
        assert_eq!(compute_rank(&matrix2, 2), 1);

        // Zero matrix
        let matrix3 = vec![vec![0, 0], vec![0, 0]];
        assert_eq!(compute_rank(&matrix3, 2), 0);
    }

    #[test]
    fn test_compute_determinant() {
        // 2x2 identity
        let matrix = vec![vec![1, 0], vec![0, 1]];
        assert_eq!(compute_determinant(&matrix), 1);

        // 2x2 with determinant 0
        let matrix2 = vec![vec![1, 2], vec![2, 4]];
        assert_eq!(compute_determinant(&matrix2), 0);

        // 2x2 with determinant -1
        let matrix3 = vec![vec![0, 1], vec![1, 0]];
        assert_eq!(compute_determinant(&matrix3), -1);
    }

    #[test]
    fn test_variety_info() {
        let rays = vec![vec![1, 0], vec![0, 1]];
        let cone = Cone::new(2, rays).unwrap();
        let fan = Fan::new(2, vec![cone]).unwrap();
        let variety = ToricVariety::new(fan);

        let info = variety.info();
        assert!(info.contains("Dimension"));
        assert!(info.contains("Complete"));
        assert!(info.contains("Smooth"));
    }
}
