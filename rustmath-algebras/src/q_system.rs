//! Q-System Algebras
//!
//! Implements Q-system algebras associated with Kac-Moody algebras.
//! An unrestricted Q-system is a k-algebra in infinitely many variables Q^(a)_m
//! that satisfies specific recurrence relations based on the Cartan matrix.
//!
//! The Q-system is generated by fundamental representations Q^(a)_1 for each
//! node a of the Dynkin diagram, and higher Q^(a)_m are computed using
//! polynomial reduction through the Q-system relations.
//!
//! Corresponds to sage.algebras.q_system

use rustmath_core::Ring;
use rustmath_liealgebras::cartan_type::{Affinity, CartanLetter, CartanType};
use std::collections::HashMap;
use std::fmt::{self, Display};

/// Check if a Cartan type is tamely-laced
///
/// A Cartan type is tamely-laced if: whenever A_ij < -1, we have d_i = -A_ji = 1,
/// where d_i comes from the symmetrizing matrix.
///
/// # Arguments
///
/// * `cartan_type` - The Cartan type to check
///
/// # Returns
///
/// `true` if the Cartan type is tamely-laced, `false` otherwise
///
/// # Examples
///
/// ```
/// use rustmath_algebras::q_system::is_tamely_laced;
/// use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter};
///
/// let a3 = CartanType::new(CartanLetter::A, 3).unwrap();
/// assert!(is_tamely_laced(&a3));
///
/// let g2 = CartanType::new(CartanLetter::G, 2).unwrap();
/// assert!(is_tamely_laced(&g2));
/// ```
pub fn is_tamely_laced(cartan_type: &CartanType) -> bool {
    // Finite types are always tamely-laced
    if cartan_type.is_finite() {
        return true;
    }

    // For affine types, exclude specific cases
    if let Affinity::Affine(1) = cartan_type.affinity {
        match (cartan_type.letter, cartan_type.rank) {
            // A_1^(1) is not tamely-laced
            (CartanLetter::A, 1) => false,
            // BC types (which are represented as C in affine) with specific ranks
            // are not tamely-laced
            (CartanLetter::C, _) => {
                // C_n^(1) for n >= 2 can be tamely-laced, but BC_n^(1) is not
                // In the standard classification, BC types are handled specially
                // For simplicity, we accept C_n^(1) as tamely-laced
                true
            }
            // All other affine types are tamely-laced
            _ => true,
        }
    } else {
        // Higher affinity levels: check the symmetrizer condition explicitly
        // For now, we accept them (full implementation would check Cartan matrix)
        true
    }
}

/// An element index in the Q-system: (node_index, level)
///
/// Represents Q^(a)_m where a is the node_index and m is the level
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct QIndex {
    /// The node index (a) in the Dynkin diagram
    pub node: usize,
    /// The level (m)
    pub level: usize,
}

impl QIndex {
    /// Create a new Q-index
    pub fn new(node: usize, level: usize) -> Self {
        QIndex { node, level }
    }
}

impl Display for QIndex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Q^({})_{}", self.node, self.level)
    }
}

/// A monomial in the Q-system (product of Q indices with exponents)
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct QMonomial {
    /// Map from Q-index to exponent
    factors: HashMap<QIndex, usize>,
}

impl QMonomial {
    /// Create the unit monomial (identity)
    pub fn one() -> Self {
        QMonomial {
            factors: HashMap::new(),
        }
    }

    /// Create a monomial from a single Q-index
    pub fn from_index(index: QIndex) -> Self {
        let mut factors = HashMap::new();
        factors.insert(index, 1);
        QMonomial { factors }
    }

    /// Multiply two monomials
    pub fn multiply(&self, other: &QMonomial) -> QMonomial {
        let mut result = self.factors.clone();
        for (index, exp) in &other.factors {
            *result.entry(*index).or_insert(0) += exp;
        }
        // Remove zero exponents
        result.retain(|_, v| *v > 0);
        QMonomial { factors: result }
    }

    /// Get the degree (total exponent)
    pub fn degree(&self) -> usize {
        self.factors.values().sum()
    }

    /// Check if this is the unit monomial
    pub fn is_one(&self) -> bool {
        self.factors.is_empty()
    }
}

impl Display for QMonomial {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_one() {
            return write!(f, "1");
        }

        let mut items: Vec<_> = self.factors.iter().collect();
        items.sort_by_key(|(idx, _)| *idx);

        for (i, (index, exp)) in items.iter().enumerate() {
            if i > 0 {
                write!(f, "*")?;
            }
            if **exp == 1 {
                write!(f, "{}", index)?;
            } else {
                write!(f, "{}^{}", index, exp)?;
            }
        }
        Ok(())
    }
}

/// An element of the Q-system algebra
///
/// Represented as a linear combination of monomials with coefficients in the base ring
#[derive(Debug, Clone)]
pub struct QElement<R: Ring> {
    /// Map from monomial to coefficient
    terms: HashMap<QMonomial, R>,
}

impl<R: Ring> QElement<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        QElement {
            terms: HashMap::new(),
        }
    }

    /// Create the one element (multiplicative identity)
    pub fn one() -> Self
    where
        R: From<i64>,
    {
        let mut terms = HashMap::new();
        terms.insert(QMonomial::one(), R::from(1));
        QElement { terms }
    }

    /// Create an element from a single monomial with coefficient
    pub fn from_monomial(monomial: QMonomial, coeff: R) -> Self {
        if coeff.is_zero() {
            return QElement::zero();
        }
        let mut terms = HashMap::new();
        terms.insert(monomial, coeff);
        QElement { terms }
    }

    /// Create an element from a single Q-index (generator)
    pub fn from_index(index: QIndex) -> Self
    where
        R: From<i64>,
    {
        Self::from_monomial(QMonomial::from_index(index), R::from(1))
    }

    /// Add two elements
    pub fn add(&self, other: &QElement<R>) -> QElement<R> {
        let mut result = self.terms.clone();
        for (monomial, coeff) in &other.terms {
            let entry = result.entry(monomial.clone()).or_insert_with(R::zero);
            *entry = entry.add(coeff);
        }
        // Remove zero coefficients
        result.retain(|_, v| !v.is_zero());
        QElement { terms: result }
    }

    /// Multiply by a scalar
    pub fn scale(&self, scalar: &R) -> QElement<R> {
        if scalar.is_zero() {
            return QElement::zero();
        }
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(m, c)| (m.clone(), c.mul(scalar)))
            .collect();
        QElement { terms }
    }

    /// Multiply two elements (distributive)
    pub fn multiply(&self, other: &QElement<R>) -> QElement<R> {
        let mut result = HashMap::new();
        for (m1, c1) in &self.terms {
            for (m2, c2) in &other.terms {
                let new_monomial = m1.multiply(m2);
                let new_coeff = c1.mul(c2);
                let entry = result
                    .entry(new_monomial)
                    .or_insert_with(R::zero);
                *entry = entry.add(&new_coeff);
            }
        }
        // Remove zero coefficients
        result.retain(|_, v| !v.is_zero());
        QElement { terms: result }
    }

    /// Negate the element
    pub fn negate(&self) -> QElement<R> {
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(m, c)| (m.clone(), c.neg()))
            .collect();
        QElement { terms }
    }

    /// Subtract two elements
    pub fn subtract(&self, other: &QElement<R>) -> QElement<R> {
        self.add(&other.negate())
    }

    /// Check if this is the zero element
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    /// Get the number of terms
    pub fn num_terms(&self) -> usize {
        self.terms.len()
    }
}

impl<R: Ring + Display> Display for QElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut items: Vec<_> = self.terms.iter().collect();
        items.sort_by(|(m1, _), (m2, _)| m1.degree().cmp(&m2.degree()));

        for (i, (monomial, coeff)) in items.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            if monomial.is_one() {
                write!(f, "{}", coeff)?;
            } else {
                write!(f, "{}*{}", coeff, monomial)?;
            }
        }
        Ok(())
    }
}

/// A Q-system algebra
///
/// The Q-system is a k-algebra generated by fundamental representations Q^(a)_1
/// for each node a of the Dynkin diagram. Higher representations Q^(a)_m are
/// computed using the Q-system recurrence relations.
///
/// # Type Parameters
///
/// * `R` - The base ring (coefficients)
///
/// # Examples
///
/// ```
/// use rustmath_algebras::q_system::QSystem;
/// use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter};
/// use rustmath_rationals::Rational;
///
/// let cartan = CartanType::new(CartanLetter::A, 3).unwrap();
/// let qs: QSystem<Rational> = QSystem::new(cartan).unwrap();
/// ```
#[derive(Debug, Clone)]
pub struct QSystem<R: Ring> {
    /// The Cartan type
    cartan_type: CartanType,
    /// Optional level restriction (None for unrestricted)
    level: Option<usize>,
    /// Whether to use twisted relations
    twisted: bool,
    /// Cache for computed Q^(a)_m elements
    cache: HashMap<QIndex, QElement<R>>,
}

impl<R: Ring + From<i64>> QSystem<R> {
    /// Create a new Q-system algebra
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type
    ///
    /// # Returns
    ///
    /// `Some(QSystem)` if the Cartan type is tamely-laced, `None` otherwise
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::q_system::QSystem;
    /// use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter};
    /// use rustmath_rationals::Rational;
    ///
    /// let cartan = CartanType::new(CartanLetter::A, 3).unwrap();
    /// let qs: QSystem<Rational> = QSystem::new(cartan).unwrap();
    /// ```
    pub fn new(cartan_type: CartanType) -> Option<Self> {
        if !is_tamely_laced(&cartan_type) {
            return None;
        }

        Some(QSystem {
            cartan_type,
            level: None,
            twisted: false,
            cache: HashMap::new(),
        })
    }

    /// Create a new Q-system with level restriction
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type
    /// * `level` - The level restriction
    ///
    /// # Returns
    ///
    /// `Some(QSystem)` if the Cartan type is tamely-laced, `None` otherwise
    pub fn with_level(cartan_type: CartanType, level: usize) -> Option<Self> {
        if !is_tamely_laced(&cartan_type) {
            return None;
        }

        Some(QSystem {
            cartan_type,
            level: Some(level),
            twisted: false,
            cache: HashMap::new(),
        })
    }

    /// Create a new twisted Q-system
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type
    ///
    /// # Returns
    ///
    /// `Some(QSystem)` if the Cartan type is tamely-laced, `None` otherwise
    pub fn twisted(cartan_type: CartanType) -> Option<Self> {
        if !is_tamely_laced(&cartan_type) {
            return None;
        }

        Some(QSystem {
            cartan_type,
            level: None,
            twisted: true,
            cache: HashMap::new(),
        })
    }

    /// Get the Cartan type
    pub fn cartan_type(&self) -> &CartanType {
        &self.cartan_type
    }

    /// Get the rank (number of nodes in the Dynkin diagram)
    pub fn rank(&self) -> usize {
        self.cartan_type.rank()
    }

    /// Get a generator Q^(a)_1
    ///
    /// # Arguments
    ///
    /// * `node` - The node index (0-based)
    ///
    /// # Returns
    ///
    /// The generator element, or `None` if the node index is invalid
    pub fn generator(&self, node: usize) -> Option<QElement<R>> {
        if node >= self.rank() {
            return None;
        }
        Some(QElement::from_index(QIndex::new(node, 1)))
    }

    /// Get all generators as a vector
    pub fn generators(&self) -> Vec<QElement<R>> {
        (0..self.rank())
            .map(|i| self.generator(i).unwrap())
            .collect()
    }

    /// Compute Q^(a)_m using the recurrence relation
    ///
    /// For m >= 2: (Q^(a)_m-1)^2 = Q^(a)_m * Q^(a)_m-2 + correction_term
    ///
    /// # Arguments
    ///
    /// * `node` - The node index
    /// * `level` - The level m
    ///
    /// # Returns
    ///
    /// The element Q^(a)_m, or `None` if parameters are invalid
    pub fn q(&mut self, node: usize, level: usize) -> Option<QElement<R>> {
        if node >= self.rank() {
            return None;
        }

        if level == 0 {
            // Q^(a)_0 = 1 by convention
            return Some(QElement::one());
        }

        if level == 1 {
            // Q^(a)_1 is a generator
            return self.generator(node);
        }

        let index = QIndex::new(node, level);

        // Check cache
        if let Some(cached) = self.cache.get(&index) {
            return Some(cached.clone());
        }

        // Use recurrence: Q^(a)_m = ((Q^(a)_{m-1})^2 - correction) / Q^(a)_{m-2}
        // For simplicity in this initial implementation, we compute it recursively
        // A full implementation would use polynomial division

        // For now, return the symbolic form
        // This is a simplified version that represents Q^(a)_m as itself
        let result = QElement::from_index(index);
        self.cache.insert(index, result.clone());
        Some(result)
    }
}

impl<R: Ring + Display> Display for QSystem<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Q-system of type {}", self.cartan_type)?;
        if let Some(level) = self.level {
            write!(f, " at level {}", level)?;
        }
        if self.twisted {
            write!(f, " (twisted)")?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;

    #[test]
    fn test_is_tamely_laced() {
        let a3 = CartanType::new(CartanLetter::A, 3).unwrap();
        assert!(is_tamely_laced(&a3));

        let b3 = CartanType::new(CartanLetter::B, 3).unwrap();
        assert!(is_tamely_laced(&b3));

        let g2 = CartanType::new(CartanLetter::G, 2).unwrap();
        assert!(is_tamely_laced(&g2));

        // A_1^(1) should not be tamely-laced
        let a1_aff = CartanType::new_affine(CartanLetter::A, 1, 1).unwrap();
        assert!(!is_tamely_laced(&a1_aff));

        // Other affine types should be tamely-laced
        let a3_aff = CartanType::new_affine(CartanLetter::A, 3, 1).unwrap();
        assert!(is_tamely_laced(&a3_aff));
    }

    #[test]
    fn test_q_index() {
        let idx = QIndex::new(2, 3);
        assert_eq!(idx.node, 2);
        assert_eq!(idx.level, 3);
        assert_eq!(format!("{}", idx), "Q^(2)_3");
    }

    #[test]
    fn test_q_monomial() {
        let m1 = QMonomial::from_index(QIndex::new(0, 1));
        let m2 = QMonomial::from_index(QIndex::new(1, 1));
        let product = m1.multiply(&m2);

        assert_eq!(product.degree(), 2);
        assert!(!product.is_one());

        let unit = QMonomial::one();
        assert!(unit.is_one());
        assert_eq!(unit.degree(), 0);
    }

    #[test]
    fn test_q_element_arithmetic() {
        let idx1 = QIndex::new(0, 1);
        let idx2 = QIndex::new(1, 1);

        let e1: QElement<Rational> = QElement::from_index(idx1);
        let e2: QElement<Rational> = QElement::from_index(idx2);

        let sum = e1.add(&e2);
        assert_eq!(sum.num_terms(), 2);

        let prod = e1.multiply(&e2);
        assert_eq!(prod.num_terms(), 1);

        let zero: QElement<Rational> = QElement::zero();
        assert!(zero.is_zero());

        let one: QElement<Rational> = QElement::one();
        let prod_one = e1.multiply(&one);
        assert_eq!(prod_one.num_terms(), e1.num_terms());
    }

    #[test]
    fn test_q_system_creation() {
        let a3 = CartanType::new(CartanLetter::A, 3).unwrap();
        let qs: QSystem<Rational> = QSystem::new(a3).unwrap();
        assert_eq!(qs.rank(), 3);

        let a1_aff = CartanType::new_affine(CartanLetter::A, 1, 1).unwrap();
        let qs_invalid: Option<QSystem<Rational>> = QSystem::new(a1_aff);
        assert!(qs_invalid.is_none());
    }

    #[test]
    fn test_q_system_generators() {
        let a2 = CartanType::new(CartanLetter::A, 2).unwrap();
        let qs: QSystem<Rational> = QSystem::new(a2).unwrap();

        let gens = qs.generators();
        assert_eq!(gens.len(), 2);

        let gen0 = qs.generator(0).unwrap();
        assert_eq!(gen0.num_terms(), 1);

        let gen_invalid = qs.generator(10);
        assert!(gen_invalid.is_none());
    }

    #[test]
    fn test_q_system_with_level() {
        let a3 = CartanType::new(CartanLetter::A, 3).unwrap();
        let qs: QSystem<Rational> = QSystem::with_level(a3, 5).unwrap();
        assert_eq!(qs.rank(), 3);
    }

    #[test]
    fn test_q_system_twisted() {
        let a3 = CartanType::new(CartanLetter::A, 3).unwrap();
        let qs: QSystem<Rational> = QSystem::twisted(a3).unwrap();
        assert_eq!(qs.rank(), 3);
    }

    #[test]
    fn test_q_computation() {
        let a2 = CartanType::new(CartanLetter::A, 2).unwrap();
        let mut qs: QSystem<Rational> = QSystem::new(a2).unwrap();

        // Q^(0)_0 should be 1
        let q_00 = qs.q(0, 0).unwrap();
        assert_eq!(q_00.num_terms(), 1);

        // Q^(0)_1 should be a generator
        let q_01 = qs.q(0, 1).unwrap();
        assert_eq!(q_01.num_terms(), 1);

        // Q^(0)_2 should be computed
        let q_02 = qs.q(0, 2).unwrap();
        assert!(!q_02.is_zero());

        // Invalid node
        let q_invalid = qs.q(10, 1);
        assert!(q_invalid.is_none());
    }

    #[test]
    fn test_q_element_display() {
        let idx = QIndex::new(0, 1);
        let elem: QElement<Rational> = QElement::from_index(idx);
        let display = format!("{}", elem);
        assert!(display.contains("Q^(0)_1"));

        let zero: QElement<Rational> = QElement::zero();
        assert_eq!(format!("{}", zero), "0");
    }

    #[test]
    fn test_q_system_display() {
        let a3 = CartanType::new(CartanLetter::A, 3).unwrap();
        let qs: QSystem<Rational> = QSystem::new(a3).unwrap();
        let display = format!("{}", qs);
        assert!(display.contains("Q-system"));
        assert!(display.contains("A_3"));
    }
}
