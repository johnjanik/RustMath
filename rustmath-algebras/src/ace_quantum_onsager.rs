//! ACE Quantum Onsager Algebra
//!
//! Implements the alternating central extension of the q-Onsager algebra,
//! a current algebra introduced by Baseilhac and Koizumi.
//!
//! The algebra is generated by three families of generators:
//! - G_n for n ∈ ℤ₊ (positive integers)
//! - W_n for n ∈ ℤ (all integers)
//! - Gt_n for n ∈ ℤ₊ (positive integers, t denotes "tilde")
//!
//! These generators satisfy seven fundamental commutation relations that define
//! a PBW (Poincaré-Birkhoff-Witt) basis ordering.
//!
//! Corresponds to sage.algebras.quantum_groups.ace_quantum_onsager

use rustmath_core::Ring;
use std::collections::HashMap;
use std::fmt::{self, Display};

/// Generators of the ACE quantum Onsager algebra
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum Generator {
    /// G_n generator for positive integer n
    G(u32),
    /// W_n generator for any integer n
    W(i32),
    /// Gt_n generator for positive integer n (tilde variant)
    Gt(u32),
}

impl Display for Generator {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Generator::G(n) => write!(f, "G_{}", n),
            Generator::W(n) => write!(f, "W_{}", n),
            Generator::Gt(n) => write!(f, "Gt_{}", n),
        }
    }
}

impl Generator {
    /// Get the degree of this generator
    ///
    /// - G_n and Gt_n have degree 2|n|
    /// - W_n has degree 2n-1 for n > 0, and -2n+1 for n ≤ 0
    pub fn degree(&self) -> i32 {
        match self {
            Generator::G(n) => 2 * (*n as i32),
            Generator::Gt(n) => 2 * (*n as i32),
            Generator::W(n) => {
                if *n > 0 {
                    2 * n - 1
                } else {
                    -2 * n + 1
                }
            }
        }
    }

    /// Apply the automorphism σ to this generator
    ///
    /// σ(G_n) = Gt_n, σ(Gt_n) = G_n, σ(W_n) = W_{-n+1}
    pub fn sigma(&self) -> Generator {
        match self {
            Generator::G(n) => Generator::Gt(*n),
            Generator::Gt(n) => Generator::G(*n),
            Generator::W(n) => Generator::W(-n + 1),
        }
    }
}

/// A monomial in the ACE quantum Onsager algebra
///
/// Represented as a sequence of generators in PBW ordering
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OnsagerMonomial {
    /// Sequence of generators in PBW order
    generators: Vec<Generator>,
}

impl OnsagerMonomial {
    /// Create the identity monomial (empty sequence)
    pub fn one() -> Self {
        OnsagerMonomial {
            generators: Vec::new(),
        }
    }

    /// Create a monomial from a single generator
    pub fn from_generator(gen: Generator) -> Self {
        OnsagerMonomial {
            generators: vec![gen],
        }
    }

    /// Create a monomial from a sequence of generators
    pub fn from_generators(gens: Vec<Generator>) -> Self {
        OnsagerMonomial { generators: gens }
    }

    /// Get the degree of this monomial
    pub fn degree(&self) -> i32 {
        self.generators.iter().map(|g| g.degree()).sum()
    }

    /// Check if this is the identity monomial
    pub fn is_one(&self) -> bool {
        self.generators.is_empty()
    }

    /// Get the number of generators in this monomial
    pub fn len(&self) -> usize {
        self.generators.len()
    }

    /// Apply the automorphism σ to this monomial
    pub fn sigma(&self) -> Self {
        OnsagerMonomial {
            generators: self.generators.iter().map(|g| g.sigma()).collect(),
        }
    }

    /// Apply the antiautomorphism † to this monomial
    ///
    /// Reverses the order and applies σ to each generator
    pub fn dagger(&self) -> Self {
        let mut reversed: Vec<Generator> = self.generators.iter().map(|g| g.sigma()).collect();
        reversed.reverse();
        OnsagerMonomial {
            generators: reversed,
        }
    }

    /// Get an iterator over the generators
    pub fn generators(&self) -> &[Generator] {
        &self.generators
    }
}

impl Display for OnsagerMonomial {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_one() {
            write!(f, "1")
        } else {
            for (i, gen) in self.generators.iter().enumerate() {
                if i > 0 {
                    write!(f, "*")?;
                }
                write!(f, "{}", gen)?;
            }
            Ok(())
        }
    }
}

/// An element of the ACE quantum Onsager algebra
///
/// Represented as a linear combination of monomials
#[derive(Debug, Clone)]
pub struct ACEOnsagerElement<R: Ring> {
    /// Map from monomial to coefficient
    terms: HashMap<OnsagerMonomial, R>,
}

impl<R: Ring> ACEOnsagerElement<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        ACEOnsagerElement {
            terms: HashMap::new(),
        }
    }

    /// Create the one element (multiplicative identity)
    pub fn one() -> Self
    where
        R: From<i64>,
    {
        let mut terms = HashMap::new();
        terms.insert(OnsagerMonomial::one(), R::from(1));
        ACEOnsagerElement { terms }
    }

    /// Create an element from a single monomial with coefficient
    pub fn from_monomial(monomial: OnsagerMonomial, coeff: R) -> Self {
        if coeff.is_zero() {
            return ACEOnsagerElement::zero();
        }
        let mut terms = HashMap::new();
        terms.insert(monomial, coeff);
        ACEOnsagerElement { terms }
    }

    /// Create an element from a single generator
    pub fn from_generator(gen: Generator) -> Self
    where
        R: From<i64>,
    {
        Self::from_monomial(OnsagerMonomial::from_generator(gen), R::from(1))
    }

    /// Add two elements
    pub fn add(&self, other: &ACEOnsagerElement<R>) -> ACEOnsagerElement<R> {
        let mut result = self.terms.clone();
        for (monomial, coeff) in &other.terms {
            let entry = result.entry(monomial.clone()).or_insert_with(R::zero);
            *entry = entry.add(coeff);
        }
        // Remove zero coefficients
        result.retain(|_, v| !v.is_zero());
        ACEOnsagerElement { terms: result }
    }

    /// Multiply by a scalar
    pub fn scale(&self, scalar: &R) -> ACEOnsagerElement<R> {
        if scalar.is_zero() {
            return ACEOnsagerElement::zero();
        }
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(m, c)| (m.clone(), c.mul(scalar)))
            .collect();
        ACEOnsagerElement { terms }
    }

    /// Negate the element
    pub fn negate(&self) -> ACEOnsagerElement<R> {
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(m, c)| (m.clone(), c.neg()))
            .collect();
        ACEOnsagerElement { terms }
    }

    /// Check if this is the zero element
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    /// Get the number of terms
    pub fn num_terms(&self) -> usize {
        self.terms.len()
    }

    /// Apply the automorphism σ to this element
    pub fn sigma(&self) -> Self
    where
        R: Clone,
    {
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(m, c)| (m.sigma(), c.clone()))
            .collect();
        ACEOnsagerElement { terms }
    }

    /// Apply the antiautomorphism † to this element
    pub fn dagger(&self) -> Self
    where
        R: Clone,
    {
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(m, c)| (m.dagger(), c.clone()))
            .collect();
        ACEOnsagerElement { terms }
    }

    /// Get the terms as a reference to the HashMap
    pub fn terms(&self) -> &HashMap<OnsagerMonomial, R> {
        &self.terms
    }
}

impl<R: Ring + Display> Display for ACEOnsagerElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut items: Vec<_> = self.terms.iter().collect();
        items.sort_by_key(|(m, _)| m.degree());

        for (i, (monomial, coeff)) in items.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            if monomial.is_one() {
                write!(f, "{}", coeff)?;
            } else {
                write!(f, "{}*{}", coeff, monomial)?;
            }
        }
        Ok(())
    }
}

/// The ACE quantum Onsager algebra
///
/// A combinatorial free module over a base ring R with quantum parameter q.
/// The algebra is generated by three families of generators (G, W, Gt) with
/// specific commutation relations.
pub struct ACEQuantumOnsagerAlgebra<R: Ring> {
    /// The base ring
    base_ring: R,
    /// The quantum parameter q (stored as an element of R)
    q: R,
}

impl<R: Ring + From<i64>> ACEQuantumOnsagerAlgebra<R> {
    /// Create a new ACE quantum Onsager algebra
    ///
    /// # Arguments
    /// * `base_ring` - The base ring for coefficients
    /// * `q` - The quantum parameter
    pub fn new(base_ring: R, q: R) -> Self {
        ACEQuantumOnsagerAlgebra { base_ring, q }
    }

    /// Get a reference to the base ring
    pub fn base_ring(&self) -> &R {
        &self.base_ring
    }

    /// Get a reference to the quantum parameter
    pub fn quantum_parameter(&self) -> &R {
        &self.q
    }

    /// Create the zero element
    pub fn zero(&self) -> ACEOnsagerElement<R> {
        ACEOnsagerElement::zero()
    }

    /// Create the one element
    pub fn one(&self) -> ACEOnsagerElement<R> {
        ACEOnsagerElement::one()
    }

    /// Get the G_n generator
    pub fn g(&self, n: u32) -> ACEOnsagerElement<R> {
        ACEOnsagerElement::from_generator(Generator::G(n))
    }

    /// Get the W_n generator
    pub fn w(&self, n: i32) -> ACEOnsagerElement<R> {
        ACEOnsagerElement::from_generator(Generator::W(n))
    }

    /// Get the Gt_n generator (tilde variant)
    pub fn gt(&self, n: u32) -> ACEOnsagerElement<R> {
        ACEOnsagerElement::from_generator(Generator::Gt(n))
    }

    /// Compute the product c = q^{-1}(q - q^{-1})^2
    ///
    /// This is the special parameter used in the ACE quantum Onsager algebra
    pub fn compute_c_parameter(&self) -> R
    where
        R: Clone,
    {
        // c = q^{-1}(q - q^{-1})^2
        // For simplicity, we return a symbolic representation
        // In practice, this would need to be computed based on the ring structure
        self.q.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_generator_display() {
        assert_eq!(format!("{}", Generator::G(1)), "G_1");
        assert_eq!(format!("{}", Generator::W(-2)), "W_-2");
        assert_eq!(format!("{}", Generator::Gt(3)), "Gt_3");
    }

    #[test]
    fn test_generator_degree() {
        assert_eq!(Generator::G(1).degree(), 2);
        assert_eq!(Generator::G(3).degree(), 6);
        assert_eq!(Generator::Gt(2).degree(), 4);
        assert_eq!(Generator::W(1).degree(), 1);
        assert_eq!(Generator::W(2).degree(), 3);
        assert_eq!(Generator::W(0).degree(), 1);
        assert_eq!(Generator::W(-1).degree(), 3);
    }

    #[test]
    fn test_generator_sigma() {
        assert_eq!(Generator::G(1).sigma(), Generator::Gt(1));
        assert_eq!(Generator::Gt(2).sigma(), Generator::G(2));
        assert_eq!(Generator::W(3).sigma(), Generator::W(-2));
        assert_eq!(Generator::W(0).sigma(), Generator::W(1));
    }

    #[test]
    fn test_monomial_one() {
        let m = OnsagerMonomial::one();
        assert!(m.is_one());
        assert_eq!(m.len(), 0);
        assert_eq!(m.degree(), 0);
        assert_eq!(format!("{}", m), "1");
    }

    #[test]
    fn test_monomial_from_generator() {
        let m = OnsagerMonomial::from_generator(Generator::G(1));
        assert!(!m.is_one());
        assert_eq!(m.len(), 1);
        assert_eq!(m.degree(), 2);
        assert_eq!(format!("{}", m), "G_1");
    }

    #[test]
    fn test_monomial_from_generators() {
        let m = OnsagerMonomial::from_generators(vec![
            Generator::G(1),
            Generator::W(2),
            Generator::Gt(1),
        ]);
        assert_eq!(m.len(), 3);
        assert_eq!(m.degree(), 2 + 3 + 2); // G_1=2, W_2=3, Gt_1=2
        assert_eq!(format!("{}", m), "G_1*W_2*Gt_1");
    }

    #[test]
    fn test_monomial_sigma() {
        let m = OnsagerMonomial::from_generators(vec![Generator::G(1), Generator::W(2)]);
        let sigma_m = m.sigma();
        assert_eq!(sigma_m.generators()[0], Generator::Gt(1));
        assert_eq!(sigma_m.generators()[1], Generator::W(-1));
    }

    #[test]
    fn test_monomial_dagger() {
        let m = OnsagerMonomial::from_generators(vec![Generator::G(1), Generator::W(2)]);
        let dagger_m = m.dagger();
        // † reverses and applies σ
        assert_eq!(dagger_m.generators()[0], Generator::W(-1)); // σ(W_2) = W_{-1}
        assert_eq!(dagger_m.generators()[1], Generator::Gt(1)); // σ(G_1) = Gt_1
    }

    #[test]
    fn test_element_zero() {
        let e: ACEOnsagerElement<Integer> = ACEOnsagerElement::zero();
        assert!(e.is_zero());
        assert_eq!(e.num_terms(), 0);
    }

    #[test]
    fn test_element_one() {
        let e: ACEOnsagerElement<Integer> = ACEOnsagerElement::one();
        assert!(!e.is_zero());
        assert_eq!(e.num_terms(), 1);
    }

    #[test]
    fn test_element_from_generator() {
        let e: ACEOnsagerElement<Integer> = ACEOnsagerElement::from_generator(Generator::G(1));
        assert!(!e.is_zero());
        assert_eq!(e.num_terms(), 1);
    }

    #[test]
    fn test_element_add() {
        let e1: ACEOnsagerElement<Integer> =
            ACEOnsagerElement::from_generator(Generator::G(1));
        let e2: ACEOnsagerElement<Integer> =
            ACEOnsagerElement::from_generator(Generator::W(2));
        let sum = e1.add(&e2);
        assert_eq!(sum.num_terms(), 2);
    }

    #[test]
    fn test_element_scale() {
        let e: ACEOnsagerElement<Integer> =
            ACEOnsagerElement::from_generator(Generator::G(1));
        let scaled = e.scale(&Integer::from(3));
        assert_eq!(scaled.num_terms(), 1);
    }

    #[test]
    fn test_element_negate() {
        let e: ACEOnsagerElement<Integer> =
            ACEOnsagerElement::from_generator(Generator::G(1));
        let neg = e.negate();
        assert_eq!(neg.num_terms(), 1);
    }

    #[test]
    fn test_element_sigma() {
        let e: ACEOnsagerElement<Integer> =
            ACEOnsagerElement::from_generator(Generator::G(1));
        let sigma_e = e.sigma();
        assert_eq!(sigma_e.num_terms(), 1);
        // Check that the generator was transformed correctly
        let monomial = sigma_e.terms().keys().next().unwrap();
        assert_eq!(monomial.generators()[0], Generator::Gt(1));
    }

    #[test]
    fn test_element_dagger() {
        let e: ACEOnsagerElement<Integer> =
            ACEOnsagerElement::from_generator(Generator::G(1));
        let dagger_e = e.dagger();
        assert_eq!(dagger_e.num_terms(), 1);
        let monomial = dagger_e.terms().keys().next().unwrap();
        assert_eq!(monomial.generators()[0], Generator::Gt(1));
    }

    #[test]
    fn test_algebra_creation() {
        let q = Integer::from(2);
        let algebra = ACEQuantumOnsagerAlgebra::new(Integer::from(0), q);
        let zero = algebra.zero();
        assert!(zero.is_zero());
        let one = algebra.one();
        assert!(!one.is_zero());
    }

    #[test]
    fn test_algebra_generators() {
        let q = Integer::from(2);
        let algebra = ACEQuantumOnsagerAlgebra::new(Integer::from(0), q);
        let g1 = algebra.g(1);
        assert_eq!(g1.num_terms(), 1);
        let w2 = algebra.w(2);
        assert_eq!(w2.num_terms(), 1);
        let gt3 = algebra.gt(3);
        assert_eq!(gt3.num_terms(), 1);
    }

    #[test]
    fn test_sigma_involution() {
        // σ² = id
        let m = OnsagerMonomial::from_generator(Generator::G(1));
        let sigma_twice = m.sigma().sigma();
        assert_eq!(m, sigma_twice);
    }

    #[test]
    fn test_dagger_involution() {
        // †² = id
        let m = OnsagerMonomial::from_generator(Generator::G(1));
        let dagger_twice = m.dagger().dagger();
        assert_eq!(m, dagger_twice);
    }

    #[test]
    fn test_complex_monomial() {
        let m = OnsagerMonomial::from_generators(vec![
            Generator::G(1),
            Generator::G(2),
            Generator::W(1),
            Generator::Gt(1),
        ]);
        assert_eq!(m.len(), 4);
        // Degrees: G_1=2, G_2=4, W_1=1, Gt_1=2
        assert_eq!(m.degree(), 2 + 4 + 1 + 2);
    }

    #[test]
    fn test_element_addition_same_monomial() {
        let m = OnsagerMonomial::from_generator(Generator::G(1));
        let e1: ACEOnsagerElement<Integer> = ACEOnsagerElement::from_monomial(m.clone(), Integer::from(2));
        let e2: ACEOnsagerElement<Integer> = ACEOnsagerElement::from_monomial(m, Integer::from(3));
        let sum = e1.add(&e2);
        // Should combine to 5*G_1
        assert_eq!(sum.num_terms(), 1);
    }

    #[test]
    fn test_element_cancellation() {
        let m = OnsagerMonomial::from_generator(Generator::G(1));
        let e1: ACEOnsagerElement<Integer> = ACEOnsagerElement::from_monomial(m.clone(), Integer::from(2));
        let e2: ACEOnsagerElement<Integer> = ACEOnsagerElement::from_monomial(m, Integer::from(-2));
        let sum = e1.add(&e2);
        // Should cancel to 0
        assert!(sum.is_zero());
    }
}
