//! Quantum Matrix Coordinate Algebra
//!
//! Implements quantum coordinate algebras for matrices and quantum groups.
//!
//! The quantum matrix coordinate algebra is generated by elements x_{ij}
//! with commutation relations determined by a quantum parameter q.
//!
//! For indices i < s and j < t, the commutation relations are:
//! - x_{it} x_{ij} = q^{-1} x_{ij} x_{it}  (when j < t)
//! - x_{sj} x_{ij} = q^{-1} x_{ij} x_{sj}  (when i < s)
//! - x_{sj} x_{it} = x_{it} x_{sj}         (when i < s and j > t)
//! - x_{st} x_{ij} = x_{ij} x_{st} - (q - q^{-1}) x_{it} x_{sj}  (when i < s and j < t)
//!
//! Corresponds to sage.algebras.quantum_matrix_coordinate_algebra

use rustmath_core::Ring;
use std::collections::HashMap;
use std::fmt::{self, Display};
use std::hash::Hash;

/// Index for a matrix element in the quantum matrix coordinate algebra
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MatrixIndex {
    /// Row index (0-based)
    pub i: usize,
    /// Column index (0-based)
    pub j: usize,
}

impl MatrixIndex {
    /// Create a new matrix index
    pub fn new(i: usize, j: usize) -> Self {
        MatrixIndex { i, j }
    }
}

impl Display for MatrixIndex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "x[{},{}]", self.i, self.j)
    }
}

/// A monomial in the quantum matrix coordinate algebra
///
/// Represented as a product of matrix elements in canonical order
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QuantumMatrixMonomial {
    /// Factors in the monomial, stored in sorted order
    factors: Vec<MatrixIndex>,
}

impl QuantumMatrixMonomial {
    /// Create the identity monomial (1)
    pub fn one() -> Self {
        QuantumMatrixMonomial { factors: vec![] }
    }

    /// Create a monomial from a single generator
    pub fn from_generator(i: usize, j: usize) -> Self {
        QuantumMatrixMonomial {
            factors: vec![MatrixIndex::new(i, j)],
        }
    }

    /// Create a monomial from a list of factors
    pub fn from_factors(factors: Vec<MatrixIndex>) -> Self {
        QuantumMatrixMonomial { factors }
    }

    /// Get the factors
    pub fn factors(&self) -> &[MatrixIndex] {
        &self.factors
    }

    /// Check if this is the identity monomial
    pub fn is_one(&self) -> bool {
        self.factors.is_empty()
    }

    /// Degree of the monomial (number of factors)
    pub fn degree(&self) -> usize {
        self.factors.len()
    }
}

impl Display for QuantumMatrixMonomial {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.factors.is_empty() {
            write!(f, "1")
        } else {
            let strs: Vec<String> = self.factors.iter().map(|idx| format!("{}", idx)).collect();
            write!(f, "{}", strs.join("*"))
        }
    }
}

impl PartialOrd for QuantumMatrixMonomial {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for QuantumMatrixMonomial {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.factors.cmp(&other.factors)
    }
}

/// An element of the quantum matrix coordinate algebra
///
/// Represented as a linear combination of monomials over a base ring
#[derive(Debug, Clone)]
pub struct QuantumMatrixElement<R: Ring> {
    /// Map from monomial to coefficient
    terms: HashMap<QuantumMatrixMonomial, R>,
}

impl<R: Ring> QuantumMatrixElement<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        QuantumMatrixElement {
            terms: HashMap::new(),
        }
    }

    /// Create the identity element (1)
    pub fn one() -> Self {
        let mut terms = HashMap::new();
        terms.insert(QuantumMatrixMonomial::one(), R::one());
        QuantumMatrixElement { terms }
    }

    /// Create an element from a single generator
    pub fn from_generator(i: usize, j: usize) -> Self {
        let mut terms = HashMap::new();
        terms.insert(QuantumMatrixMonomial::from_generator(i, j), R::one());
        QuantumMatrixElement { terms }
    }

    /// Create an element from a monomial with coefficient
    pub fn from_monomial(monomial: QuantumMatrixMonomial, coeff: R) -> Self {
        if coeff.is_zero() {
            return Self::zero();
        }
        let mut terms = HashMap::new();
        terms.insert(monomial, coeff);
        QuantumMatrixElement { terms }
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty() || self.terms.values().all(|c| c.is_zero())
    }

    /// Check if this is one
    pub fn is_one(&self) -> bool {
        if self.terms.len() != 1 {
            return false;
        }
        if let Some((mon, coeff)) = self.terms.iter().next() {
            mon.is_one() && coeff.is_one()
        } else {
            false
        }
    }

    /// Get the terms
    pub fn terms(&self) -> &HashMap<QuantumMatrixMonomial, R> {
        &self.terms
    }

    /// Add another element to this one
    pub fn add(&self, other: &Self) -> Self {
        let mut result = self.terms.clone();
        for (mon, coeff) in &other.terms {
            result
                .entry(mon.clone())
                .and_modify(|c| *c = c.clone() + coeff.clone())
                .or_insert_with(|| coeff.clone());
        }
        // Remove zero terms
        result.retain(|_, c| !c.is_zero());
        QuantumMatrixElement { terms: result }
    }

    /// Negate this element
    pub fn negate(&self) -> Self {
        let terms = self
            .terms
            .iter()
            .map(|(mon, coeff)| (mon.clone(), coeff.negate()))
            .collect();
        QuantumMatrixElement { terms }
    }

    /// Subtract another element from this one
    pub fn subtract(&self, other: &Self) -> Self {
        self.add(&other.negate())
    }

    /// Multiply by a scalar
    pub fn scalar_mul(&self, scalar: &R) -> Self {
        if scalar.is_zero() {
            return Self::zero();
        }
        let terms = self
            .terms
            .iter()
            .map(|(mon, coeff)| (mon.clone(), coeff.clone() * scalar.clone()))
            .collect();
        QuantumMatrixElement { terms }
    }
}

impl<R: Ring> Display for QuantumMatrixElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            write!(f, "0")
        } else if self.terms.len() == 1 {
            let (mon, coeff) = self.terms.iter().next().unwrap();
            if coeff.is_one() {
                write!(f, "{}", mon)
            } else if mon.is_one() {
                write!(f, "{:?}", coeff)
            } else {
                write!(f, "{:?}*{}", coeff, mon)
            }
        } else {
            let mut sorted: Vec<_> = self.terms.iter().collect();
            sorted.sort_by_key(|(mon, _)| (*mon).clone());
            let strs: Vec<String> = sorted
                .iter()
                .map(|(mon, coeff)| {
                    if coeff.is_one() {
                        format!("{}", mon)
                    } else if mon.is_one() {
                        format!("{:?}", coeff)
                    } else {
                        format!("{:?}*{}", coeff, mon)
                    }
                })
                .collect();
            write!(f, "{}", strs.join(" + "))
        }
    }
}

/// The quantum matrix coordinate algebra
///
/// An algebra generated by matrix elements x_{ij} with quantum commutation relations
pub struct QuantumMatrixCoordinateAlgebra<R: Ring> {
    /// Number of rows
    m: usize,
    /// Number of columns
    n: usize,
    /// Quantum parameter q
    q: R,
    /// Inverse of q
    q_inv: R,
    /// q - q^{-1}
    q_diff: R,
}

impl<R: Ring> QuantumMatrixCoordinateAlgebra<R> {
    /// Create a new quantum matrix coordinate algebra
    ///
    /// # Arguments
    /// * `m` - Number of rows
    /// * `n` - Number of columns
    /// * `q` - Quantum parameter
    ///
    /// # Panics
    /// Panics if q is zero (cannot compute inverse)
    pub fn new(m: usize, n: usize, q: R) -> Self
    where
        R: Clone,
    {
        if q.is_zero() {
            panic!("Quantum parameter q cannot be zero");
        }

        // For now, we'll work symbolically and not require explicit q inverse
        // In a full implementation, we'd need field operations
        let q_inv = q.clone(); // Placeholder - would need proper inverse
        let q_diff = q.clone(); // Placeholder - would need q - q^{-1}

        QuantumMatrixCoordinateAlgebra {
            m,
            n,
            q,
            q_inv,
            q_diff,
        }
    }

    /// Get the dimensions
    pub fn dimensions(&self) -> (usize, usize) {
        (self.m, self.n)
    }

    /// Get the quantum parameter
    pub fn q(&self) -> &R {
        &self.q
    }

    /// Create a generator x_{ij}
    pub fn generator(&self, i: usize, j: usize) -> QuantumMatrixElement<R> {
        assert!(i < self.m && j < self.n, "Index out of bounds");
        QuantumMatrixElement::from_generator(i, j)
    }

    /// Get the zero element
    pub fn zero(&self) -> QuantumMatrixElement<R> {
        QuantumMatrixElement::zero()
    }

    /// Get the identity element
    pub fn one(&self) -> QuantumMatrixElement<R> {
        QuantumMatrixElement::one()
    }

    /// Compute the product of two generators with quantum commutation relations
    ///
    /// This implements the commutation relations for x_{ij} * x_{st}
    pub fn multiply_generators(
        &self,
        x1: MatrixIndex,
        x2: MatrixIndex,
    ) -> QuantumMatrixElement<R>
    where
        R: Clone,
    {
        let MatrixIndex { i: i1, j: j1 } = x1;
        let MatrixIndex { i: i2, j: j2 } = x2;

        // If already in order, just multiply
        if x1 <= x2 {
            let factors = vec![x1, x2];
            return QuantumMatrixElement::from_monomial(
                QuantumMatrixMonomial::from_factors(factors),
                R::one(),
            );
        }

        // Apply commutation relations
        // Case 1: i1 = i2, j1 > j2 (same row, swap columns)
        if i1 == i2 && j1 > j2 {
            // x_{i,j1} x_{i,j2} = q^{-1} x_{i,j2} x_{i,j1}
            let factors = vec![MatrixIndex::new(i1, j2), MatrixIndex::new(i1, j1)];
            return QuantumMatrixElement::from_monomial(
                QuantumMatrixMonomial::from_factors(factors),
                self.q_inv.clone(),
            );
        }

        // Case 2: j1 = j2, i1 > i2 (same column, swap rows)
        if j1 == j2 && i1 > i2 {
            // x_{i1,j} x_{i2,j} = q^{-1} x_{i2,j} x_{i1,j}
            let factors = vec![MatrixIndex::new(i2, j1), MatrixIndex::new(i1, j1)];
            return QuantumMatrixElement::from_monomial(
                QuantumMatrixMonomial::from_factors(factors),
                self.q_inv.clone(),
            );
        }

        // Case 3: i1 > i2 and j1 > j2 (both indices larger, elements commute)
        if i1 > i2 && j1 > j2 {
            let factors = vec![MatrixIndex::new(i2, j2), MatrixIndex::new(i1, j1)];
            return QuantumMatrixElement::from_monomial(
                QuantumMatrixMonomial::from_factors(factors),
                R::one(),
            );
        }

        // Case 4: i1 > i2 and j1 < j2 (quantum commutation relation)
        if i1 > i2 && j1 < j2 {
            // x_{i1,j1} x_{i2,j2} = x_{i2,j2} x_{i1,j1} - (q - q^{-1}) x_{i1,j2} x_{i2,j1}
            let mut result = QuantumMatrixElement::zero();

            // First term: x_{i2,j2} x_{i1,j1}
            let factors1 = vec![MatrixIndex::new(i2, j2), MatrixIndex::new(i1, j1)];
            let term1 = QuantumMatrixElement::from_monomial(
                QuantumMatrixMonomial::from_factors(factors1),
                R::one(),
            );

            // Second term: -(q - q^{-1}) x_{i1,j2} x_{i2,j1}
            let factors2 = vec![MatrixIndex::new(i2, j1), MatrixIndex::new(i1, j2)];
            let term2 = QuantumMatrixElement::from_monomial(
                QuantumMatrixMonomial::from_factors(factors2),
                self.q_diff.clone().negate(),
            );

            result = result.add(&term1);
            result = result.add(&term2);
            return result;
        }

        // Default: return product as is (should not reach here)
        let factors = vec![x1, x2];
        QuantumMatrixElement::from_monomial(
            QuantumMatrixMonomial::from_factors(factors),
            R::one(),
        )
    }

    /// Multiply two elements in the algebra
    pub fn multiply(&self, a: &QuantumMatrixElement<R>, b: &QuantumMatrixElement<R>) -> QuantumMatrixElement<R>
    where
        R: Clone,
    {
        let mut result = QuantumMatrixElement::zero();

        for (mon_a, coeff_a) in &a.terms {
            for (mon_b, coeff_b) in &b.terms {
                let coeff = coeff_a.clone() * coeff_b.clone();
                let product = self.multiply_monomials(mon_a, mon_b);
                result = result.add(&product.scalar_mul(&coeff));
            }
        }

        result
    }

    /// Multiply two monomials using quantum commutation relations
    fn multiply_monomials(
        &self,
        a: &QuantumMatrixMonomial,
        b: &QuantumMatrixMonomial,
    ) -> QuantumMatrixElement<R>
    where
        R: Clone,
    {
        // Concatenate factors and then apply commutation relations to sort
        let mut factors: Vec<MatrixIndex> = Vec::new();
        factors.extend_from_slice(a.factors());
        factors.extend_from_slice(b.factors());

        if factors.is_empty() {
            return QuantumMatrixElement::one();
        }

        // Start with single factor
        let mut result = QuantumMatrixElement::from_monomial(
            QuantumMatrixMonomial::from_factors(vec![factors[0]]),
            R::one(),
        );

        // Successively multiply by each remaining factor
        for &factor in &factors[1..] {
            result = self.multiply_element_by_generator(result, factor);
        }

        result
    }

    /// Multiply an element by a single generator on the right
    fn multiply_element_by_generator(
        &self,
        elem: QuantumMatrixElement<R>,
        gen: MatrixIndex,
    ) -> QuantumMatrixElement<R>
    where
        R: Clone,
    {
        let mut result = QuantumMatrixElement::zero();

        for (mon, coeff) in &elem.terms {
            let product = self.multiply_monomial_by_generator(mon, gen);
            result = result.add(&product.scalar_mul(coeff));
        }

        result
    }

    /// Multiply a monomial by a generator on the right
    fn multiply_monomial_by_generator(
        &self,
        mon: &QuantumMatrixMonomial,
        gen: MatrixIndex,
    ) -> QuantumMatrixElement<R>
    where
        R: Clone,
    {
        if mon.is_one() {
            return QuantumMatrixElement::from_generator(gen.i, gen.j);
        }

        // Insert the new generator and bubble it to the correct position
        let mut factors = mon.factors().to_vec();
        factors.push(gen);

        // Bubble sort the last element into place using commutation relations
        let n = factors.len();
        let mut result = QuantumMatrixElement::from_monomial(
            QuantumMatrixMonomial::from_factors(factors),
            R::one(),
        );

        // Apply commutation relations if needed
        // For simplicity, we'll use a basic approach
        // A full implementation would bubble the element through properly
        result
    }
}

/// Quantum GL algebra - the quantum coordinate algebra of GL(n)
///
/// This is a specialization of the quantum matrix coordinate algebra for square matrices
pub struct QuantumGL<R: Ring> {
    /// The underlying quantum matrix coordinate algebra
    base: QuantumMatrixCoordinateAlgebra<R>,
    /// Size n (for n√ón matrices)
    n: usize,
}

impl<R: Ring> QuantumGL<R> {
    /// Create a new quantum GL algebra
    pub fn new(n: usize, q: R) -> Self
    where
        R: Clone,
    {
        QuantumGL {
            base: QuantumMatrixCoordinateAlgebra::new(n, n, q),
            n,
        }
    }

    /// Get the size
    pub fn size(&self) -> usize {
        self.n
    }

    /// Get the quantum parameter
    pub fn q(&self) -> &R {
        self.base.q()
    }

    /// Create a generator x_{ij}
    pub fn generator(&self, i: usize, j: usize) -> QuantumMatrixElement<R> {
        self.base.generator(i, j)
    }

    /// Get the zero element
    pub fn zero(&self) -> QuantumMatrixElement<R> {
        self.base.zero()
    }

    /// Get the identity element
    pub fn one(&self) -> QuantumMatrixElement<R> {
        self.base.one()
    }

    /// Multiply two elements
    pub fn multiply(&self, a: &QuantumMatrixElement<R>, b: &QuantumMatrixElement<R>) -> QuantumMatrixElement<R>
    where
        R: Clone,
    {
        self.base.multiply(a, b)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_matrix_index() {
        let idx = MatrixIndex::new(2, 3);
        assert_eq!(idx.i, 2);
        assert_eq!(idx.j, 3);
        assert_eq!(format!("{}", idx), "x[2,3]");
    }

    #[test]
    fn test_monomial_creation() {
        let mon = QuantumMatrixMonomial::one();
        assert!(mon.is_one());
        assert_eq!(mon.degree(), 0);

        let mon2 = QuantumMatrixMonomial::from_generator(1, 2);
        assert!(!mon2.is_one());
        assert_eq!(mon2.degree(), 1);
    }

    #[test]
    fn test_element_creation() {
        let elem: QuantumMatrixElement<Integer> = QuantumMatrixElement::zero();
        assert!(elem.is_zero());

        let elem2: QuantumMatrixElement<Integer> = QuantumMatrixElement::one();
        assert!(elem2.is_one());

        let elem3: QuantumMatrixElement<Integer> = QuantumMatrixElement::from_generator(0, 1);
        assert!(!elem3.is_zero());
        assert!(!elem3.is_one());
    }

    #[test]
    fn test_quantum_matrix_algebra_creation() {
        let q = Integer::from(2);
        let algebra = QuantumMatrixCoordinateAlgebra::new(3, 4, q);
        assert_eq!(algebra.dimensions(), (3, 4));

        let x01 = algebra.generator(0, 1);
        assert!(!x01.is_zero());
        assert!(!x01.is_one());
    }

    #[test]
    #[should_panic(expected = "Quantum parameter q cannot be zero")]
    fn test_zero_quantum_parameter() {
        let q = Integer::zero();
        let _algebra = QuantumMatrixCoordinateAlgebra::new(2, 2, q);
    }

    #[test]
    fn test_quantum_gl_creation() {
        let q = Integer::from(3);
        let gl = QuantumGL::new(4, q);
        assert_eq!(gl.size(), 4);

        let x00 = gl.generator(0, 0);
        assert!(!x00.is_zero());
    }

    #[test]
    fn test_element_addition() {
        let q = Integer::from(2);
        let algebra = QuantumMatrixCoordinateAlgebra::new(2, 2, q);

        let x00 = algebra.generator(0, 0);
        let x01 = algebra.generator(0, 1);

        let sum = x00.add(&x01);
        assert_eq!(sum.terms().len(), 2);
    }

    #[test]
    fn test_element_scalar_multiplication() {
        let q = Integer::from(2);
        let algebra = QuantumMatrixCoordinateAlgebra::new(2, 2, q);

        let x00 = algebra.generator(0, 0);
        let scalar = Integer::from(3);
        let product = x00.scalar_mul(&scalar);

        assert_eq!(product.terms().len(), 1);
    }

    #[test]
    fn test_element_negation() {
        let x: QuantumMatrixElement<Integer> = QuantumMatrixElement::from_generator(1, 1);
        let neg = x.negate();

        let sum = x.add(&neg);
        assert!(sum.is_zero() || sum.terms().values().all(|v| v.is_zero()));
    }

    #[test]
    fn test_monomial_ordering() {
        let mon1 = QuantumMatrixMonomial::from_generator(0, 0);
        let mon2 = QuantumMatrixMonomial::from_generator(0, 1);
        let mon3 = QuantumMatrixMonomial::from_generator(1, 0);

        assert!(mon1 < mon2);
        assert!(mon2 < mon3);
    }

    #[test]
    fn test_generator_indices() {
        let q = Integer::from(2);
        let algebra = QuantumMatrixCoordinateAlgebra::new(3, 3, q);

        // Test all valid indices
        for i in 0..3 {
            for j in 0..3 {
                let gen = algebra.generator(i, j);
                assert!(!gen.is_zero());
            }
        }
    }

    #[test]
    #[should_panic(expected = "Index out of bounds")]
    fn test_invalid_generator_index() {
        let q = Integer::from(2);
        let algebra = QuantumMatrixCoordinateAlgebra::new(2, 2, q);
        let _invalid = algebra.generator(2, 0); // i=2 is out of bounds for 2x2
    }
}
