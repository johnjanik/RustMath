//! Weyl Algebra (Differential Weyl Algebra) Implementation
//!
//! The Weyl algebra A_n(R) is the algebra of differential operators over a ring R.
//! It is generated by variables x_1, ..., x_n and partial derivatives ∂_1, ..., ∂_n
//! with the commutation relations:
//!
//! - [∂_i, x_j] = δ_ij (Kronecker delta)
//! - [x_i, x_j] = 0
//! - [∂_i, ∂_j] = 0
//!
//! # Mathematical Background
//!
//! The Weyl algebra is a fundamental object in:
//! - Representation theory
//! - Quantum mechanics (canonical commutation relations)
//! - D-module theory
//! - Symbolic computation of differential operators
//!
//! Elements are represented as polynomials in the generators with the
//! non-commutative multiplication determined by the commutation relations.
//!
//! # Examples
//!
//! ```
//! use rustmath_algebras::weyl_algebra::{WeylAlgebra, WeylElement};
//! use rustmath_rationals::Rational;
//!
//! // Create Weyl algebra in 2 variables
//! let weyl = WeylAlgebra::<Rational>::new(2);
//!
//! // Get generators: x_0, x_1, d_0, d_1
//! let x0 = weyl.x_generator(0);
//! let d0 = weyl.d_generator(0);
//!
//! // Verify [d_0, x_0] = 1
//! let commutator = d0.multiply(&x0).sub(&x0.multiply(&d0));
//! assert_eq!(commutator, weyl.one());
//! ```

use rustmath_core::{Ring, Field};
use std::collections::HashMap;
use std::fmt;

/// A monomial in the Weyl algebra
///
/// Represented in normal form: x_0^{a_0} ... x_{n-1}^{a_{n-1}} ∂_0^{b_0} ... ∂_{n-1}^{b_{n-1}}
/// where all x's come before all ∂'s (due to commutation relations)
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct WeylMonomial {
    /// Powers of x variables (x_i^{x_powers[i]})
    x_powers: Vec<usize>,
    /// Powers of ∂ variables (∂_i^{d_powers[i]})
    d_powers: Vec<usize>,
}

impl WeylMonomial {
    /// Create a new Weyl monomial
    pub fn new(x_powers: Vec<usize>, d_powers: Vec<usize>) -> Self {
        assert_eq!(x_powers.len(), d_powers.len(), "Dimension mismatch");
        Self { x_powers, d_powers }
    }

    /// Create the unit monomial
    pub fn unit(dimension: usize) -> Self {
        Self {
            x_powers: vec![0; dimension],
            d_powers: vec![0; dimension],
        }
    }

    /// Get the dimension
    pub fn dimension(&self) -> usize {
        self.x_powers.len()
    }

    /// Get total degree in x variables
    pub fn x_degree(&self) -> usize {
        self.x_powers.iter().sum()
    }

    /// Get total degree in ∂ variables
    pub fn d_degree(&self) -> usize {
        self.d_powers.iter().sum()
    }

    /// Get total degree
    pub fn total_degree(&self) -> usize {
        self.x_degree() + self.d_degree()
    }

    /// Check if this is the unit monomial
    pub fn is_unit(&self) -> bool {
        self.x_powers.iter().all(|&p| p == 0) && self.d_powers.iter().all(|&p| p == 0)
    }

    /// Multiply by x_i
    pub fn mul_x(&self, i: usize) -> Self {
        let mut result = self.clone();
        result.x_powers[i] += 1;
        result
    }

    /// Multiply by ∂_i
    pub fn mul_d(&self, i: usize) -> Self {
        let mut result = self.clone();
        result.d_powers[i] += 1;
        result
    }
}

impl fmt::Display for WeylMonomial {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_unit() {
            return write!(f, "1");
        }

        let mut parts = Vec::new();

        // x variables
        for (i, &pow) in self.x_powers.iter().enumerate() {
            if pow > 0 {
                if pow == 1 {
                    parts.push(format!("x_{}", i));
                } else {
                    parts.push(format!("x_{}^{}", i, pow));
                }
            }
        }

        // ∂ variables
        for (i, &pow) in self.d_powers.iter().enumerate() {
            if pow > 0 {
                if pow == 1 {
                    parts.push(format!("∂_{}", i));
                } else {
                    parts.push(format!("∂_{}^{}", i, pow));
                }
            }
        }

        write!(f, "{}", parts.join("·"))
    }
}

/// An element of the Weyl algebra
#[derive(Debug, Clone, PartialEq)]
pub struct WeylElement<R: Ring> {
    /// Coefficients for each monomial
    terms: HashMap<WeylMonomial, R>,
    /// Number of variables
    dimension: usize,
}

impl<R: Ring> WeylElement<R> {
    /// Create a new Weyl element
    pub fn new(dimension: usize) -> Self {
        Self {
            terms: HashMap::new(),
            dimension,
        }
    }

    /// Create from a single monomial
    pub fn from_monomial(monomial: WeylMonomial, coefficient: R) -> Self {
        let dimension = monomial.dimension();
        let mut terms = HashMap::new();
        if !coefficient.is_zero() {
            terms.insert(monomial, coefficient);
        }
        Self { terms, dimension }
    }

    /// Create zero element
    pub fn zero(dimension: usize) -> Self {
        Self::new(dimension)
    }

    /// Create unit element
    pub fn one(dimension: usize) -> Self {
        Self::from_monomial(WeylMonomial::unit(dimension), R::one())
    }

    /// Check if zero
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    /// Check if this equals the unit
    pub fn is_one(&self) -> bool {
        if self.terms.len() != 1 {
            return false;
        }
        if let Some((monomial, coeff)) = self.terms.iter().next() {
            monomial.is_unit() && coeff.is_one()
        } else {
            false
        }
    }

    /// Get dimension
    pub fn dimension(&self) -> usize {
        self.dimension
    }

    /// Add a term
    pub fn add_term(&mut self, monomial: WeylMonomial, coefficient: R) {
        if coefficient.is_zero() {
            return;
        }

        let entry = self.terms.entry(monomial).or_insert_with(R::zero);
        *entry = entry.clone() + coefficient;

        // Remove if it becomes zero
        let is_zero = entry.is_zero();
        if is_zero {
            // We need to get the key again since we can't remove during iteration
            let keys_to_remove: Vec<_> = self.terms.iter()
                .filter(|(_, v)| v.is_zero())
                .map(|(k, _)| k.clone())
                .collect();
            for key in keys_to_remove {
                self.terms.remove(&key);
            }
        }
    }

    /// Addition
    pub fn add(&self, other: &Self) -> Self {
        assert_eq!(self.dimension, other.dimension, "Dimension mismatch");
        let mut result = self.clone();
        for (monomial, coeff) in &other.terms {
            result.add_term(monomial.clone(), coeff.clone());
        }
        result
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Self {
        if scalar.is_zero() {
            return Self::zero(self.dimension);
        }
        let mut result = Self::new(self.dimension);
        for (monomial, coeff) in &self.terms {
            result.terms.insert(monomial.clone(), coeff.clone() * scalar.clone());
        }
        result
    }

    /// Negation
    pub fn negate(&self) -> Self {
        self.scalar_mul(&R::zero().sub(&R::one()))
    }

    /// Subtraction
    pub fn sub(&self, other: &Self) -> Self {
        self.add(&other.negate())
    }

    /// Multiply two monomials using commutation relations
    ///
    /// Key insight: When we have ∂_i * x_i, we use [∂_i, x_i] = 1
    /// So ∂_i * x_i = x_i * ∂_i + 1
    fn multiply_monomials(m1: &WeylMonomial, m2: &WeylMonomial) -> HashMap<WeylMonomial, usize> {
        let n = m1.dimension();
        let mut result: HashMap<WeylMonomial, usize> = HashMap::new();

        // We need to commute all ∂'s from m1 past all x's from m2
        // Start with the trivial contribution (no commutations)
        let mut current = WeylMonomial::new(
            m1.x_powers.iter().zip(&m2.x_powers).map(|(a, b)| a + b).collect(),
            m1.d_powers.iter().zip(&m2.d_powers).map(|(a, b)| a + b).collect(),
        );

        // For each pair (i, power_d1, power_x2), we have ∂_i^{d1} * x_i^{x2}
        // This generates binomial coefficients from commutations
        // ∂^k * x^l = Σ_{j=0}^{min(k,l)} C(k,j)*C(l,j)*j! * x^{l-j} * ∂^{k-j}

        // Simplified approach: Start with x's from m1, then ∂'s from m1, then x's from m2, then ∂'s from m2
        // Move ∂'s from m1 past x's from m2

        result.insert(current, 1);

        // For each variable i
        for i in 0..n {
            let d1 = m1.d_powers[i];
            let x2 = m2.x_powers[i];

            if d1 > 0 && x2 > 0 {
                // We need to handle ∂_i^{d1} passing by x_i^{x2}
                // This creates terms with different powers due to commutation
                let mut new_result: HashMap<WeylMonomial, usize> = HashMap::new();

                for (monomial, coeff) in result {
                    // Apply commutation: each ∂_i that passes x_i contributes a factor
                    for k in 0..=std::cmp::min(d1, x2) {
                        let mut new_monomial = monomial.clone();
                        // Adjust powers for commutation at position i
                        new_monomial.x_powers[i] = new_monomial.x_powers[i] - k;
                        new_monomial.d_powers[i] = new_monomial.d_powers[i] - k;

                        // Binomial coefficient and factorial
                        let binom_factor = binomial(d1, k) * binomial(x2, k) * factorial(k);
                        let new_coeff = coeff * binom_factor;

                        *new_result.entry(new_monomial).or_insert(0) += new_coeff;
                    }
                }
                result = new_result;
            }
        }

        result
    }

    /// Multiplication in the Weyl algebra
    pub fn multiply(&self, other: &Self) -> Self {
        assert_eq!(self.dimension, other.dimension, "Dimension mismatch");

        let mut result = Self::new(self.dimension);

        for (m1, c1) in &self.terms {
            for (m2, c2) in &other.terms {
                let products = Self::multiply_monomials(m1, m2);
                for (monomial, factor) in products {
                    let coeff = c1.clone() * c2.clone() * R::from_int(factor as i64);
                    result.add_term(monomial, coeff);
                }
            }
        }

        result
    }

    /// Compute commutator [self, other]
    pub fn commutator(&self, other: &Self) -> Self {
        self.multiply(other).sub(&other.multiply(self))
    }
}

impl<R: Ring> fmt::Display for WeylElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut terms: Vec<_> = self.terms.iter().collect();
        terms.sort_by_key(|(m, _)| *m);

        let mut first = true;
        for (monomial, coeff) in terms {
            if !first {
                write!(f, " + ")?;
            }
            first = false;

            if monomial.is_unit() {
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "{}", monomial)?;
            } else {
                write!(f, "{}·{}", coeff, monomial)?;
            }
        }
        Ok(())
    }
}

/// The differential Weyl algebra
#[derive(Debug, Clone)]
pub struct WeylAlgebra<R: Ring> {
    /// Number of variables
    dimension: usize,
    _phantom: std::marker::PhantomData<R>,
}

impl<R: Ring> WeylAlgebra<R> {
    /// Create a new Weyl algebra with n variables
    pub fn new(dimension: usize) -> Self {
        Self {
            dimension,
            _phantom: std::marker::PhantomData,
        }
    }

    /// Get the dimension (number of x and ∂ pairs)
    pub fn dimension(&self) -> usize {
        self.dimension
    }

    /// Get the x_i generator
    pub fn x_generator(&self, i: usize) -> WeylElement<R> {
        assert!(i < self.dimension, "Index out of bounds");
        let mut x_powers = vec![0; self.dimension];
        x_powers[i] = 1;
        WeylElement::from_monomial(
            WeylMonomial::new(x_powers, vec![0; self.dimension]),
            R::one(),
        )
    }

    /// Get the ∂_i generator
    pub fn d_generator(&self, i: usize) -> WeylElement<R> {
        assert!(i < self.dimension, "Index out of bounds");
        let mut d_powers = vec![0; self.dimension];
        d_powers[i] = 1;
        WeylElement::from_monomial(
            WeylMonomial::new(vec![0; self.dimension], d_powers),
            R::one(),
        )
    }

    /// Get zero element
    pub fn zero(&self) -> WeylElement<R> {
        WeylElement::zero(self.dimension)
    }

    /// Get unit element
    pub fn one(&self) -> WeylElement<R> {
        WeylElement::one(self.dimension)
    }

    /// Create a monomial x^a * ∂^b
    pub fn monomial(&self, x_powers: Vec<usize>, d_powers: Vec<usize>) -> WeylElement<R> {
        assert_eq!(x_powers.len(), self.dimension);
        assert_eq!(d_powers.len(), self.dimension);
        WeylElement::from_monomial(WeylMonomial::new(x_powers, d_powers), R::one())
    }
}

// Helper functions for binomial coefficients and factorials
fn binomial(n: usize, k: usize) -> usize {
    if k > n {
        return 0;
    }
    if k == 0 || k == n {
        return 1;
    }
    let k = std::cmp::min(k, n - k);
    let mut result = 1;
    for i in 0..k {
        result = result * (n - i) / (i + 1);
    }
    result
}

fn factorial(n: usize) -> usize {
    (1..=n).product()
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;
    use rustmath_integers::Integer;

    #[test]
    fn test_weyl_monomial_creation() {
        let m = WeylMonomial::new(vec![1, 2], vec![3, 0]);
        assert_eq!(m.dimension(), 2);
        assert_eq!(m.x_degree(), 3);
        assert_eq!(m.d_degree(), 3);
        assert_eq!(m.total_degree(), 6);
    }

    #[test]
    fn test_weyl_algebra_creation() {
        let weyl = WeylAlgebra::<Rational>::new(2);
        assert_eq!(weyl.dimension(), 2);
    }

    #[test]
    fn test_generators() {
        let weyl = WeylAlgebra::<Integer>::new(2);
        let x0 = weyl.x_generator(0);
        let x1 = weyl.x_generator(1);
        let d0 = weyl.d_generator(0);
        let d1 = weyl.d_generator(1);

        assert!(!x0.is_zero());
        assert!(!x1.is_zero());
        assert!(!d0.is_zero());
        assert!(!d1.is_zero());
    }

    #[test]
    fn test_addition() {
        let weyl = WeylAlgebra::<Rational>::new(2);
        let x0 = weyl.x_generator(0);
        let x1 = weyl.x_generator(1);

        let sum = x0.add(&x1);
        assert!(!sum.is_zero());

        let diff = sum.sub(&sum);
        assert!(diff.is_zero());
    }

    #[test]
    fn test_scalar_multiplication() {
        let weyl = WeylAlgebra::<Rational>::new(1);
        let x = weyl.x_generator(0);

        let two = Rational::from(2);
        let scaled = x.scalar_mul(&two);
        assert!(!scaled.is_zero());
    }

    #[test]
    fn test_canonical_commutation_relation() {
        // Test [∂, x] = 1
        let weyl = WeylAlgebra::<Rational>::new(1);
        let x = weyl.x_generator(0);
        let d = weyl.d_generator(0);

        let dx = d.multiply(&x);
        let xd = x.multiply(&d);
        let commutator = dx.sub(&xd);

        // [∂, x] should equal 1
        assert_eq!(commutator, weyl.one());
    }

    #[test]
    fn test_x_variables_commute() {
        // Test [x_i, x_j] = 0
        let weyl = WeylAlgebra::<Integer>::new(2);
        let x0 = weyl.x_generator(0);
        let x1 = weyl.x_generator(1);

        let prod1 = x0.multiply(&x1);
        let prod2 = x1.multiply(&x0);

        assert_eq!(prod1, prod2);
    }

    #[test]
    fn test_d_variables_commute() {
        // Test [∂_i, ∂_j] = 0
        let weyl = WeylAlgebra::<Integer>::new(2);
        let d0 = weyl.d_generator(0);
        let d1 = weyl.d_generator(1);

        let prod1 = d0.multiply(&d1);
        let prod2 = d1.multiply(&d0);

        assert_eq!(prod1, prod2);
    }

    #[test]
    fn test_different_indices_commute() {
        // Test [∂_i, x_j] = 0 for i ≠ j
        let weyl = WeylAlgebra::<Rational>::new(2);
        let x0 = weyl.x_generator(0);
        let d1 = weyl.d_generator(1);

        let commutator = d1.multiply(&x0).sub(&x0.multiply(&d1));
        assert!(commutator.is_zero());
    }

    #[test]
    fn test_unit_element() {
        let weyl = WeylAlgebra::<Rational>::new(2);
        let one = weyl.one();
        let x0 = weyl.x_generator(0);

        // 1 * x = x
        let prod1 = one.multiply(&x0);
        assert_eq!(prod1, x0);

        // x * 1 = x
        let prod2 = x0.multiply(&one);
        assert_eq!(prod2, x0);
    }

    #[test]
    fn test_associativity() {
        let weyl = WeylAlgebra::<Rational>::new(1);
        let x = weyl.x_generator(0);
        let d = weyl.d_generator(0);

        // (x * d) * x = x * (d * x)
        let left = x.multiply(&d).multiply(&x);
        let right = x.multiply(&d.multiply(&x));

        assert_eq!(left, right);
    }

    #[test]
    fn test_distributivity() {
        let weyl = WeylAlgebra::<Rational>::new(1);
        let x = weyl.x_generator(0);
        let d = weyl.d_generator(0);

        // d * (x + x) = d*x + d*x
        let sum = x.add(&x);
        let left = d.multiply(&sum);
        let right = d.multiply(&x).add(&d.multiply(&x));

        assert_eq!(left, right);
    }

    #[test]
    fn test_binomial_helper() {
        assert_eq!(binomial(5, 0), 1);
        assert_eq!(binomial(5, 1), 5);
        assert_eq!(binomial(5, 2), 10);
        assert_eq!(binomial(5, 3), 10);
        assert_eq!(binomial(5, 5), 1);
    }

    #[test]
    fn test_factorial_helper() {
        assert_eq!(factorial(0), 1);
        assert_eq!(factorial(1), 1);
        assert_eq!(factorial(5), 120);
    }

    #[test]
    fn test_zero_properties() {
        let weyl = WeylAlgebra::<Rational>::new(2);
        let zero = weyl.zero();
        let x0 = weyl.x_generator(0);

        // 0 + x = x
        assert_eq!(zero.add(&x0), x0);

        // 0 * x = 0
        let prod = zero.multiply(&x0);
        assert!(prod.is_zero());
    }
}
