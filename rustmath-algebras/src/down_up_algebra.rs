//! Down-Up Algebra
//!
//! The down-up algebra DU(α, β, γ) is an associative unital algebra
//! generated by two elements d (down) and u (up) satisfying the relations:
//! - d²u = αdud + βud² + γd
//! - du² = αudu + βu²d + γu
//!
//! The algebra admits a PBW-type basis consisting of monomials:
//! {u^i(du)^j d^k | i,j,k ∈ ℤ≥0}
//!
//! Corresponds to sage.algebras.down_up_algebra
//!
//! References:
//! - Benkart, G. and Roby, T. "Down-Up Algebras" (1998)
//! - Differential poset theory

use rustmath_core::{Ring, Field};
use rustmath_modules::CombinatorialFreeModuleElement;
use std::collections::HashMap;
use std::fmt::{self, Display};

/// Basis index for the down-up algebra
///
/// Represents the monomial u^i (du)^j d^k
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DownUpBasisIndex {
    /// Exponent of u
    pub i: usize,
    /// Exponent of du
    pub j: usize,
    /// Exponent of d
    pub k: usize,
}

impl DownUpBasisIndex {
    /// Create a new basis index for u^i (du)^j d^k
    pub fn new(i: usize, j: usize, k: usize) -> Self {
        DownUpBasisIndex { i, j, k }
    }

    /// Degree of this basis element
    ///
    /// The grading is deg(u^i (du)^j d^k) = i - k
    pub fn degree(&self) -> isize {
        self.i as isize - self.k as isize
    }

    /// Check if this is the identity (1 = u^0 (du)^0 d^0)
    pub fn is_identity(&self) -> bool {
        self.i == 0 && self.j == 0 && self.k == 0
    }
}

impl Display for DownUpBasisIndex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_identity() {
            return write!(f, "1");
        }

        let mut parts = Vec::new();

        if self.i > 0 {
            if self.i == 1 {
                parts.push("u".to_string());
            } else {
                parts.push(format!("u^{}", self.i));
            }
        }

        if self.j > 0 {
            if self.j == 1 {
                parts.push("(du)".to_string());
            } else {
                parts.push(format!("(du)^{}", self.j));
            }
        }

        if self.k > 0 {
            if self.k == 1 {
                parts.push("d".to_string());
            } else {
                parts.push(format!("d^{}", self.k));
            }
        }

        write!(f, "{}", parts.join(""))
    }
}

/// The down-up algebra DU(α, β, γ)
///
/// An associative algebra generated by d and u with specific commutation relations
///
/// # Type Parameters
///
/// * `R` - The base ring (coefficient ring)
///
/// # Examples
///
/// ```
/// use rustmath_algebras::down_up_algebra::DownUpAlgebra;
/// use rustmath_rationals::Rational;
///
/// // Create DU(1, 0, 0) over rationals
/// let algebra = DownUpAlgebra::<Rational>::new(
///     Rational::from(1),
///     Rational::from(0),
///     Rational::from(0)
/// );
/// ```
#[derive(Clone, Debug)]
pub struct DownUpAlgebra<R: Ring> {
    /// Parameter α
    alpha: R,
    /// Parameter β
    beta: R,
    /// Parameter γ
    gamma: R,
    /// Phantom data for ring
    _phantom: std::marker::PhantomData<R>,
}

impl<R: Ring> DownUpAlgebra<R> {
    /// Create a new down-up algebra DU(α, β, γ)
    ///
    /// # Arguments
    ///
    /// * `alpha` - The α parameter
    /// * `beta` - The β parameter
    /// * `gamma` - The γ parameter
    pub fn new(alpha: R, beta: R, gamma: R) -> Self {
        DownUpAlgebra {
            alpha,
            beta,
            gamma,
            _phantom: std::marker::PhantomData,
        }
    }

    /// Get α parameter
    pub fn alpha(&self) -> &R {
        &self.alpha
    }

    /// Get β parameter
    pub fn beta(&self) -> &R {
        &self.beta
    }

    /// Get γ parameter
    pub fn gamma(&self) -> &R {
        &self.gamma
    }

    /// Get the identity element
    pub fn one(&self) -> Element<R> {
        Element {
            module_element: CombinatorialFreeModuleElement::from_basis_index(
                DownUpBasisIndex::new(0, 0, 0)
            ),
        }
    }

    /// Get the zero element
    pub fn zero(&self) -> Element<R> {
        Element {
            module_element: CombinatorialFreeModuleElement::zero(),
        }
    }

    /// Get generator d (down)
    pub fn d(&self) -> Element<R> {
        Element {
            module_element: CombinatorialFreeModuleElement::from_basis_index(
                DownUpBasisIndex::new(0, 0, 1)
            ),
        }
    }

    /// Get generator u (up)
    pub fn u(&self) -> Element<R> {
        Element {
            module_element: CombinatorialFreeModuleElement::from_basis_index(
                DownUpBasisIndex::new(1, 0, 0)
            ),
        }
    }

    /// Get both generators as a tuple (d, u)
    pub fn algebra_generators(&self) -> (Element<R>, Element<R>) {
        (self.d(), self.u())
    }

    /// Multiply two basis elements
    ///
    /// Uses the PBW basis structure and applies reduction relations:
    /// - d²u = αdud + βud² + γd
    /// - du² = αudu + βu²d + γu
    ///
    /// # Arguments
    ///
    /// * `b1` - First basis index
    /// * `b2` - Second basis index
    pub fn product_on_basis(&self, b1: &DownUpBasisIndex, b2: &DownUpBasisIndex) -> Element<R> {
        // Result of multiplying u^{i1} (du)^{j1} d^{k1} * u^{i2} (du)^{j2} d^{k2}
        // This is a simplified implementation that handles basic cases

        // If either is identity, return the other
        if b1.is_identity() {
            return Element {
                module_element: CombinatorialFreeModuleElement::from_basis_index(b2.clone()),
            };
        }
        if b2.is_identity() {
            return Element {
                module_element: CombinatorialFreeModuleElement::from_basis_index(b1.clone()),
            };
        }

        // For the simple case where we just concatenate (no d's meeting u's):
        // u^{i1} (du)^{j1} d^{k1} * u^{i2} (du)^{j2} d^{k2}
        // If k1 == 0 (no trailing d's on left), this becomes:
        // u^{i1} (du)^{j1} * u^{i2} (du)^{j2} d^{k2}
        // Which needs reduction using du² = αudu + βu²d + γu

        // Simplified: for now just handle the case where no reduction is needed
        // Full implementation would recursively apply commutation relations

        if b1.k == 0 && b2.i == 0 {
            // u^{i1} (du)^{j1} * (du)^{j2} d^{k2} = u^{i1} (du)^{j1+j2} d^{k2}
            return Element {
                module_element: CombinatorialFreeModuleElement::from_basis_index(
                    DownUpBasisIndex::new(b1.i, b1.j + b2.j, b2.k)
                ),
            };
        }

        if b1.k == 0 && b1.j == 0 && b2.i == 0 && b2.j == 0 {
            // u^{i1} * d^{k2}
            // No reduction needed if they don't overlap
            return Element {
                module_element: CombinatorialFreeModuleElement::from_basis_index(
                    DownUpBasisIndex::new(b1.i, 0, b2.k)
                ),
            };
        }

        // General case: would need to apply commutation relations
        // For now, return a basic result
        // A complete implementation would recursively reduce using the relations

        // Placeholder: return zero for complex cases
        // TODO: Implement full reduction algorithm
        self.zero()
    }
}

/// An element of the down-up algebra
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Element<R: Ring> {
    /// The underlying combinatorial free module element
    pub module_element: CombinatorialFreeModuleElement<R, DownUpBasisIndex>,
}

impl<R: Ring> Element<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        Element {
            module_element: CombinatorialFreeModuleElement::zero(),
        }
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool {
        self.module_element.is_zero()
    }

    /// Add two elements
    pub fn add(&self, other: &Element<R>) -> Element<R> {
        Element {
            module_element: self.module_element.clone() + other.module_element.clone(),
        }
    }

    /// Subtract two elements
    pub fn sub(&self, other: &Element<R>) -> Element<R> {
        Element {
            module_element: self.module_element.clone() - other.module_element.clone(),
        }
    }

    /// Negate this element
    pub fn neg(&self) -> Element<R> {
        Element {
            module_element: -self.module_element.clone(),
        }
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Element<R> {
        Element {
            module_element: self.module_element.scalar_mul(scalar),
        }
    }

    /// Multiply two algebra elements
    ///
    /// Uses bilinearity and the product_on_basis method
    pub fn multiply(&self, other: &Element<R>, algebra: &DownUpAlgebra<R>) -> Element<R> {
        let mut result = Element::zero();

        for (b1, coeff1) in self.module_element.iter() {
            for (b2, coeff2) in other.module_element.iter() {
                // Compute product of basis elements
                let basis_product = algebra.product_on_basis(b1, b2);

                // Multiply by coefficients
                let coeff_product = coeff1.clone() * coeff2.clone();
                let term = basis_product.scalar_mul(&coeff_product);

                result = result.add(&term);
            }
        }

        result
    }

    /// Compute the degree of this element
    ///
    /// For a homogeneous element, returns its degree. For non-homogeneous,
    /// returns the maximum degree among terms
    pub fn degree(&self) -> Option<isize> {
        if self.is_zero() {
            return None;
        }

        self.module_element
            .iter()
            .map(|(idx, _)| idx.degree())
            .max()
    }
}

impl<R: Ring + Display> Display for Element<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let terms: Vec<_> = self.module_element.iter().collect();

        for (i, (idx, coeff)) in terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }

            if coeff.is_one() && !idx.is_identity() {
                write!(f, "{}", idx)?;
            } else if idx.is_identity() {
                write!(f, "{}", coeff)?;
            } else {
                write!(f, "{}*{}", coeff, idx)?;
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_algebra_creation() {
        let algebra = DownUpAlgebra::new(
            Integer::from(1),
            Integer::from(0),
            Integer::from(0),
        );

        assert_eq!(*algebra.alpha(), Integer::from(1));
        assert_eq!(*algebra.beta(), Integer::from(0));
        assert_eq!(*algebra.gamma(), Integer::from(0));
    }

    #[test]
    fn test_generators() {
        let algebra = DownUpAlgebra::new(
            Integer::from(1),
            Integer::from(0),
            Integer::from(0),
        );

        let d = algebra.d();
        let u = algebra.u();

        assert!(!d.is_zero());
        assert!(!u.is_zero());
    }

    #[test]
    fn test_identity() {
        let algebra = DownUpAlgebra::new(
            Integer::from(1),
            Integer::from(0),
            Integer::from(0),
        );

        let one = algebra.one();
        let d = algebra.d();

        // 1 * d = d
        let product = one.multiply(&d, &algebra);
        assert_eq!(product, d);
    }

    #[test]
    fn test_addition() {
        let algebra = DownUpAlgebra::new(
            Integer::from(1),
            Integer::from(0),
            Integer::from(0),
        );

        let d = algebra.d();
        let u = algebra.u();

        let sum = d.add(&u);
        assert!(!sum.is_zero());
    }

    #[test]
    fn test_scalar_multiplication() {
        let algebra = DownUpAlgebra::new(
            Integer::from(1),
            Integer::from(0),
            Integer::from(0),
        );

        let d = algebra.d();
        let scaled = d.scalar_mul(&Integer::from(3));

        assert!(!scaled.is_zero());
    }

    #[test]
    fn test_degree() {
        let d_idx = DownUpBasisIndex::new(0, 0, 1);  // d has degree -1
        let u_idx = DownUpBasisIndex::new(1, 0, 0);  // u has degree 1
        let du_idx = DownUpBasisIndex::new(0, 1, 0); // du has degree 0

        assert_eq!(d_idx.degree(), -1);
        assert_eq!(u_idx.degree(), 1);
        assert_eq!(du_idx.degree(), 0);
    }

    #[test]
    fn test_basis_index_display() {
        let idx1 = DownUpBasisIndex::new(0, 0, 0);
        assert_eq!(format!("{}", idx1), "1");

        let idx2 = DownUpBasisIndex::new(1, 0, 0);
        assert_eq!(format!("{}", idx2), "u");

        let idx3 = DownUpBasisIndex::new(0, 0, 1);
        assert_eq!(format!("{}", idx3), "d");

        let idx4 = DownUpBasisIndex::new(2, 3, 1);
        assert_eq!(format!("{}", idx4), "u^2(du)^3d");
    }
}
