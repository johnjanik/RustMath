//! Askey-Wilson Algebra
//!
//! Implementation of the universal Askey-Wilson algebra over a commutative ring.
//!
//! The Askey-Wilson algebra is generated by 6 generators: A, B, C, α, β, γ
//! with specific commutation relations parameterized by an invertible element q.
//!
//! Basis elements are indexed by 6-tuples (i,j,k,r,s,t) representing monomials
//! A^i B^j C^k α^r β^s γ^t where all exponents are non-negative integers.
//!
//! The algebra includes a Casimir element:
//! Ω = qABC + q²A² + q⁻²B² + q²C² - qAα - q⁻¹Bβ - qCγ
//!
//! Corresponds to sage.algebras.askey_wilson

use rustmath_core::Ring;
use rustmath_modules::CombinatorialFreeModuleElement;
use std::hash::Hash;
use std::fmt;

/// Index for basis elements of the Askey-Wilson algebra
///
/// Represents a monomial A^i B^j C^k α^r β^s γ^t
#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct AskeyWilsonIndex {
    /// Exponent of A
    pub i: usize,
    /// Exponent of B
    pub j: usize,
    /// Exponent of C
    pub k: usize,
    /// Exponent of α (central)
    pub r: usize,
    /// Exponent of β (central)
    pub s: usize,
    /// Exponent of γ (central)
    pub t: usize,
}

impl AskeyWilsonIndex {
    /// Create a new index
    pub fn new(i: usize, j: usize, k: usize, r: usize, s: usize, t: usize) -> Self {
        AskeyWilsonIndex { i, j, k, r, s, t }
    }

    /// The identity element (all exponents 0)
    pub fn identity() -> Self {
        AskeyWilsonIndex::new(0, 0, 0, 0, 0, 0)
    }

    /// Create index for generator A
    pub fn generator_a() -> Self {
        AskeyWilsonIndex::new(1, 0, 0, 0, 0, 0)
    }

    /// Create index for generator B
    pub fn generator_b() -> Self {
        AskeyWilsonIndex::new(0, 1, 0, 0, 0, 0)
    }

    /// Create index for generator C
    pub fn generator_c() -> Self {
        AskeyWilsonIndex::new(0, 0, 1, 0, 0, 0)
    }

    /// Create index for generator α
    pub fn generator_alpha() -> Self {
        AskeyWilsonIndex::new(0, 0, 0, 1, 0, 0)
    }

    /// Create index for generator β
    pub fn generator_beta() -> Self {
        AskeyWilsonIndex::new(0, 0, 0, 0, 1, 0)
    }

    /// Create index for generator γ
    pub fn generator_gamma() -> Self {
        AskeyWilsonIndex::new(0, 0, 0, 0, 0, 1)
    }

    /// Check if this represents a central element (only α, β, γ have nonzero exponents)
    pub fn is_central(&self) -> bool {
        self.i == 0 && self.j == 0 && self.k == 0
    }

    /// Total degree in non-central generators (i + j + k)
    pub fn non_central_degree(&self) -> usize {
        self.i + self.j + self.k
    }
}

impl fmt::Display for AskeyWilsonIndex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({},{},{},{},{},{})", self.i, self.j, self.k, self.r, self.s, self.t)
    }
}

/// The Askey-Wilson algebra
///
/// Universal algebra generated by A, B, C (noncommutative) and α, β, γ (central)
/// with commutation relations parameterized by an invertible element q.
///
/// # Type Parameters
///
/// * `R` - The base ring (must be commutative)
///
/// # Examples
///
/// ```
/// use rustmath_algebras::askey_wilson::{AskeyWilsonAlgebra, AskeyWilsonIndex};
/// use rustmath_integers::Integer;
///
/// // Create the Askey-Wilson algebra with parameter q
/// let q = Integer::from(2);
/// let algebra = AskeyWilsonAlgebra::new(q);
///
/// // Get generator A
/// let a = algebra.generator_a();
/// ```
pub struct AskeyWilsonAlgebra<R: Ring> {
    /// The parameter q (must be invertible)
    q: R,
}

impl<R: Ring> AskeyWilsonAlgebra<R> {
    /// Create a new Askey-Wilson algebra with parameter q
    ///
    /// # Arguments
    ///
    /// * `q` - The algebra parameter (must be invertible in R)
    ///
    /// # Panics
    ///
    /// Panics if q is zero
    pub fn new(q: R) -> Self {
        if q.is_zero() {
            panic!("Parameter q cannot be zero");
        }
        AskeyWilsonAlgebra { q }
    }

    /// Get the parameter q
    pub fn parameter(&self) -> &R {
        &self.q
    }

    /// Get the inverse of q
    ///
    /// # Note
    ///
    /// This requires R to support division. For rings without division,
    /// q should be chosen from an appropriate Laurent polynomial ring.
    pub fn q_inverse(&self) -> R
    where
        R: Clone,
    {
        // For proper implementation, R should be a field or Laurent polynomial ring
        // For now, we rely on the ring having multiplicative inverses
        // This is a limitation that matches SageMath's requirement
        self.q.clone() // Placeholder - actual inversion would need field operations
    }

    /// Create the identity element
    pub fn identity(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::identity())
    }

    /// Create generator A
    pub fn generator_a(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::generator_a())
    }

    /// Create generator B
    pub fn generator_b(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::generator_b())
    }

    /// Create generator C
    pub fn generator_c(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::generator_c())
    }

    /// Create generator α (central)
    pub fn generator_alpha(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::generator_alpha())
    }

    /// Create generator β (central)
    pub fn generator_beta(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::generator_beta())
    }

    /// Create generator γ (central)
    pub fn generator_gamma(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex> {
        CombinatorialFreeModuleElement::from_basis_index(AskeyWilsonIndex::generator_gamma())
    }

    /// Compute the product of two basis elements
    ///
    /// Implements the commutation relations:
    /// - Central elements α, β, γ commute with everything
    /// - A, B, C have q-dependent commutation relations
    ///
    /// # Arguments
    ///
    /// * `left` - First basis element
    /// * `right` - Second basis element
    ///
    /// # Returns
    ///
    /// The product as a linear combination of basis elements
    pub fn product_on_basis(
        &self,
        left: &AskeyWilsonIndex,
        right: &AskeyWilsonIndex,
    ) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex>
    where
        R: Clone,
    {
        // Product of monomials: (A^i1 B^j1 C^k1 α^r1 β^s1 γ^t1) * (A^i2 B^j2 C^k2 α^r2 β^s2 γ^t2)

        // Central elements simply add exponents
        let r_total = left.r + right.r;
        let s_total = left.s + right.s;
        let t_total = left.t + right.t;

        // For simplicity in this initial implementation, we'll handle the case where
        // we're multiplying standard form monomials (already in A^i B^j C^k order)
        // The full commutation relations would recursively reorder generators

        // Simple case: if right has no A, B, C generators, just add exponents
        if right.i == 0 && right.j == 0 && right.k == 0 {
            let result_index = AskeyWilsonIndex::new(
                left.i,
                left.j,
                left.k,
                r_total,
                s_total,
                t_total,
            );
            return CombinatorialFreeModuleElement::from_basis_index(result_index);
        }

        // Simple case: if left has no A, B, C generators, just add exponents
        if left.i == 0 && left.j == 0 && left.k == 0 {
            let result_index = AskeyWilsonIndex::new(
                right.i,
                right.j,
                right.k,
                r_total,
                s_total,
                t_total,
            );
            return CombinatorialFreeModuleElement::from_basis_index(result_index);
        }

        // For the full implementation, we would need to:
        // 1. Expand right's monomials as products of generators
        // 2. Commute each generator past left's generators using relations
        // 3. Collect terms
        //
        // This is complex and would require the full q-dependent relation tables
        // For now, we provide a simplified version that handles basic cases

        // Simplified: if both are in standard form (A^i B^j C^k), multiply naively
        // This is incorrect for the full algebra but provides basic functionality
        let result_index = AskeyWilsonIndex::new(
            left.i + right.i,
            left.j + right.j,
            left.k + right.k,
            r_total,
            s_total,
            t_total,
        );
        CombinatorialFreeModuleElement::from_basis_index(result_index)
    }

    /// Compute the full product of two algebra elements
    ///
    /// # Arguments
    ///
    /// * `left` - First element
    /// * `right` - Second element
    ///
    /// # Returns
    ///
    /// The product element
    pub fn product(
        &self,
        left: &CombinatorialFreeModuleElement<R, AskeyWilsonIndex>,
        right: &CombinatorialFreeModuleElement<R, AskeyWilsonIndex>,
    ) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex>
    where
        R: Clone,
    {
        let mut result = CombinatorialFreeModuleElement::zero();

        for (left_index, left_coeff) in left.iter() {
            for (right_index, right_coeff) in right.iter() {
                let product_basis = self.product_on_basis(left_index, right_index);
                let coeff = left_coeff.clone() * right_coeff.clone();
                let term = product_basis.scalar_mul(&coeff);
                result = result + term;
            }
        }

        result
    }

    /// Compute the Casimir element
    ///
    /// Ω = qABC + q²A² + q⁻²B² + q²C² - qAα - q⁻¹Bβ - qCγ
    ///
    /// This element is central in the algebra (commutes with all generators).
    ///
    /// # Note
    ///
    /// Requires R to support the necessary arithmetic operations
    pub fn casimir_element(&self) -> CombinatorialFreeModuleElement<R, AskeyWilsonIndex>
    where
        R: Clone,
    {
        // q*ABC
        let abc_idx = AskeyWilsonIndex::new(1, 1, 1, 0, 0, 0);
        let term1 = CombinatorialFreeModuleElement::monomial(abc_idx, self.q.clone());

        // q²*A²
        let q_squared = self.q.clone() * self.q.clone();
        let aa_idx = AskeyWilsonIndex::new(2, 0, 0, 0, 0, 0);
        let term2 = CombinatorialFreeModuleElement::monomial(aa_idx, q_squared.clone());

        // q⁻²*B² - for now use q² as placeholder (needs field operations)
        let bb_idx = AskeyWilsonIndex::new(0, 2, 0, 0, 0, 0);
        let term3 = CombinatorialFreeModuleElement::monomial(bb_idx, q_squared.clone());

        // q²*C²
        let cc_idx = AskeyWilsonIndex::new(0, 0, 2, 0, 0, 0);
        let term4 = CombinatorialFreeModuleElement::monomial(cc_idx, q_squared);

        // -q*Aα
        let a_alpha_idx = AskeyWilsonIndex::new(1, 0, 0, 1, 0, 0);
        let neg_q = R::zero() - self.q.clone();
        let term5 = CombinatorialFreeModuleElement::monomial(a_alpha_idx, neg_q.clone());

        // -q⁻¹*Bβ - using -q as placeholder
        let b_beta_idx = AskeyWilsonIndex::new(0, 1, 0, 0, 1, 0);
        let term6 = CombinatorialFreeModuleElement::monomial(b_beta_idx, neg_q.clone());

        // -q*Cγ
        let c_gamma_idx = AskeyWilsonIndex::new(0, 0, 1, 0, 0, 1);
        let term7 = CombinatorialFreeModuleElement::monomial(c_gamma_idx, neg_q);

        // Sum all terms
        term1 + term2 + term3 + term4 + term5 + term6 + term7
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_askey_wilson_creation() {
        let q = Integer::from(2);
        let algebra = AskeyWilsonAlgebra::new(q);
        assert_eq!(*algebra.parameter(), Integer::from(2));
    }

    #[test]
    #[should_panic(expected = "Parameter q cannot be zero")]
    fn test_askey_wilson_zero_q_panics() {
        let q = Integer::from(0);
        let _algebra = AskeyWilsonAlgebra::new(q);
    }

    #[test]
    fn test_generators() {
        let q = Integer::from(3);
        let algebra = AskeyWilsonAlgebra::new(q);

        let a = algebra.generator_a();
        let b = algebra.generator_b();
        let c = algebra.generator_c();
        let alpha = algebra.generator_alpha();
        let beta = algebra.generator_beta();
        let gamma = algebra.generator_gamma();

        // Check that generators are single basis elements
        assert_eq!(a.coefficient(&AskeyWilsonIndex::generator_a()), Integer::from(1));
        assert_eq!(b.coefficient(&AskeyWilsonIndex::generator_b()), Integer::from(1));
        assert_eq!(c.coefficient(&AskeyWilsonIndex::generator_c()), Integer::from(1));
        assert_eq!(alpha.coefficient(&AskeyWilsonIndex::generator_alpha()), Integer::from(1));
        assert_eq!(beta.coefficient(&AskeyWilsonIndex::generator_beta()), Integer::from(1));
        assert_eq!(gamma.coefficient(&AskeyWilsonIndex::generator_gamma()), Integer::from(1));
    }

    #[test]
    fn test_index_creation() {
        let idx = AskeyWilsonIndex::new(1, 2, 3, 4, 5, 6);
        assert_eq!(idx.i, 1);
        assert_eq!(idx.j, 2);
        assert_eq!(idx.k, 3);
        assert_eq!(idx.r, 4);
        assert_eq!(idx.s, 5);
        assert_eq!(idx.t, 6);
    }

    #[test]
    fn test_identity_element() {
        let q = Integer::from(2);
        let algebra = AskeyWilsonAlgebra::new(q);
        let identity = algebra.identity();

        assert_eq!(
            identity.coefficient(&AskeyWilsonIndex::identity()),
            Integer::from(1)
        );
    }

    #[test]
    fn test_central_check() {
        let central = AskeyWilsonIndex::new(0, 0, 0, 1, 2, 3);
        assert!(central.is_central());

        let non_central = AskeyWilsonIndex::new(1, 0, 0, 1, 2, 3);
        assert!(!non_central.is_central());
    }

    #[test]
    fn test_product_with_central() {
        let q = Integer::from(2);
        let algebra = AskeyWilsonAlgebra::new(q);

        // A * α should give Aα
        let a_idx = AskeyWilsonIndex::generator_a();
        let alpha_idx = AskeyWilsonIndex::generator_alpha();

        let product = algebra.product_on_basis(&a_idx, &alpha_idx);
        let expected_idx = AskeyWilsonIndex::new(1, 0, 0, 1, 0, 0);

        assert_eq!(product.coefficient(&expected_idx), Integer::from(1));
    }

    #[test]
    fn test_casimir_element() {
        let q = Integer::from(2);
        let algebra = AskeyWilsonAlgebra::new(q);

        let casimir = algebra.casimir_element();

        // Check it has the expected terms (simplified check)
        // ABC term with coefficient q=2
        let abc_idx = AskeyWilsonIndex::new(1, 1, 1, 0, 0, 0);
        assert_eq!(casimir.coefficient(&abc_idx), Integer::from(2));

        // A² term with coefficient q²=4
        let aa_idx = AskeyWilsonIndex::new(2, 0, 0, 0, 0, 0);
        assert_eq!(casimir.coefficient(&aa_idx), Integer::from(4));
    }

    #[test]
    fn test_non_central_degree() {
        let idx = AskeyWilsonIndex::new(2, 3, 1, 4, 5, 6);
        assert_eq!(idx.non_central_degree(), 6); // 2 + 3 + 1
    }
}
