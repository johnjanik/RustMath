//! Quantum Group Representations
//!
//! This module implements representations of quantum groups indexed by crystal bases.
//! It provides a framework for studying quantum group actions on vector spaces.
//!
//! # Mathematical Background
//!
//! A representation of a quantum group U_q(g) is a vector space V with actions
//! of the generators E_i, F_i, and K_i satisfying the quantum group relations.
//!
//! Crystal bases provide a combinatorial framework for understanding these
//! representations at q=0, where the operators become simpler.
//!
//! # Representation Types
//!
//! - **QuantumGroupRepresentation**: General representation indexed by crystal elements
//! - **CyclicRepresentation**: Representation generated by a single element
//! - **AdjointRepresentation**: Generalized adjoint representation
//! - **MinusculeRepresentation**: Representation where operators act without q-integers
//!
//! # Examples
//!
//! ```
//! use rustmath_algebras::quantum_group_representations::*;
//!
//! // Create a quantum group representation
//! let rep = QuantumGroupRepresentation::new("A2".to_string(), "q".to_string());
//! ```

use rustmath_core::Ring;
use std::collections::HashMap;
use std::fmt;

/// Crystal element
///
/// Represents an element in a crystal graph, used to index basis vectors.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CrystalElement {
    /// Weight vector
    weight: Vec<i32>,
    /// Element identifier
    id: usize,
}

impl CrystalElement {
    /// Create a new crystal element
    pub fn new(weight: Vec<i32>, id: usize) -> Self {
        Self { weight, id }
    }

    /// Get the weight
    pub fn weight(&self) -> &[i32] {
        &self.weight
    }

    /// Get the ID
    pub fn id(&self) -> usize {
        self.id
    }

    /// Apply crystal operator e_i
    pub fn e(&self, _i: usize) -> Option<Self> {
        // Placeholder: would compute crystal raising operator
        None
    }

    /// Apply crystal operator f_i
    pub fn f(&self, _i: usize) -> Option<Self> {
        // Placeholder: would compute crystal lowering operator
        None
    }
}

/// Quantum group representation
///
/// A representation of a quantum group indexed by a crystal basis.
#[derive(Debug, Clone)]
pub struct QuantumGroupRepresentation {
    /// Cartan type
    cartan_type: String,
    /// Quantum parameter
    q_param: String,
    /// Rank
    rank: usize,
    /// Crystal basis elements
    basis: Vec<CrystalElement>,
}

impl QuantumGroupRepresentation {
    /// Create a new quantum group representation
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type (e.g., "A2", "B3")
    /// * `q_param` - The quantum parameter
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::quantum_group_representations::QuantumGroupRepresentation;
    ///
    /// let rep = QuantumGroupRepresentation::new("A2".to_string(), "q".to_string());
    /// assert_eq!(rep.rank(), 2);
    /// ```
    pub fn new(cartan_type: String, q_param: String) -> Self {
        let rank = cartan_type
            .chars()
            .skip(1)
            .collect::<String>()
            .parse::<usize>()
            .unwrap_or(1);

        Self {
            cartan_type,
            q_param,
            rank,
            basis: Vec::new(),
        }
    }

    /// Get the Cartan type
    pub fn cartan_type(&self) -> &str {
        &self.cartan_type
    }

    /// Get the quantum parameter
    pub fn q_param(&self) -> &str {
        &self.q_param
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.rank
    }

    /// Get the basis
    pub fn basis(&self) -> &[CrystalElement] {
        &self.basis
    }

    /// Add a basis element
    pub fn add_basis_element(&mut self, element: CrystalElement) {
        self.basis.push(element);
    }

    /// Get dimension
    pub fn dimension(&self) -> usize {
        self.basis.len()
    }

    /// Action of K_i on a basis element
    pub fn k_on_basis(&self, basis_index: usize, i: usize) -> Option<i32> {
        if basis_index >= self.basis.len() || i >= self.rank {
            return None;
        }

        // K_i acts by q^{alpha_i(wt)} where wt is the weight
        let weight = &self.basis[basis_index].weight;
        if i < weight.len() {
            Some(weight[i])
        } else {
            None
        }
    }

    /// Check if the representation is finite-dimensional
    pub fn is_finite_dimensional(&self) -> bool {
        !self.basis.is_empty()
    }
}

impl fmt::Display for QuantumGroupRepresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Quantum group representation of type {} with parameter {}",
            self.cartan_type, self.q_param
        )
    }
}

/// Cyclic representation
///
/// A representation generated by a single element (the module generator).
#[derive(Debug, Clone)]
pub struct CyclicRepresentation {
    /// Base representation
    base: QuantumGroupRepresentation,
    /// Index of the module generator in the basis
    generator_index: usize,
    /// Weight of the generator
    generator_weight: Vec<i32>,
}

impl CyclicRepresentation {
    /// Create a new cyclic representation
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type
    /// * `q_param` - The quantum parameter
    /// * `generator_weight` - The weight of the generating element
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::quantum_group_representations::CyclicRepresentation;
    ///
    /// let rep = CyclicRepresentation::new("A1".to_string(), "q".to_string(), vec![1]);
    /// assert_eq!(rep.generator_weight(), &[1]);
    /// ```
    pub fn new(cartan_type: String, q_param: String, generator_weight: Vec<i32>) -> Self {
        let mut base = QuantumGroupRepresentation::new(cartan_type, q_param);

        // Add the generator as the first basis element
        let generator = CrystalElement::new(generator_weight.clone(), 0);
        base.add_basis_element(generator);

        Self {
            base,
            generator_index: 0,
            generator_weight,
        }
    }

    /// Get the base representation
    pub fn base(&self) -> &QuantumGroupRepresentation {
        &self.base
    }

    /// Get the module generator
    pub fn module_generator(&self) -> &CrystalElement {
        &self.base.basis[self.generator_index]
    }

    /// Get the generator weight
    pub fn generator_weight(&self) -> &[i32] {
        &self.generator_weight
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.base.rank()
    }
}

impl fmt::Display for CyclicRepresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Cyclic representation generated by element of weight {:?}",
            self.generator_weight
        )
    }
}

/// Adjoint representation
///
/// The generalized adjoint representation of a quantum group.
/// This is the representation on the quantum group itself via the adjoint action.
#[derive(Debug, Clone)]
pub struct AdjointRepresentation {
    /// Base cyclic representation
    base: CyclicRepresentation,
}

impl AdjointRepresentation {
    /// Create a new adjoint representation
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type
    /// * `q_param` - The quantum parameter
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::quantum_group_representations::AdjointRepresentation;
    ///
    /// let adj = AdjointRepresentation::new("A2".to_string(), "q".to_string());
    /// assert_eq!(adj.rank(), 2);
    /// ```
    pub fn new(cartan_type: String, q_param: String) -> Self {
        let rank = cartan_type
            .chars()
            .skip(1)
            .collect::<String>()
            .parse::<usize>()
            .unwrap_or(1);

        // Adjoint representation has highest weight = highest root
        // For type A_n, this is (1,1,...,1)
        let generator_weight = vec![1; rank];

        Self {
            base: CyclicRepresentation::new(cartan_type, q_param, generator_weight),
        }
    }

    /// Get the base cyclic representation
    pub fn base(&self) -> &CyclicRepresentation {
        &self.base
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.base.rank()
    }

    /// Action of E_i on a basis element
    pub fn e_on_basis(&self, basis_index: usize, i: usize) -> Option<(usize, String)> {
        // Placeholder: would compute the raising operator action
        // Returns (new_basis_index, coefficient_expression)
        None
    }

    /// Action of F_i on a basis element
    pub fn f_on_basis(&self, basis_index: usize, i: usize) -> Option<(usize, String)> {
        // Placeholder: would compute the lowering operator action
        None
    }
}

impl fmt::Display for AdjointRepresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Adjoint representation of type {}",
            self.base.base().cartan_type()
        )
    }
}

/// Minuscule representation
///
/// A representation where the Chevalley operators act directly without q-integer
/// coefficients. These are the "smallest" fundamental representations.
#[derive(Debug, Clone)]
pub struct MinusculeRepresentation {
    /// Base cyclic representation
    base: CyclicRepresentation,
    /// Minuscule weight index
    minuscule_index: usize,
}

impl MinusculeRepresentation {
    /// Create a new minuscule representation
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type
    /// * `q_param` - The quantum parameter
    /// * `minuscule_index` - The index of the minuscule weight
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::quantum_group_representations::MinusculeRepresentation;
    ///
    /// let min_rep = MinusculeRepresentation::new("A2".to_string(), "q".to_string(), 0);
    /// ```
    pub fn new(cartan_type: String, q_param: String, minuscule_index: usize) -> Self {
        let rank = cartan_type
            .chars()
            .skip(1)
            .collect::<String>()
            .parse::<usize>()
            .unwrap_or(1);

        assert!(minuscule_index < rank, "Minuscule index out of range");

        // Generator weight is the minuscule fundamental weight
        let mut generator_weight = vec![0; rank];
        generator_weight[minuscule_index] = 1;

        Self {
            base: CyclicRepresentation::new(cartan_type, q_param, generator_weight),
            minuscule_index,
        }
    }

    /// Get the base cyclic representation
    pub fn base(&self) -> &CyclicRepresentation {
        &self.base
    }

    /// Get the minuscule index
    pub fn minuscule_index(&self) -> usize {
        self.minuscule_index
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.base.rank()
    }

    /// Action of E_i on a basis element
    ///
    /// In minuscule representations, e_i acts as the crystal operator
    /// without coefficients.
    pub fn e_on_basis(&self, basis_index: usize, i: usize) -> Option<usize> {
        if basis_index >= self.base.base().basis().len() {
            return None;
        }

        // Apply crystal e_i
        let crystal_elem = &self.base.base().basis()[basis_index];
        crystal_elem.e(i).map(|new_elem| new_elem.id())
    }

    /// Action of F_i on a basis element
    ///
    /// In minuscule representations, f_i acts as the crystal operator
    /// without coefficients.
    pub fn f_on_basis(&self, basis_index: usize, i: usize) -> Option<usize> {
        if basis_index >= self.base.base().basis().len() {
            return None;
        }

        // Apply crystal f_i
        let crystal_elem = &self.base.base().basis()[basis_index];
        crystal_elem.f(i).map(|new_elem| new_elem.id())
    }
}

impl fmt::Display for MinusculeRepresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Minuscule representation (index {}) of type {}",
            self.minuscule_index,
            self.base.base().cartan_type()
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_crystal_element() {
        let elem = CrystalElement::new(vec![1, 0], 0);
        assert_eq!(elem.weight(), &[1, 0]);
        assert_eq!(elem.id(), 0);
    }

    #[test]
    fn test_crystal_operators() {
        let elem = CrystalElement::new(vec![1, 0], 0);
        let raised = elem.e(0);
        let lowered = elem.f(0);

        // Placeholders return None
        assert!(raised.is_none());
        assert!(lowered.is_none());
    }

    #[test]
    fn test_quantum_group_representation() {
        let rep = QuantumGroupRepresentation::new("A2".to_string(), "q".to_string());
        assert_eq!(rep.cartan_type(), "A2");
        assert_eq!(rep.q_param(), "q");
        assert_eq!(rep.rank(), 2);
        assert_eq!(rep.dimension(), 0);
    }

    #[test]
    fn test_add_basis_element() {
        let mut rep = QuantumGroupRepresentation::new("A1".to_string(), "q".to_string());
        let elem = CrystalElement::new(vec![1], 0);
        rep.add_basis_element(elem);
        assert_eq!(rep.dimension(), 1);
    }

    #[test]
    fn test_k_on_basis() {
        let mut rep = QuantumGroupRepresentation::new("A2".to_string(), "q".to_string());
        let elem = CrystalElement::new(vec![1, -1], 0);
        rep.add_basis_element(elem);

        assert_eq!(rep.k_on_basis(0, 0), Some(1));
        assert_eq!(rep.k_on_basis(0, 1), Some(-1));
        assert_eq!(rep.k_on_basis(0, 2), None);
        assert_eq!(rep.k_on_basis(1, 0), None);
    }

    #[test]
    fn test_cyclic_representation() {
        let rep = CyclicRepresentation::new("A1".to_string(), "q".to_string(), vec![2]);
        assert_eq!(rep.generator_weight(), &[2]);
        assert_eq!(rep.rank(), 1);
    }

    #[test]
    fn test_module_generator() {
        let rep = CyclicRepresentation::new("A2".to_string(), "q".to_string(), vec![1, 0]);
        let gen = rep.module_generator();
        assert_eq!(gen.weight(), &[1, 0]);
    }

    #[test]
    fn test_adjoint_representation() {
        let adj = AdjointRepresentation::new("A2".to_string(), "q".to_string());
        assert_eq!(adj.rank(), 2);
    }

    #[test]
    fn test_adjoint_operators() {
        let adj = AdjointRepresentation::new("A1".to_string(), "q".to_string());
        let e_result = adj.e_on_basis(0, 0);
        let f_result = adj.f_on_basis(0, 0);

        // Placeholders return None
        assert!(e_result.is_none());
        assert!(f_result.is_none());
    }

    #[test]
    fn test_minuscule_representation() {
        let min_rep = MinusculeRepresentation::new("A2".to_string(), "q".to_string(), 0);
        assert_eq!(min_rep.minuscule_index(), 0);
        assert_eq!(min_rep.rank(), 2);
    }

    #[test]
    #[should_panic(expected = "Minuscule index out of range")]
    fn test_minuscule_invalid_index() {
        MinusculeRepresentation::new("A1".to_string(), "q".to_string(), 5);
    }

    #[test]
    fn test_minuscule_operators() {
        let min_rep = MinusculeRepresentation::new("A1".to_string(), "q".to_string(), 0);
        let e_result = min_rep.e_on_basis(0, 0);
        let f_result = min_rep.f_on_basis(0, 0);

        // Placeholders return None
        assert!(e_result.is_none());
        assert!(f_result.is_none());
    }

    #[test]
    fn test_representation_display() {
        let rep = QuantumGroupRepresentation::new("A2".to_string(), "q".to_string());
        let display = format!("{}", rep);
        assert!(display.contains("A2"));
        assert!(display.contains("q"));
    }

    #[test]
    fn test_cyclic_display() {
        let rep = CyclicRepresentation::new("A1".to_string(), "q".to_string(), vec![2]);
        let display = format!("{}", rep);
        assert!(display.contains("Cyclic"));
        assert!(display.contains("[2]"));
    }

    #[test]
    fn test_adjoint_display() {
        let adj = AdjointRepresentation::new("A2".to_string(), "q".to_string());
        let display = format!("{}", adj);
        assert!(display.contains("Adjoint"));
        assert!(display.contains("A2"));
    }

    #[test]
    fn test_minuscule_display() {
        let min_rep = MinusculeRepresentation::new("A2".to_string(), "q".to_string(), 1);
        let display = format!("{}", min_rep);
        assert!(display.contains("Minuscule"));
        assert!(display.contains("index 1"));
    }

    #[test]
    fn test_is_finite_dimensional() {
        let mut rep = QuantumGroupRepresentation::new("A1".to_string(), "q".to_string());
        assert!(!rep.is_finite_dimensional());

        rep.add_basis_element(CrystalElement::new(vec![1], 0));
        assert!(rep.is_finite_dimensional());
    }

    #[test]
    fn test_multiple_basis_elements() {
        let mut rep = QuantumGroupRepresentation::new("A1".to_string(), "q".to_string());
        rep.add_basis_element(CrystalElement::new(vec![2], 0));
        rep.add_basis_element(CrystalElement::new(vec![0], 1));
        rep.add_basis_element(CrystalElement::new(vec![-2], 2));

        assert_eq!(rep.dimension(), 3);
        assert_eq!(rep.basis()[0].weight(), &[2]);
        assert_eq!(rep.basis()[1].weight(), &[0]);
        assert_eq!(rep.basis()[2].weight(), &[-2]);
    }
}
