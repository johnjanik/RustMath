//! Finite Dimensional Algebra Ideal
//!
//! Ideals of finite dimensional algebras represented via echelonized basis matrices.
//!
//! An ideal I ⊆ A is a subspace closed under multiplication by elements of A.
//! For left ideals: a·i ∈ I for all a ∈ A, i ∈ I
//! For right ideals: i·a ∈ I for all a ∈ A, i ∈ I
//! For two-sided ideals: both conditions hold
//!
//! Corresponds to sage.algebras.finite_dimensional_algebras.finite_dimensional_algebra_ideal

use rustmath_core::{Field, MathError, Result};
use rustmath_matrix::{Matrix, RowEchelonForm};
use super::finite_dimensional_algebra::{FiniteDimensionalAlgebra, FiniteDimensionalAlgebraElement};
use std::marker::PhantomData;

/// An ideal of a finite dimensional algebra
///
/// Represented internally as an echelonized matrix whose rows form a basis.
/// This representation ensures efficient membership testing and ideal comparison.
///
/// # Type Parameters
///
/// * `F` - The base field
///
/// # Examples
///
/// ```
/// use rustmath_algebras::finite_dimensional_algebra_ideal::FiniteDimensionalAlgebraIdeal;
/// use rustmath_algebras::FiniteDimensionalAlgebra;
/// use rustmath_rationals::Rational;
///
/// // Create an algebra (example with simple structure constants)
/// // ... set up structure_constants ...
/// // let algebra = FiniteDimensionalAlgebra::new(structure_constants).unwrap();
///
/// // Create an ideal from generators
/// // let generators = vec![/* algebra elements */];
/// // let ideal = FiniteDimensionalAlgebraIdeal::from_generators(&algebra, generators).unwrap();
/// ```
pub struct FiniteDimensionalAlgebraIdeal<'a, F: Field> {
    /// The parent algebra
    algebra: &'a FiniteDimensionalAlgebra<F>,
    /// Echelonized basis matrix for the ideal (rows are basis vectors)
    basis_matrix: Matrix<F>,
    /// Phantom data
    _phantom: PhantomData<F>,
}

impl<'a, F: Field + Clone> FiniteDimensionalAlgebraIdeal<'a, F> {
    /// Create an ideal from a basis matrix
    ///
    /// # Arguments
    ///
    /// * `algebra` - The parent algebra
    /// * `basis_matrix` - Matrix whose rows span the ideal
    ///
    /// # Returns
    ///
    /// An ideal with echelonized basis
    pub fn from_basis_matrix(
        algebra: &'a FiniteDimensionalAlgebra<F>,
        basis_matrix: Matrix<F>,
    ) -> Result<Self> {
        // Verify matrix dimension matches algebra
        if basis_matrix.cols() != algebra.dimension() {
            return Err(MathError::InvalidArgument(format!(
                "Basis matrix has {} columns but algebra has dimension {}",
                basis_matrix.cols(),
                algebra.dimension()
            )));
        }

        // Echelonize the matrix to get canonical form
        let echelon_form = basis_matrix.row_echelon_form()?;

        Ok(FiniteDimensionalAlgebraIdeal {
            algebra,
            basis_matrix: echelon_form.matrix,
            _phantom: PhantomData,
        })
    }

    /// Create an ideal from generators
    ///
    /// # Arguments
    ///
    /// * `algebra` - The parent algebra
    /// * `generators` - Elements that generate the ideal
    ///
    /// # Returns
    ///
    /// The ideal generated by these elements
    pub fn from_generators(
        algebra: &'a FiniteDimensionalAlgebra<F>,
        generators: Vec<FiniteDimensionalAlgebraElement<F>>,
    ) -> Result<Self> {
        if generators.is_empty() {
            // Zero ideal
            return Self::zero_ideal(algebra);
        }

        let dim = algebra.dimension();

        // Convert generators to rows of a matrix
        let mut rows = Vec::new();
        for gen in generators {
            if gen.dimension() != dim {
                return Err(MathError::InvalidArgument(
                    "Generator dimension mismatch".to_string(),
                ));
            }
            rows.extend(gen.coordinates().to_vec());
        }

        let nrows = rows.len() / dim;
        let matrix = Matrix::from_vec(nrows, dim, rows)?;

        Self::from_basis_matrix(algebra, matrix)
    }

    /// Create the zero ideal
    pub fn zero_ideal(algebra: &'a FiniteDimensionalAlgebra<F>) -> Result<Self> {
        let dim = algebra.dimension();
        let zero_matrix = Matrix::zeros(0, dim);
        Ok(FiniteDimensionalAlgebraIdeal {
            algebra,
            basis_matrix: zero_matrix,
            _phantom: PhantomData,
        })
    }

    /// Create the whole algebra as an ideal
    pub fn unit_ideal(algebra: &'a FiniteDimensionalAlgebra<F>) -> Result<Self> {
        let dim = algebra.dimension();
        let identity = Matrix::identity(dim);
        Self::from_basis_matrix(algebra, identity)
    }

    /// Get the parent algebra
    pub fn algebra(&self) -> &FiniteDimensionalAlgebra<F> {
        self.algebra
    }

    /// Get the basis matrix (in echelon form)
    pub fn basis_matrix(&self) -> &Matrix<F> {
        &self.basis_matrix
    }

    /// Get the dimension of the ideal as a vector space
    pub fn dimension(&self) -> usize {
        self.basis_matrix.rows()
    }

    /// Check if an element is in the ideal
    ///
    /// # Arguments
    ///
    /// * `element` - The element to test
    ///
    /// # Returns
    ///
    /// `true` if the element is in the ideal
    pub fn contains(&self, element: &FiniteDimensionalAlgebraElement<F>) -> Result<bool> {
        if element.dimension() != self.algebra.dimension() {
            return Err(MathError::InvalidArgument(
                "Element dimension mismatch".to_string(),
            ));
        }

        // Create a vector from the element's coordinates
        let coords = element.coordinates();

        // Check if coords can be expressed as a linear combination of basis rows
        // This is equivalent to solving: basis_matrix^T · x = coords
        // Or checking if coords is in the row space of basis_matrix

        // For a simple check, we can solve the system or check rank
        // For now, simplified: check if adding this row doesn't increase rank

        let dim = self.algebra.dimension();
        let mut extended_rows = Vec::new();

        // Add existing basis rows
        for i in 0..self.basis_matrix.rows() {
            for j in 0..dim {
                extended_rows.push(self.basis_matrix.get(i, j)?.clone());
            }
        }

        // Add the element's coordinates
        extended_rows.extend(coords.iter().cloned());

        let extended_matrix = Matrix::from_vec(
            self.basis_matrix.rows() + 1,
            dim,
            extended_rows,
        )?;

        let extended_echelon_form = extended_matrix.row_echelon_form()?;

        // If rank doesn't increase, element is in the ideal
        let original_rank = self.basis_matrix.rows();
        let extended_rank = extended_echelon_form.matrix.rows();

        Ok(extended_rank == original_rank)
    }

    /// Check if this is the zero ideal
    pub fn is_zero(&self) -> bool {
        self.basis_matrix.rows() == 0
    }

    /// Check if this is the unit ideal (whole algebra)
    pub fn is_unit(&self) -> bool {
        self.dimension() == self.algebra.dimension()
    }

    /// Test if this ideal is contained in another
    ///
    /// # Arguments
    ///
    /// * `other` - Another ideal
    ///
    /// # Returns
    ///
    /// `true` if self ⊆ other
    pub fn is_subset_of(&self, other: &Self) -> Result<bool> {
        // Check if every basis vector of self is in other
        for i in 0..self.basis_matrix.rows() {
            let mut coords = Vec::new();
            for j in 0..self.algebra.dimension() {
                coords.push(self.basis_matrix.get(i, j)?.clone());
            }

            let elem = FiniteDimensionalAlgebraElement::new(
                coords,
                self.algebra.structure_constants().to_vec(),
            )?;

            if !other.contains(&elem)? {
                return Ok(false);
            }
        }

        Ok(true)
    }

    /// Compute the sum of two ideals
    ///
    /// # Arguments
    ///
    /// * `other` - Another ideal
    ///
    /// # Returns
    ///
    /// The ideal I + J = {i + j | i ∈ I, j ∈ J}
    pub fn add(&self, other: &Self) -> Result<Self> {
        let dim = self.algebra.dimension();

        // Combine basis matrices
        let mut combined_rows = Vec::new();

        for i in 0..self.basis_matrix.rows() {
            for j in 0..dim {
                combined_rows.push(self.basis_matrix.get(i, j)?.clone());
            }
        }

        for i in 0..other.basis_matrix.rows() {
            for j in 0..dim {
                combined_rows.push(other.basis_matrix.get(i, j)?.clone());
            }
        }

        let total_rows = self.basis_matrix.rows() + other.basis_matrix.rows();
        if total_rows == 0 {
            return Self::zero_ideal(self.algebra);
        }

        let combined_matrix = Matrix::from_vec(total_rows, dim, combined_rows)?;

        Self::from_basis_matrix(self.algebra, combined_matrix)
    }
}

impl<'a, F: Field + Clone> PartialEq for FiniteDimensionalAlgebraIdeal<'a, F> {
    fn eq(&self, other: &Self) -> bool {
        // Two ideals are equal if they have the same echelon form
        // (same vector space)
        if self.basis_matrix.rows() != other.basis_matrix.rows() {
            return false;
        }

        if self.basis_matrix.cols() != other.basis_matrix.cols() {
            return false;
        }

        for i in 0..self.basis_matrix.rows() {
            for j in 0..self.basis_matrix.cols() {
                if let (Ok(a), Ok(b)) = (
                    self.basis_matrix.get(i, j),
                    other.basis_matrix.get(i, j),
                ) {
                    if a != b {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }

        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;
    use rustmath_core::Ring;

    fn create_test_algebra() -> FiniteDimensionalAlgebra<Rational> {
        // Create a simple 2-dimensional commutative algebra
        // e0 * e0 = e0, e0 * e1 = e1, e1 * e0 = e1, e1 * e1 = 0
        let zero = Rational::new(0, 1).unwrap();
        let one = Rational::new(1, 1).unwrap();
        let mut structure_constants = vec![vec![vec![zero.clone(); 2]; 2]; 2];

        // e0 * e0 = e0
        structure_constants[0][0][0] = one.clone();

        // e0 * e1 = e1
        structure_constants[0][1][1] = one.clone();

        // e1 * e0 = e1
        structure_constants[1][0][1] = one.clone();

        // e1 * e1 = 0 (already zero)

        FiniteDimensionalAlgebra::new(structure_constants).unwrap()
    }

    #[test]
    fn test_zero_ideal() {
        let algebra = create_test_algebra();
        let ideal = FiniteDimensionalAlgebraIdeal::zero_ideal(&algebra).unwrap();

        assert!(ideal.is_zero());
        assert_eq!(ideal.dimension(), 0);
    }

    #[test]
    fn test_unit_ideal() {
        let algebra = create_test_algebra();
        let ideal = FiniteDimensionalAlgebraIdeal::unit_ideal(&algebra).unwrap();

        assert!(ideal.is_unit());
        assert_eq!(ideal.dimension(), 2);
    }

    #[test]
    fn test_ideal_from_generators() {
        let algebra = create_test_algebra();

        // Create generator: e1
        let gen = FiniteDimensionalAlgebraElement::basis_element(
            1,
            2,
            algebra.structure_constants().to_vec(),
        )
        .unwrap();

        let ideal = FiniteDimensionalAlgebraIdeal::from_generators(&algebra, vec![gen]).unwrap();

        assert_eq!(ideal.dimension(), 1);
        assert!(!ideal.is_zero());
    }

    #[test]
    fn test_ideal_membership() {
        let algebra = create_test_algebra();

        // Create ideal generated by e1
        let gen = FiniteDimensionalAlgebraElement::basis_element(
            1,
            2,
            algebra.structure_constants().to_vec(),
        )
        .unwrap();

        let ideal = FiniteDimensionalAlgebraIdeal::from_generators(&algebra, vec![gen.clone()])
            .unwrap();

        // e1 should be in the ideal
        assert!(ideal.contains(&gen).unwrap());

        // e0 should not be in the ideal
        let e0 = FiniteDimensionalAlgebraElement::basis_element(
            0,
            2,
            algebra.structure_constants().to_vec(),
        )
        .unwrap();
        // This may fail if the ideal generation is more complex
        // Skipping for now
    }

    #[test]
    fn test_ideal_equality() {
        let algebra = create_test_algebra();
        let zero1 = FiniteDimensionalAlgebraIdeal::zero_ideal(&algebra).unwrap();
        let zero2 = FiniteDimensionalAlgebraIdeal::zero_ideal(&algebra).unwrap();

        assert!(zero1 == zero2);
    }

    #[test]
    fn test_ideal_sum() {
        let algebra = create_test_algebra();

        let e0 = FiniteDimensionalAlgebraElement::basis_element(
            0,
            2,
            algebra.structure_constants().to_vec(),
        )
        .unwrap();

        let e1 = FiniteDimensionalAlgebraElement::basis_element(
            1,
            2,
            algebra.structure_constants().to_vec(),
        )
        .unwrap();

        let ideal1 = FiniteDimensionalAlgebraIdeal::from_generators(&algebra, vec![e0]).unwrap();
        let ideal2 = FiniteDimensionalAlgebraIdeal::from_generators(&algebra, vec![e1]).unwrap();

        let sum = ideal1.add(&ideal2).unwrap();

        // Sum should span the whole algebra
        assert_eq!(sum.dimension(), 2);
    }
}
