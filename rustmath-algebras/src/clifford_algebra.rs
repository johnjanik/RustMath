//! Clifford Algebra Implementation
//!
//! The Clifford algebra Cl(V,Q) associated to a quadratic form Q on a vector space V.
//! Important in geometry and physics (geometric algebra, spinors).
//!
//! The algebra is generated by a vector space V with the relation:
//! v * v = Q(v) for all v in V
//!
//! Corresponds to sage.algebras.clifford_algebra

use rustmath_core::{Ring, MathError, Result};
use std::collections::HashMap;
use std::fmt::{self, Display};
use std::ops::{Add, Mul, Neg, Sub};

/// A basis element in the Clifford algebra
///
/// Represented as a sorted set of generator indices (antisymmetric product)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CliffordBasisElement {
    /// Indices of the generators in this basis element
    /// Always kept sorted for canonical form
    indices: Vec<usize>,
}

impl CliffordBasisElement {
    /// Create a new basis element
    pub fn new(mut indices: Vec<usize>) -> Self {
        indices.sort_unstable();
        indices.dedup(); // Remove duplicates (e_i * e_i is scalar)
        Self { indices }
    }

    /// The scalar basis element (empty product)
    pub fn scalar() -> Self {
        Self { indices: Vec::new() }
    }

    /// A single generator
    pub fn generator(index: usize) -> Self {
        Self { indices: vec![index] }
    }

    /// Grade (number of generators in the product)
    pub fn grade(&self) -> usize {
        self.indices.len()
    }

    /// Check if this is the scalar element
    pub fn is_scalar(&self) -> bool {
        self.indices.is_empty()
    }
}

impl Display for CliffordBasisElement {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_scalar() {
            write!(f, "1")
        } else {
            for (i, &idx) in self.indices.iter().enumerate() {
                if i > 0 {
                    write!(f, "^")?;
                }
                write!(f, "e{}", idx)?;
            }
            Ok(())
        }
    }
}

/// An element of a Clifford algebra
#[derive(Clone, Debug)]
pub struct CliffordAlgebraElement<R: Ring> {
    /// Coefficients for each basis element
    terms: HashMap<CliffordBasisElement, R>,
    /// Dimension of the underlying vector space
    dimension: usize,
    /// Quadratic form values: Q(e_i) for each generator
    quadratic_form: Vec<R>,
}

impl<R: Ring> CliffordAlgebraElement<R> {
    /// Create a new Clifford algebra element
    pub fn new(dimension: usize, quadratic_form: Vec<R>) -> Self {
        assert_eq!(dimension, quadratic_form.len());
        Self {
            terms: HashMap::new(),
            dimension,
            quadratic_form,
        }
    }

    /// Create from a single term
    pub fn from_term(
        coeff: R,
        basis: CliffordBasisElement,
        dimension: usize,
        quadratic_form: Vec<R>,
    ) -> Self {
        let mut terms = HashMap::new();
        if !coeff.is_zero() {
            terms.insert(basis, coeff);
        }
        Self {
            terms,
            dimension,
            quadratic_form,
        }
    }

    /// Create a scalar element
    pub fn scalar(value: R, dimension: usize, quadratic_form: Vec<R>) -> Self {
        Self::from_term(value, CliffordBasisElement::scalar(), dimension, quadratic_form)
    }

    /// Create a generator element
    pub fn generator(index: usize, dimension: usize, quadratic_form: Vec<R>) -> Self {
        Self::from_term(
            R::one(),
            CliffordBasisElement::generator(index),
            dimension,
            quadratic_form,
        )
    }

    /// Add a term
    pub fn add_term(&mut self, coeff: R, basis: CliffordBasisElement) {
        if coeff.is_zero() {
            return;
        }
        let entry = self.terms.entry(basis).or_insert_with(R::zero);
        *entry = entry.clone() + coeff;

        // Clean up zero coefficients
        self.terms.retain(|_, c| !c.is_zero());
    }

    /// Check if this element is a scalar
    pub fn is_scalar(&self) -> bool {
        self.terms.len() <= 1 && self.terms.keys().all(|b| b.is_scalar())
    }

    /// Get the scalar value (if this is a scalar)
    pub fn to_scalar(&self) -> Option<R> {
        if self.is_scalar() {
            Some(
                self.terms
                    .get(&CliffordBasisElement::scalar())
                    .cloned()
                    .unwrap_or_else(R::zero),
            )
        } else {
            None
        }
    }

    /// Get the grade-k component
    pub fn grade_component(&self, k: usize) -> Self {
        let mut result = Self::new(self.dimension, self.quadratic_form.clone());
        for (basis, coeff) in &self.terms {
            if basis.grade() == k {
                result.add_term(coeff.clone(), basis.clone());
            }
        }
        result
    }

    /// Multiply two basis elements using the Clifford product
    ///
    /// Returns (sign, resulting_basis) where sign is Â±1
    fn multiply_basis(
        &self,
        a: &CliffordBasisElement,
        b: &CliffordBasisElement,
    ) -> (R, CliffordBasisElement) {
        // Clifford product with: e_i * e_j = Q(e_i) if i==j, else anticommutes

        let mut result_indices = Vec::new();
        let mut sign_flips = 0;
        let mut scalar_part = R::one();

        let mut i = 0;
        let mut j = 0;

        while i < a.indices.len() || j < b.indices.len() {
            if i >= a.indices.len() {
                result_indices.push(b.indices[j]);
                j += 1;
            } else if j >= b.indices.len() {
                result_indices.push(a.indices[i]);
                i += 1;
            } else if a.indices[i] < b.indices[j] {
                result_indices.push(a.indices[i]);
                i += 1;
            } else if a.indices[i] > b.indices[j] {
                // Count sign flips: b.indices[j] needs to pass all remaining a indices
                sign_flips += a.indices.len() - i;
                result_indices.push(b.indices[j]);
                j += 1;
            } else {
                // a.indices[i] == b.indices[j]
                // e_i * e_i = Q(e_i)
                let qi = &self.quadratic_form[a.indices[i]];
                scalar_part = scalar_part * qi.clone();
                i += 1;
                j += 1;
            }
        }

        // Apply sign from anticommutations
        let sign = if sign_flips % 2 == 0 {
            scalar_part
        } else {
            -scalar_part
        };

        (sign, CliffordBasisElement::new(result_indices))
    }
}

impl<R: Ring> PartialEq for CliffordAlgebraElement<R> {
    fn eq(&self, other: &Self) -> bool {
        if self.dimension != other.dimension {
            return false;
        }
        if self.terms.len() != other.terms.len() {
            return false;
        }
        for (basis, coeff) in &self.terms {
            let other_coeff = other.terms.get(basis).cloned().unwrap_or_else(R::zero);
            if *coeff != other_coeff {
                return false;
            }
        }
        true
    }
}

impl<R: Ring> Display for CliffordAlgebraElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.terms.is_empty() {
            return write!(f, "0");
        }

        let mut sorted_terms: Vec<_> = self.terms.iter().collect();
        sorted_terms.sort_by_key(|(b, _)| *b);

        for (i, (basis, coeff)) in sorted_terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            if basis.is_scalar() {
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "{}", basis)?;
            } else {
                write!(f, "{}*{}", coeff, basis)?;
            }
        }
        Ok(())
    }
}

impl<R: Ring> Add for CliffordAlgebraElement<R> {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        assert_eq!(self.dimension, other.dimension);

        let mut result = self.clone();
        for (basis, coeff) in other.terms {
            result.add_term(coeff, basis);
        }
        result
    }
}

impl<R: Ring> Sub for CliffordAlgebraElement<R> {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        self + (-other)
    }
}

impl<R: Ring> Neg for CliffordAlgebraElement<R> {
    type Output = Self;

    fn neg(self) -> Self {
        let mut result = Self::new(self.dimension, self.quadratic_form.clone());
        for (basis, coeff) in self.terms {
            result.add_term(-coeff, basis);
        }
        result
    }
}

impl<R: Ring> Mul for CliffordAlgebraElement<R> {
    type Output = Self;

    fn mul(self, other: Self) -> Self {
        assert_eq!(self.dimension, other.dimension);

        let mut result = Self::new(self.dimension, self.quadratic_form.clone());

        for (basis1, coeff1) in &self.terms {
            for (basis2, coeff2) in &other.terms {
                let (sign, new_basis) = self.multiply_basis(basis1, basis2);
                let new_coeff = coeff1.clone() * coeff2.clone() * sign;
                result.add_term(new_coeff, new_basis);
            }
        }

        result
    }
}

impl<R: Ring> Ring for CliffordAlgebraElement<R> {
    fn zero() -> Self {
        Self::new(0, Vec::new())
    }

    fn one() -> Self {
        Self::scalar(R::one(), 0, Vec::new())
    }

    fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    fn is_one(&self) -> bool {
        self.terms.len() == 1
            && self.terms
                .get(&CliffordBasisElement::scalar())
                .map_or(false, |c| c.is_one())
    }
}

/// A Clifford algebra Cl(V,Q)
pub struct CliffordAlgebra<R: Ring> {
    /// Dimension of the underlying vector space
    dimension: usize,
    /// Quadratic form values
    quadratic_form: Vec<R>,
}

impl<R: Ring> CliffordAlgebra<R> {
    /// Create a Clifford algebra with a given quadratic form
    ///
    /// quadratic_form[i] = Q(e_i) where e_i are the basis vectors
    pub fn new(quadratic_form: Vec<R>) -> Self {
        let dimension = quadratic_form.len();
        Self {
            dimension,
            quadratic_form,
        }
    }

    /// Create the standard Clifford algebra (Q(e_i) = 1 for all i)
    pub fn standard(dimension: usize) -> Self {
        let quadratic_form = vec![R::one(); dimension];
        Self::new(quadratic_form)
    }

    /// The dimension of the underlying vector space
    pub fn dimension(&self) -> usize {
        self.dimension
    }

    /// The dimension of the Clifford algebra (as a vector space)
    pub fn algebra_dimension(&self) -> usize {
        1 << self.dimension // 2^n
    }

    /// Create the zero element
    pub fn zero(&self) -> CliffordAlgebraElement<R> {
        CliffordAlgebraElement::new(self.dimension, self.quadratic_form.clone())
    }

    /// Create the one element
    pub fn one(&self) -> CliffordAlgebraElement<R> {
        CliffordAlgebraElement::scalar(R::one(), self.dimension, self.quadratic_form.clone())
    }

    /// Get a generator
    pub fn generator(&self, index: usize) -> Option<CliffordAlgebraElement<R>> {
        if index < self.dimension {
            Some(CliffordAlgebraElement::generator(
                index,
                self.dimension,
                self.quadratic_form.clone(),
            ))
        } else {
            None
        }
    }

    /// Get all generators
    pub fn generators(&self) -> Vec<CliffordAlgebraElement<R>> {
        (0..self.dimension)
            .map(|i| self.generator(i).unwrap())
            .collect()
    }
}

/// The exterior algebra (special case: Q = 0)
pub type ExteriorAlgebra<R> = CliffordAlgebra<R>;

impl<R: Ring> CliffordAlgebra<R> {
    /// Create an exterior algebra (all Q(e_i) = 0)
    pub fn exterior(dimension: usize) -> Self {
        let quadratic_form = vec![R::zero(); dimension];
        Self::new(quadratic_form)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_clifford_algebra_creation() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::standard(3);
        assert_eq!(alg.dimension(), 3);
        assert_eq!(alg.algebra_dimension(), 8); // 2^3
    }

    #[test]
    fn test_clifford_multiplication() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::standard(2);
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();

        // e0 * e0 = Q(e0) = 1
        let prod = e0.clone() * e0.clone();
        assert!(prod.is_scalar());

        // e0 * e1 != e1 * e0 (anticommutes)
        let prod1 = e0.clone() * e1.clone();
        let prod2 = e1.clone() * e0.clone();
        assert_eq!(prod1, -prod2);
    }

    #[test]
    fn test_exterior_algebra() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::exterior(2);
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();

        // In exterior algebra, e_i * e_i = 0
        let prod = e0.clone() * e0.clone();
        assert!(prod.is_zero());

        // Still anticommutes
        let prod1 = e0.clone() * e1.clone();
        let prod2 = e1.clone() * e0.clone();
        assert_eq!(prod1, -prod2);
    }
}
