//! Clifford Algebra Implementation
//!
//! The Clifford algebra Cl(V,Q) associated to a quadratic form Q on a vector space V.
//! Important in geometry and physics (geometric algebra, spinors).
//!
//! The algebra is generated by a vector space V with the relation:
//! v * v = Q(v) for all v in V
//!
//! Corresponds to sage.algebras.clifford_algebra

use rustmath_core::{Ring, MathError, Result};
use std::collections::HashMap;
use std::fmt::{self, Display};
use std::ops::{Add, Mul, Neg, Sub};

/// A basis element in the Clifford algebra
///
/// Represented as a sorted set of generator indices (antisymmetric product)
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CliffordBasisElement {
    /// Indices of the generators in this basis element
    /// Always kept sorted for canonical form
    indices: Vec<usize>,
}

impl CliffordBasisElement {
    /// Create a new basis element
    pub fn new(mut indices: Vec<usize>) -> Self {
        indices.sort_unstable();
        indices.dedup(); // Remove duplicates (e_i * e_i is scalar)
        Self { indices }
    }

    /// The scalar basis element (empty product)
    pub fn scalar() -> Self {
        Self { indices: Vec::new() }
    }

    /// A single generator
    pub fn generator(index: usize) -> Self {
        Self { indices: vec![index] }
    }

    /// Grade (number of generators in the product)
    pub fn grade(&self) -> usize {
        self.indices.len()
    }

    /// Check if this is the scalar element
    pub fn is_scalar(&self) -> bool {
        self.indices.is_empty()
    }
}

impl Display for CliffordBasisElement {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_scalar() {
            write!(f, "1")
        } else {
            for (i, &idx) in self.indices.iter().enumerate() {
                if i > 0 {
                    write!(f, "^")?;
                }
                write!(f, "e{}", idx)?;
            }
            Ok(())
        }
    }
}

/// An element of a Clifford algebra
#[derive(Clone, Debug)]
pub struct CliffordAlgebraElement<R: Ring> {
    /// Coefficients for each basis element
    terms: HashMap<CliffordBasisElement, R>,
    /// Dimension of the underlying vector space
    dimension: usize,
    /// Quadratic form values: Q(e_i) for each generator
    quadratic_form: Vec<R>,
}

impl<R: Ring> CliffordAlgebraElement<R> {
    /// Create a new Clifford algebra element
    pub fn new(dimension: usize, quadratic_form: Vec<R>) -> Self {
        assert_eq!(dimension, quadratic_form.len());
        Self {
            terms: HashMap::new(),
            dimension,
            quadratic_form,
        }
    }

    /// Create from a single term
    pub fn from_term(
        coeff: R,
        basis: CliffordBasisElement,
        dimension: usize,
        quadratic_form: Vec<R>,
    ) -> Self {
        let mut terms = HashMap::new();
        if !coeff.is_zero() {
            terms.insert(basis, coeff);
        }
        Self {
            terms,
            dimension,
            quadratic_form,
        }
    }

    /// Create a scalar element
    pub fn scalar(value: R, dimension: usize, quadratic_form: Vec<R>) -> Self {
        Self::from_term(value, CliffordBasisElement::scalar(), dimension, quadratic_form)
    }

    /// Create a generator element
    pub fn generator(index: usize, dimension: usize, quadratic_form: Vec<R>) -> Self {
        Self::from_term(
            R::one(),
            CliffordBasisElement::generator(index),
            dimension,
            quadratic_form,
        )
    }

    /// Add a term
    pub fn add_term(&mut self, coeff: R, basis: CliffordBasisElement) {
        if coeff.is_zero() {
            return;
        }
        let entry = self.terms.entry(basis).or_insert_with(R::zero);
        *entry = entry.clone() + coeff;

        // Clean up zero coefficients
        self.terms.retain(|_, c| !c.is_zero());
    }

    /// Check if this element is a scalar
    pub fn is_scalar(&self) -> bool {
        self.terms.len() <= 1 && self.terms.keys().all(|b| b.is_scalar())
    }

    /// Get the scalar value (if this is a scalar)
    pub fn to_scalar(&self) -> Option<R> {
        if self.is_scalar() {
            Some(
                self.terms
                    .get(&CliffordBasisElement::scalar())
                    .cloned()
                    .unwrap_or_else(R::zero),
            )
        } else {
            None
        }
    }

    /// Get the grade-k component
    pub fn grade_component(&self, k: usize) -> Self {
        let mut result = Self::new(self.dimension, self.quadratic_form.clone());
        for (basis, coeff) in &self.terms {
            if basis.grade() == k {
                result.add_term(coeff.clone(), basis.clone());
            }
        }
        result
    }

    /// Multiply two basis elements using the Clifford product
    ///
    /// Returns (sign, resulting_basis) where sign is ±1
    fn multiply_basis(
        &self,
        a: &CliffordBasisElement,
        b: &CliffordBasisElement,
    ) -> (R, CliffordBasisElement) {
        // Clifford product with: e_i * e_j = Q(e_i) if i==j, else anticommutes

        let mut result_indices = Vec::new();
        let mut sign_flips = 0;
        let mut scalar_part = R::one();

        let mut i = 0;
        let mut j = 0;

        while i < a.indices.len() || j < b.indices.len() {
            if i >= a.indices.len() {
                result_indices.push(b.indices[j]);
                j += 1;
            } else if j >= b.indices.len() {
                result_indices.push(a.indices[i]);
                i += 1;
            } else if a.indices[i] < b.indices[j] {
                result_indices.push(a.indices[i]);
                i += 1;
            } else if a.indices[i] > b.indices[j] {
                // Count sign flips: b.indices[j] needs to pass all remaining a indices
                sign_flips += a.indices.len() - i;
                result_indices.push(b.indices[j]);
                j += 1;
            } else {
                // a.indices[i] == b.indices[j]
                // e_i * e_i = Q(e_i)
                let qi = &self.quadratic_form[a.indices[i]];
                scalar_part = scalar_part * qi.clone();
                i += 1;
                j += 1;
            }
        }

        // Apply sign from anticommutations
        let sign = if sign_flips % 2 == 0 {
            scalar_part
        } else {
            -scalar_part
        };

        (sign, CliffordBasisElement::new(result_indices))
    }
}

impl<R: Ring> PartialEq for CliffordAlgebraElement<R> {
    fn eq(&self, other: &Self) -> bool {
        if self.dimension != other.dimension {
            return false;
        }
        if self.terms.len() != other.terms.len() {
            return false;
        }
        for (basis, coeff) in &self.terms {
            let other_coeff = other.terms.get(basis).cloned().unwrap_or_else(R::zero);
            if *coeff != other_coeff {
                return false;
            }
        }
        true
    }
}

impl<R: Ring> Display for CliffordAlgebraElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.terms.is_empty() {
            return write!(f, "0");
        }

        let mut sorted_terms: Vec<_> = self.terms.iter().collect();
        sorted_terms.sort_by_key(|(b, _)| *b);

        for (i, (basis, coeff)) in sorted_terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            if basis.is_scalar() {
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "{}", basis)?;
            } else {
                write!(f, "{}*{}", coeff, basis)?;
            }
        }
        Ok(())
    }
}

impl<R: Ring> Add for CliffordAlgebraElement<R> {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        assert_eq!(self.dimension, other.dimension);

        let mut result = self.clone();
        for (basis, coeff) in other.terms {
            result.add_term(coeff, basis);
        }
        result
    }
}

impl<R: Ring> Sub for CliffordAlgebraElement<R> {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        self + (-other)
    }
}

impl<R: Ring> Neg for CliffordAlgebraElement<R> {
    type Output = Self;

    fn neg(self) -> Self {
        let mut result = Self::new(self.dimension, self.quadratic_form.clone());
        for (basis, coeff) in self.terms {
            result.add_term(-coeff, basis);
        }
        result
    }
}

impl<R: Ring> Mul for CliffordAlgebraElement<R> {
    type Output = Self;

    fn mul(self, other: Self) -> Self {
        assert_eq!(self.dimension, other.dimension);

        let mut result = Self::new(self.dimension, self.quadratic_form.clone());

        for (basis1, coeff1) in &self.terms {
            for (basis2, coeff2) in &other.terms {
                let (sign, new_basis) = self.multiply_basis(basis1, basis2);
                let new_coeff = coeff1.clone() * coeff2.clone() * sign;
                result.add_term(new_coeff, new_basis);
            }
        }

        result
    }
}

impl<R: Ring> Ring for CliffordAlgebraElement<R> {
    fn zero() -> Self {
        Self::new(0, Vec::new())
    }

    fn one() -> Self {
        Self::scalar(R::one(), 0, Vec::new())
    }

    fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    fn is_one(&self) -> bool {
        self.terms.len() == 1
            && self.terms
                .get(&CliffordBasisElement::scalar())
                .map_or(false, |c| c.is_one())
    }
}

/// A Clifford algebra Cl(V,Q)
#[derive(Clone, Debug)]
pub struct CliffordAlgebra<R: Ring> {
    /// Dimension of the underlying vector space
    dimension: usize,
    /// Quadratic form values
    quadratic_form: Vec<R>,
}

impl<R: Ring> CliffordAlgebra<R> {
    /// Create a Clifford algebra with a given quadratic form
    ///
    /// quadratic_form[i] = Q(e_i) where e_i are the basis vectors
    pub fn new(quadratic_form: Vec<R>) -> Self {
        let dimension = quadratic_form.len();
        Self {
            dimension,
            quadratic_form,
        }
    }

    /// Create the standard Clifford algebra (Q(e_i) = 1 for all i)
    pub fn standard(dimension: usize) -> Self {
        let quadratic_form = vec![R::one(); dimension];
        Self::new(quadratic_form)
    }

    /// The dimension of the underlying vector space
    pub fn dimension(&self) -> usize {
        self.dimension
    }

    /// The dimension of the Clifford algebra (as a vector space)
    pub fn algebra_dimension(&self) -> usize {
        1 << self.dimension // 2^n
    }

    /// Create the zero element
    pub fn zero(&self) -> CliffordAlgebraElement<R> {
        CliffordAlgebraElement::new(self.dimension, self.quadratic_form.clone())
    }

    /// Create the one element
    pub fn one(&self) -> CliffordAlgebraElement<R> {
        CliffordAlgebraElement::scalar(R::one(), self.dimension, self.quadratic_form.clone())
    }

    /// Get a generator
    pub fn generator(&self, index: usize) -> Option<CliffordAlgebraElement<R>> {
        if index < self.dimension {
            Some(CliffordAlgebraElement::generator(
                index,
                self.dimension,
                self.quadratic_form.clone(),
            ))
        } else {
            None
        }
    }

    /// Get all generators
    pub fn generators(&self) -> Vec<CliffordAlgebraElement<R>> {
        (0..self.dimension)
            .map(|i| self.generator(i).unwrap())
            .collect()
    }
}

/// The exterior algebra (special case: Q = 0)
pub type ExteriorAlgebra<R> = CliffordAlgebra<R>;

impl<R: Ring> CliffordAlgebra<R> {
    /// Create an exterior algebra (all Q(e_i) = 0)
    pub fn exterior(dimension: usize) -> Self {
        let quadratic_form = vec![R::zero(); dimension];
        Self::new(quadratic_form)
    }
}

/// Structure coefficients for Lie algebra differentials
///
/// Maps pairs of basis indices (i,j) to the bracket [x_i, x_j] represented
/// as a linear combination of basis elements
pub type StructureCoefficients<R> = HashMap<(usize, usize), HashMap<usize, R>>;

/// A differential operator on an exterior algebra
///
/// Base structure for boundary and coboundary operators used in
/// (co)homology computations of Lie algebras
#[derive(Clone, Debug)]
pub struct ExteriorAlgebraDifferential<R: Ring> {
    /// The underlying exterior algebra
    algebra: ExteriorAlgebra<R>,
    /// Structure coefficients defining the differential
    /// For indices i < j: structure_coeffs[(i,j)][k] = c_{ij}^k where [x_i, x_j] = Σ c_{ij}^k x_k
    structure_coeffs: StructureCoefficients<R>,
    /// Whether this increases degree (coboundary) or decreases (boundary)
    increases_degree: bool,
}

impl<R: Ring> ExteriorAlgebraDifferential<R> {
    /// Create a new differential from structure coefficients
    ///
    /// # Arguments
    /// * `algebra` - The exterior algebra to operate on
    /// * `structure_coeffs` - Maps (i,j) pairs to linear combinations representing [x_i, x_j]
    /// * `increases_degree` - true for coboundary (d), false for boundary (∂)
    pub fn new(
        algebra: ExteriorAlgebra<R>,
        structure_coeffs: StructureCoefficients<R>,
        increases_degree: bool,
    ) -> Self {
        Self {
            algebra,
            structure_coeffs,
            increases_degree,
        }
    }

    /// Apply the differential to an exterior algebra element
    ///
    /// For boundary: maps (k+1)-forms to k-forms
    /// For coboundary: maps k-forms to (k+1)-forms
    pub fn apply(&self, element: &CliffordAlgebraElement<R>) -> CliffordAlgebraElement<R> {
        let mut result = self.algebra.zero();

        for (basis, coeff) in &element.terms {
            let diff_term = self.apply_to_basis(basis);
            let scaled = self.scalar_mult(&diff_term, coeff.clone());
            result = result + scaled;
        }

        result
    }

    /// Apply differential to a single basis element
    fn apply_to_basis(&self, basis: &CliffordBasisElement) -> CliffordAlgebraElement<R> {
        let mut result = self.algebra.zero();

        if self.increases_degree {
            // Coboundary: increase degree by 1
            // d(e_{i1} ∧ ... ∧ e_{ik}) involves structure coefficients
            for (i, j) in basis.indices.iter().enumerate().flat_map(|(idx, &i)| {
                basis.indices[idx + 1..].iter().map(move |&j| (i, j))
            }) {
                if let Some(bracket) = self.get_structure_coeff(i, j) {
                    // Compute sign and construct result term
                    for (k, c) in bracket {
                        let mut new_indices = basis.indices.clone();
                        new_indices.push(*k);
                        new_indices.sort_unstable();

                        let new_basis = CliffordBasisElement::new(new_indices);
                        result.add_term(c.clone(), new_basis);
                    }
                }
            }
        } else {
            // Boundary: decrease degree by 1
            // ∂(e_{i1} ∧ ... ∧ e_{ik}) = Σ (-1)^{p+q} [e_{ip}, e_{iq}] ∧ e_{i1} ∧ ... (omitting ip, iq)
            let indices = &basis.indices;
            for p in 0..indices.len() {
                for q in (p + 1)..indices.len() {
                    let i = indices[p];
                    let j = indices[q];

                    if let Some(bracket) = self.get_structure_coeff(i, j) {
                        // Sign from position
                        let sign_flips = (p + q) % 2;

                        // Construct basis without indices p and q
                        let mut remaining: Vec<usize> = indices
                            .iter()
                            .enumerate()
                            .filter_map(|(idx, &val)| {
                                if idx != p && idx != q {
                                    Some(val)
                                } else {
                                    None
                                }
                            })
                            .collect();

                        for (k, c) in bracket {
                            remaining.push(*k);
                            remaining.sort_unstable();

                            let new_basis = CliffordBasisElement::new(remaining.clone());
                            let signed_coeff = if sign_flips % 2 == 0 {
                                c.clone()
                            } else {
                                -c.clone()
                            };
                            result.add_term(signed_coeff, new_basis);

                            remaining.pop();
                        }
                    }
                }
            }
        }

        result
    }

    /// Get structure coefficient for [x_i, x_j]
    fn get_structure_coeff(&self, i: usize, j: usize) -> Option<&HashMap<usize, R>> {
        if i < j {
            self.structure_coeffs.get(&(i, j))
        } else if i > j {
            // Use antisymmetry: [x_j, x_i] = -[x_i, x_j]
            self.structure_coeffs.get(&(j, i))
        } else {
            // [x_i, x_i] = 0
            None
        }
    }

    /// Scalar multiplication helper
    fn scalar_mult(&self, element: &CliffordAlgebraElement<R>, scalar: R) -> CliffordAlgebraElement<R> {
        let mut result = self.algebra.zero();
        for (basis, coeff) in &element.terms {
            result.add_term(coeff.clone() * scalar.clone(), basis.clone());
        }
        result
    }

    /// Get the underlying algebra
    pub fn algebra(&self) -> &ExteriorAlgebra<R> {
        &self.algebra
    }
}

/// Boundary operator for Lie algebra homology
///
/// The boundary ∂: ∧^{k+1}(L) → ∧^k(L) is defined using structure coefficients
/// of the Lie algebra L. It satisfies ∂² = 0, making (∧(L), ∂) a chain complex.
#[derive(Clone, Debug)]
pub struct ExteriorAlgebraBoundary<R: Ring> {
    differential: ExteriorAlgebraDifferential<R>,
}

impl<R: Ring> ExteriorAlgebraBoundary<R> {
    /// Create a boundary operator from structure coefficients
    pub fn new(algebra: ExteriorAlgebra<R>, structure_coeffs: StructureCoefficients<R>) -> Self {
        let differential = ExteriorAlgebraDifferential::new(algebra, structure_coeffs, false);
        Self { differential }
    }

    /// Apply the boundary operator to an element
    pub fn apply(&self, element: &CliffordAlgebraElement<R>) -> CliffordAlgebraElement<R> {
        self.differential.apply(element)
    }

    /// Get the underlying algebra
    pub fn algebra(&self) -> &ExteriorAlgebra<R> {
        self.differential.algebra()
    }

    /// Verify that ∂² = 0 for a given element
    pub fn verify_chain_complex(&self, element: &CliffordAlgebraElement<R>) -> bool {
        let first_application = self.apply(element);
        let second_application = self.apply(&first_application);
        second_application.is_zero()
    }
}

/// Coboundary operator for Lie algebra cohomology
///
/// The coboundary d: ∧^k(L) → ∧^{k+1}(L) is the dual operator to the boundary.
/// It satisfies d² = 0, making (∧(L), d) a cochain complex.
#[derive(Clone, Debug)]
pub struct ExteriorAlgebraCoboundary<R: Ring> {
    differential: ExteriorAlgebraDifferential<R>,
}

impl<R: Ring> ExteriorAlgebraCoboundary<R> {
    /// Create a coboundary operator from structure coefficients
    pub fn new(algebra: ExteriorAlgebra<R>, structure_coeffs: StructureCoefficients<R>) -> Self {
        let differential = ExteriorAlgebraDifferential::new(algebra, structure_coeffs, true);
        Self { differential }
    }

    /// Apply the coboundary operator to an element
    pub fn apply(&self, element: &CliffordAlgebraElement<R>) -> CliffordAlgebraElement<R> {
        self.differential.apply(element)
    }

    /// Get the underlying algebra
    pub fn algebra(&self) -> &ExteriorAlgebra<R> {
        self.differential.algebra()
    }

    /// Verify that d² = 0 for a given element
    pub fn verify_cochain_complex(&self, element: &CliffordAlgebraElement<R>) -> bool {
        let first_application = self.apply(element);
        let second_application = self.apply(&first_application);
        second_application.is_zero()
    }
}

/// An ideal in an exterior algebra
///
/// Represents a two-sided ideal in ∧(V), which is a subspace I such that
/// for all x ∈ I and y ∈ ∧(V), both x∧y and y∧x are in I.
#[derive(Clone, Debug)]
pub struct ExteriorAlgebraIdeal<R: Ring> {
    /// The exterior algebra containing this ideal
    algebra: ExteriorAlgebra<R>,
    /// Generator elements of the ideal
    generators: Vec<CliffordAlgebraElement<R>>,
    /// Cached Gröbner-like basis (optional, for efficiency)
    basis: Option<Vec<CliffordAlgebraElement<R>>>,
}

impl<R: Ring> ExteriorAlgebraIdeal<R> {
    /// Create a new ideal from generators
    pub fn new(algebra: ExteriorAlgebra<R>, generators: Vec<CliffordAlgebraElement<R>>) -> Self {
        Self {
            algebra,
            generators,
            basis: None,
        }
    }

    /// Create the zero ideal
    pub fn zero(algebra: ExteriorAlgebra<R>) -> Self {
        Self::new(algebra, Vec::new())
    }

    /// Create the unit ideal (whole algebra)
    pub fn unit(algebra: ExteriorAlgebra<R>) -> Self {
        Self::new(algebra.clone(), vec![algebra.one()])
    }

    /// Get the generators of this ideal
    pub fn generators(&self) -> &[CliffordAlgebraElement<R>] {
        &self.generators
    }

    /// Check if an element is in this ideal
    ///
    /// Note: This is a simplified membership test. For exact computation,
    /// Gröbner basis methods would be needed.
    pub fn contains(&self, element: &CliffordAlgebraElement<R>) -> bool {
        // Simplified: check if element is in span of generators
        // Full implementation would use reduction algorithms
        if element.is_zero() {
            return true;
        }

        if self.generators.is_empty() {
            return element.is_zero();
        }

        // For now, just check if it's a generator
        self.generators.iter().any(|g| g == element)
    }

    /// Add a generator to the ideal
    pub fn add_generator(&mut self, generator: CliffordAlgebraElement<R>) {
        if !generator.is_zero() {
            self.generators.push(generator);
            self.basis = None; // Invalidate cached basis
        }
    }

    /// Get the underlying algebra
    pub fn algebra(&self) -> &ExteriorAlgebra<R> {
        &self.algebra
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_clifford_algebra_creation() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::standard(3);
        assert_eq!(alg.dimension(), 3);
        assert_eq!(alg.algebra_dimension(), 8); // 2^3
    }

    #[test]
    fn test_clifford_multiplication() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::standard(2);
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();

        // e0 * e0 = Q(e0) = 1
        let prod = e0.clone() * e0.clone();
        assert!(prod.is_scalar());

        // e0 * e1 != e1 * e0 (anticommutes)
        let prod1 = e0.clone() * e1.clone();
        let prod2 = e1.clone() * e0.clone();
        assert_eq!(prod1, -prod2);
    }

    #[test]
    fn test_exterior_algebra() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::exterior(2);
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();

        // In exterior algebra, e_i * e_i = 0
        let prod = e0.clone() * e0.clone();
        assert!(prod.is_zero());

        // Still anticommutes
        let prod1 = e0.clone() * e1.clone();
        let prod2 = e1.clone() * e0.clone();
        assert_eq!(prod1, -prod2);
    }

    #[test]
    fn test_exterior_differential_basic() {
        // Create a 3-dimensional exterior algebra
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::exterior(3);

        // Define structure coefficients for a simple Lie algebra
        // Let's use sl_2: [h,e] = 2e, [h,f] = -2f, [e,f] = h
        // Indices: 0=h, 1=e, 2=f
        let mut structure_coeffs = HashMap::new();

        // [h, e] = 2e (indices 0,1 -> 1)
        let mut bracket_01 = HashMap::new();
        bracket_01.insert(1, Integer::from(2));
        structure_coeffs.insert((0, 1), bracket_01);

        // [h, f] = -2f (indices 0,2 -> 2)
        let mut bracket_02 = HashMap::new();
        bracket_02.insert(2, Integer::from(-2));
        structure_coeffs.insert((0, 2), bracket_02);

        // [e, f] = h (indices 1,2 -> 0)
        let mut bracket_12 = HashMap::new();
        bracket_12.insert(0, Integer::from(1));
        structure_coeffs.insert((1, 2), bracket_12);

        // Create boundary operator
        let boundary = ExteriorAlgebraBoundary::new(alg.clone(), structure_coeffs);

        // Test on a 2-form: e_0 ∧ e_1
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();
        let two_form = e0.clone() * e1.clone();

        let result = boundary.apply(&two_form);
        // ∂(e_0 ∧ e_1) = [e_0, e_1] = 2e_1
        // The result should be a 1-form
        assert!(!result.is_zero());
    }

    #[test]
    fn test_exterior_boundary_chain_complex() {
        // Create exterior algebra
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::exterior(3);

        // Simple structure coefficients (abelian Lie algebra: all brackets = 0)
        let structure_coeffs = HashMap::new();

        let boundary = ExteriorAlgebraBoundary::new(alg.clone(), structure_coeffs);

        // For abelian Lie algebra, ∂ should be zero
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();
        let two_form = e0 * e1;

        assert!(boundary.verify_chain_complex(&two_form));
    }

    #[test]
    fn test_exterior_algebra_ideal() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::exterior(3);
        let e0 = alg.generator(0).unwrap();
        let e1 = alg.generator(1).unwrap();

        // Create ideal generated by e0
        let ideal = ExteriorAlgebraIdeal::new(alg.clone(), vec![e0.clone()]);

        assert!(ideal.contains(&e0));
        assert!(!ideal.contains(&e1));
        assert_eq!(ideal.generators().len(), 1);
    }

    #[test]
    fn test_exterior_algebra_ideal_unit_and_zero() {
        let alg: CliffordAlgebra<Integer> = CliffordAlgebra::exterior(2);
        let e0 = alg.generator(0).unwrap();

        // Zero ideal
        let zero_ideal = ExteriorAlgebraIdeal::zero(alg.clone());
        assert!(zero_ideal.contains(&alg.zero()));
        assert!(!zero_ideal.contains(&e0));

        // Unit ideal
        let unit_ideal = ExteriorAlgebraIdeal::unit(alg.clone());
        assert!(unit_ideal.contains(&alg.one()));
    }

    #[test]
    fn test_clifford_basis_element_grade() {
        let basis1 = CliffordBasisElement::scalar();
        assert_eq!(basis1.grade(), 0);

        let basis2 = CliffordBasisElement::generator(0);
        assert_eq!(basis2.grade(), 1);

        let basis3 = CliffordBasisElement::new(vec![0, 1, 2]);
        assert_eq!(basis3.grade(), 3);
    }
}
