//! Free Algebra Implementation
//!
//! A free algebra is the non-commutative polynomial algebra over a ring R
//! generated by a set of generators. Elements are linear combinations of
//! monomials (words) in the generators.
//!
//! Corresponds to sage.algebras.free_algebra

use rustmath_core::{Ring, MathError, Result};
use std::collections::HashMap;
use std::fmt::{self, Display};
use std::ops::{Add, Mul, Neg, Sub};
use crate::traits::{Algebra, FreeAlgebra as FreeAlgebraTrait};

/// A monomial in a free algebra: a word in the generators
#[derive(Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct Word {
    /// The generators in this word, in order
    generators: Vec<usize>,
}

impl Word {
    /// Create a new word from a sequence of generator indices
    pub fn new(generators: Vec<usize>) -> Self {
        Self { generators }
    }

    /// The empty word (identity element for multiplication)
    pub fn identity() -> Self {
        Self { generators: Vec::new() }
    }

    /// Check if this is the empty word
    pub fn is_identity(&self) -> bool {
        self.generators.is_empty()
    }

    /// Degree (length) of the word
    pub fn degree(&self) -> usize {
        self.generators.len()
    }

    /// Concatenate two words
    pub fn concatenate(&self, other: &Self) -> Self {
        let mut result = self.generators.clone();
        result.extend_from_slice(&other.generators);
        Self { generators: result }
    }
}

impl Display for Word {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_identity() {
            write!(f, "1")
        } else {
            for (i, &gen) in self.generators.iter().enumerate() {
                if i > 0 {
                    write!(f, "*")?;
                }
                write!(f, "x{}", gen)?;
            }
            Ok(())
        }
    }
}

/// An element of a free algebra over a ring R
///
/// Represented as a linear combination of words (monomials)
#[derive(Clone, Debug)]
pub struct FreeAlgebraElement<R: Ring> {
    /// Coefficients for each monomial (word -> coefficient)
    terms: HashMap<Word, R>,
    /// Number of generators
    num_generators: usize,
}

impl<R: Ring> FreeAlgebraElement<R> {
    /// Create a new free algebra element
    pub fn new(num_generators: usize) -> Self {
        Self {
            terms: HashMap::new(),
            num_generators,
        }
    }

    /// Create from a single term
    pub fn from_term(coeff: R, word: Word, num_generators: usize) -> Self {
        let mut terms = HashMap::new();
        if !coeff.is_zero() {
            terms.insert(word, coeff);
        }
        Self { terms, num_generators }
    }

    /// Create from a generator
    pub fn generator(index: usize, num_generators: usize) -> Self {
        Self::from_term(
            R::one(),
            Word::new(vec![index]),
            num_generators,
        )
    }

    /// Add a term to this element
    pub fn add_term(&mut self, coeff: R, word: Word) {
        if coeff.is_zero() {
            return;
        }

        let entry = self.terms.entry(word).or_insert_with(R::zero);
        *entry = entry.clone() + coeff;

        // Remove zero coefficients
        self.terms.retain(|_, c| !c.is_zero());
    }

    /// Get the coefficient of a word
    pub fn coeff(&self, word: &Word) -> R {
        self.terms.get(word).cloned().unwrap_or_else(R::zero)
    }

    /// Check if this element is a scalar
    pub fn is_scalar(&self) -> bool {
        self.terms.len() == 1 && self.terms.contains_key(&Word::identity())
            || self.terms.is_empty()
    }

    /// Get the scalar value (if this is a scalar)
    pub fn to_scalar(&self) -> Option<R> {
        if self.is_scalar() {
            Some(self.terms.get(&Word::identity())
                .cloned()
                .unwrap_or_else(R::zero))
        } else {
            None
        }
    }

    /// Degree of the element (maximum degree of monomials)
    pub fn degree(&self) -> Option<usize> {
        self.terms.keys().map(|w| w.degree()).max()
    }

    /// Get homogeneous component of given degree
    pub fn homogeneous_component(&self, degree: usize) -> Self {
        let mut result = Self::new(self.num_generators);
        for (word, coeff) in &self.terms {
            if word.degree() == degree {
                result.add_term(coeff.clone(), word.clone());
            }
        }
        result
    }
}

impl<R: Ring> PartialEq for FreeAlgebraElement<R> {
    fn eq(&self, other: &Self) -> bool {
        if self.num_generators != other.num_generators {
            return false;
        }
        if self.terms.len() != other.terms.len() {
            return false;
        }
        for (word, coeff) in &self.terms {
            if other.coeff(word) != *coeff {
                return false;
            }
        }
        true
    }
}

impl<R: Ring> Display for FreeAlgebraElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.terms.is_empty() {
            return write!(f, "0");
        }

        let mut sorted_terms: Vec<_> = self.terms.iter().collect();
        sorted_terms.sort_by_key(|(w, _)| *w);

        for (i, (word, coeff)) in sorted_terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            if word.is_identity() {
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "{}", word)?;
            } else {
                write!(f, "{}*{}", coeff, word)?;
            }
        }
        Ok(())
    }
}

impl<R: Ring> Add for FreeAlgebraElement<R> {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        assert_eq!(self.num_generators, other.num_generators,
            "Cannot add elements from algebras with different numbers of generators");

        let mut result = self.clone();
        for (word, coeff) in other.terms {
            result.add_term(coeff, word);
        }
        result
    }
}

impl<R: Ring> Sub for FreeAlgebraElement<R> {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        self + (-other)
    }
}

impl<R: Ring> Neg for FreeAlgebraElement<R> {
    type Output = Self;

    fn neg(self) -> Self {
        let mut result = Self::new(self.num_generators);
        for (word, coeff) in self.terms {
            result.add_term(-coeff, word);
        }
        result
    }
}

impl<R: Ring> Mul for FreeAlgebraElement<R> {
    type Output = Self;

    fn mul(self, other: Self) -> Self {
        assert_eq!(self.num_generators, other.num_generators,
            "Cannot multiply elements from algebras with different numbers of generators");

        let mut result = Self::new(self.num_generators);

        for (word1, coeff1) in &self.terms {
            for (word2, coeff2) in &other.terms {
                let new_word = word1.concatenate(word2);
                let new_coeff = coeff1.clone() * coeff2.clone();
                result.add_term(new_coeff, new_word);
            }
        }

        result
    }
}

impl<R: Ring> Ring for FreeAlgebraElement<R> {
    fn zero() -> Self {
        Self::new(0) // Default to 0 generators, will be set by context
    }

    fn one() -> Self {
        let mut result = Self::new(0);
        result.add_term(R::one(), Word::identity());
        result
    }

    fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    fn is_one(&self) -> bool {
        self.terms.len() == 1 &&
            self.terms.get(&Word::identity()).map_or(false, |c| c.is_one())
    }
}

impl<R: Ring> Algebra<R> for FreeAlgebraElement<R> {
    fn base_ring() -> R {
        R::zero() // Placeholder - should return type info
    }

    fn scalar_mul(&self, scalar: &R) -> Self {
        let mut result = Self::new(self.num_generators);
        for (word, coeff) in &self.terms {
            result.add_term(coeff.clone() * scalar.clone(), word.clone());
        }
        result
    }
}

impl<R: Ring> FreeAlgebraTrait<R> for FreeAlgebraElement<R> {
    type Generator = usize;

    fn generators() -> Vec<Self::Generator> {
        // This would need to be stored in the algebra structure
        Vec::new()
    }

    fn rank() -> usize {
        // This would need to be stored in the algebra structure
        0
    }
}

/// A free algebra over a ring R with a specified number of generators
pub struct FreeAlgebra<R: Ring> {
    /// Number of generators
    num_generators: usize,
    /// Names of generators (optional)
    generator_names: Vec<String>,
    /// Base ring (phantom)
    _phantom: std::marker::PhantomData<R>,
}

impl<R: Ring> FreeAlgebra<R> {
    /// Create a new free algebra with the given number of generators
    pub fn new(num_generators: usize) -> Self {
        let generator_names = (0..num_generators)
            .map(|i| format!("x{}", i))
            .collect();
        Self {
            num_generators,
            generator_names,
            _phantom: std::marker::PhantomData,
        }
    }

    /// Create a new free algebra with named generators
    pub fn with_names(generator_names: Vec<String>) -> Self {
        let num_generators = generator_names.len();
        Self {
            num_generators,
            generator_names,
            _phantom: std::marker::PhantomData,
        }
    }

    /// Get the number of generators
    pub fn rank(&self) -> usize {
        self.num_generators
    }

    /// Get a generator by index
    pub fn generator(&self, index: usize) -> Option<FreeAlgebraElement<R>> {
        if index < self.num_generators {
            Some(FreeAlgebraElement::generator(index, self.num_generators))
        } else {
            None
        }
    }

    /// Get all generators
    pub fn generators(&self) -> Vec<FreeAlgebraElement<R>> {
        (0..self.num_generators)
            .map(|i| FreeAlgebraElement::generator(i, self.num_generators))
            .collect()
    }

    /// Create the zero element
    pub fn zero(&self) -> FreeAlgebraElement<R> {
        FreeAlgebraElement::new(self.num_generators)
    }

    /// Create the one element
    pub fn one(&self) -> FreeAlgebraElement<R> {
        FreeAlgebraElement::from_term(
            R::one(),
            Word::identity(),
            self.num_generators,
        )
    }

    /// Create a scalar element
    pub fn scalar(&self, value: R) -> FreeAlgebraElement<R> {
        FreeAlgebraElement::from_term(
            value,
            Word::identity(),
            self.num_generators,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_word_operations() {
        let w1 = Word::new(vec![0, 1]);
        let w2 = Word::new(vec![2]);
        let w3 = w1.concatenate(&w2);

        assert_eq!(w3.generators, vec![0, 1, 2]);
        assert_eq!(w3.degree(), 3);
    }

    #[test]
    fn test_free_algebra_creation() {
        let algebra: FreeAlgebra<Integer> = FreeAlgebra::new(3);
        assert_eq!(algebra.rank(), 3);
    }

    #[test]
    fn test_free_algebra_arithmetic() {
        let algebra: FreeAlgebra<Integer> = FreeAlgebra::new(2);
        let x0 = algebra.generator(0).unwrap();
        let x1 = algebra.generator(1).unwrap();

        // Test addition
        let sum = x0.clone() + x1.clone();
        assert!(!sum.is_zero());

        // Test multiplication (non-commutative!)
        let prod1 = x0.clone() * x1.clone(); // x0*x1
        let prod2 = x1.clone() * x0.clone(); // x1*x0
        assert_ne!(prod1, prod2); // Should be different in non-commutative algebra

        // Test associativity
        let a = x0.clone();
        let b = x1.clone();
        let c = x0.clone();
        let lhs = (a.clone() * b.clone()) * c.clone();
        let rhs = a * (b * c);
        assert_eq!(lhs, rhs);
    }

    #[test]
    fn test_free_algebra_distributivity() {
        let algebra: FreeAlgebra<Integer> = FreeAlgebra::new(2);
        let x = algebra.generator(0).unwrap();
        let y = algebra.generator(1).unwrap();
        let z = algebra.generator(0).unwrap();

        // Test left distributivity: x * (y + z) = x*y + x*z
        let lhs = x.clone() * (y.clone() + z.clone());
        let rhs = x.clone() * y.clone() + x.clone() * z.clone();
        assert_eq!(lhs, rhs);

        // Test right distributivity: (y + z) * x = y*x + z*x
        let lhs = (y.clone() + z.clone()) * x.clone();
        let rhs = y.clone() * x.clone() + z.clone() * x.clone();
        assert_eq!(lhs, rhs);
    }
}
