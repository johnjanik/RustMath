//! Cluster Algebras
//!
//! A cluster algebra is a commutative ring generated by cluster variables
//! organized into overlapping sets called clusters. These algebras were
//! introduced by Fomin and Zelevinsky in 2002.
//!
//! This implementation models cluster algebras as subrings of Laurent
//! polynomial rings, with cluster variables parametrized by g-vectors
//! and computed from F-polynomials via the "separation of additions" formula.
//!
//! Corresponds to sage.algebras.cluster_algebra
//!
//! References:
//! - Fomin, S. and Zelevinsky, A. "Cluster algebras I: Foundations" (2002)
//! - Fomin, S. and Zelevinsky, A. "Cluster algebras IV: Coefficients" (2007)

use rustmath_core::{Ring, Field};
use rustmath_matrix::Matrix;
use rustmath_polynomials::{Polynomial, MultivariatePolynomial};
use std::collections::{HashMap, VecDeque, HashSet};
use std::fmt::{self, Display};
use std::hash::{Hash, Hasher};

/// A g-vector representing the homogeneous degree of a cluster variable
///
/// G-vectors are used to parametrize cluster variables and track their
/// positions in the exchange graph.
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GVector {
    /// Components of the g-vector
    pub components: Vec<i64>,
}

impl GVector {
    /// Create a new g-vector from components
    pub fn new(components: Vec<i64>) -> Self {
        GVector { components }
    }

    /// Create a standard basis g-vector e_i
    pub fn standard_basis(rank: usize, index: usize) -> Self {
        let mut components = vec![0; rank];
        if index < rank {
            components[index] = 1;
        }
        GVector { components }
    }

    /// Dimension of the g-vector
    pub fn dim(&self) -> usize {
        self.components.len()
    }

    /// Dot product with another g-vector
    pub fn dot(&self, other: &GVector) -> i64 {
        self.components.iter().zip(other.components.iter())
            .map(|(a, b)| a * b)
            .sum()
    }

    /// Add two g-vectors
    pub fn add(&self, other: &GVector) -> GVector {
        let components = self.components.iter().zip(other.components.iter())
            .map(|(a, b)| a + b)
            .collect();
        GVector { components }
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: i64) -> GVector {
        let components = self.components.iter().map(|x| x * scalar).collect();
        GVector { components }
    }
}

impl Display for GVector {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "(")?;
        for (i, comp) in self.components.iter().enumerate() {
            if i > 0 {
                write!(f, ", ")?;
            }
            write!(f, "{}", comp)?;
        }
        write!(f, ")")
    }
}

/// A d-vector representing the denominator vector of a cluster variable
///
/// D-vectors encode the denominator exponents when expressing a cluster
/// variable as a Laurent polynomial.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DVector {
    /// Components of the d-vector
    pub components: Vec<i64>,
}

impl DVector {
    /// Create a new d-vector from components
    pub fn new(components: Vec<i64>) -> Self {
        DVector { components }
    }

    /// Dimension of the d-vector
    pub fn dim(&self) -> usize {
        self.components.len()
    }
}

impl Display for DVector {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "(")?;
        for (i, comp) in self.components.iter().enumerate() {
            if i > 0 {
                write!(f, ", ")?;
            }
            write!(f, "{}", comp)?;
        }
        write!(f, ")")
    }
}

/// Exchange matrix for cluster algebra
///
/// The exchange matrix B encodes the mutation rules for the cluster algebra.
/// For a cluster algebra of rank n with m coefficients, B is an (n+m) × n matrix.
#[derive(Debug, Clone)]
pub struct ExchangeMatrix<R: Ring> {
    /// Matrix data
    pub matrix: Matrix<R>,
    /// Rank of the cluster algebra (number of cluster variables)
    pub rank: usize,
    /// Number of coefficients
    pub num_coefficients: usize,
}

impl<R: Ring + Clone> ExchangeMatrix<R> {
    /// Create a new exchange matrix
    pub fn new(matrix: Matrix<R>, rank: usize) -> Self {
        let num_coefficients = matrix.rows() - rank;
        ExchangeMatrix {
            matrix,
            rank,
            num_coefficients,
        }
    }

    /// Get the principal part (top rank × rank submatrix)
    pub fn principal_part(&self) -> Matrix<R> {
        let mut result = Matrix::zeros(self.rank, self.rank);
        for i in 0..self.rank {
            for j in 0..self.rank {
                if let Ok(val) = self.matrix.get(i, j) {
                    result.set(i, j, val.clone());
                }
            }
        }
        result
    }

    /// Get entry (i, j)
    pub fn get(&self, i: usize, j: usize) -> R {
        self.matrix.get(i, j).unwrap().clone()
    }

    /// Mutate the exchange matrix in direction k
    ///
    /// Applies the mutation formula:
    /// b'_ij = -b_ij if i=k or j=k
    ///        = b_ij + sgn(b_ik) * max(b_ik * b_kj, 0) otherwise
    pub fn mutate(&mut self, k: usize) where R: Ord + std::ops::Neg<Output=R> {
        let rows = self.matrix.rows();
        let cols = self.matrix.cols();

        for i in 0..rows {
            for j in 0..cols {
                if i == k || j == k {
                    // Flip sign for row k or column k
                    if let Ok(val) = self.matrix.get(i, j) {
                        self.matrix.set(i, j, -val.clone());
                    }
                } else {
                    // Apply mutation formula
                    if let (Ok(bik), Ok(bkj), Ok(bij)) = (
                        self.matrix.get(i, k),
                        self.matrix.get(k, j),
                        self.matrix.get(i, j)
                    ) {
                        // This is simplified; full implementation would handle signs properly
                        if bik > &R::zero() && bkj > &R::zero() {
                            self.matrix.set(i, j, bij.clone() + bik.clone() * bkj.clone());
                        }
                    }
                }
            }
        }
    }
}

/// A seed in the cluster algebra exchange graph
///
/// Seeds contain the combinatorial data (B, C, G matrices) needed for
/// mutations and cluster variable computation.
#[derive(Clone)]
pub struct ClusterAlgebraSeed<R: Ring> {
    /// Exchange matrix
    b_matrix: ExchangeMatrix<R>,
    /// C-vectors matrix (coefficients)
    c_matrix: Matrix<R>,
    /// G-vectors matrix (cluster variables)
    g_matrix: Matrix<R>,
    /// Mutation path from initial seed
    path: Vec<usize>,
}

impl<R: Ring + Clone> ClusterAlgebraSeed<R> {
    /// Create a new seed from matrices
    pub fn new(
        b_matrix: ExchangeMatrix<R>,
        c_matrix: Matrix<R>,
        g_matrix: Matrix<R>,
    ) -> Self {
        ClusterAlgebraSeed {
            b_matrix,
            c_matrix,
            g_matrix,
            path: Vec::new(),
        }
    }

    /// Create the initial seed for a cluster algebra
    pub fn initial(b_matrix: ExchangeMatrix<R>) -> Self {
        let rank = b_matrix.rank;
        let num_coeff = b_matrix.num_coefficients;

        // C matrix is identity for coefficients
        let mut c_matrix = Matrix::zeros(num_coeff, rank);
        for i in 0..num_coeff.min(rank) {
            c_matrix.set(i, i, R::one());
        }

        // G matrix is identity
        let mut g_matrix = Matrix::zeros(rank, rank);
        for i in 0..rank {
            g_matrix.set(i, i, R::one());
        }

        ClusterAlgebraSeed {
            b_matrix,
            c_matrix,
            g_matrix,
            path: Vec::new(),
        }
    }

    /// Get the B matrix
    pub fn b_matrix(&self) -> &ExchangeMatrix<R> {
        &self.b_matrix
    }

    /// Get the C matrix
    pub fn c_matrix(&self) -> &Matrix<R> {
        &self.c_matrix
    }

    /// Get the G matrix
    pub fn g_matrix(&self) -> &Matrix<R> {
        &self.g_matrix
    }

    /// Get g-vector at index j
    pub fn g_vector(&self, _j: usize) -> GVector {
        let mut components = Vec::new();
        for _i in 0..self.g_matrix.rows() {
            // Convert to i64 for g-vector (assumes R can be converted)
            components.push(0); // Simplified; proper implementation would convert
        }
        GVector::new(components)
    }

    /// Get c-vector at index j
    pub fn c_vector(&self, j: usize) -> Vec<R> {
        let mut result = Vec::new();
        for i in 0..self.c_matrix.rows() {
            if let Ok(val) = self.c_matrix.get(i, j) {
                result.push(val.clone());
            }
        }
        result
    }

    /// Get the mutation path from the initial seed
    pub fn path(&self) -> &[usize] {
        &self.path
    }

    /// Mutate the seed in direction k
    pub fn mutate(&mut self, k: usize)
    where
        R: Ord + std::ops::Neg<Output=R> + From<i64>
    {
        // Mutate B matrix
        self.b_matrix.mutate(k);

        // Mutate C matrix (simplified version)
        // Full implementation would apply proper C-vector mutation formulas

        // Mutate G matrix (simplified version)
        // Full implementation would apply proper G-vector mutation formulas

        // Update path
        self.path.push(k);
    }

    /// Create a mutated copy of this seed
    pub fn mutated(&self, k: usize) -> Self
    where
        R: Ord + std::ops::Neg<Output=R> + From<i64>
    {
        let mut new_seed = Self {
            b_matrix: self.b_matrix.clone(),
            c_matrix: self.c_matrix.clone(),
            g_matrix: self.g_matrix.clone(),
            path: self.path.clone(),
        };
        new_seed.mutate(k);
        new_seed
    }
}

/// Element of a cluster algebra
///
/// Cluster algebra elements are represented as Laurent polynomials
/// in the cluster variables.
pub struct ClusterAlgebraElement<R: Ring> {
    /// The underlying Laurent polynomial representation
    value: MultivariatePolynomial<R>,
    /// Parent cluster algebra
    parent: Option<usize>, // Simplified; would be reference to ClusterAlgebra
}

impl<R: Ring + Clone> ClusterAlgebraElement<R> {
    /// Create a new cluster algebra element
    pub fn new(value: MultivariatePolynomial<R>) -> Self {
        ClusterAlgebraElement {
            value,
            parent: None,
        }
    }

    /// Get the d-vector (denominator vector)
    ///
    /// Returns the exponent vector of the denominator when this element
    /// is expressed as a Laurent polynomial.
    pub fn d_vector(&self) -> DVector {
        // Simplified implementation
        // Full version would analyze the Laurent polynomial structure
        DVector::new(Vec::new())
    }

    /// Get the underlying polynomial value
    pub fn value(&self) -> &MultivariatePolynomial<R> {
        &self.value
    }
}

impl<R: Ring + Clone + PartialEq> PartialEq for ClusterAlgebraElement<R> {
    fn eq(&self, other: &Self) -> bool {
        self.value == other.value
    }
}

impl<R: Ring + Clone + PartialEq> Eq for ClusterAlgebraElement<R> {}

impl<R: Ring + Clone> Clone for ClusterAlgebraElement<R> {
    fn clone(&self) -> Self {
        ClusterAlgebraElement {
            value: self.value.clone(),
            parent: self.parent,
        }
    }
}

/// Principal cluster algebra element
///
/// For cluster algebras with principal coefficients, elements have
/// additional structure including g-vectors and F-polynomials.
pub struct PrincipalClusterAlgebraElement<R: Ring> {
    /// Base element
    base: ClusterAlgebraElement<R>,
}

impl<R: Ring + Clone> PrincipalClusterAlgebraElement<R> {
    /// Create a new principal element
    pub fn new(base: ClusterAlgebraElement<R>) -> Self {
        PrincipalClusterAlgebraElement { base }
    }

    /// Get the g-vector if this element is homogeneous
    pub fn g_vector(&self) -> Option<GVector> {
        if self.is_homogeneous() {
            // Extract g-vector from homogeneous element
            Some(GVector::new(Vec::new())) // Simplified
        } else {
            None
        }
    }

    /// Check if this element is homogeneous
    pub fn is_homogeneous(&self) -> bool {
        // Simplified; full version would check if all terms have same degree
        false
    }

    /// Get the F-polynomial for a homogeneous element
    pub fn f_polynomial(&self) -> Option<MultivariatePolynomial<R>> {
        if self.is_homogeneous() {
            Some(self.base.value.clone()) // Simplified
        } else {
            None
        }
    }

    /// Get homogeneous components
    ///
    /// Returns a map from g-vectors to the corresponding homogeneous summands
    pub fn homogeneous_components(&self) -> HashMap<GVector, ClusterAlgebraElement<R>> {
        // Simplified implementation
        HashMap::new()
    }
}

/// A Cluster Algebra
///
/// Cluster algebras are commutative rings generated by cluster variables.
/// This implementation supports exploration of the exchange graph,
/// computation of cluster variables via g-vectors, and mutation operations.
///
/// # Type Parameters
///
/// * `R` - The coefficient ring
pub struct ClusterAlgebra<R: Ring> {
    /// Initial exchange matrix
    initial_b_matrix: ExchangeMatrix<R>,
    /// Rank (number of cluster variables)
    rank: usize,
    /// Current seed
    current_seed: ClusterAlgebraSeed<R>,
    /// Cache of computed g-vectors to paths
    g_vector_cache: HashMap<GVector, Vec<usize>>,
    /// Cache of F-polynomials by g-vector
    f_polynomial_cache: HashMap<GVector, MultivariatePolynomial<R>>,
    /// Whether this is a principal coefficient algebra
    is_principal: bool,
}

impl<R: Ring + Clone + Ord + std::ops::Neg<Output=R> + From<i64>> ClusterAlgebra<R> {
    /// Create a new cluster algebra from an exchange matrix
    pub fn new(b_matrix: ExchangeMatrix<R>) -> Self {
        let rank = b_matrix.rank;
        let initial_seed = ClusterAlgebraSeed::initial(b_matrix.clone());

        ClusterAlgebra {
            initial_b_matrix: b_matrix,
            rank,
            current_seed: initial_seed,
            g_vector_cache: HashMap::new(),
            f_polynomial_cache: HashMap::new(),
            is_principal: false,
        }
    }

    /// Create a cluster algebra with principal coefficients
    pub fn with_principal_coefficients(b_matrix: ExchangeMatrix<R>) -> Self {
        let mut algebra = Self::new(b_matrix);
        algebra.is_principal = true;
        algebra
    }

    /// Get the rank of the cluster algebra
    pub fn rank(&self) -> usize {
        self.rank
    }

    /// Get the initial seed
    pub fn initial_seed(&self) -> &ClusterAlgebraSeed<R> {
        // Return reference to a recreated initial seed
        // Simplified; proper implementation would cache this
        &self.current_seed
    }

    /// Get the current seed
    pub fn current_seed(&self) -> &ClusterAlgebraSeed<R> {
        &self.current_seed
    }

    /// Set the current seed
    pub fn set_current_seed(&mut self, seed: ClusterAlgebraSeed<R>) {
        self.current_seed = seed;
    }

    /// Reset to the initial seed
    pub fn reset_to_initial(&mut self) {
        self.current_seed = ClusterAlgebraSeed::initial(self.initial_b_matrix.clone());
    }

    /// Compute a cluster variable from its g-vector
    ///
    /// Uses the separation of additions formula to compute the cluster
    /// variable as a Laurent polynomial.
    pub fn cluster_variable(&self, _g_vec: &GVector) -> ClusterAlgebraElement<R> {
        // Simplified implementation
        // Full version would use separation of additions formula:
        // x_g = g_monomial * F_standard * F_tropical

        ClusterAlgebraElement::new(MultivariatePolynomial::zero())
    }

    /// Find the mutation path to a given g-vector
    ///
    /// Uses breadth-first search on the exchange graph.
    pub fn find_g_vector(&mut self, target: &GVector, max_depth: Option<usize>) -> Option<Vec<usize>> {
        let mut queue = VecDeque::new();
        let mut visited: HashSet<GVector> = HashSet::new();

        // Start from initial seed
        let initial = ClusterAlgebraSeed::initial(self.initial_b_matrix.clone());
        queue.push_back((initial, Vec::new()));

        while let Some((seed, path)) = queue.pop_front() {
            // Check depth limit
            if let Some(max) = max_depth {
                if path.len() >= max {
                    continue;
                }
            }

            // Check if we found the target
            // Simplified; would extract g-vectors from seed and compare

            // Explore mutations
            for k in 0..self.rank {
                let mut new_seed = seed.clone();
                new_seed.mutate(k);
                let mut new_path = path.clone();
                new_path.push(k);

                // Check if visited (simplified)
                queue.push_back((new_seed, new_path));
            }
        }

        None
    }

    /// Get all g-vectors up to a given depth
    pub fn g_vectors_up_to_depth(&self, _depth: usize) -> Vec<GVector> {
        // Breadth-first exploration
        let mut result = Vec::new();

        // Start with standard basis vectors
        for i in 0..self.rank {
            result.push(GVector::standard_basis(self.rank, i));
        }

        result
    }

    /// Clear all computed data and caches
    pub fn clear_cache(&mut self) {
        self.g_vector_cache.clear();
        self.f_polynomial_cache.clear();
        self.reset_to_initial();
    }

    /// Mutate the initial seed to create a new cluster algebra
    pub fn mutate_initial(&self, direction: usize) -> Self {
        let mut new_b_matrix = self.initial_b_matrix.clone();
        new_b_matrix.mutate(direction);
        Self::new(new_b_matrix)
    }

    /// Check if this is a principal coefficient algebra
    pub fn is_principal(&self) -> bool {
        self.is_principal
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_g_vector_creation() {
        let g = GVector::new(vec![1, 2, 3]);
        assert_eq!(g.dim(), 3);
        assert_eq!(g.components, vec![1, 2, 3]);
    }

    #[test]
    fn test_g_vector_standard_basis() {
        let e0 = GVector::standard_basis(3, 0);
        assert_eq!(e0.components, vec![1, 0, 0]);

        let e1 = GVector::standard_basis(3, 1);
        assert_eq!(e1.components, vec![0, 1, 0]);
    }

    #[test]
    fn test_g_vector_operations() {
        let g1 = GVector::new(vec![1, 2, 3]);
        let g2 = GVector::new(vec![4, 5, 6]);

        let sum = g1.add(&g2);
        assert_eq!(sum.components, vec![5, 7, 9]);

        let scaled = g1.scalar_mul(2);
        assert_eq!(scaled.components, vec![2, 4, 6]);

        let dot = g1.dot(&g2);
        assert_eq!(dot, 1*4 + 2*5 + 3*6);
    }

    #[test]
    fn test_d_vector_creation() {
        let d = DVector::new(vec![1, 0, 2]);
        assert_eq!(d.dim(), 3);
    }

    #[test]
    fn test_exchange_matrix() {
        let mut matrix = Matrix::zeros(2, 2);
        matrix.set(0, 0, Integer::from(0));
        matrix.set(0, 1, Integer::from(1));
        matrix.set(1, 0, Integer::from(-1));
        matrix.set(1, 1, Integer::from(0));

        let exch = ExchangeMatrix::new(matrix, 2);
        assert_eq!(exch.rank, 2);
        assert_eq!(exch.num_coefficients, 0);
    }

    #[test]
    fn test_cluster_algebra_creation() {
        // Create A2 exchange matrix (rank 2)
        let mut matrix = Matrix::zeros(2, 2);
        matrix.set(0, 0, Integer::from(0));
        matrix.set(0, 1, Integer::from(1));
        matrix.set(1, 0, Integer::from(-1));
        matrix.set(1, 1, Integer::from(0));

        let exch = ExchangeMatrix::new(matrix, 2);
        let algebra = ClusterAlgebra::new(exch);

        assert_eq!(algebra.rank(), 2);
        assert!(!algebra.is_principal());
    }

    #[test]
    fn test_principal_cluster_algebra() {
        let mut matrix = Matrix::zeros(2, 2);
        matrix.set(0, 0, Integer::from(0));
        matrix.set(0, 1, Integer::from(1));
        matrix.set(1, 0, Integer::from(-1));
        matrix.set(1, 1, Integer::from(0));

        let exch = ExchangeMatrix::new(matrix, 2);
        let algebra = ClusterAlgebra::with_principal_coefficients(exch);

        assert!(algebra.is_principal());
    }

    #[test]
    fn test_seed_creation() {
        let mut matrix = Matrix::zeros(2, 2);
        matrix.set(0, 0, Integer::from(0));
        matrix.set(0, 1, Integer::from(1));
        matrix.set(1, 0, Integer::from(-1));
        matrix.set(1, 1, Integer::from(0));

        let exch = ExchangeMatrix::new(matrix, 2);
        let seed = ClusterAlgebraSeed::initial(exch);

        assert_eq!(seed.path().len(), 0);
    }
}
