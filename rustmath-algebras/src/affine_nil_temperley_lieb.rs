//! Affine Nil-Temperley-Lieb Algebra
//!
//! The affine nil-Temperley-Lieb algebra of type A_{n-1}^{(1)} is a combinatorial
//! free module generated by elements a_i (for i=0,1,...,n-1) subject to:
//! - a_i * a_i = 0 (nilpotent)
//! - a_i * a_{i+1} * a_i = 0 (braid relation)
//! - a_{i+1} * a_i * a_{i+1} = 0 (braid relation)
//! - a_i * a_j = a_j * a_i when |i-j| > 1 (mod n) (distant commutativity)
//!
//! Corresponds to sage.algebras.affine_nil_temperley_lieb
//!
//! References:
//! - Graham, J. J. and Lehrer, G. I. "Cellular algebras" (1996)
//! - Temperley, H. N. V. and Lieb, E. H. "Relations between the 'percolation' and 'colouring' problem" (1971)

use rustmath_core::{Ring, MathError, Result};
use rustmath_modules::CombinatorialFreeModuleElement;
use rustmath_liealgebras::cartan_type::{CartanType, CartanLetter, Affinity};
use rustmath_liealgebras::weyl_group::{WeylGroup, WeylGroupElement};
use std::collections::HashMap;
use std::fmt::{self, Display};

/// The affine nil-Temperley-Lieb algebra of type A_{n-1}^{(1)}
///
/// This algebra is defined as a combinatorial free module over a ring R,
/// with basis indexed by elements of the affine Weyl group that satisfy
/// certain admissibility conditions (no forbidden braid relations).
///
/// # Type Parameters
///
/// * `R` - The base ring (coefficient ring)
///
/// # Examples
///
/// ```
/// use rustmath_algebras::affine_nil_temperley_lieb::AffineNilTemperleyLiebTypeA;
/// use rustmath_integers::Integer;
///
/// // Create the algebra for n=4 over the integers
/// let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(4, "a".to_string());
/// ```
#[derive(Clone, Debug)]
pub struct AffineNilTemperleyLiebTypeA<R: Ring> {
    /// The parameter n (dimension)
    n: usize,
    /// The base ring
    base_ring: std::marker::PhantomData<R>,
    /// The Weyl group of type A_{n-1}^{(1)}
    weyl_group: WeylGroup,
    /// Prefix for algebra generators (usually "a")
    prefix: String,
}

impl<R: Ring> AffineNilTemperleyLiebTypeA<R> {
    /// Create a new affine nil-Temperley-Lieb algebra
    ///
    /// # Arguments
    ///
    /// * `n` - The parameter (creates type A_{n-1}^{(1)})
    /// * `prefix` - String prefix for displaying generators
    ///
    /// # Returns
    ///
    /// The algebra, or an error if n < 1
    pub fn new(n: usize, prefix: String) -> Self {
        assert!(n >= 1, "n must be at least 1");

        // Create the affine Cartan type A_{n-1}^{(1)}
        let cartan_type = CartanType::new_affine(CartanLetter::A, n - 1, 1)
            .expect("Invalid Cartan type");

        let weyl_group = WeylGroup::new(cartan_type);

        AffineNilTemperleyLiebTypeA {
            n,
            base_ring: std::marker::PhantomData,
            weyl_group,
            prefix,
        }
    }

    /// Get the parameter n
    pub fn n(&self) -> usize {
        self.n
    }

    /// Get the Weyl group
    pub fn weyl_group(&self) -> &WeylGroup {
        &self.weyl_group
    }

    /// Get the identity element
    pub fn one(&self) -> Element<R> {
        Element {
            module_element: CombinatorialFreeModuleElement::from_basis_index(
                WeylGroupElement::identity(self.n)
            ),
        }
    }

    /// Get the zero element
    pub fn zero(&self) -> Element<R> {
        Element {
            module_element: CombinatorialFreeModuleElement::zero(),
        }
    }

    /// Get algebra generator a_i
    ///
    /// # Arguments
    ///
    /// * `i` - The index (0 <= i < n)
    ///
    /// # Returns
    ///
    /// The generator a_i as an algebra element
    pub fn generator(&self, i: usize) -> Element<R> {
        assert!(i < self.n, "Generator index must be less than n");

        let w = WeylGroupElement::simple_reflection(i, self.n);
        Element {
            module_element: CombinatorialFreeModuleElement::from_basis_index(w),
        }
    }

    /// Get all algebra generators
    ///
    /// # Returns
    ///
    /// A vector of generators [a_0, a_1, ..., a_{n-1}]
    pub fn algebra_generators(&self) -> Vec<Element<R>> {
        (0..self.n)
            .map(|i| self.generator(i))
            .collect()
    }

    /// Check if multiplying Weyl group element w by simple reflection s_i
    /// creates a forbidden braid relation
    ///
    /// Returns false if the multiplication would create:
    /// - s_i * s_i (square of a simple reflection)
    /// - s_i * s_{i+1} * s_i or s_{i+1} * s_i * s_{i+1} (braid relations)
    ///
    /// # Arguments
    ///
    /// * `w` - The Weyl group element
    /// * `i` - The index of the simple reflection
    pub fn has_no_braid_relation(&self, w: &WeylGroupElement, i: usize) -> bool {
        let word = &w.reduced_word;

        // Check if the last reflection is s_i (would create s_i * s_i = 0)
        if let Some(&last) = word.last() {
            if last == i {
                return false;
            }

            // Check for braid relations s_i * s_{i±1} * s_i = 0
            // In affine type A, indices are mod n
            let i_plus_1 = (i + 1) % self.n;
            let i_minus_1 = if i == 0 { self.n - 1 } else { i - 1 };

            // If last is adjacent to i, check for braid pattern
            if last == i_plus_1 || last == i_minus_1 {
                // Check if second-to-last is i
                if word.len() >= 2 && word[word.len() - 2] == i {
                    return false;
                }
            }
        }

        true
    }

    /// Multiply two basis elements (Weyl group elements)
    ///
    /// Returns zero if the multiplication creates forbidden braid relations
    ///
    /// # Arguments
    ///
    /// * `w1` - First Weyl group element
    /// * `w2` - Second Weyl group element
    pub fn product_on_basis(&self, w1: &WeylGroupElement, w2: &WeylGroupElement) -> Element<R> {
        // Start with w1
        let mut result = w1.clone();

        // Apply each simple reflection from w2
        for &i in &w2.reduced_word {
            // Check if multiplying by s_i creates a forbidden relation
            if !self.has_no_braid_relation(&result, i) {
                // Return zero element
                return self.zero();
            }

            // Multiply by s_i (append to reduced word)
            result = WeylGroupElement::from_reduced_word(
                {
                    let mut word = result.reduced_word.clone();
                    word.push(i);
                    word
                },
                self.n,
            );
        }

        Element {
            module_element: CombinatorialFreeModuleElement::from_basis_index(result),
        }
    }

    /// Display a Weyl group element as a product of generators
    ///
    /// # Arguments
    ///
    /// * `w` - The Weyl group element
    /// * `short_display` - If true, use compact form; otherwise use bracketed form
    pub fn display_element(&self, w: &WeylGroupElement, short_display: bool) -> String {
        if w.is_identity() {
            return "1".to_string();
        }

        if short_display {
            w.reduced_word
                .iter()
                .map(|&i| format!("{}{}", self.prefix, i))
                .collect::<Vec<_>>()
                .join("*")
        } else {
            w.reduced_word
                .iter()
                .map(|&i| format!("{}[{}]", self.prefix, i))
                .collect::<Vec<_>>()
                .join("*")
        }
    }
}

/// An element of the affine nil-Temperley-Lieb algebra
///
/// Represented as a linear combination of basis elements (Weyl group elements)
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Element<R: Ring> {
    /// The underlying combinatorial free module element
    pub module_element: CombinatorialFreeModuleElement<R, WeylGroupElement>,
}

impl<R: Ring> Element<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        Element {
            module_element: CombinatorialFreeModuleElement::zero(),
        }
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool {
        self.module_element.is_zero()
    }

    /// Add two elements
    pub fn add(&self, other: &Element<R>) -> Element<R> {
        Element {
            module_element: self.module_element.clone() + other.module_element.clone(),
        }
    }

    /// Subtract two elements
    pub fn sub(&self, other: &Element<R>) -> Element<R> {
        Element {
            module_element: self.module_element.clone() - other.module_element.clone(),
        }
    }

    /// Negate this element
    pub fn neg(&self) -> Element<R> {
        Element {
            module_element: -self.module_element.clone(),
        }
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Element<R> {
        Element {
            module_element: self.module_element.scalar_mul(scalar),
        }
    }

    /// Multiply two algebra elements
    ///
    /// Uses bilinearity: (Σ a_i w_i) * (Σ b_j w_j) = Σ a_i b_j (w_i * w_j)
    pub fn multiply(&self, other: &Element<R>, algebra: &AffineNilTemperleyLiebTypeA<R>) -> Element<R> {
        let mut result = Element::zero();

        for (w1, coeff1) in self.module_element.iter() {
            for (w2, coeff2) in other.module_element.iter() {
                // Compute product of basis elements
                let basis_product = algebra.product_on_basis(w1, w2);

                // Multiply by coefficients
                let coeff_product = coeff1.clone() * coeff2.clone();
                let term = basis_product.scalar_mul(&coeff_product);

                result = result.add(&term);
            }
        }

        result
    }
}

impl<R: Ring + Display> Display for Element<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let terms: Vec<_> = self.module_element.iter().collect();

        for (i, (w, coeff)) in terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }

            if coeff.is_one() && !w.is_identity() {
                // Display just the word
                write!(f, "a{:?}", w.reduced_word)?;
            } else if w.is_identity() {
                // Display just the coefficient
                write!(f, "{}", coeff)?;
            } else {
                // Display coefficient * word
                write!(f, "{}*a{:?}", coeff, w.reduced_word)?;
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;

    #[test]
    fn test_algebra_creation() {
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(4, "a".to_string());
        assert_eq!(algebra.n(), 4);
    }

    #[test]
    fn test_generators() {
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(4, "a".to_string());
        let generators = algebra.algebra_generators();
        assert_eq!(generators.len(), 4);

        for gen in generators {
            assert!(!gen.is_zero());
        }
    }

    #[test]
    fn test_nilpotent_relation() {
        // Test a_i * a_i = 0
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(3, "a".to_string());
        let a0 = algebra.generator(0);

        let product = a0.multiply(&a0, &algebra);
        assert!(product.is_zero(), "a_i * a_i should be zero");
    }

    #[test]
    fn test_braid_relation() {
        // Test a_i * a_{{i+1}} * a_i = 0
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(3, "a".to_string());
        let a0 = algebra.generator(0);
        let a1 = algebra.generator(1);

        let product1 = a0.multiply(&a1, &algebra);
        let product2 = product1.multiply(&a0, &algebra);
        assert!(product2.is_zero(), "a_i * a_{{i+1}} * a_i should be zero");
    }

    #[test]
    fn test_distant_commutativity() {
        // Test a_0 * a_2 and a_2 * a_0 both exist (don't annihilate)
        // Full commutativity would require Weyl group word reduction
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(5, "a".to_string());
        let a0 = algebra.generator(0);
        let a2 = algebra.generator(2);

        let prod1 = a0.multiply(&a2, &algebra);
        let prod2 = a2.multiply(&a0, &algebra);

        // Both products should be non-zero (distant generators don't create forbidden relations)
        assert!(!prod1.is_zero(), "a_0 * a_2 should be non-zero");
        assert!(!prod2.is_zero(), "a_2 * a_0 should be non-zero");
    }

    #[test]
    fn test_identity_element() {
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(3, "a".to_string());
        let one = algebra.one();
        let a0 = algebra.generator(0);

        let product1 = a0.multiply(&one, &algebra);
        let product2 = one.multiply(&a0, &algebra);

        assert_eq!(product1, a0, "1 * a_i = a_i");
        assert_eq!(product2, a0, "a_i * 1 = a_i");
    }

    #[test]
    fn test_scalar_multiplication() {
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(3, "a".to_string());
        let a0 = algebra.generator(0);
        let scalar = Integer::from(3);

        let scaled = a0.scalar_mul(&scalar);
        assert!(!scaled.is_zero());
    }

    #[test]
    fn test_addition() {
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(3, "a".to_string());
        let a0 = algebra.generator(0);
        let a1 = algebra.generator(1);

        let sum = a0.add(&a1);
        assert!(!sum.is_zero());
    }

    #[test]
    fn test_has_no_braid_relation() {
        let algebra = AffineNilTemperleyLiebTypeA::<Integer>::new(4, "a".to_string());

        // Identity can be multiplied by any reflection
        let id = WeylGroupElement::identity(4);
        assert!(algebra.has_no_braid_relation(&id, 0));
        assert!(algebra.has_no_braid_relation(&id, 1));

        // s_0 cannot be multiplied by s_0 (would give s_0 * s_0)
        let s0 = WeylGroupElement::simple_reflection(0, 4);
        assert!(!algebra.has_no_braid_relation(&s0, 0));
        assert!(algebra.has_no_braid_relation(&s0, 1));

        // s_0 * s_1 cannot be multiplied by s_0 (would give s_0 * s_1 * s_0)
        let s0_s1 = WeylGroupElement::from_reduced_word(vec![0, 1], 4);
        assert!(!algebra.has_no_braid_relation(&s0_s1, 0));
    }
}
