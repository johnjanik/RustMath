//! Tensor Algebra Implementation
//!
//! The tensor algebra T(V) over a module V is the free algebra generated by V.
//! It is the direct sum T(V) = ⊕_{n≥0} V^⊗n where V^⊗n is the n-fold tensor
//! product of V with itself.
//!
//! # Mathematical Background
//!
//! For a module V over a ring R:
//! - T^0(V) = R (the base ring)
//! - T^1(V) = V
//! - T^2(V) = V ⊗ V
//! - T^n(V) = V ⊗ V ⊗ ... ⊗ V (n times)
//!
//! The tensor algebra has a natural grading by tensor rank and satisfies
//! the universal property for algebras: any linear map from V to an algebra A
//! extends uniquely to an algebra homomorphism from T(V) to A.
//!
//! # Examples
//!
//! ```
//! use rustmath_algebras::tensor_algebra::{TensorAlgebra, TensorElement};
//! use rustmath_rationals::Rational;
//!
//! // Create tensor algebra over Q^3
//! let tensor_alg = TensorAlgebra::<Rational>::new(3);
//!
//! // Create a rank-1 tensor (vector)
//! let v = tensor_alg.generator(0);
//!
//! // Tensor product creates higher rank tensors
//! let v_squared = v.tensor_product(&v);
//! assert_eq!(v_squared.rank(), 2);
//! ```

use rustmath_core::{Ring, Field};
use std::collections::HashMap;
use std::fmt;

/// A monomial in the tensor algebra, represented as a sequence of basis indices
#[derive(Debug, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TensorMonomial {
    /// Sequence of basis element indices
    indices: Vec<usize>,
}

impl TensorMonomial {
    /// Create a new tensor monomial from a sequence of indices
    pub fn new(indices: Vec<usize>) -> Self {
        Self { indices }
    }

    /// Create the unit monomial (rank 0)
    pub fn unit() -> Self {
        Self { indices: Vec::new() }
    }

    /// Get the rank (tensor order) of this monomial
    pub fn rank(&self) -> usize {
        self.indices.len()
    }

    /// Get the indices
    pub fn indices(&self) -> &[usize] {
        &self.indices
    }

    /// Tensor product of two monomials (concatenation)
    pub fn tensor_product(&self, other: &Self) -> Self {
        let mut result = self.indices.clone();
        result.extend_from_slice(&other.indices);
        Self { indices: result }
    }
}

impl fmt::Display for TensorMonomial {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.indices.is_empty() {
            write!(f, "1")
        } else {
            write!(f, "e_{}", self.indices[0])?;
            for &idx in &self.indices[1..] {
                write!(f, " ⊗ e_{}", idx)?;
            }
            Ok(())
        }
    }
}

/// An element of the tensor algebra, represented as a linear combination of monomials
#[derive(Debug, Clone, PartialEq)]
pub struct TensorElement<R: Ring> {
    /// Coefficients for each monomial
    terms: HashMap<TensorMonomial, R>,
    /// Dimension of the underlying module
    dimension: usize,
}

impl<R: Ring> TensorElement<R> {
    /// Create a new tensor element
    pub fn new(dimension: usize) -> Self {
        Self {
            terms: HashMap::new(),
            dimension,
        }
    }

    /// Create a tensor element from a single monomial with coefficient
    pub fn from_monomial(monomial: TensorMonomial, coefficient: R, dimension: usize) -> Self {
        let mut terms = HashMap::new();
        if !coefficient.is_zero() {
            terms.insert(monomial, coefficient);
        }
        Self { terms, dimension }
    }

    /// Create the zero element
    pub fn zero(dimension: usize) -> Self {
        Self::new(dimension)
    }

    /// Create the unit element (1 in the base ring)
    pub fn one(dimension: usize) -> Self {
        Self::from_monomial(TensorMonomial::unit(), R::one(), dimension)
    }

    /// Check if this is the zero element
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    /// Get the dimension of the underlying module
    pub fn dimension(&self) -> usize {
        self.dimension
    }

    /// Get the maximum rank of monomials in this element
    pub fn max_rank(&self) -> Option<usize> {
        self.terms.keys().map(|m| m.rank()).max()
    }

    /// Get the homogeneous component of a given rank
    pub fn homogeneous_component(&self, rank: usize) -> Self {
        let mut result = Self::new(self.dimension);
        for (monomial, coeff) in &self.terms {
            if monomial.rank() == rank {
                result.terms.insert(monomial.clone(), coeff.clone());
            }
        }
        result
    }

    /// Add a term to this element
    pub fn add_term(&mut self, monomial: TensorMonomial, coefficient: R) {
        if coefficient.is_zero() {
            return;
        }

        let entry = self.terms.entry(monomial).or_insert_with(R::zero);
        *entry = entry.clone() + coefficient;

        if entry.is_zero() {
            self.terms.remove(&TensorMonomial::unit());
        }
    }

    /// Addition of tensor elements
    pub fn add(&self, other: &Self) -> Self {
        assert_eq!(self.dimension, other.dimension, "Dimension mismatch");

        let mut result = self.clone();
        for (monomial, coeff) in &other.terms {
            result.add_term(monomial.clone(), coeff.clone());
        }
        result
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Self {
        if scalar.is_zero() {
            return Self::zero(self.dimension);
        }

        let mut result = Self::new(self.dimension);
        for (monomial, coeff) in &self.terms {
            result.terms.insert(monomial.clone(), coeff.clone() * scalar.clone());
        }
        result
    }

    /// Tensor product of two elements
    pub fn tensor_product(&self, other: &Self) -> Self {
        assert_eq!(self.dimension, other.dimension, "Dimension mismatch");

        let mut result = Self::new(self.dimension);
        for (m1, c1) in &self.terms {
            for (m2, c2) in &other.terms {
                let new_monomial = m1.tensor_product(m2);
                let new_coeff = c1.clone() * c2.clone();
                result.add_term(new_monomial, new_coeff);
            }
        }
        result
    }

    /// Negation
    pub fn negate(&self) -> Self {
        self.scalar_mul(&R::zero().sub(&R::one()))
    }

    /// Subtraction
    pub fn sub(&self, other: &Self) -> Self {
        self.add(&other.negate())
    }
}

impl<R: Ring> fmt::Display for TensorElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut terms: Vec<_> = self.terms.iter().collect();
        terms.sort_by_key(|(m, _)| *m);

        let mut first = true;
        for (monomial, coeff) in terms {
            if !first {
                write!(f, " + ")?;
            }
            first = false;

            if monomial.rank() == 0 {
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "{}", monomial)?;
            } else {
                write!(f, "{}·{}", coeff, monomial)?;
            }
        }
        Ok(())
    }
}

/// The tensor algebra T(V) over a module V
#[derive(Debug, Clone)]
pub struct TensorAlgebra<R: Ring> {
    /// Dimension of the underlying module V
    dimension: usize,
    /// Phantom data for the ring
    _phantom: std::marker::PhantomData<R>,
}

impl<R: Ring> TensorAlgebra<R> {
    /// Create a new tensor algebra over a module of given dimension
    ///
    /// # Arguments
    ///
    /// * `dimension` - The dimension of the underlying module V
    pub fn new(dimension: usize) -> Self {
        Self {
            dimension,
            _phantom: std::marker::PhantomData,
        }
    }

    /// Get the dimension of the underlying module
    pub fn dimension(&self) -> usize {
        self.dimension
    }

    /// Get the i-th generator (basis element of rank 1)
    ///
    /// # Panics
    ///
    /// Panics if `i >= dimension`
    pub fn generator(&self, i: usize) -> TensorElement<R> {
        assert!(i < self.dimension, "Generator index out of bounds");
        TensorElement::from_monomial(
            TensorMonomial::new(vec![i]),
            R::one(),
            self.dimension,
        )
    }

    /// Get all generators
    pub fn generators(&self) -> Vec<TensorElement<R>> {
        (0..self.dimension).map(|i| self.generator(i)).collect()
    }

    /// Create the zero element
    pub fn zero(&self) -> TensorElement<R> {
        TensorElement::zero(self.dimension)
    }

    /// Create the unit element
    pub fn one(&self) -> TensorElement<R> {
        TensorElement::one(self.dimension)
    }

    /// Create a basis element from a sequence of indices
    pub fn monomial(&self, indices: Vec<usize>) -> TensorElement<R> {
        for &idx in &indices {
            assert!(idx < self.dimension, "Index out of bounds");
        }
        TensorElement::from_monomial(
            TensorMonomial::new(indices),
            R::one(),
            self.dimension,
        )
    }

    /// Get the rank n component (n-fold tensor product subspace)
    pub fn rank_component(&self, element: &TensorElement<R>, n: usize) -> TensorElement<R> {
        element.homogeneous_component(n)
    }
}

/// Functor that constructs tensor algebras
#[derive(Debug, Clone)]
pub struct TensorAlgebraFunctor;

impl TensorAlgebraFunctor {
    /// Apply the functor to a module dimension
    pub fn apply<R: Ring>(dimension: usize) -> TensorAlgebra<R> {
        TensorAlgebra::new(dimension)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;
    use rustmath_integers::Integer;

    #[test]
    fn test_tensor_monomial_creation() {
        let m1 = TensorMonomial::unit();
        assert_eq!(m1.rank(), 0);

        let m2 = TensorMonomial::new(vec![0, 1, 2]);
        assert_eq!(m2.rank(), 3);
        assert_eq!(m2.indices(), &[0, 1, 2]);
    }

    #[test]
    fn test_tensor_monomial_product() {
        let m1 = TensorMonomial::new(vec![0, 1]);
        let m2 = TensorMonomial::new(vec![2, 3]);
        let product = m1.tensor_product(&m2);
        assert_eq!(product.indices(), &[0, 1, 2, 3]);
        assert_eq!(product.rank(), 4);
    }

    #[test]
    fn test_tensor_algebra_creation() {
        let alg = TensorAlgebra::<Rational>::new(3);
        assert_eq!(alg.dimension(), 3);

        let zero = alg.zero();
        assert!(zero.is_zero());

        let one = alg.one();
        assert!(!one.is_zero());
    }

    #[test]
    fn test_generators() {
        let alg = TensorAlgebra::<Rational>::new(3);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);
        let e2 = alg.generator(2);

        assert_eq!(e0.max_rank(), Some(1));
        assert_eq!(e1.max_rank(), Some(1));
        assert_eq!(e2.max_rank(), Some(1));
    }

    #[test]
    fn test_tensor_product() {
        let alg = TensorAlgebra::<Integer>::new(2);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);

        let e0_tensor_e1 = e0.tensor_product(&e1);
        assert_eq!(e0_tensor_e1.max_rank(), Some(2));

        let triple_product = e0.tensor_product(&e1).tensor_product(&e0);
        assert_eq!(triple_product.max_rank(), Some(3));
    }

    #[test]
    fn test_addition() {
        let alg = TensorAlgebra::<Rational>::new(2);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);

        let sum = e0.add(&e1);
        assert_eq!(sum.max_rank(), Some(1));

        let zero = sum.sub(&sum);
        assert!(zero.is_zero());
    }

    #[test]
    fn test_scalar_multiplication() {
        let alg = TensorAlgebra::<Rational>::new(2);
        let e0 = alg.generator(0);

        let two = Rational::from(2);
        let scaled = e0.scalar_mul(&two);
        assert_eq!(scaled.max_rank(), Some(1));

        let zero_scalar = Rational::zero();
        let zero_result = e0.scalar_mul(&zero_scalar);
        assert!(zero_result.is_zero());
    }

    #[test]
    fn test_distributivity() {
        let alg = TensorAlgebra::<Rational>::new(2);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);

        // Test (e0 + e1) ⊗ e0 = e0⊗e0 + e1⊗e0
        let sum = e0.add(&e1);
        let left = sum.tensor_product(&e0);
        let right = e0.tensor_product(&e0).add(&e1.tensor_product(&e0));
        assert_eq!(left, right);
    }

    #[test]
    fn test_associativity() {
        let alg = TensorAlgebra::<Integer>::new(2);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);

        // Test (e0 ⊗ e1) ⊗ e0 = e0 ⊗ (e1 ⊗ e0)
        let left = e0.tensor_product(&e1).tensor_product(&e0);
        let right = e0.tensor_product(&e1.tensor_product(&e0));
        assert_eq!(left, right);
    }

    #[test]
    fn test_homogeneous_component() {
        let alg = TensorAlgebra::<Rational>::new(2);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);

        // Create e0 + e0⊗e1
        let mixed = e0.add(&e0.tensor_product(&e1));

        let rank1 = mixed.homogeneous_component(1);
        assert_eq!(rank1.max_rank(), Some(1));

        let rank2 = mixed.homogeneous_component(2);
        assert_eq!(rank2.max_rank(), Some(2));
    }

    #[test]
    fn test_unit_element() {
        let alg = TensorAlgebra::<Rational>::new(2);
        let one = alg.one();
        let e0 = alg.generator(0);

        // Test 1 ⊗ e0 = e0
        let product1 = one.tensor_product(&e0);
        assert_eq!(product1, e0);

        // Test e0 ⊗ 1 = e0
        let product2 = e0.tensor_product(&one);
        assert_eq!(product2, e0);
    }

    #[test]
    fn test_monomial_creation() {
        let alg = TensorAlgebra::<Integer>::new(3);
        let m = alg.monomial(vec![0, 1, 2]);
        assert_eq!(m.max_rank(), Some(3));
    }

    #[test]
    #[should_panic(expected = "Index out of bounds")]
    fn test_invalid_monomial() {
        let alg = TensorAlgebra::<Integer>::new(3);
        let _ = alg.monomial(vec![0, 5]); // 5 is out of bounds
    }

    #[test]
    fn test_zero_properties() {
        let alg = TensorAlgebra::<Rational>::new(2);
        let zero = alg.zero();
        let e0 = alg.generator(0);

        // 0 + e0 = e0
        let sum = zero.add(&e0);
        assert_eq!(sum, e0);

        // e0 + 0 = e0
        let sum2 = e0.add(&zero);
        assert_eq!(sum2, e0);

        // 0 ⊗ e0 = 0
        let product = zero.tensor_product(&e0);
        assert!(product.is_zero());
    }

    #[test]
    fn test_complex_expression() {
        let alg = TensorAlgebra::<Rational>::new(3);
        let e0 = alg.generator(0);
        let e1 = alg.generator(1);
        let e2 = alg.generator(2);

        // Build: e0⊗e1 + e1⊗e2 + e0⊗e1⊗e2
        let term1 = e0.tensor_product(&e1);
        let term2 = e1.tensor_product(&e2);
        let term3 = e0.tensor_product(&e1).tensor_product(&e2);

        let expr = term1.add(&term2).add(&term3);

        // Check that we have components of different ranks
        let rank2_part = expr.homogeneous_component(2);
        assert_eq!(rank2_part.max_rank(), Some(2));

        let rank3_part = expr.homogeneous_component(3);
        assert_eq!(rank3_part.max_rank(), Some(3));
    }
}
