//! Blob Algebra
//!
//! The blob algebra B_n(δ, α) is a diagram algebra that generalizes the Temperley-Lieb algebra
//! by adding a "blob" element with a propagating number parameter α.
//!
//! The algebra is generated by:
//! - e_i (i = 1, ..., n-1): Temperley-Lieb generators representing strand connections
//! - u_1: The blob element with propagating number α
//!
//! The defining relations are:
//! - e_i² = δ·e_i (idempotent relation with loop parameter δ)
//! - e_i·e_{i±1}·e_i = e_i (Jones relation)
//! - e_i·e_j = e_j·e_i when |i-j| > 1 (distant generators commute)
//! - u_1² = α·u_1 (blob idempotent with propagating number α)
//! - u_1·e_1 = e_1·u_1 = e_1 (blob absorbs adjacent connection)
//! - u_1·e_i = e_i·u_1 for i ≥ 2 (blob commutes with distant generators)
//!
//! References:
//! - Jones, V. F. R. "The Potts model and the symmetric group" (1994)
//! - Martin, P. "The blob algebra and the periodic Temperley-Lieb algebra" (1994)

use rustmath_core::{Ring, MathError, Result};
use std::collections::HashMap;
use std::fmt::{self, Display};
use std::hash::Hash;

/// A basis element for the blob algebra
///
/// Represented as a word in the generators {e_1, ..., e_{n-1}, u_1}
/// In the reduced form after applying all relations.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct BlobBasisElement {
    /// The word as a sequence of generators
    /// Positive integers 1..n-1 represent e_i
    /// Zero represents u_1
    word: Vec<i32>,
}

impl BlobBasisElement {
    /// Create the identity element (empty word)
    pub fn identity() -> Self {
        BlobBasisElement { word: vec![] }
    }

    /// Create element e_i
    pub fn e_generator(i: usize) -> Self {
        BlobBasisElement { word: vec![i as i32] }
    }

    /// Create the blob element u_1
    pub fn blob() -> Self {
        BlobBasisElement { word: vec![0] }
    }

    /// Create from a word
    pub fn from_word(word: Vec<i32>) -> Self {
        BlobBasisElement { word }
    }

    /// Get the word
    pub fn word(&self) -> &[i32] {
        &self.word
    }

    /// Check if this is the identity
    pub fn is_identity(&self) -> bool {
        self.word.is_empty()
    }
}

/// The blob algebra B_n(δ, α)
///
/// # Type Parameters
///
/// * `R` - The base ring (coefficient ring) which must contain δ and α
///
/// # Examples
///
/// ```
/// use rustmath_algebras::blob_algebra::BlobAlgebra;
/// use rustmath_rationals::Rational;
///
/// // Create blob algebra B_4(2, 3) over the rationals
/// let algebra = BlobAlgebra::<Rational>::new(
///     4,
///     Rational::from(2),
///     Rational::from(3)
/// ).unwrap();
/// ```
#[derive(Clone, Debug)]
pub struct BlobAlgebra<R: Ring> {
    /// The rank n (number of strands)
    n: usize,
    /// The loop parameter δ (delta)
    delta: R,
    /// The propagating number α (alpha) - the blob parameter
    alpha: R,
}

impl<R: Ring + Clone> BlobAlgebra<R> {
    /// Create a new blob algebra B_n(δ, α)
    ///
    /// # Arguments
    ///
    /// * `n` - The rank (number of strands, must be ≥ 2)
    /// * `delta` - The loop parameter δ
    /// * `alpha` - The propagating number α (blob parameter)
    ///
    /// # Returns
    ///
    /// The algebra, or an error if n < 2
    pub fn new(n: usize, delta: R, alpha: R) -> Result<Self> {
        if n < 2 {
            return Err(MathError::InvalidArgument(
                "Blob algebra requires n >= 2".to_string()
            ));
        }

        Ok(BlobAlgebra { n, delta, alpha })
    }

    /// Get the rank n
    pub fn n(&self) -> usize {
        self.n
    }

    /// Get the loop parameter δ
    pub fn delta(&self) -> &R {
        &self.delta
    }

    /// Get the propagating number α
    pub fn alpha(&self) -> &R {
        &self.alpha
    }

    /// Get the identity element
    pub fn one(&self) -> BlobElement<R> {
        BlobElement::from_basis(BlobBasisElement::identity(), R::one())
    }

    /// Get the zero element
    pub fn zero(&self) -> BlobElement<R> {
        BlobElement::zero()
    }

    /// Get Temperley-Lieb generator e_i
    ///
    /// # Arguments
    ///
    /// * `i` - The index (1 <= i < n)
    ///
    /// # Returns
    ///
    /// The generator e_i as an algebra element
    pub fn e_generator(&self, i: usize) -> Result<BlobElement<R>> {
        if i < 1 || i >= self.n {
            return Err(MathError::InvalidArgument(
                format!("Generator index must be between 1 and {}", self.n - 1)
            ));
        }

        Ok(BlobElement::from_basis(BlobBasisElement::e_generator(i), R::one()))
    }

    /// Get the blob element u_1
    ///
    /// # Returns
    ///
    /// The blob element u_1
    pub fn blob_generator(&self) -> BlobElement<R> {
        BlobElement::from_basis(BlobBasisElement::blob(), R::one())
    }

    /// Get all Temperley-Lieb generators [e_1, e_2, ..., e_{n-1}]
    pub fn e_generators(&self) -> Vec<BlobElement<R>> {
        (1..self.n)
            .map(|i| self.e_generator(i).unwrap())
            .collect()
    }

    /// Multiply two basis elements and apply relations
    ///
    /// Returns the result as a linear combination of basis elements
    ///
    /// # Arguments
    ///
    /// * `b1` - First basis element
    /// * `b2` - Second basis element
    pub fn multiply_basis(&self, b1: &BlobBasisElement, b2: &BlobBasisElement) -> BlobElement<R> {
        // Concatenate the words
        let mut word = b1.word.clone();
        word.extend_from_slice(&b2.word);

        // Apply relations to reduce
        self.reduce_word(word)
    }

    /// Reduce a word by applying all relations
    ///
    /// This applies the blob algebra relations repeatedly until no more reductions are possible:
    /// - e_i² = δ·e_i
    /// - e_i·e_{i±1}·e_i = e_i
    /// - u_1² = α·u_1
    /// - u_1·e_1 = e_1
    fn reduce_word(&self, mut word: Vec<i32>) -> BlobElement<R> {
        let mut coefficient = R::one();
        let mut changed = true;

        while changed {
            changed = false;
            let mut i = 0;

            while i < word.len() {
                // Check for e_i² = δ·e_i
                if i + 1 < word.len()
                    && word[i] > 0
                    && word[i] == word[i + 1] {
                    coefficient = coefficient * self.delta.clone();
                    word.remove(i + 1);
                    changed = true;
                    continue;
                }

                // Check for u_1² = α·u_1
                if i + 1 < word.len()
                    && word[i] == 0
                    && word[i + 1] == 0 {
                    coefficient = coefficient * self.alpha.clone();
                    word.remove(i + 1);
                    changed = true;
                    continue;
                }

                // Check for u_1·e_1 = e_1 (blob absorbs adjacent connection)
                if i + 1 < word.len()
                    && word[i] == 0
                    && word[i + 1] == 1 {
                    word.remove(i); // Remove u_1
                    changed = true;
                    continue;
                }

                // Check for e_1·u_1 = e_1 (blob absorbs adjacent connection, reverse)
                if i + 1 < word.len()
                    && word[i] == 1
                    && word[i + 1] == 0 {
                    word.remove(i + 1); // Remove u_1
                    changed = true;
                    continue;
                }

                // Check for e_i·e_{i±1}·e_i = e_i (Jones relation)
                if i + 2 < word.len()
                    && word[i] > 0
                    && word[i + 2] > 0
                    && word[i] == word[i + 2]
                    && (word[i + 1] == word[i] + 1 || word[i + 1] == word[i] - 1) {
                    word.remove(i + 2);
                    word.remove(i + 1);
                    changed = true;
                    continue;
                }

                i += 1;
            }
        }

        BlobElement::from_basis(BlobBasisElement::from_word(word), coefficient)
    }

    /// Display a basis element as a product of generators
    pub fn display_basis(&self, basis: &BlobBasisElement) -> String {
        if basis.is_identity() {
            return "1".to_string();
        }

        basis.word
            .iter()
            .map(|&i| {
                if i == 0 {
                    "u_1".to_string()
                } else {
                    format!("e_{}", i)
                }
            })
            .collect::<Vec<_>>()
            .join("·")
    }
}

/// An element of the blob algebra
///
/// Represented as a linear combination of basis elements
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct BlobElement<R: Ring> {
    /// Map from basis elements to coefficients
    terms: HashMap<BlobBasisElement, R>,
}

impl<R: Ring + Clone> BlobElement<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        BlobElement {
            terms: HashMap::new(),
        }
    }

    /// Create an element from a single basis element with coefficient
    pub fn from_basis(basis: BlobBasisElement, coeff: R) -> Self {
        let mut terms = HashMap::new();
        if !coeff.is_zero() {
            terms.insert(basis, coeff);
        }
        BlobElement { terms }
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty() || self.terms.values().all(|c| c.is_zero())
    }

    /// Add a term (basis element with coefficient)
    pub fn add_term(&mut self, basis: BlobBasisElement, coeff: R) {
        if coeff.is_zero() {
            return;
        }

        self.terms
            .entry(basis)
            .and_modify(|c| *c = c.clone() + coeff.clone())
            .or_insert(coeff.clone());

        // Remove zero coefficients
        self.terms.retain(|_, c| !c.is_zero());
    }

    /// Add two elements
    pub fn add(&self, other: &BlobElement<R>) -> BlobElement<R> {
        let mut result = self.clone();
        for (basis, coeff) in &other.terms {
            result.add_term(basis.clone(), coeff.clone());
        }
        result
    }

    /// Negate this element
    pub fn neg(&self) -> BlobElement<R> {
        let mut result = BlobElement::zero();
        for (basis, coeff) in &self.terms {
            result.add_term(basis.clone(), -coeff.clone());
        }
        result
    }

    /// Subtract two elements
    pub fn sub(&self, other: &BlobElement<R>) -> BlobElement<R> {
        self.add(&other.neg())
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> BlobElement<R> {
        let mut result = BlobElement::zero();
        for (basis, coeff) in &self.terms {
            result.add_term(basis.clone(), coeff.clone() * scalar.clone());
        }
        result
    }

    /// Multiply two algebra elements
    ///
    /// Uses bilinearity: (Σ a_i b_i) * (Σ c_j b_j) = Σ a_i c_j (b_i * b_j)
    pub fn multiply(&self, other: &BlobElement<R>, algebra: &BlobAlgebra<R>) -> BlobElement<R> {
        let mut result = BlobElement::zero();

        for (b1, coeff1) in &self.terms {
            for (b2, coeff2) in &other.terms {
                // Compute product of basis elements (returns a linear combination)
                let basis_product = algebra.multiply_basis(b1, b2);

                // Multiply by coefficients
                let scaled = basis_product.scalar_mul(&(coeff1.clone() * coeff2.clone()));

                result = result.add(&scaled);
            }
        }

        result
    }

    /// Get the number of terms
    pub fn len(&self) -> usize {
        self.terms.len()
    }

    /// Check if empty
    pub fn is_empty(&self) -> bool {
        self.terms.is_empty()
    }

    /// Iterate over terms
    pub fn iter(&self) -> impl Iterator<Item = (&BlobBasisElement, &R)> {
        self.terms.iter()
    }
}

impl<R: Ring + Clone + Display> Display for BlobElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut terms: Vec<_> = self.terms.iter().collect();
        terms.sort_by_key(|(basis, _)| basis.word.len());

        for (i, (basis, coeff)) in terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }

            if coeff.is_one() && !basis.is_identity() {
                // Display just the basis element
                if basis.word.is_empty() {
                    write!(f, "1")?;
                } else {
                    for (j, &gen) in basis.word.iter().enumerate() {
                        if j > 0 {
                            write!(f, "·")?;
                        }
                        if gen == 0 {
                            write!(f, "u_1")?;
                        } else {
                            write!(f, "e_{}", gen)?;
                        }
                    }
                }
            } else if basis.is_identity() {
                // Display just the coefficient
                write!(f, "{}", coeff)?;
            } else {
                // Display coefficient * basis
                write!(f, "{}·", coeff)?;
                for (j, &gen) in basis.word.iter().enumerate() {
                    if j > 0 {
                        write!(f, "·")?;
                    }
                    if gen == 0 {
                        write!(f, "u_1")?;
                    } else {
                        write!(f, "e_{}", gen)?;
                    }
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_integers::Integer;
    use rustmath_rationals::Rational;

    #[test]
    fn test_algebra_creation() {
        let algebra = BlobAlgebra::<Integer>::new(4, Integer::from(2), Integer::from(3)).unwrap();
        assert_eq!(algebra.n(), 4);
        assert_eq!(*algebra.delta(), Integer::from(2));
        assert_eq!(*algebra.alpha(), Integer::from(3));
    }

    #[test]
    fn test_algebra_creation_invalid() {
        let result = BlobAlgebra::<Integer>::new(1, Integer::from(2), Integer::from(3));
        assert!(result.is_err());
    }

    #[test]
    fn test_generators() {
        let algebra = BlobAlgebra::<Integer>::new(4, Integer::from(2), Integer::from(3)).unwrap();
        let generators = algebra.e_generators();
        assert_eq!(generators.len(), 3); // e_1, e_2, e_3

        let blob = algebra.blob_generator();
        assert!(!blob.is_zero());
    }

    #[test]
    fn test_identity() {
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let one = algebra.one();
        let e1 = algebra.e_generator(1).unwrap();

        let product1 = e1.multiply(&one, &algebra);
        let product2 = one.multiply(&e1, &algebra);

        assert_eq!(product1, e1, "e_1 * 1 = e_1");
        assert_eq!(product2, e1, "1 * e_1 = e_1");
    }

    #[test]
    fn test_idempotent_relation_e() {
        // Test e_i² = δ·e_i
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let e1 = algebra.e_generator(1).unwrap();

        let product = e1.multiply(&e1, &algebra);
        let expected = e1.scalar_mul(&Integer::from(2));

        assert_eq!(product, expected, "e_1² = 2·e_1");
    }

    #[test]
    fn test_idempotent_relation_blob() {
        // Test u_1² = α·u_1
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let u1 = algebra.blob_generator();

        let product = u1.multiply(&u1, &algebra);
        let expected = u1.scalar_mul(&Integer::from(3));

        assert_eq!(product, expected, "u_1² = 3·u_1");
    }

    #[test]
    fn test_jones_relation() {
        // Test e_i·e_{i+1}·e_i = e_i
        let algebra = BlobAlgebra::<Integer>::new(4, Integer::from(2), Integer::from(3)).unwrap();
        let e1 = algebra.e_generator(1).unwrap();
        let e2 = algebra.e_generator(2).unwrap();

        let product = e1.multiply(&e2, &algebra).multiply(&e1, &algebra);

        assert_eq!(product, e1, "e_1·e_2·e_1 = e_1");
    }

    #[test]
    fn test_distant_generators_commute() {
        // Test e_i·e_j = e_j·e_i when |i-j| > 1
        let algebra = BlobAlgebra::<Integer>::new(5, Integer::from(2), Integer::from(3)).unwrap();
        let e1 = algebra.e_generator(1).unwrap();
        let e3 = algebra.e_generator(3).unwrap();

        let prod1 = e1.multiply(&e3, &algebra);
        let prod2 = e3.multiply(&e1, &algebra);

        assert_eq!(prod1, prod2, "e_1·e_3 = e_3·e_1");
    }

    #[test]
    fn test_blob_absorbs_adjacent() {
        // Test u_1·e_1 = e_1
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let u1 = algebra.blob_generator();
        let e1 = algebra.e_generator(1).unwrap();

        let product1 = u1.multiply(&e1, &algebra);
        assert_eq!(product1, e1, "u_1·e_1 = e_1");

        let product2 = e1.multiply(&u1, &algebra);
        assert_eq!(product2, e1, "e_1·u_1 = e_1");
    }

    #[test]
    fn test_blob_commutes_distant() {
        // Test u_1·e_i = e_i·u_1 for i ≥ 2
        let algebra = BlobAlgebra::<Integer>::new(4, Integer::from(2), Integer::from(3)).unwrap();
        let u1 = algebra.blob_generator();
        let e2 = algebra.e_generator(2).unwrap();

        let prod1 = u1.multiply(&e2, &algebra);
        let prod2 = e2.multiply(&u1, &algebra);

        assert_eq!(prod1, prod2, "u_1·e_2 = e_2·u_1");
    }

    #[test]
    fn test_addition() {
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let e1 = algebra.e_generator(1).unwrap();
        let e2 = algebra.e_generator(2).unwrap();

        let sum = e1.add(&e2);
        assert!(!sum.is_zero());
        assert_eq!(sum.len(), 2);
    }

    #[test]
    fn test_scalar_multiplication() {
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let e1 = algebra.e_generator(1).unwrap();
        let scalar = Integer::from(5);

        let scaled = e1.scalar_mul(&scalar);
        assert!(!scaled.is_zero());
    }

    #[test]
    fn test_with_rational_parameters() {
        // Test with rational parameters (common in mathematical applications)
        let delta = Rational::new(Integer::from(2), Integer::from(1));
        let alpha = Rational::new(Integer::from(-1), Integer::from(1));
        let algebra = BlobAlgebra::new(3, delta.clone(), alpha.clone()).unwrap();

        let e1 = algebra.e_generator(1).unwrap();
        let product = e1.multiply(&e1, &algebra);
        let expected = e1.scalar_mul(&delta);

        assert_eq!(product, expected);
    }

    #[test]
    fn test_complex_expression() {
        // Test (e_1 + u_1)²
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let e1 = algebra.e_generator(1).unwrap();
        let u1 = algebra.blob_generator();

        let sum = e1.add(&u1);
        let square = sum.multiply(&sum, &algebra);

        // (e_1 + u_1)² = e_1² + e_1·u_1 + u_1·e_1 + u_1²
        //              = 2·e_1 + e_1 + e_1 + 3·u_1
        //              = 4·e_1 + 3·u_1
        let expected = e1.scalar_mul(&Integer::from(4)).add(&u1.scalar_mul(&Integer::from(3)));

        assert_eq!(square, expected);
    }

    #[test]
    fn test_zero_element() {
        let algebra = BlobAlgebra::<Integer>::new(3, Integer::from(2), Integer::from(3)).unwrap();
        let zero = algebra.zero();
        let e1 = algebra.e_generator(1).unwrap();

        assert!(zero.is_zero());
        assert_eq!(e1.add(&zero), e1);
        assert_eq!(zero.add(&e1), e1);
        assert!(e1.multiply(&zero, &algebra).is_zero());
        assert!(zero.multiply(&e1, &algebra).is_zero());
    }
}
