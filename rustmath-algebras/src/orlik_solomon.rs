//! Orlik-Solomon Algebra
//!
//! The Orlik-Solomon algebra is a fundamental algebraic structure associated with
//! matroids and hyperplane arrangements. It is constructed as a quotient of an
//! exterior algebra by an ideal generated from matroid circuits.
//!
//! # Mathematical Background
//!
//! For a matroid M with groundset X, the Orlik-Solomon algebra A(M) is defined as:
//! - Start with the exterior algebra E = ⋀(e_x | x ∈ X)
//! - Quotient by the Orlik-Solomon ideal J(M), generated by ∂e_S for each circuit S
//! - The boundary operator ∂e_S = Σ_{x ∈ S} (-1)^i e_{S\{x}} where x is the i-th element
//!
//! ## Properties
//!
//! - **Graded**: Degree equals cardinality of basis elements
//! - **Finite-dimensional**: Dimension equals number of NBC sets
//! - **Skew-commutative**: e_i ∧ e_j = -e_j ∧ e_i
//! - **Basis**: No broken circuit (NBC) sets
//!
//! ## No Broken Circuits
//!
//! A *broken circuit* is a circuit with its smallest element removed.
//! An *NBC set* is a subset containing no broken circuit.
//! The NBC sets form a basis for the Orlik-Solomon algebra.
//!
//! # Examples
//!
//! ```
//! use rustmath_algebras::{OrlikSolomonAlgebra, Matroid};
//!
//! // Create a simple matroid (uniform matroid U(2,3))
//! let groundset = vec![0, 1, 2];
//! let circuits = vec![vec![0, 1, 2]]; // All three elements form a circuit
//! let matroid = Matroid::from_circuits(groundset.clone(), circuits);
//!
//! // Create the Orlik-Solomon algebra over the integers
//! let os = OrlikSolomonAlgebra::new(1i64, matroid);
//!
//! assert_eq!(os.rank(), 2); // Rank of the matroid
//! ```
//!
//! # References
//!
//! - Orlik, P. & Solomon, L. "Combinatorics and topology of complements of hyperplanes" (1980)
//! - Björner, A. "The homology and shellability of matroids and geometric lattices" (1992)
//! - SageMath: sage.algebras.orlik_solomon
//!
//! Corresponds to sage.algebras.orlik_solomon

use rustmath_core::Ring;
use std::collections::{HashMap, HashSet};
use std::fmt::{self, Display};

/// Simple matroid representation
///
/// A matroid is a combinatorial structure that abstracts the notion of
/// linear independence. It consists of a groundset and a collection of
/// independent sets satisfying certain axioms.
///
/// For the Orlik-Solomon algebra, we primarily need:
/// - The groundset (finite set of elements)
/// - Circuits (minimal dependent sets)
/// - Rank information
#[derive(Clone, Debug)]
pub struct Matroid {
    /// The groundset (elements of the matroid)
    groundset: Vec<usize>,
    /// Circuits (minimal dependent sets)
    circuits: Vec<Vec<usize>>,
    /// Rank of the matroid
    rank: usize,
}

impl Matroid {
    /// Create a matroid from circuits
    ///
    /// # Arguments
    ///
    /// * `groundset` - The elements of the matroid
    /// * `circuits` - The minimal dependent sets
    pub fn from_circuits(groundset: Vec<usize>, circuits: Vec<Vec<usize>>) -> Self {
        // Compute rank as maximum size of independent set
        // For simplicity, estimate as |groundset| - 1 if circuits exist
        let rank = if circuits.is_empty() {
            groundset.len()
        } else {
            groundset.len().saturating_sub(1)
        };

        Matroid {
            groundset,
            circuits,
            rank,
        }
    }

    /// Create a uniform matroid U(r, n)
    ///
    /// All subsets of size ≤ r are independent.
    /// Circuits are all subsets of size r+1.
    pub fn uniform(r: usize, n: usize) -> Self {
        let groundset: Vec<usize> = (0..n).collect();

        // Generate all (r+1)-element subsets as circuits
        let mut circuits = Vec::new();
        if r + 1 <= n {
            circuits = generate_subsets(&groundset, r + 1);
        }

        Matroid {
            groundset,
            circuits,
            rank: r,
        }
    }

    /// Get the groundset
    pub fn groundset(&self) -> &[usize] {
        &self.groundset
    }

    /// Get the circuits
    pub fn circuits(&self) -> &[Vec<usize>] {
        &self.circuits
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.rank
    }

    /// Check if a set is a circuit
    pub fn is_circuit(&self, set: &[usize]) -> bool {
        let set_sorted: Vec<usize> = {
            let mut s = set.to_vec();
            s.sort_unstable();
            s
        };

        self.circuits.iter().any(|c| {
            let mut c_sorted = c.clone();
            c_sorted.sort_unstable();
            c_sorted == set_sorted
        })
    }

    /// Get broken circuits
    ///
    /// A broken circuit is a circuit with its smallest element removed.
    pub fn broken_circuits(&self) -> Vec<Vec<usize>> {
        self.circuits
            .iter()
            .filter_map(|circuit| {
                if circuit.is_empty() {
                    None
                } else {
                    let min = circuit.iter().min().unwrap();
                    let bc: Vec<usize> = circuit.iter()
                        .filter(|&x| x != min)
                        .copied()
                        .collect();
                    if bc.is_empty() {
                        None
                    } else {
                        Some(bc)
                    }
                }
            })
            .collect()
    }

    /// Check if a set contains a broken circuit
    pub fn contains_broken_circuit(&self, set: &[usize]) -> bool {
        let set_hash: HashSet<usize> = set.iter().copied().collect();
        let broken_circuits = self.broken_circuits();

        broken_circuits.iter().any(|bc| {
            bc.iter().all(|x| set_hash.contains(x))
        })
    }

    /// Get all NBC (No Broken Circuit) sets of a given size
    pub fn nbc_sets(&self, size: usize) -> Vec<Vec<usize>> {
        let all_subsets = generate_subsets(&self.groundset, size);
        all_subsets
            .into_iter()
            .filter(|subset| !self.contains_broken_circuit(subset))
            .collect()
    }

    /// Get all NBC sets (basis for Orlik-Solomon algebra)
    pub fn all_nbc_sets(&self) -> Vec<Vec<usize>> {
        let mut all = Vec::new();
        all.push(vec![]); // Empty set is always NBC

        for size in 1..=self.rank {
            all.extend(self.nbc_sets(size));
        }

        all
    }
}

/// Generate all k-element subsets of a set
fn generate_subsets(set: &[usize], k: usize) -> Vec<Vec<usize>> {
    if k == 0 {
        return vec![vec![]];
    }
    if k > set.len() {
        return vec![];
    }

    let mut result = Vec::new();
    generate_subsets_helper(set, k, 0, &mut vec![], &mut result);
    result
}

fn generate_subsets_helper(
    set: &[usize],
    k: usize,
    start: usize,
    current: &mut Vec<usize>,
    result: &mut Vec<Vec<usize>>,
) {
    if current.len() == k {
        result.push(current.clone());
        return;
    }

    for i in start..set.len() {
        current.push(set[i]);
        generate_subsets_helper(set, k, i + 1, current, result);
        current.pop();
    }
}

/// Orlik-Solomon Algebra
///
/// The Orlik-Solomon algebra A(M) associated with a matroid M.
/// It is a graded, finite-dimensional, skew-commutative algebra with
/// basis given by the NBC (no broken circuit) sets.
///
/// # Type Parameters
///
/// * `R` - The base ring
///
/// # Examples
///
/// ```
/// use rustmath_algebras::{OrlikSolomonAlgebra, Matroid};
///
/// let matroid = Matroid::uniform(2, 3);
/// let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, matroid);
/// ```
#[derive(Clone)]
pub struct OrlikSolomonAlgebra<R: Ring> {
    /// Base ring
    base_ring: R,
    /// The underlying matroid
    matroid: Matroid,
    /// NBC basis (cached)
    nbc_basis: Vec<Vec<usize>>,
    /// Ordering of groundset
    ordering: Vec<usize>,
}

impl<R: Ring + Clone> OrlikSolomonAlgebra<R> {
    /// Create a new Orlik-Solomon algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring (typically integers or rationals)
    /// * `matroid` - The matroid defining the algebra
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::{OrlikSolomonAlgebra, Matroid};
    ///
    /// let m = Matroid::uniform(2, 4);
    /// let os = OrlikSolomonAlgebra::new(1i64, m);
    /// ```
    pub fn new(base_ring: R, matroid: Matroid) -> Self {
        let ordering = matroid.groundset().to_vec();
        let nbc_basis = matroid.all_nbc_sets();

        OrlikSolomonAlgebra {
            base_ring,
            matroid,
            nbc_basis,
            ordering,
        }
    }

    /// Create with a custom ordering of the groundset
    pub fn with_ordering(base_ring: R, matroid: Matroid, ordering: Vec<usize>) -> Self {
        let nbc_basis = matroid.all_nbc_sets();

        OrlikSolomonAlgebra {
            base_ring,
            matroid,
            nbc_basis,
            ordering,
        }
    }

    /// Get the base ring
    pub fn base_ring(&self) -> &R {
        &self.base_ring
    }

    /// Get the matroid
    pub fn matroid(&self) -> &Matroid {
        &self.matroid
    }

    /// Get the rank of the underlying matroid
    pub fn rank(&self) -> usize {
        self.matroid.rank()
    }

    /// Get the dimension of the algebra
    ///
    /// This equals the number of NBC sets.
    pub fn dimension(&self) -> usize {
        self.nbc_basis.len()
    }

    /// Get the NBC basis
    pub fn nbc_basis(&self) -> &[Vec<usize>] {
        &self.nbc_basis
    }

    /// Get the dimension at a given grading
    ///
    /// Returns the number of NBC sets of the specified size.
    pub fn dimension_at_grade(&self, grade: usize) -> usize {
        self.nbc_basis
            .iter()
            .filter(|nbc| nbc.len() == grade)
            .count()
    }

    /// Get algebra generators (degree 1 elements)
    ///
    /// Returns elements e_i for each groundset element i.
    pub fn algebra_generators(&self) -> Vec<OrlikSolomonElement<R>>
    where
        R: From<i64>,
    {
        self.matroid
            .groundset()
            .iter()
            .map(|&i| {
                let mut terms = HashMap::new();
                terms.insert(vec![i], R::from(1));
                OrlikSolomonElement::new(terms)
            })
            .collect()
    }

    /// Create element from subset
    ///
    /// Returns the element e_S corresponding to subset S.
    pub fn subset_image(&self, subset: &[usize]) -> OrlikSolomonElement<R>
    where
        R: From<i64>,
    {
        if self.matroid.contains_broken_circuit(subset) {
            // Contains broken circuit, so equals 0 in quotient
            OrlikSolomonElement::zero()
        } else {
            let mut terms = HashMap::new();
            let mut sorted = subset.to_vec();
            sorted.sort_unstable();
            terms.insert(sorted, R::from(1));
            OrlikSolomonElement::new(terms)
        }
    }

    /// Get the zero element
    pub fn zero(&self) -> OrlikSolomonElement<R> {
        OrlikSolomonElement::zero()
    }

    /// Get the identity element (empty set basis element)
    pub fn one(&self) -> OrlikSolomonElement<R>
    where
        R: From<i64>,
    {
        let mut terms = HashMap::new();
        terms.insert(vec![], R::from(1));
        OrlikSolomonElement::new(terms)
    }
}

/// Element of an Orlik-Solomon algebra
///
/// Elements are represented as linear combinations of NBC sets.
/// The terms map NBC sets (represented as sorted vectors) to coefficients.
///
/// # Type Parameters
///
/// * `R` - The base ring
#[derive(Clone, Debug)]
pub struct OrlikSolomonElement<R: Ring> {
    /// Terms: map from NBC set to coefficient
    terms: HashMap<Vec<usize>, R>,
}

impl<R: Ring + Clone> OrlikSolomonElement<R> {
    /// Create a new element
    pub fn new(terms: HashMap<Vec<usize>, R>) -> Self {
        OrlikSolomonElement { terms }
    }

    /// Create the zero element
    pub fn zero() -> Self {
        OrlikSolomonElement {
            terms: HashMap::new(),
        }
    }

    /// Get the terms
    pub fn terms(&self) -> &HashMap<Vec<usize>, R> {
        &self.terms
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool
    where
        R: PartialEq,
    {
        self.terms.is_empty() || self.terms.values().all(|c| c.is_zero())
    }

    /// Get the degree (maximum size of NBC sets in the support)
    pub fn degree(&self) -> Option<usize>
    where
        R: PartialEq,
    {
        self.terms
            .iter()
            .filter(|(_, coeff)| !coeff.is_zero())
            .map(|(nbc, _)| nbc.len())
            .max()
    }

    /// Add two elements
    pub fn add(&self, other: &Self) -> Self
    where
        R: std::ops::Add<Output = R> + PartialEq,
    {
        let mut result = self.terms.clone();

        for (nbc, coeff) in &other.terms {
            let new_coeff = if let Some(existing) = result.get(nbc) {
                existing.clone() + coeff.clone()
            } else {
                coeff.clone()
            };

            if !new_coeff.is_zero() {
                result.insert(nbc.clone(), new_coeff);
            } else {
                result.remove(nbc);
            }
        }

        OrlikSolomonElement { terms: result }
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Self
    where
        R: std::ops::Mul<Output = R> + PartialEq,
    {
        if scalar.is_zero() {
            return Self::zero();
        }

        let terms = self
            .terms
            .iter()
            .map(|(nbc, coeff)| (nbc.clone(), coeff.clone() * scalar.clone()))
            .collect();

        OrlikSolomonElement { terms }
    }

    /// Negate the element
    pub fn negate(&self) -> Self
    where
        R: std::ops::Neg<Output = R>,
    {
        let terms = self
            .terms
            .iter()
            .map(|(nbc, coeff)| (nbc.clone(), -coeff.clone()))
            .collect();

        OrlikSolomonElement { terms }
    }

    /// Wedge product (exterior product)
    ///
    /// For now, this is a placeholder that returns zero.
    /// A full implementation would compute the wedge product respecting
    /// the skew-symmetry and Orlik-Solomon relations.
    pub fn wedge(&self, _other: &Self) -> Self
    where
        R: std::ops::Mul<Output = R> + std::ops::Add<Output = R> + std::ops::Neg<Output = R> + PartialEq + From<i64>,
    {
        // Full implementation would:
        // 1. Multiply NBC sets by taking union
        // 2. Apply sign based on permutation
        // 3. Reduce using Orlik-Solomon relations
        //
        // For now, return zero as placeholder
        Self::zero()
    }
}

impl<R: Ring + Clone + Display> Display for OrlikSolomonElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.terms.is_empty() {
            return write!(f, "0");
        }

        let mut first = true;
        for (nbc, coeff) in &self.terms {
            if !first {
                write!(f, " + ")?;
            }
            first = false;

            if nbc.is_empty() {
                // Identity element
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "e_{{{}}}", format_set(nbc))?;
            } else {
                write!(f, "{}*e_{{{}}}", coeff, format_set(nbc))?;
            }
        }

        Ok(())
    }
}

fn format_set(set: &[usize]) -> String {
    set.iter()
        .map(|x| x.to_string())
        .collect::<Vec<_>>()
        .join(",")
}

impl<R: Ring + Clone + Display> Display for OrlikSolomonAlgebra<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orlik-Solomon algebra of rank {} over {}",
            self.rank(),
            self.base_ring
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_matroid_creation() {
        let m = Matroid::uniform(2, 3);
        assert_eq!(m.rank(), 2);
        assert_eq!(m.groundset(), &[0, 1, 2]);
    }

    #[test]
    fn test_matroid_circuits() {
        let m = Matroid::uniform(2, 3);
        let circuits = m.circuits();
        assert_eq!(circuits.len(), 1); // Only one circuit: {0,1,2}
        assert!(m.is_circuit(&[0, 1, 2]));
    }

    #[test]
    fn test_broken_circuits() {
        let m = Matroid::uniform(2, 3);
        let bc = m.broken_circuits();
        assert_eq!(bc.len(), 1);
        assert!(bc[0] == vec![1, 2]); // {0,1,2} \ {0} = {1,2}
    }

    #[test]
    fn test_nbc_sets() {
        let m = Matroid::uniform(2, 3);
        let nbc = m.all_nbc_sets();
        // NBC sets for U(2,3): {}, {0}, {1}, {2}, {0,1}, {0,2}
        // {1,2} is broken circuit, so not NBC
        assert!(nbc.len() >= 6);
    }

    #[test]
    fn test_orlik_solomon_creation() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        assert_eq!(os.rank(), 2);
    }

    #[test]
    fn test_orlik_solomon_dimension() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let dim = os.dimension();
        assert!(dim >= 6); // At least the NBC sets we expect
    }

    #[test]
    fn test_algebra_generators() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let gens = os.algebra_generators();
        assert_eq!(gens.len(), 3); // Three generators for groundset {0,1,2}
    }

    #[test]
    fn test_element_creation() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let e0 = os.subset_image(&[0]);
        assert!(!e0.is_zero());
    }

    #[test]
    fn test_element_addition() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let e0 = os.subset_image(&[0]);
        let e1 = os.subset_image(&[1]);
        let sum = e0.add(&e1);
        assert_eq!(sum.terms().len(), 2);
    }

    #[test]
    fn test_zero_and_one() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let zero = os.zero();
        let one = os.one();
        assert!(zero.is_zero());
        assert!(!one.is_zero());
    }

    #[test]
    fn test_scalar_multiplication() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let e0 = os.subset_image(&[0]);
        let scaled = e0.scalar_mul(&3);
        assert!(!scaled.is_zero());
    }

    #[test]
    fn test_display() {
        let m = Matroid::uniform(2, 3);
        let os: OrlikSolomonAlgebra<i64> = OrlikSolomonAlgebra::new(1, m);
        let display = format!("{}", os);
        assert!(display.contains("Orlik-Solomon"));
        assert!(display.contains("rank 2"));
    }
}

/// Orlik-Solomon Invariant Algebra
///
/// The subalgebra of the Orlik-Solomon algebra consisting of elements
/// invariant under a group action on the matroid.
///
/// For a matroid M with a group G acting on it, the invariant algebra
/// A(M)^G consists of all elements x ∈ A(M) such that g·x = x for all g ∈ G.
///
/// # Type Parameters
///
/// * `R` - The base ring
///
/// # Examples
///
/// ```
/// use rustmath_algebras::{OrlikSolomonInvariantAlgebra, Matroid};
///
/// let m = Matroid::uniform(2, 3);
/// // Group action specified by permutations
/// let group_elements = vec![vec![0, 1, 2], vec![1, 0, 2]]; // Identity and transposition
/// let os_inv = OrlikSolomonInvariantAlgebra::new(1i64, m, group_elements);
/// ```
///
/// # References
///
/// - Orlik, P. & Terao, H. "Arrangements of Hyperplanes" (1992)
/// - SageMath: sage.algebras.orlik_solomon.OrlikSolomonInvariantAlgebra
#[derive(Clone)]
pub struct OrlikSolomonInvariantAlgebra<R: Ring> {
    /// The underlying Orlik-Solomon algebra
    base_algebra: OrlikSolomonAlgebra<R>,
    /// Group elements (as permutations of groundset)
    group_elements: Vec<Vec<usize>>,
    /// Invariant basis (cached)
    invariant_basis: Vec<Vec<usize>>,
}

impl<R: Ring + Clone> OrlikSolomonInvariantAlgebra<R> {
    /// Create a new Orlik-Solomon invariant algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring
    /// * `matroid` - The matroid with group action
    /// * `group_elements` - Group elements as permutations of the groundset
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::{OrlikSolomonInvariantAlgebra, Matroid};
    ///
    /// let m = Matroid::uniform(2, 3);
    /// let group = vec![vec![0, 1, 2]]; // Trivial group (identity only)
    /// let os_inv = OrlikSolomonInvariantAlgebra::new(1i64, m, group);
    /// ```
    pub fn new(base_ring: R, matroid: Matroid, group_elements: Vec<Vec<usize>>) -> Self {
        let base_algebra = OrlikSolomonAlgebra::new(base_ring, matroid);

        // Compute invariant basis
        // For simplicity, start with all NBC sets
        // A full implementation would filter by group invariance
        let invariant_basis = base_algebra.nbc_basis().to_vec();

        OrlikSolomonInvariantAlgebra {
            base_algebra,
            group_elements,
            invariant_basis,
        }
    }

    /// Get the base Orlik-Solomon algebra
    pub fn base_algebra(&self) -> &OrlikSolomonAlgebra<R> {
        &self.base_algebra
    }

    /// Get the group elements
    pub fn group_elements(&self) -> &[Vec<usize>] {
        &self.group_elements
    }

    /// Get the invariant basis
    pub fn invariant_basis(&self) -> &[Vec<usize>] {
        &self.invariant_basis
    }

    /// Get the dimension of the invariant algebra
    pub fn dimension(&self) -> usize {
        self.invariant_basis.len()
    }

    /// Check if an element is invariant under the group action
    ///
    /// For now, this is a placeholder returning true.
    /// A full implementation would check g·x = x for all g ∈ G.
    pub fn is_invariant(&self, _element: &OrlikSolomonElement<R>) -> bool
    where
        R: PartialEq,
    {
        // Placeholder: assume all elements are invariant
        true
    }

    /// Get the zero element
    pub fn zero(&self) -> OrlikSolomonElement<R> {
        self.base_algebra.zero()
    }

    /// Get the identity element
    pub fn one(&self) -> OrlikSolomonElement<R>
    where
        R: From<i64>,
    {
        self.base_algebra.one()
    }
}

impl<R: Ring + Clone + Display> Display for OrlikSolomonInvariantAlgebra<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orlik-Solomon invariant algebra (rank {}, group order {}) over {}",
            self.base_algebra.rank(),
            self.group_elements.len(),
            self.base_algebra.base_ring()
        )
    }
}

#[cfg(test)]
mod invariant_tests {
    use super::*;

    #[test]
    fn test_invariant_algebra_creation() {
        let m = Matroid::uniform(2, 3);
        let group = vec![vec![0, 1, 2]]; // Identity
        let os_inv: OrlikSolomonInvariantAlgebra<i64> =
            OrlikSolomonInvariantAlgebra::new(1, m, group);
        assert!(os_inv.dimension() > 0);
    }

    #[test]
    fn test_invariant_algebra_display() {
        let m = Matroid::uniform(2, 3);
        let group = vec![vec![0, 1, 2], vec![1, 0, 2]]; // Z_2 action
        let os_inv: OrlikSolomonInvariantAlgebra<i64> =
            OrlikSolomonInvariantAlgebra::new(1, m, group);
        let display = format!("{}", os_inv);
        assert!(display.contains("invariant"));
        assert!(display.contains("group order 2"));
    }

    #[test]
    fn test_invariant_zero_and_one() {
        let m = Matroid::uniform(2, 3);
        let group = vec![vec![0, 1, 2]];
        let os_inv: OrlikSolomonInvariantAlgebra<i64> =
            OrlikSolomonInvariantAlgebra::new(1, m, group);

        let zero = os_inv.zero();
        let one = os_inv.one();

        assert!(zero.is_zero());
        assert!(!one.is_zero());
    }
}

