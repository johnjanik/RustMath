//! Rational Cherednik Algebras
//!
//! This module implements rational Cherednik algebras, which are deformations of
//! the semidirect product of a polynomial ring with a finite Coxeter group.
//!
//! The rational Cherednik algebra H_{c,t}(W) is defined for a complex reflection group W,
//! with parameters c (reflection parameters) and t (deformation parameter).
//!
//! # Mathematical Background
//!
//! For a Weyl group W acting on a vector space h, the rational Cherednik algebra
//! is generated by:
//! - h: The original vector space (polynomial generators)
//! - h*: The dual space (differential operators)
//! - W: The Weyl/reflection group
//!
//! These satisfy specific commutation relations involving the reflection group action.
//!
//! # Examples
//!
//! ```
//! use rustmath_algebras::rational_cherednik_algebra::*;
//! use rustmath_core::Ring;
//!
//! // Create a rational Cherednik algebra for type A2
//! let algebra = RationalCherednikAlgebra::new(
//!     CartanType::A(2),
//!     vec![1.0], // c parameter
//!     0.0        // t parameter
//! );
//!
//! // Get algebra generators
//! let gens = algebra.algebra_generators();
//! ```

use rustmath_core::{Ring, Field};
use std::collections::HashMap;
use std::fmt;

/// Cartan types for root systems
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CartanType {
    /// Type A_n (SL(n+1))
    A(usize),
    /// Type B_n (SO(2n+1))
    B(usize),
    /// Type C_n (Sp(2n))
    C(usize),
    /// Type D_n (SO(2n))
    D(usize),
    /// Type E_6, E_7, E_8
    E(usize),
    /// Type F_4
    F4,
    /// Type G_2
    G2,
}

impl fmt::Display for CartanType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            CartanType::A(n) => write!(f, "A_{}", n),
            CartanType::B(n) => write!(f, "B_{}", n),
            CartanType::C(n) => write!(f, "C_{}", n),
            CartanType::D(n) => write!(f, "D_{}", n),
            CartanType::E(n) => write!(f, "E_{}", n),
            CartanType::F4 => write!(f, "F_4"),
            CartanType::G2 => write!(f, "G_2"),
        }
    }
}

impl CartanType {
    /// Get the rank of the Cartan type
    pub fn rank(&self) -> usize {
        match self {
            CartanType::A(n) | CartanType::B(n) | CartanType::C(n) | CartanType::D(n) => *n,
            CartanType::E(n) => *n,
            CartanType::F4 => 4,
            CartanType::G2 => 2,
        }
    }

    /// Get the number of positive roots
    pub fn num_positive_roots(&self) -> usize {
        match self {
            CartanType::A(n) => n * (n + 1) / 2,
            CartanType::B(n) | CartanType::C(n) => n * n,
            CartanType::D(n) => n * (n - 1),
            CartanType::E(6) => 36,
            CartanType::E(7) => 63,
            CartanType::E(8) => 120,
            CartanType::F4 => 24,
            CartanType::G2 => 6,
            _ => panic!("Invalid Cartan type"),
        }
    }
}

/// Elements of the rational Cherednik algebra
///
/// An element is represented as a linear combination of basis elements,
/// where each basis element is a monomial in h, h*, and W.
#[derive(Debug, Clone, PartialEq)]
pub struct RationalCherednikElement<R: Ring> {
    /// Coefficients for each basis element
    /// Key: (h_powers, w_index, h_dual_powers)
    /// where h_powers and h_dual_powers are vectors of exponents
    coefficients: HashMap<(Vec<usize>, usize, Vec<usize>), R>,
}

impl<R: Ring> RationalCherednikElement<R> {
    /// Create a zero element
    pub fn zero() -> Self {
        Self {
            coefficients: HashMap::new(),
        }
    }

    /// Create an element from a single monomial
    pub fn monomial(h_powers: Vec<usize>, w_index: usize, h_dual_powers: Vec<usize>, coeff: R) -> Self {
        let mut coefficients = HashMap::new();
        if !coeff.is_zero() {
            coefficients.insert((h_powers, w_index, h_dual_powers), coeff);
        }
        Self { coefficients }
    }

    /// Check if the element is zero
    pub fn is_zero(&self) -> bool {
        self.coefficients.is_empty()
    }

    /// Get the coefficients
    pub fn coefficients(&self) -> &HashMap<(Vec<usize>, usize, Vec<usize>), R> {
        &self.coefficients
    }
}

impl<R: Ring> fmt::Display for RationalCherednikElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut terms: Vec<_> = self.coefficients.iter().collect();
        terms.sort_by_key(|(k, _)| k.clone());

        for (i, ((h, w, hd), coeff)) in terms.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            write!(f, "{}*h^{:?}*s{}*a^{:?}", coeff, h, w, hd)?;
        }
        Ok(())
    }
}

/// Rational Cherednik Algebra
///
/// The rational Cherednik algebra H_{c,t}(W) associated to a complex reflection group W.
#[derive(Debug, Clone)]
pub struct RationalCherednikAlgebra {
    /// The Cartan type of the root system
    cartan_type: CartanType,
    /// Reflection parameters (one per conjugacy class of reflections)
    c_parameters: Vec<f64>,
    /// Deformation parameter t
    t_parameter: f64,
    /// Rank of the root system
    rank: usize,
}

impl RationalCherednikAlgebra {
    /// Create a new rational Cherednik algebra
    ///
    /// # Arguments
    ///
    /// * `cartan_type` - The Cartan type of the root system
    /// * `c_parameters` - Reflection parameters (one per conjugacy class)
    /// * `t_parameter` - The deformation parameter t
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::rational_cherednik_algebra::*;
    ///
    /// // Type A2 with c=1, t=0
    /// let algebra = RationalCherednikAlgebra::new(
    ///     CartanType::A(2),
    ///     vec![1.0],
    ///     0.0
    /// );
    /// assert_eq!(algebra.rank(), 2);
    /// ```
    pub fn new(cartan_type: CartanType, c_parameters: Vec<f64>, t_parameter: f64) -> Self {
        let rank = cartan_type.rank();
        Self {
            cartan_type,
            c_parameters,
            t_parameter,
            rank,
        }
    }

    /// Get the Cartan type
    pub fn cartan_type(&self) -> &CartanType {
        &self.cartan_type
    }

    /// Get the rank
    pub fn rank(&self) -> usize {
        self.rank
    }

    /// Get the c parameters
    pub fn c_parameters(&self) -> &[f64] {
        &self.c_parameters
    }

    /// Get the t parameter
    pub fn t_parameter(&self) -> f64 {
        self.t_parameter
    }

    /// Get algebra generators
    ///
    /// Returns (simple_roots, simple_reflections, simple_coroots)
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::rational_cherednik_algebra::*;
    ///
    /// let algebra = RationalCherednikAlgebra::new(CartanType::A(2), vec![1.0], 0.0);
    /// let (roots, reflections, coroots) = algebra.algebra_generators();
    /// assert_eq!(roots.len(), 2);
    /// assert_eq!(reflections.len(), 2);
    /// assert_eq!(coroots.len(), 2);
    /// ```
    pub fn algebra_generators(&self) -> (Vec<String>, Vec<String>, Vec<String>) {
        let n = self.rank;

        let roots: Vec<String> = (0..n).map(|i| format!("a{}", i)).collect();
        let reflections: Vec<String> = (0..n).map(|i| format!("s{}", i)).collect();
        let coroots: Vec<String> = (0..n).map(|i| format!("ac{}", i)).collect();

        (roots, reflections, coroots)
    }

    /// Compute the trivial idempotent
    ///
    /// Returns the idempotent e = (1/|W|) * sum_{w in W} w
    /// This is used in the construction of spherical Cherednik algebras.
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::rational_cherednik_algebra::*;
    ///
    /// let algebra = RationalCherednikAlgebra::new(CartanType::A(1), vec![1.0], 0.0);
    /// let idempotent = algebra.trivial_idempotent();
    /// // For type A1, |W| = 2
    /// ```
    pub fn trivial_idempotent(&self) -> String {
        format!("e_trivial({})", self.cartan_type)
    }

    /// Compute the deformed Euler element
    ///
    /// The deformed Euler element is an important central element
    /// used in representation theory.
    pub fn deformed_euler(&self) -> String {
        format!("euler_{}(c={:?}, t={})", self.cartan_type, self.c_parameters, self.t_parameter)
    }

    /// Get the Weyl group order
    ///
    /// Returns |W| where W is the Weyl group of the root system
    pub fn weyl_group_order(&self) -> usize {
        match &self.cartan_type {
            CartanType::A(n) => {
                // |S_{n+1}| = (n+1)!
                let mut result = 1;
                for i in 1..=(*n + 1) {
                    result *= i;
                }
                result
            }
            CartanType::B(n) | CartanType::C(n) => {
                // |BC_n| = 2^n * n!
                let mut result = 1 << n; // 2^n
                for i in 1..=*n {
                    result *= i;
                }
                result
            }
            CartanType::D(n) => {
                // |D_n| = 2^{n-1} * n!
                let mut result = 1 << (n - 1); // 2^{n-1}
                for i in 1..=*n {
                    result *= i;
                }
                result
            }
            CartanType::E(6) => 51840,
            CartanType::E(7) => 2903040,
            CartanType::E(8) => 696729600,
            CartanType::F4 => 1152,
            CartanType::G2 => 12,
            _ => panic!("Invalid Cartan type"),
        }
    }

    /// Compute degree of a basis element
    ///
    /// The algebra has a natural grading where:
    /// - Elements of h have degree 1
    /// - Elements of h* have degree -1
    /// - Elements of W have degree 0
    pub fn degree_on_basis(&self, h_powers: &[usize], h_dual_powers: &[usize]) -> i32 {
        let h_deg: i32 = h_powers.iter().sum::<usize>() as i32;
        let hd_deg: i32 = h_dual_powers.iter().sum::<usize>() as i32;
        h_deg - hd_deg
    }

    /// Check if this is a simply-laced type
    ///
    /// Simply-laced types are A, D, E (all roots have the same length)
    pub fn is_simply_laced(&self) -> bool {
        matches!(self.cartan_type, CartanType::A(_) | CartanType::D(_) | CartanType::E(_))
    }
}

impl fmt::Display for RationalCherednikAlgebra {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Rational Cherednik algebra of type {} with c={:?}, t={}",
            self.cartan_type, self.c_parameters, self.t_parameter
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cartan_type_rank() {
        assert_eq!(CartanType::A(3).rank(), 3);
        assert_eq!(CartanType::B(4).rank(), 4);
        assert_eq!(CartanType::E(6).rank(), 6);
        assert_eq!(CartanType::G2.rank(), 2);
    }

    #[test]
    fn test_cartan_type_num_positive_roots() {
        assert_eq!(CartanType::A(2).num_positive_roots(), 3); // n(n+1)/2 = 2*3/2 = 3
        assert_eq!(CartanType::A(3).num_positive_roots(), 6); // 3*4/2 = 6
        assert_eq!(CartanType::B(3).num_positive_roots(), 9); // n^2 = 9
        assert_eq!(CartanType::G2.num_positive_roots(), 6);
    }

    #[test]
    fn test_rational_cherednik_algebra_creation() {
        let algebra = RationalCherednikAlgebra::new(
            CartanType::A(2),
            vec![1.0],
            0.0
        );
        assert_eq!(algebra.rank(), 2);
        assert_eq!(algebra.c_parameters(), &[1.0]);
        assert_eq!(algebra.t_parameter(), 0.0);
    }

    #[test]
    fn test_algebra_generators() {
        let algebra = RationalCherednikAlgebra::new(CartanType::A(2), vec![1.0], 0.0);
        let (roots, reflections, coroots) = algebra.algebra_generators();

        assert_eq!(roots.len(), 2);
        assert_eq!(reflections.len(), 2);
        assert_eq!(coroots.len(), 2);

        assert_eq!(roots[0], "a0");
        assert_eq!(reflections[0], "s0");
        assert_eq!(coroots[0], "ac0");
    }

    #[test]
    fn test_weyl_group_order() {
        // Type A_n has order (n+1)!
        assert_eq!(RationalCherednikAlgebra::new(CartanType::A(1), vec![1.0], 0.0).weyl_group_order(), 2);
        assert_eq!(RationalCherednikAlgebra::new(CartanType::A(2), vec![1.0], 0.0).weyl_group_order(), 6);
        assert_eq!(RationalCherednikAlgebra::new(CartanType::A(3), vec![1.0], 0.0).weyl_group_order(), 24);

        // Type B_2 has order 2^2 * 2! = 8
        assert_eq!(RationalCherednikAlgebra::new(CartanType::B(2), vec![1.0, 1.0], 0.0).weyl_group_order(), 8);

        // Type G_2 has order 12
        assert_eq!(RationalCherednikAlgebra::new(CartanType::G2, vec![1.0], 0.0).weyl_group_order(), 12);
    }

    #[test]
    fn test_degree_on_basis() {
        let algebra = RationalCherednikAlgebra::new(CartanType::A(2), vec![1.0], 0.0);

        // Pure h element: degree = sum of powers
        assert_eq!(algebra.degree_on_basis(&[1, 0], &[0, 0]), 1);
        assert_eq!(algebra.degree_on_basis(&[1, 2], &[0, 0]), 3);

        // Pure h* element: degree = -sum of powers
        assert_eq!(algebra.degree_on_basis(&[0, 0], &[1, 0]), -1);
        assert_eq!(algebra.degree_on_basis(&[0, 0], &[2, 1]), -3);

        // Mixed: degree = h_powers - h*_powers
        assert_eq!(algebra.degree_on_basis(&[1, 1], &[1, 0]), 1);
        assert_eq!(algebra.degree_on_basis(&[2, 0], &[1, 1]), 0);
    }

    #[test]
    fn test_is_simply_laced() {
        assert!(RationalCherednikAlgebra::new(CartanType::A(3), vec![1.0], 0.0).is_simply_laced());
        assert!(RationalCherednikAlgebra::new(CartanType::D(4), vec![1.0], 0.0).is_simply_laced());
        assert!(RationalCherednikAlgebra::new(CartanType::E(6), vec![1.0], 0.0).is_simply_laced());

        assert!(!RationalCherednikAlgebra::new(CartanType::B(3), vec![1.0, 1.0], 0.0).is_simply_laced());
        assert!(!RationalCherednikAlgebra::new(CartanType::C(3), vec![1.0, 1.0], 0.0).is_simply_laced());
        assert!(!RationalCherednikAlgebra::new(CartanType::G2, vec![1.0], 0.0).is_simply_laced());
    }

    #[test]
    fn test_trivial_idempotent() {
        let algebra = RationalCherednikAlgebra::new(CartanType::A(2), vec![1.0], 0.0);
        let idempotent = algebra.trivial_idempotent();
        assert!(idempotent.contains("A_2"));
    }

    #[test]
    fn test_deformed_euler() {
        let algebra = RationalCherednikAlgebra::new(CartanType::A(2), vec![1.5], 0.5);
        let euler = algebra.deformed_euler();
        assert!(euler.contains("1.5"));
        assert!(euler.contains("0.5"));
    }

    #[test]
    fn test_element_zero() {
        let elem: RationalCherednikElement<i32> = RationalCherednikElement::zero();
        assert!(elem.is_zero());
        assert_eq!(elem.coefficients().len(), 0);
    }

    #[test]
    fn test_element_monomial() {
        let elem = RationalCherednikElement::monomial(vec![1, 0], 0, vec![0, 1], 5);
        assert!(!elem.is_zero());
        assert_eq!(elem.coefficients().len(), 1);

        // Zero coefficient creates zero element
        let elem_zero = RationalCherednikElement::monomial(vec![1, 0], 0, vec![0, 1], 0);
        assert!(elem_zero.is_zero());
    }

    #[test]
    fn test_cartan_type_display() {
        assert_eq!(format!("{}", CartanType::A(3)), "A_3");
        assert_eq!(format!("{}", CartanType::B(4)), "B_4");
        assert_eq!(format!("{}", CartanType::E(6)), "E_6");
        assert_eq!(format!("{}", CartanType::G2), "G_2");
    }

    #[test]
    fn test_algebra_display() {
        let algebra = RationalCherednikAlgebra::new(CartanType::A(2), vec![1.0], 0.5);
        let display = format!("{}", algebra);
        assert!(display.contains("A_2"));
        assert!(display.contains("1.0"));
        assert!(display.contains("0.5"));
    }

    #[test]
    fn test_different_cartan_types() {
        let types = vec![
            CartanType::A(3),
            CartanType::B(3),
            CartanType::C(4),
            CartanType::D(4),
            CartanType::E(6),
            CartanType::F4,
            CartanType::G2,
        ];

        for ct in types {
            let algebra = RationalCherednikAlgebra::new(ct.clone(), vec![1.0], 0.0);
            assert_eq!(algebra.cartan_type(), &ct);
            assert!(algebra.weyl_group_order() > 0);
        }
    }

    #[test]
    fn test_exceptional_types() {
        let e6 = RationalCherednikAlgebra::new(CartanType::E(6), vec![1.0], 0.0);
        assert_eq!(e6.rank(), 6);
        assert_eq!(e6.weyl_group_order(), 51840);

        let f4 = RationalCherednikAlgebra::new(CartanType::F4, vec![1.0, 1.0], 0.0);
        assert_eq!(f4.rank(), 4);
        assert_eq!(f4.weyl_group_order(), 1152);
    }

    #[test]
    fn test_element_display() {
        let elem = RationalCherednikElement::monomial(vec![1, 0], 0, vec![0, 1], 5);
        let display = format!("{}", elem);
        assert!(display.contains("5"));

        let zero: RationalCherednikElement<i32> = RationalCherednikElement::zero();
        assert_eq!(format!("{}", zero), "0");
    }
}
