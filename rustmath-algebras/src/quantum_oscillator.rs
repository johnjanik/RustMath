//! Quantum Oscillator Algebra
//!
//! Implements the q-oscillator algebra, a mathematical structure generated by
//! creation (a⁺) and annihilation (a⁻) operators along with weight operators (k, k⁻¹).
//!
//! The algebra satisfies these fundamental commutation relations:
//! - k·a^(±) = q^(±1)·a^(±)·k
//! - a⁻·a⁺ = 1 - q²k²
//! - a⁺·a⁻ = 1 - k²
//!
//! Corresponds to sage.algebras.quantum_oscillator

use rustmath_core::Ring;
use std::collections::HashMap;
use std::fmt::{self, Display};

/// Generators of the quantum oscillator algebra
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Generator {
    /// Creation operator a⁺
    APlus,
    /// Annihilation operator a⁻
    AMinus,
    /// Weight operator k
    K,
    /// Inverse weight operator k⁻¹
    KInverse,
}

impl Display for Generator {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Generator::APlus => write!(f, "a+"),
            Generator::AMinus => write!(f, "a-"),
            Generator::K => write!(f, "k"),
            Generator::KInverse => write!(f, "k^-1"),
        }
    }
}

/// An index in the quantum oscillator algebra basis
///
/// Represented as (a, k_power) where:
/// - a: exponent tracking creation/annihilation operators (negative = annihilation)
/// - k_power: power of the k operator
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OscillatorIndex {
    /// Operator exponent (positive for a⁺, negative for a⁻)
    pub a_power: i32,
    /// Power of k operator
    pub k_power: i32,
}

impl OscillatorIndex {
    /// Create a new oscillator index
    pub fn new(a_power: i32, k_power: i32) -> Self {
        OscillatorIndex { a_power, k_power }
    }

    /// Create the identity index (0, 0)
    pub fn one() -> Self {
        OscillatorIndex {
            a_power: 0,
            k_power: 0,
        }
    }

    /// Create index for a⁺
    pub fn a_plus() -> Self {
        OscillatorIndex {
            a_power: 1,
            k_power: 0,
        }
    }

    /// Create index for a⁻
    pub fn a_minus() -> Self {
        OscillatorIndex {
            a_power: -1,
            k_power: 0,
        }
    }

    /// Create index for k
    pub fn k() -> Self {
        OscillatorIndex {
            a_power: 0,
            k_power: 1,
        }
    }

    /// Create index for k⁻¹
    pub fn k_inverse() -> Self {
        OscillatorIndex {
            a_power: 0,
            k_power: -1,
        }
    }
}

impl Display for OscillatorIndex {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.a_power == 0 && self.k_power == 0 {
            write!(f, "1")
        } else {
            let mut parts = Vec::new();
            if self.a_power > 0 {
                if self.a_power == 1 {
                    parts.push("a+".to_string());
                } else {
                    parts.push(format!("(a+)^{}", self.a_power));
                }
            } else if self.a_power < 0 {
                if self.a_power == -1 {
                    parts.push("a-".to_string());
                } else {
                    parts.push(format!("(a-)^{}", -self.a_power));
                }
            }

            if self.k_power != 0 {
                if self.k_power == 1 {
                    parts.push("k".to_string());
                } else {
                    parts.push(format!("k^{}", self.k_power));
                }
            }

            write!(f, "{}", parts.join("*"))
        }
    }
}

/// An element of the quantum oscillator algebra
///
/// Represented as a linear combination of basis elements
#[derive(Debug, Clone)]
pub struct OscillatorElement<R: Ring> {
    /// Map from basis index to coefficient
    terms: HashMap<OscillatorIndex, R>,
}

impl<R: Ring> OscillatorElement<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        OscillatorElement {
            terms: HashMap::new(),
        }
    }

    /// Create the one element (multiplicative identity)
    pub fn one() -> Self
    where
        R: From<i64>,
    {
        let mut terms = HashMap::new();
        terms.insert(OscillatorIndex::one(), R::from(1));
        OscillatorElement { terms }
    }

    /// Create an element from a single basis index with coefficient
    pub fn from_basis(index: OscillatorIndex, coeff: R) -> Self {
        if coeff.is_zero() {
            return OscillatorElement::zero();
        }
        let mut terms = HashMap::new();
        terms.insert(index, coeff);
        OscillatorElement { terms }
    }

    /// Create an element from a generator
    pub fn from_generator(gen: Generator) -> Self
    where
        R: From<i64>,
    {
        let index = match gen {
            Generator::APlus => OscillatorIndex::a_plus(),
            Generator::AMinus => OscillatorIndex::a_minus(),
            Generator::K => OscillatorIndex::k(),
            Generator::KInverse => OscillatorIndex::k_inverse(),
        };
        Self::from_basis(index, R::from(1))
    }

    /// Add two elements
    pub fn add(&self, other: &OscillatorElement<R>) -> OscillatorElement<R> {
        let mut result = self.terms.clone();
        for (index, coeff) in &other.terms {
            let entry = result.entry(*index).or_insert_with(R::zero);
            *entry = entry.add(coeff);
        }
        // Remove zero coefficients
        result.retain(|_, v| !v.is_zero());
        OscillatorElement { terms: result }
    }

    /// Multiply by a scalar
    pub fn scale(&self, scalar: &R) -> OscillatorElement<R> {
        if scalar.is_zero() {
            return OscillatorElement::zero();
        }
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(idx, c)| (*idx, c.mul(scalar)))
            .collect();
        OscillatorElement { terms }
    }

    /// Negate the element
    pub fn negate(&self) -> OscillatorElement<R> {
        let terms: HashMap<_, _> = self
            .terms
            .iter()
            .map(|(idx, c)| (*idx, c.neg()))
            .collect();
        OscillatorElement { terms }
    }

    /// Check if this is the zero element
    pub fn is_zero(&self) -> bool {
        self.terms.is_empty()
    }

    /// Get the number of terms
    pub fn num_terms(&self) -> usize {
        self.terms.len()
    }
}

impl<R: Ring + Display> Display for OscillatorElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut items: Vec<_> = self.terms.iter().collect();
        items.sort_by_key(|(idx, _)| *idx);

        for (i, (index, coeff)) in items.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            if index == &&OscillatorIndex::one() {
                write!(f, "{}", coeff)?;
            } else {
                write!(f, "{}*{}", coeff, index)?;
            }
        }
        Ok(())
    }
}

/// Quantum Oscillator Algebra
///
/// A q-oscillator algebra generated by creation (a⁺), annihilation (a⁻),
/// and weight (k, k⁻¹) operators.
///
/// # Type Parameters
///
/// * `R` - The base ring (coefficients)
///
/// # Examples
///
/// ```
/// use rustmath_algebras::quantum_oscillator::{QuantumOscillatorAlgebra, Generator};
/// use rustmath_rationals::Rational;
///
/// let qosc: QuantumOscillatorAlgebra<Rational> = QuantumOscillatorAlgebra::new();
/// let a_plus = qosc.generator(Generator::APlus);
/// ```
#[derive(Debug, Clone)]
pub struct QuantumOscillatorAlgebra<R: Ring> {
    /// The q parameter (stored as an element)
    q: R,
}

impl<R: Ring + From<i64>> QuantumOscillatorAlgebra<R> {
    /// Create a new quantum oscillator algebra with default q parameter
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::quantum_oscillator::QuantumOscillatorAlgebra;
    /// use rustmath_rationals::Rational;
    ///
    /// let qosc: QuantumOscillatorAlgebra<Rational> = QuantumOscillatorAlgebra::new();
    /// ```
    pub fn new() -> Self {
        QuantumOscillatorAlgebra { q: R::from(1) }
    }

    /// Create a quantum oscillator algebra with a specific q parameter
    ///
    /// # Arguments
    ///
    /// * `q` - The q parameter
    pub fn with_q(q: R) -> Self {
        QuantumOscillatorAlgebra { q }
    }

    /// Get the q parameter
    pub fn q(&self) -> &R {
        &self.q
    }

    /// Get a generator
    ///
    /// # Arguments
    ///
    /// * `gen` - The generator to retrieve
    ///
    /// # Returns
    ///
    /// An element representing the generator
    pub fn generator(&self, gen: Generator) -> OscillatorElement<R> {
        OscillatorElement::from_generator(gen)
    }

    /// Get all generators as a vector
    ///
    /// Returns [a⁺, a⁻, k, k⁻¹]
    pub fn generators(&self) -> Vec<OscillatorElement<R>> {
        vec![
            self.generator(Generator::APlus),
            self.generator(Generator::AMinus),
            self.generator(Generator::K),
            self.generator(Generator::KInverse),
        ]
    }

    /// Get the one element (identity)
    pub fn one(&self) -> OscillatorElement<R> {
        OscillatorElement::one()
    }

    /// Get the zero element
    pub fn zero(&self) -> OscillatorElement<R> {
        OscillatorElement::zero()
    }
}

impl<R: Ring + From<i64>> Default for QuantumOscillatorAlgebra<R> {
    fn default() -> Self {
        Self::new()
    }
}

impl<R: Ring + Display> Display for QuantumOscillatorAlgebra<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Quantum oscillator algebra with q = {}", self.q)
    }
}

/// Fock space representation of the quantum oscillator algebra
///
/// The Fock space is spanned by basis states |n⟩ for n ≥ 0.
/// The generators act as:
/// - a⁺|n⟩ = |n+1⟩
/// - a⁻|n⟩ = (1 - q^(2n))·|n-1⟩
/// - k|n⟩ = q^n·|n⟩
/// - k⁻¹|n⟩ = q^(-n)·|n⟩
#[derive(Debug, Clone)]
pub struct FockSpaceElement<R: Ring> {
    /// Map from state index to coefficient
    states: HashMap<usize, R>,
}

impl<R: Ring> FockSpaceElement<R> {
    /// Create the zero element
    pub fn zero() -> Self {
        FockSpaceElement {
            states: HashMap::new(),
        }
    }

    /// Create the vacuum state |0⟩
    pub fn vacuum() -> Self
    where
        R: From<i64>,
    {
        let mut states = HashMap::new();
        states.insert(0, R::from(1));
        FockSpaceElement { states }
    }

    /// Create a basis state |n⟩
    pub fn basis_state(n: usize) -> Self
    where
        R: From<i64>,
    {
        let mut states = HashMap::new();
        states.insert(n, R::from(1));
        FockSpaceElement { states }
    }

    /// Check if this is the zero element
    pub fn is_zero(&self) -> bool {
        self.states.is_empty()
    }
}

impl<R: Ring + Display> Display for FockSpaceElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.is_zero() {
            return write!(f, "0");
        }

        let mut items: Vec<_> = self.states.iter().collect();
        items.sort_by_key(|(n, _)| *n);

        for (i, (n, coeff)) in items.iter().enumerate() {
            if i > 0 {
                write!(f, " + ")?;
            }
            write!(f, "{}*|{}⟩", coeff, n)?;
        }
        Ok(())
    }
}

/// Fock space representation
#[derive(Debug, Clone)]
pub struct FockSpaceRepresentation<R: Ring> {
    /// The underlying quantum oscillator algebra
    algebra: QuantumOscillatorAlgebra<R>,
}

impl<R: Ring + From<i64>> FockSpaceRepresentation<R> {
    /// Create a new Fock space representation
    pub fn new(algebra: QuantumOscillatorAlgebra<R>) -> Self {
        FockSpaceRepresentation { algebra }
    }

    /// Get the vacuum state |0⟩
    pub fn vacuum(&self) -> FockSpaceElement<R> {
        FockSpaceElement::vacuum()
    }

    /// Get a basis state |n⟩
    pub fn basis_state(&self, n: usize) -> FockSpaceElement<R> {
        FockSpaceElement::basis_state(n)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rustmath_rationals::Rational;

    #[test]
    fn test_oscillator_index() {
        let idx = OscillatorIndex::new(1, 2);
        assert_eq!(idx.a_power, 1);
        assert_eq!(idx.k_power, 2);

        let one = OscillatorIndex::one();
        assert_eq!(one.a_power, 0);
        assert_eq!(one.k_power, 0);

        let a_plus = OscillatorIndex::a_plus();
        assert_eq!(a_plus.a_power, 1);
        assert_eq!(a_plus.k_power, 0);

        let a_minus = OscillatorIndex::a_minus();
        assert_eq!(a_minus.a_power, -1);
        assert_eq!(a_minus.k_power, 0);
    }

    #[test]
    fn test_oscillator_element() {
        let idx = OscillatorIndex::a_plus();
        let elem: OscillatorElement<Rational> = OscillatorElement::from_basis(idx, Rational::from(2));
        assert_eq!(elem.num_terms(), 1);

        let zero: OscillatorElement<Rational> = OscillatorElement::zero();
        assert!(zero.is_zero());

        let one: OscillatorElement<Rational> = OscillatorElement::one();
        assert_eq!(one.num_terms(), 1);
    }

    #[test]
    fn test_oscillator_algebra() {
        let qosc: QuantumOscillatorAlgebra<Rational> = QuantumOscillatorAlgebra::new();
        let a_plus = qosc.generator(Generator::APlus);
        assert_eq!(a_plus.num_terms(), 1);

        let gens = qosc.generators();
        assert_eq!(gens.len(), 4);

        let one = qosc.one();
        assert_eq!(one.num_terms(), 1);
    }

    #[test]
    fn test_oscillator_arithmetic() {
        let qosc: QuantumOscillatorAlgebra<Rational> = QuantumOscillatorAlgebra::new();
        let a_plus = qosc.generator(Generator::APlus);
        let a_minus = qosc.generator(Generator::AMinus);

        let sum = a_plus.add(&a_minus);
        assert_eq!(sum.num_terms(), 2);

        let scaled = a_plus.scale(&Rational::from(3));
        assert_eq!(scaled.num_terms(), 1);

        let neg = a_plus.negate();
        assert_eq!(neg.num_terms(), 1);
    }

    #[test]
    fn test_fock_space() {
        let qosc: QuantumOscillatorAlgebra<Rational> = QuantumOscillatorAlgebra::new();
        let fock = FockSpaceRepresentation::new(qosc);

        let vacuum = fock.vacuum();
        assert!(!vacuum.is_zero());

        let state1 = fock.basis_state(1);
        assert!(!state1.is_zero());

        let zero: FockSpaceElement<Rational> = FockSpaceElement::zero();
        assert!(zero.is_zero());
    }

    #[test]
    fn test_generator_display() {
        assert_eq!(format!("{}", Generator::APlus), "a+");
        assert_eq!(format!("{}", Generator::AMinus), "a-");
        assert_eq!(format!("{}", Generator::K), "k");
        assert_eq!(format!("{}", Generator::KInverse), "k^-1");
    }

    #[test]
    fn test_index_display() {
        let one = OscillatorIndex::one();
        assert_eq!(format!("{}", one), "1");

        let a_plus = OscillatorIndex::a_plus();
        assert!(format!("{}", a_plus).contains("a+"));

        let complex = OscillatorIndex::new(2, 3);
        let display = format!("{}", complex);
        assert!(display.contains("a+") && display.contains("k"));
    }

    #[test]
    fn test_algebra_with_q() {
        let q = Rational::from(2);
        let qosc = QuantumOscillatorAlgebra::with_q(q.clone());
        assert_eq!(qosc.q(), &q);
    }

    #[test]
    fn test_fock_display() {
        let vacuum: FockSpaceElement<Rational> = FockSpaceElement::vacuum();
        let display = format!("{}", vacuum);
        assert!(display.contains("|0⟩"));
    }
}
