//! Orlik-Terao Algebra
//!
//! The Orlik-Terao algebra is a graded, commutative, finite-dimensional algebra
//! associated with matroids and hyperplane arrangements. Unlike the Orlik-Solomon
//! algebra (which is skew-commutative), the Orlik-Terao algebra is commutative.
//!
//! # Mathematical Background
//!
//! For a matroid M with groundset X and representation over a field, the
//! Orlik-Terao algebra A_OT(M) is defined as:
//! - Start with the exterior algebra E = ⋀(e_x | x ∈ X)
//! - Quotient by the Orlik-Terao ideal, generated by circuit-based partial derivatives
//!
//! ## Key Differences from Orlik-Solomon
//!
//! - **Orlik-Solomon**: Skew-commutative (e_i ∧ e_j = -e_j ∧ e_i)
//! - **Orlik-Terao**: Commutative (e_i · e_j = e_j · e_i)
//! - **Relations**: Different defining ideals and reduction algorithms
//!
//! ## Properties
//!
//! - **Graded**: Degree equals cardinality of basis elements
//! - **Finite-dimensional**: Dimension equals number of NBC sets
//! - **Commutative**: Standard commutative multiplication
//! - **Basis**: No broken circuit (NBC) sets (same as Orlik-Solomon)
//!
//! # Examples
//!
//! ```
//! use rustmath_algebras::{OrlikTeraoAlgebra, Matroid};
//!
//! // Create a simple matroid (uniform matroid U(2,3))
//! let groundset = vec![0, 1, 2];
//! let circuits = vec![vec![0, 1, 2]]; // All three elements form a circuit
//! let matroid = Matroid::from_circuits(groundset.clone(), circuits);
//!
//! // Create the Orlik-Terao algebra over the integers
//! let ot = OrlikTeraoAlgebra::new(1i64, matroid);
//!
//! assert_eq!(ot.rank(), 2); // Rank of the matroid
//! ```
//!
//! # References
//!
//! - Orlik, P. & Terao, H. "Arrangements of Hyperplanes" (1992)
//! - SageMath: sage.algebras.orlik_terao
//!
//! Corresponds to sage.algebras.orlik_terao

use rustmath_core::Ring;
use std::collections::{HashMap, HashSet};
use std::fmt::{self, Display};
use crate::orlik_solomon::Matroid;

/// Orlik-Terao Algebra
///
/// The Orlik-Terao algebra A_OT(M) associated with a matroid M.
/// It is a graded, finite-dimensional, **commutative** algebra with
/// basis given by the NBC (no broken circuit) sets.
///
/// # Type Parameters
///
/// * `R` - The base ring
///
/// # Examples
///
/// ```
/// use rustmath_algebras::{OrlikTeraoAlgebra, Matroid};
///
/// let matroid = Matroid::uniform(2, 3);
/// let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, matroid);
/// ```
#[derive(Clone)]
pub struct OrlikTeraoAlgebra<R: Ring> {
    /// Base ring
    base_ring: R,
    /// The underlying matroid
    matroid: Matroid,
    /// NBC basis (cached)
    nbc_basis: Vec<Vec<usize>>,
    /// Ordering of groundset
    ordering: Vec<usize>,
}

impl<R: Ring + Clone> OrlikTeraoAlgebra<R> {
    /// Create a new Orlik-Terao algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring (typically integers or rationals)
    /// * `matroid` - The matroid defining the algebra
    ///
    /// # Examples
    ///
    /// ```
    /// use rustmath_algebras::{OrlikTeraoAlgebra, Matroid};
    ///
    /// let m = Matroid::uniform(2, 4);
    /// let ot = OrlikTeraoAlgebra::new(1i64, m);
    /// ```
    pub fn new(base_ring: R, matroid: Matroid) -> Self {
        let ordering = matroid.groundset().to_vec();
        let nbc_basis = matroid.all_nbc_sets();

        OrlikTeraoAlgebra {
            base_ring,
            matroid,
            nbc_basis,
            ordering,
        }
    }

    /// Create with a custom ordering of the groundset
    pub fn with_ordering(base_ring: R, matroid: Matroid, ordering: Vec<usize>) -> Self {
        let nbc_basis = matroid.all_nbc_sets();

        OrlikTeraoAlgebra {
            base_ring,
            matroid,
            nbc_basis,
            ordering,
        }
    }

    /// Get the base ring
    pub fn base_ring(&self) -> &R {
        &self.base_ring
    }

    /// Get the matroid
    pub fn matroid(&self) -> &Matroid {
        &self.matroid
    }

    /// Get the rank of the underlying matroid
    pub fn rank(&self) -> usize {
        self.matroid.rank()
    }

    /// Get the dimension of the algebra
    ///
    /// This equals the number of NBC sets.
    pub fn dimension(&self) -> usize {
        self.nbc_basis.len()
    }

    /// Get the NBC basis
    pub fn nbc_basis(&self) -> &[Vec<usize>] {
        &self.nbc_basis
    }

    /// Get the dimension at a given grading
    ///
    /// Returns the number of NBC sets of the specified size.
    pub fn dimension_at_grade(&self, grade: usize) -> usize {
        self.nbc_basis
            .iter()
            .filter(|nbc| nbc.len() == grade)
            .count()
    }

    /// Get algebra generators (degree 1 elements)
    ///
    /// Returns elements e_i for each groundset element i.
    pub fn algebra_generators(&self) -> Vec<OrlikTeraoElement<R>>
    where
        R: From<i64>,
    {
        self.matroid
            .groundset()
            .iter()
            .map(|&i| {
                let mut terms = HashMap::new();
                terms.insert(vec![i], R::from(1));
                OrlikTeraoElement::new(terms)
            })
            .collect()
    }

    /// Create element from subset
    ///
    /// Returns the element e_S corresponding to subset S.
    pub fn subset_image(&self, subset: &[usize]) -> OrlikTeraoElement<R>
    where
        R: From<i64>,
    {
        if self.matroid.contains_broken_circuit(subset) {
            // Contains broken circuit, so equals 0 in quotient
            OrlikTeraoElement::zero()
        } else {
            let mut terms = HashMap::new();
            let mut sorted = subset.to_vec();
            sorted.sort_unstable();
            terms.insert(sorted, R::from(1));
            OrlikTeraoElement::new(terms)
        }
    }

    /// Get the zero element
    pub fn zero(&self) -> OrlikTeraoElement<R> {
        OrlikTeraoElement::zero()
    }

    /// Get the identity element (empty set basis element)
    pub fn one(&self) -> OrlikTeraoElement<R>
    where
        R: From<i64>,
    {
        let mut terms = HashMap::new();
        terms.insert(vec![], R::from(1));
        OrlikTeraoElement::new(terms)
    }
}

/// Element of an Orlik-Terao algebra
///
/// Elements are represented as linear combinations of NBC sets.
/// The terms map NBC sets (represented as sorted vectors) to coefficients.
///
/// Unlike Orlik-Solomon elements, multiplication is **commutative**.
///
/// # Type Parameters
///
/// * `R` - The base ring
#[derive(Clone, Debug)]
pub struct OrlikTeraoElement<R: Ring> {
    /// Terms: map from NBC set to coefficient
    terms: HashMap<Vec<usize>, R>,
}

impl<R: Ring + Clone> OrlikTeraoElement<R> {
    /// Create a new element
    pub fn new(terms: HashMap<Vec<usize>, R>) -> Self {
        OrlikTeraoElement { terms }
    }

    /// Create the zero element
    pub fn zero() -> Self {
        OrlikTeraoElement {
            terms: HashMap::new(),
        }
    }

    /// Get the terms
    pub fn terms(&self) -> &HashMap<Vec<usize>, R> {
        &self.terms
    }

    /// Check if this is zero
    pub fn is_zero(&self) -> bool
    where
        R: PartialEq,
    {
        self.terms.is_empty() || self.terms.values().all(|c| c.is_zero())
    }

    /// Get the degree (maximum size of NBC sets in the support)
    pub fn degree(&self) -> Option<usize>
    where
        R: PartialEq,
    {
        self.terms
            .iter()
            .filter(|(_, coeff)| !coeff.is_zero())
            .map(|(nbc, _)| nbc.len())
            .max()
    }

    /// Add two elements
    pub fn add(&self, other: &Self) -> Self
    where
        R: std::ops::Add<Output = R> + PartialEq,
    {
        let mut result = self.terms.clone();

        for (nbc, coeff) in &other.terms {
            let new_coeff = if let Some(existing) = result.get(nbc) {
                existing.clone() + coeff.clone()
            } else {
                coeff.clone()
            };

            if !new_coeff.is_zero() {
                result.insert(nbc.clone(), new_coeff);
            } else {
                result.remove(nbc);
            }
        }

        OrlikTeraoElement { terms: result }
    }

    /// Scalar multiplication
    pub fn scalar_mul(&self, scalar: &R) -> Self
    where
        R: std::ops::Mul<Output = R> + PartialEq,
    {
        if scalar.is_zero() {
            return Self::zero();
        }

        let terms = self
            .terms
            .iter()
            .map(|(nbc, coeff)| (nbc.clone(), coeff.clone() * scalar.clone()))
            .collect();

        OrlikTeraoElement { terms }
    }

    /// Negate the element
    pub fn negate(&self) -> Self
    where
        R: std::ops::Neg<Output = R>,
    {
        let terms = self
            .terms
            .iter()
            .map(|(nbc, coeff)| (nbc.clone(), -coeff.clone()))
            .collect();

        OrlikTeraoElement { terms }
    }

    /// Commutative product
    ///
    /// For now, this is a placeholder that returns zero.
    /// A full implementation would compute the product respecting
    /// commutativity and Orlik-Terao relations.
    pub fn multiply(&self, _other: &Self) -> Self
    where
        R: std::ops::Mul<Output = R> + std::ops::Add<Output = R> + PartialEq + From<i64>,
    {
        // Full implementation would:
        // 1. Multiply NBC sets by taking union
        // 2. Check commutativity (no sign change)
        // 3. Reduce using Orlik-Terao relations
        //
        // For now, return zero as placeholder
        Self::zero()
    }
}

impl<R: Ring + Clone + Display> Display for OrlikTeraoElement<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        if self.terms.is_empty() {
            return write!(f, "0");
        }

        let mut first = true;
        for (nbc, coeff) in &self.terms {
            if !first {
                write!(f, " + ")?;
            }
            first = false;

            if nbc.is_empty() {
                // Identity element
                write!(f, "{}", coeff)?;
            } else if coeff.is_one() {
                write!(f, "e_{{{}}}", format_set(nbc))?;
            } else {
                write!(f, "{}*e_{{{}}}", coeff, format_set(nbc))?;
            }
        }

        Ok(())
    }
}

fn format_set(set: &[usize]) -> String {
    set.iter()
        .map(|x| x.to_string())
        .collect::<Vec<_>>()
        .join(",")
}

impl<R: Ring + Clone + Display> Display for OrlikTeraoAlgebra<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orlik-Terao algebra of rank {} over {}",
            self.rank(),
            self.base_ring
        )
    }
}

/// Orlik-Terao Invariant Algebra
///
/// The subalgebra of the Orlik-Terao algebra consisting of elements
/// invariant under a group action on the matroid.
///
/// # Type Parameters
///
/// * `R` - The base ring
///
/// # References
///
/// - SageMath: sage.algebras.orlik_terao.OrlikTeraoInvariantAlgebra
#[derive(Clone)]
pub struct OrlikTeraoInvariantAlgebra<R: Ring> {
    /// The underlying Orlik-Terao algebra
    base_algebra: OrlikTeraoAlgebra<R>,
    /// Group elements (as permutations of groundset)
    group_elements: Vec<Vec<usize>>,
    /// Invariant basis (cached)
    invariant_basis: Vec<Vec<usize>>,
}

impl<R: Ring + Clone> OrlikTeraoInvariantAlgebra<R> {
    /// Create a new Orlik-Terao invariant algebra
    ///
    /// # Arguments
    ///
    /// * `base_ring` - The base ring
    /// * `matroid` - The matroid with group action
    /// * `group_elements` - Group elements as permutations of the groundset
    pub fn new(base_ring: R, matroid: Matroid, group_elements: Vec<Vec<usize>>) -> Self {
        let base_algebra = OrlikTeraoAlgebra::new(base_ring, matroid);

        // Compute invariant basis
        // For simplicity, start with all NBC sets
        // A full implementation would filter by group invariance
        let invariant_basis = base_algebra.nbc_basis().to_vec();

        OrlikTeraoInvariantAlgebra {
            base_algebra,
            group_elements,
            invariant_basis,
        }
    }

    /// Get the base Orlik-Terao algebra
    pub fn base_algebra(&self) -> &OrlikTeraoAlgebra<R> {
        &self.base_algebra
    }

    /// Get the group elements
    pub fn group_elements(&self) -> &[Vec<usize>] {
        &self.group_elements
    }

    /// Get the invariant basis
    pub fn invariant_basis(&self) -> &[Vec<usize>] {
        &self.invariant_basis
    }

    /// Get the dimension of the invariant algebra
    pub fn dimension(&self) -> usize {
        self.invariant_basis.len()
    }

    /// Get the zero element
    pub fn zero(&self) -> OrlikTeraoElement<R> {
        self.base_algebra.zero()
    }

    /// Get the identity element
    pub fn one(&self) -> OrlikTeraoElement<R>
    where
        R: From<i64>,
    {
        self.base_algebra.one()
    }
}

impl<R: Ring + Clone + Display> Display for OrlikTeraoInvariantAlgebra<R> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Orlik-Terao invariant algebra (rank {}, group order {}) over {}",
            self.base_algebra.rank(),
            self.group_elements.len(),
            self.base_algebra.base_ring()
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_orlik_terao_creation() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        assert_eq!(ot.rank(), 2);
    }

    #[test]
    fn test_orlik_terao_dimension() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let dim = ot.dimension();
        assert!(dim >= 6); // At least the NBC sets we expect
    }

    #[test]
    fn test_algebra_generators() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let gens = ot.algebra_generators();
        assert_eq!(gens.len(), 3); // Three generators for groundset {0,1,2}
    }

    #[test]
    fn test_element_creation() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let e0 = ot.subset_image(&[0]);
        assert!(!e0.is_zero());
    }

    #[test]
    fn test_element_addition() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let e0 = ot.subset_image(&[0]);
        let e1 = ot.subset_image(&[1]);
        let sum = e0.add(&e1);
        assert_eq!(sum.terms().len(), 2);
    }

    #[test]
    fn test_zero_and_one() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let zero = ot.zero();
        let one = ot.one();
        assert!(zero.is_zero());
        assert!(!one.is_zero());
    }

    #[test]
    fn test_scalar_multiplication() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let e0 = ot.subset_image(&[0]);
        let scaled = e0.scalar_mul(&3);
        assert!(!scaled.is_zero());
    }

    #[test]
    fn test_display() {
        let m = Matroid::uniform(2, 3);
        let ot: OrlikTeraoAlgebra<i64> = OrlikTeraoAlgebra::new(1, m);
        let display = format!("{}", ot);
        assert!(display.contains("Orlik-Terao"));
        assert!(display.contains("rank 2"));
    }

    #[test]
    fn test_invariant_algebra() {
        let m = Matroid::uniform(2, 3);
        let group = vec![vec![0, 1, 2]]; // Identity
        let ot_inv: OrlikTeraoInvariantAlgebra<i64> =
            OrlikTeraoInvariantAlgebra::new(1, m, group);
        assert!(ot_inv.dimension() > 0);
    }

    #[test]
    fn test_invariant_algebra_display() {
        let m = Matroid::uniform(2, 3);
        let group = vec![vec![0, 1, 2], vec![1, 0, 2]]; // Z_2 action
        let ot_inv: OrlikTeraoInvariantAlgebra<i64> =
            OrlikTeraoInvariantAlgebra::new(1, m, group);
        let display = format!("{}", ot_inv);
        assert!(display.contains("invariant"));
        assert!(display.contains("group order 2"));
    }
}
